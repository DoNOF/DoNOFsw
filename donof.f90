!======================================================================!
!                                                                      !
!                               Do N O F                               !
!                                                                      !
!       (Donostia Natural Orbital Functional Software Program)         !
!                                                                      !
!                  COPYRIGHT by Mario Piris (2009)                     !
!    IPR registered under Basque Government and Spanish Ministry ECD   !
!                  Registration number 01/2020/360                     !
!                                                                      !
!           Donostia International Physics Center (DIPC)               !
!            University of the Basque Country (UPV/EHU)                !
!            Basque Foundation for Science (IKERBASQUE)                !
!                                                                      !
!               GNU General Public License version 3                   !
!                                                                      !
! ==================================================================== !
!                                                                      !
!      Please inform me of any bugs, by phone at: +34 943 01 8328,     !
!        by e-mail to: mario.piris@ehu.eus, or write to me at:         !
!            Donostia International Physics Center (DIPC),             !
!            Manuel de Lardizabal 4, 20018 Donostia, Spain.            !
!                                                                      !
! ==================================================================== !
!                                                                      !
!                           Date: March 2021                           !
!                                                                      !
!    Program to compute the ground state properties of a molecule      !
!    in the gas phase using PNOF5 - PNOF7 + perturbation corrections   !
!                                                                      !
!======================================================================!

      PROGRAM DoNOF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"                                                      
      character(8) :: date
      character(10):: time
      character(5) :: zone
      integer,dimension(8) :: val
!
      INTEGER,ALLOCATABLE,DIMENSION(:)::IAN0,IMIN0,IMAX0,KSTART0,KATOM0
      INTEGER,ALLOCATABLE,DIMENSION(:)::IAN, IMIN, IMAX, KSTART, KATOM
      INTEGER,ALLOCATABLE,DIMENSION(:)::KTYPE0,KLOC0,INTYP0,KNG0,KMIN0
      INTEGER,ALLOCATABLE,DIMENSION(:)::KTYPE, KLOC, INTYP, KNG, KMIN
      INTEGER,ALLOCATABLE,DIMENSION(:)::KMAX0,ISH0,ITYP0
      INTEGER,ALLOCATABLE,DIMENSION(:)::KMAX, ISH, ITYP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::Cxyz0,Cxyz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: ZAN0,ZMASS0,C10,C20
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: ZAN, ZMASS, C1, C2 
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: EX0,CS0,CP0,CD0
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: EX, CS, CP, CD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CF0,CG0,CH0,CI0
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CF, CG, CH, CI
!
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: GRADS      
      DOUBLE PRECISION,DIMENSION(3) :: EVEC,DIPS
!-----------------------------------------------------------------------
!     MPI initialization
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL INIMPI()
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      call date_and_time(date,time,zone,val)
      write(6,1)val(5),val(6),val(2),val(3),val(1)
      call cpu_time(timestart)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Header on the output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,2)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Input namelist INPRUN variables (NINTEG=NINTMX)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!     IRUNTYP: Specifies the run calculation
!         ICH: Molecular charge  
!         MUL: Multiplicity of the electronic state
!      NINTEG: Total Number of 2e- integrals (NINTEG = NINTMX)
!      IDONTW: Do not write 2e- integrals on the disk (Unit=1)
!       IEMOM: Electrostatic moments calculation
!        EVEC: An array of the three x,y,z components of
!        IECP: Effective Core Potentials
!     IHSSCAL: Compute Hessian and vibrational analysis if IRUNTYP=3
!    IPROJECT: Project Hessian to eliminate rot/vib contaminants
!      ISIGMA: Rotational symmetric number for thermochemistry
!
!      NATmax: Maximum Number of Atoms
!   NSHELLmax: Maximum Number of Shells
!   NPRIMImax: Maximum Number of Gaussian Functions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL NAMELIST_INPRUN(IRUNTYP,ICH,MUL,NINTEG,IDONTW,IEMOM,EVEC,    &
                           ILIBRETA,IECP,IHSSCAL,IPROJECT,ISIGMA,       &
                           NATmax,NSHELLmax,NPRIMImax)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Initialize for the integral quadratures if ERI HONDO Calculator
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(ILIBRETA==0)CALL INIINTQUAD
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ZAN0(NATmax),Cxyz0(3,NATmax),IAN0(NATmax),IMIN0(NATmax), &            
               IMAX0(NATmax),ZMASS0(NATmax),KSTART0(NSHELLmax),         &
               KATOM0(NSHELLmax),KTYPE0(NSHELLmax),KLOC0(NSHELLmax),    &
               INTYP0(NSHELLmax),KNG0(NSHELLmax),KMIN0(NSHELLmax),      &
               KMAX0(NSHELLmax),ISH0(NPRIMImax),ITYP0(NPRIMImax),       &
               C10(NPRIMImax),C20(NPRIMImax),EX0(NPRIMImax),            &
               CS0(NPRIMImax),CP0(NPRIMImax),CD0(NPRIMImax),            &
               CF0(NPRIMImax),CG0(NPRIMImax),CH0(NPRIMImax),            &
               CI0(NPRIMImax))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Read in Basis Set and get initial Molecular Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL START(NAT,NATmax,NBF,NBFaux,NQMT,NE,NA,NB,NSHELL,NSHELLmax,  &
                 NSHELLaux,NPRIMI,NPRIMImax,ZAN0,Cxyz0,IAN0,IMIN0,      &
                 IMAX0,ZMASS0,KSTART0,KATOM0,KTYPE0,KNG0,KLOC0,KMIN0,   &
                 KMAX0,INTYP0,ISH0,ITYP0,C10,C20,EX0,CS0,CP0,CD0,CF0,   &
                 CG0,CH0,CI0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NAT: Number of Atoms             
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      allocate(Cxyz(3,NAT))
      do i=1,3
       Cxyz(i,1:nat) = Cxyz0(i,1:nat)
      end do
      deallocate(Cxyz0)
      IF(NAT==1.and.IRUNTYP==3)THEN
       WRITE(6,5)
       IRUNTYP = 2
      END IF
!
      allocate(IAN(NAT),IMIN(NAT),IMAX(NAT),ZAN(NAT),ZMASS(NAT))
      IAN(1:nat)   = IAN0(1:nat)
      IMIN(1:nat)  = IMIN0(1:nat)
      IMAX(1:nat)  = IMAX0(1:nat)
      ZAN(1:nat)   = ZAN0(1:nat)
      ZMASS(1:nat) = ZMASS0(1:nat)
      deallocate(IAN0,IMIN0,IMAX0,ZAN0,ZMASS0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NSHELL: Total number of shells
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      allocate(KSTART(NSHELL),KATOM(NSHELL),KTYPE(NSHELL),KLOC(NSHELL))
      allocate(INTYP(NSHELL),KNG(NSHELL),KMIN(NSHELL),KMAX(NSHELL))
      KSTART(1:nshell)= KSTART0(1:nshell)
      KATOM(1:nshell) = KATOM0(1:nshell)
      KTYPE(1:nshell) = KTYPE0(1:nshell)
      KLOC(1:nshell)  = KLOC0(1:nshell) 
      INTYP(1:nshell) = INTYP0(1:nshell)
      KNG(1:nshell)   = KNG0(1:nshell)  
      KMIN(1:nshell)  = KMIN0(1:nshell) 
      KMAX(1:nshell)  = KMAX0(1:nshell) 
      deallocate(KSTART0,KATOM0,KTYPE0,KLOC0,INTYP0,KNG0,KMIN0,KMAX0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NPRIMI: Total number of primitive exponents
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      allocate(ISH(nprimi),ITYP(nprimi),C1(nprimi),C2(nprimi))
      allocate(EX(nprimi),CS(nprimi),CP(nprimi),CD(nprimi))
      allocate(CF(nprimi),CG(nprimi),CH(nprimi),CI(nprimi))
      ISH(1:nprimi)  = ISH0(1:nprimi) 
      ITYP(1:nprimi) = ITYP0(1:nprimi) 
      C1(1:nprimi) = C10(1:nprimi)
      C2(1:nprimi) = C20(1:nprimi)
      EX(1:nprimi) = EX0(1:nprimi)
      CS(1:nprimi) = CS0(1:nprimi)
      CP(1:nprimi) = CP0(1:nprimi)
      CD(1:nprimi) = CD0(1:nprimi)
      CF(1:nprimi) = CF0(1:nprimi)
      CG(1:nprimi) = CG0(1:nprimi)
      CH(1:nprimi) = CH0(1:nprimi)
      CI(1:nprimi) = CI0(1:nprimi)      
      deallocate(ISH0,ITYP0,C10,C20,EX0,CS0,CP0,CD0,CF0,CG0,CH0,CI0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Header on the output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!        NAT: Number of Atoms             
!        ICH: Charge of Molecule
!        MUL: State Multiplicity
!        NBF: Number of Basis Functions (NSQ=NBF*NBF,NBFT=NBF(NBF+1)/2)   
!       NQMT: Number of linearly independent orbitals  
!         NE: Number of Electrons
!         NA: Number of Alpha electrons
!         NB: Number of Beta electrons
!       EVEC: Electric Field components
!     NSHELL: Total number of shells
!     NPRIMI: Total number of primitive exponents
!        IAN: True nuclear charge
!      IEMOM: Electrostatic moments calculation
!       IECP: Effective Core Potentials
!        ZAN: Effective Nuclear Charge
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL RUNNOFHEADER(NAT,ICH,MUL,NBF,NBFaux,NQMT,NE,NA,NB,           &
                        EVEC(1),EVEC(2),EVEC(3),NSHELL,NSHELLaux,       &
                        NPRIMI,IAN,IEMOM,IECP,IRUNTYP,Cxyz,ZAN)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If RUNTYP = 1) ENERGY  : single-point energy
!                 2) GRADIENT: single-point energy + gradients
!                 3) OPTIMIZE: optimize the molecular geometry
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(GRADS(3*NAT))
      IF(IRUNTYP==1.or.IRUNTYP==2)THEN
       CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,  &
                     ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,    &
                     INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX,CS,CP,CD,    &
                     CF,CG,CH,CI,GRADS,IRUNTYP,DIPS,1,1)
      ELSE IF(IRUNTYP==3)THEN
       CALL OPTIMIZE(NINTEG,IDONTW,NAT,ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,    &
                     KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,   &
                     ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,DIPS,GRADS,     &
                     IRUNTYP,IHSSCAL,IPROJECT,ISIGMA)
      ELSE IF(IRUNTYP==4)THEN
       CALL HESSCAL(NINTEG,IDONTW,NAT,ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,     &
                    KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,    &
                    ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,DIPS,GRADS,      &
                    IRUNTYP,IPROJECT,ISIGMA)  
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(ZAN,ZMASS,Cxyz,GRADS,IAN,IMIN,IMAX)
      DEALLOCATE(KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH)
      DEALLOCATE(ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,CI)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      call cpu_time(timefinish)
      DELTATIME = timefinish - timestart
      WRITE(6,3)DELTATIME
!-----------------------------------------------------------------------
      call date_and_time(date,time,zone,val)
      write(6,4)val(5),val(6),val(2),val(3),val(1)
!-----------------------------------------------------------------------
!     Format definitions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(/' The execution started at ',I2,'h ',I2,'min on the ',    &
                I2,'/',I2,'/',I4)
    2 FORMAT(                                                           &
      /4X,'===========================================================' &
      /4X,'!                                                         !',&                                                                     
      /4X,'!                        Do N O F                         !',&   
      /4X,'!                                                         !',&                                                                     
      /4X,'!  (Donostia Natural Orbital Functional Software Program) !',&   
      /4X,'!                                                         !',&                                                                     
      /4X,'!               COPYRIGHT by Mario Piris                  !',& 
      /4X,'!                                                         !',& 
      /4X,'!      Donostia International Physics Center (DIPC)       !',&
      /4X,'!       University of the Basque Country (UPV/EHU)        !',&
      /4X,'!       Basque Foundation for Science (IKERBASQUE)        !',&
      /4X,'!                                                         !',& 
      /4X,'!          GNU General Public License version 3           !',&                                                                     
      /4X,'!                                                         !',&                                                                     
      /4X,'!                VERSION: January 2021                    !',&
      /4X,'!                                                         !',&
      /4X,'===========================================================')
    3 FORMAT(/,'  Elapsed real time :',F10.2,'  (Seconds)')
    4 FORMAT(/' The execution finished at ',I2,'h ',I2,'min on the ',   &
                I2,'/',I2,'/',I4)                                                                                                                       
    5 FORMAT(/1X,'Warning: For geometry optimization the number of'     &
                 'atoms must be greater,',/,10X,'than 1 '               &
                 'so RUNTYP has been set equal to GRAD, not OPTGEO')
!-----------------------------------------------------------------------
      STOP
      END

!----------------------------------------------------------------------!
!                                                                      !
!   NAMELIST_INPRUN: Specifies the run calculation, multiplicity, ...  !
!   RUNNOFHEADER: Write NOF header on the output file                  !
!   SETORBSPACE: Define the orbital space (NDOC,NSOC,NCWO,NVIR,...)    !
!   POINTERS: Define Pointers of the USER array for the CG subroutine  !
!   NAMELIST_NOFINP: Preset values for the NOFINP namelist variables.  !
!   OUTPUTHEADER: Write the Input NOF Options                          !
!   OPENFILES: Open all general working files.                         ! 
!   OUTPUTBASIC: Write the basic info on the output file.              !
!   SETNO1: Determine NO1 according to true nuclear charges if NO1=-1  !
!                                                                      !
!----------------------------------------------------------------------!

! NAMELIST_INPRUN
      SUBROUTINE NAMELIST_INPRUN(ITYPRUN,ICHARG,MULT,NINTEG,            &
                                 IDONTW,IEMOMENTS,EVECTOR,LIBRETA,      &
                                 IECPO,IHSSCAL,IPROJECT,ISIGMA,         &
                                 NATmax,NSHELLmax,NPRIMImax)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"      
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      COMMON/INFO/IUNTRD            
      COMMON/INTFIL/NINTMX           
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      COMMON/ELPROP/IEMOM      
      CHARACTER(8):: UNITS
      COMMON/CONTROL/UNITS
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/RUNTYPE/IRUNTYP
      COMMON/USELIBRETA/ILIBRETA
      LOGICAL DONTW,USELIB,HSSCAL,PROJECT
      DOUBLE PRECISION,DIMENSION(3) :: EVECTOR
      CHARACTER(6) :: RUNTYP,ENERGY,GRAD,OPTGEO,HESS
      DATA ENERGY,GRAD,OPTGEO,HESS/'ENERGY','GRAD  ','OPTGEO','HESS  '/
      CHARACTER(8) :: ANGS,BOHR
      DATA ANGS, BOHR /'ANGS    ','BOHR    '/
      CHARACTER(4) :: ERITYP,FULL,RI,MIX
      DATA FULL,RI,MIX /'FULL','RI  ','MIX '/
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
      CHARACTER(3) :: GEN
!----------------------------------------------------------------------!
!                   --- INPRUN NAMELIST VARIABLES ---                  !
!----------------------------------------------------------------------!
!
! RUNTYP            specifies the run calculation
!       = ENERGY    1) single-point energy calculation (Default)
!       = GRAD      2) energy + gradients with respect to nuclear coord
!       = OPTGEO    3) optimize the molecular geometry
!       = HESS      4) compute numerical hessian from analytic gradients
!
! MULT              Multiplicity of the electronic state
!       = 1         singlet (Default)
!       = 2,3,...   doublet, triplet, and so on
!
! ICHARG            Molecular charge  
!       = 0         Neutral Molecule (Default)
!
! IECP              Effective Core Potentials 
!       = 0         (Default) All electron calculation 
!       = 1         Read ECP potentials in the $ECP group
!
! IEMOM             Electrostatic moments calculation
!       = 1         calculate dipole moments (Default)
!         2         also calculate quadrupole moments
!         3         also calculate octopole moments
!
! UNITS             Distance units (any angles must be in degrees)
!       = ANGS      Angstroms (Default)
!       = BOHR      Bohr atomic units
!
! EVEC              An array of the three x,y,z components of
!                   the applied electric field, in a.u.
!                   (1 a.u. = 1 Hartree/e*bohr = 5.1422082(15)d+11 V/m)
!       = 0.0D0     (Default)
!
! USELIB            Use Libreta open source library for ERI calculation
!       = F         HONDO Calculator (Default)
!
! DONTW             Do not write 2e- integrals on the disk (Unit=1)
!       = T         (Default)
!
! ERITYP            Typ of ERIs used in calculations
!       = FULL      4c ERIs (Default)
!       = RI        3c/2c ERIs for Resolution of the Identity (RI) App.
!       = MIX       3c/2c ERIs for Resolution of the Identity (RI) App.
!                   once converged change to 4c ERIs (FULL)
!
! GEN               Generative Auxiliary Basis to use in RI Approx.
!                   if ERITYP = RI. Values: A2,A2*,A3,A3*,A4,A4* 
!       = A2*       (Default)
!
! SMCD              Symmetric Modified Cholesky Decomposition for the 
!                   G matrix in the RI Approximation
!       = F         (Default)
!      
! HSSCAL            Compute Hessian from analytic gradients and carry
!                   out normal mode vibrational analysis at st. point 
!                   if RUNTYP = OPTGEO (IRUNTYP=3)
!       = T         (Default)
!
! PROJECT           Project Hessian to eliminate rot/vib contaminants
!       = T         (Default)
!
! ISIGMA            Rotational symmetric number for thermochemistry
!       = 1         There is not a center of symmetry (Default)
!       = 2         There is a center of symmetry
!                   For more info see https://cccbdb.nist.gov/thermo.asp
!
! NATmax            Maximum Number of Atoms
!       = 100       (Default)
!
! NSHELLmax         Maximum Number of Shells
!       = 500       (Default)
!
! NPRIMImax         Maximum Number of Gaussian Functions
!       = 2000      (Default)
!
!-----------------------------------------------------------------------
      NAMELIST/INPRUN/RUNTYP,MULT,ICHARG,IECP,IEMOM,UNITS,EVEC,         &
                      USELIB,DONTW,ERITYP,GEN,SMCD,HSSCAL,PROJECT,      &
                      ISIGMA,NATmax,NSHELLmax,NPRIMImax
!-----------------------------------------------------------------------
      TI = 0.0D0                                                           
      TX = 0.0D0                                                           
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Preset values to namelist variables
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RUNTYP    = ENERGY
      MULT      = 1                                                        
      ICHARG    = 0
      IECP      = 0
      IEMOM     = 1
      UNITS     = ANGS
      EVEC      = 0.0D0     ! EVEC(1,2,3)=0
      USELIB    = .FALSE.
      DONTW     = .TRUE.
      ERITYP    = FULL
      GEN       = 'A2*'
      SMCD      = .FALSE.
      HSSCAL    = .TRUE.
      PROJECT   = .TRUE.
      ISIGMA    = 1
      NATmax    = 100     
      NSHELLmax = 500  
      NPRIMImax = 2000 
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!                            Read Namelist
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
#ifdef MPI
      CONTINUE
#else
      REWIND(5)
#endif
      READ(5,INPRUN,ERR=1,END=1)
!-----------------------------------------------------------------------
!     Determine IRUNTYP
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                   
      IF(RUNTYP==ENERGY)THEN
       IRUNTYP = 1
      ELSE IF(RUNTYP==GRAD)THEN
       IRUNTYP = 2
      ELSE IF(RUNTYP==OPTGEO)THEN
       IRUNTYP = 3
      ELSE IF(RUNTYP==HESS)THEN
       IRUNTYP = 4
      END IF
      ITYPRUN = IRUNTYP      
!
      IF(USELIB)THEN
       ILIBRETA = 1
      ELSE
       ILIBRETA = 0
      ENDIF
      LIBRETA = ILIBRETA
!     Stop if USELIB to use NAG library (E04DKF,E04DGF,F11JEF)
      IF(ILIBRETA==1)THEN
       WRITE(6,*)                                                       !lib
       WRITE(6,*)'Stop: To use the Libreta library you need data.cpp', &!lib
                 '      and uncomment calls to the relevant routines'   !lib
       CALL ABRT                                                        !lib
      END IF
!
      IF(ERITYP==FULL)THEN
       IERITYP = 1
      ELSE IF(ERITYP==RI)THEN
       IERITYP = 2
      ELSE IF(ERITYP==MIX)THEN       
       IERITYP = 3
       MIXSTATE = 1                           ! 1 = RI, 2 = FULL
      ELSE
       WRITE(6,6) 
       CALL ABRT
      ENDIF
!
      IF(IECP>0 .and. ILIBRETA==1)THEN        ! ECP only with HONDO
       WRITE(6,7)
       CALL ABRT
      END IF
!
      IF(IECP>0 .and. NATmax>100)THEN         ! due to COMMON/ECP2/
       WRITE(6,8)
       CALL ABRT
      END IF
!
      IF(IECP>0 .and. NSHELLmax>500)THEN      ! due to MAPSHL
       WRITE(6,9)
       CALL ABRT
      END IF
!
      IF(ILIBRETA==1 .and. NSHELLmax>500)THEN ! due to BASLIB
       WRITE(6,10)
       CALL ABRT
      END IF
!
      IF(IERITYP==2 .and. NSHELLmax>500)THEN  ! due to COMMON/NSHELaux/
       WRITE(6,11)
       CALL ABRT
      END IF
      IF(IERITYP==2 .and. NPRIMImax>2000)THEN ! due to COMMON/EXCaux/
       WRITE(6,12)
       CALL ABRT
      END IF
      
!     Determine Star in Auxiliary Basis if required
      if(IERITYP==2 .or. IERITYP==3)then
       READ(GEN(2:2),'(I1)')IGEN
       IF(GEN(3:3)=='*') THEN
        ISTAR = 1
       ELSE IF(GEN(3:3)==' ') THEN
        ISTAR = 0
       ELSE
        ISTAR = -1
       END IF
      end if
!      
      IF(HSSCAL)THEN
       IHSSCAL = 1
      ELSE 
       IHSSCAL = 0
      END IF
!
      IF(PROJECT)THEN
       IPROJECT = 1
      ELSE 
       IPROJECT = 0
      END IF
!
      IF(DONTW)THEN
       IDONTW = 1
      ELSE 
       IDONTW = 0
      END IF
      IF(IERITYP==2 .and. IDONTW==0)THEN
       WRITE(6,5)
       CALL ABRT
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                   
!     Electric Field
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF((EVEC(1)==0.0D0).and.(EVEC(2)==0.0D0).and.(EVEC(3)==0.0D0))THEN
       EFLDL = .FALSE.
      ELSE
       EFLDL = .TRUE.
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Integral Options (TRFOPT common block)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ISCHWZ  = 0         ! Schwarz inequality off 
      NINTMX = 15000
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!     Errors in the Input Namelist
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(UNITS==ANGS)THEN
       IUNTRD = 1                
      ELSEIF(UNITS==BOHR)THEN
       IUNTRD = -1
      ELSE
       WRITE(6,2)'UNITS ',UNITS                      
       CALL ABRT                                                      
      ENDIF                                                            
      IF(IECP<0.or.IECP>3)THEN
       WRITE(6,3)IECP                        
       CALL ABRT                                                      
      END IF
      IF(IEMOM<1.or.IEMOM>3)THEN
       WRITE(6,4)IEMOM                       
       CALL ABRT                                                      
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ICH = ICHARG                                                      
      MUL = MULT
      IEMOMENTS = IEMOM
      EVECTOR = EVEC
      NINTEG = NINTMX
      IECPO = IECP                                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                        
      RETURN
!-----------------------------------------------------------------------
    1 WRITE(6,'(/2X,27A)')'Stop: Wrong Namelist Variable'
      STOP
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    2 FORMAT(/1X,'Stop: $CONTRL KEYWORD ',A6,                           &
                ' was given an illegal value ',A8,'.'/)
    3 FORMAT(/1X,'Stop: IECP   must be between  0 and 3, not',I8,/)
    4 FORMAT(/1X,'Stop: IEMOM  must be between  1 and 3, not',I8,/) 
    5 FORMAT(/1X,'Stop: DONTW must be T with ERITYP = RI',/)
    6 FORMAT(/1X,'Stop: ERITYP must be FULL or RI',/)
    7 FORMAT(/1X,'Stop: USELIB must be F with ECP',/) 
    8 FORMAT(/1X,'Stop: NATmax must be <= 100 with ECP',/) 
    9 FORMAT(/1X,'Stop: NHELLmax must be <= 500 with ECP',/)
   10 FORMAT(/1X,'Stop: NHELLmax must be <= 500 with USELIB = T',/)
   11 FORMAT(/1X,'Stop: NHELLmax must be <= 500 with ERITYP = RI',/)
   12 FORMAT(/1X,'Stop: NPRIMImax must be <= 2000 with ERITYP = RI',/)
!-----------------------------------------------------------------------
      END

! RUNNOFHEADER
      SUBROUTINE RUNNOFHEADER(NATOMSn,ICHn,MULn,NBFn,NBFauxn,NQMTn,NEn, &
                              NAn,NBn,EXn,EYn,EZn,NSHELLn,NSHELLauxn,   &
                              NPRIMIn,IAN,IEMOMn,IECPn,IRUNTYP,Cxyz,ZNUC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL EFIELDL,RESTART,ERIACTIVATED
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPFILE_NO1PT2/NO1PT2,NEX
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/ELPROP/IEMOM      
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),              &
                  KLAST(100,6),LMAX(100),LPSKIP(100),IZCORE(100)
      COMMON/NumLinIndOrb/NQMT
!
      INTEGER,DIMENSION(NATOMSn) :: IAN
      DOUBLE PRECISION,DIMENSION(3,NATOMSn) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NATOMSn) :: ZNUC
      CHARACTER*4,ALLOCATABLE,DIMENSION(:) :: ATMNAME
!-----------------------------------------------------------------------
!     Basic information
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NATOMS: Number of Atoms             
!        ICH: Charge of Molecule
!        MUL: State Multiplicity
!        NBF: Number of Basis Functions (NSQ=NBF*NBF,NBFT=NBF(NBF+1)/2)
!       NQMT: Number of linearly independent orbitals  
!         NE: Number of Electrons
!         NA >= NB
!         NA: Number of Alpha electrons
!         NB: Number of Beta electrons
!       EVEC: Electric Field components (EX,EY,EZ)
!     NSHELL: Total number of shells
!     NPRIMI: Total number of primitive exponents
!- - - - - - - - - - - - - - - - - - - - - - - - -
!     NBFaux: Number of Auxiliary Basis Functions
!  NSHELLaux: Total number of auxiliary shells
!-----------------------------------------------------------------------
      NATOMS = NATOMSn
      ICH    = ICHn
      MUL    = MULn
      NBF    = NBFn
      NQMT   = NQMTn
      NE     = NEn
      NA     = NAn
      NB     = NBn
      EX     = EXn
      EY     = EYn
      EZ     = EZn
      NSHELL = NSHELLn
      NPRIMI = NPRIMIn
      IEMOM  = IEMOMn
      IECP   = IECPn
!- - - - - - - - - - - - - -
      NBFaux = NBFauxn
      NSHELLaux = NSHELLauxn
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NBFT: Dimension for symmetric matices
!      NSQ: Dimension for square matices
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NSQ = NBF*NBF
      NBFT = NBF*(NBF+1)/2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     State of ERIs in Nodes
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ERIACTIVATED = .FALSE.    
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Input namelist variables: ICOEF, MAXIT, ...
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL NAMELIST_NOFINP(IRUNTYP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Header of NOF Calculation on the output file 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OUTPUTHEADER
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Open files (GCF,BFST,GCFe,WFN,FCHK,APSG,FRAG,CGGRAD)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OPENFILES(IRUNTYP)
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
!     INPUTCXYZ=0: Read geometry from input file
!     INPUTCXYZ=1: Read geometry from GCF file
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTCXYZ==1) THEN
       CALL READCXYZ(ZNUC,Cxyz,NATOMS,NBF,NSQ)
       WRITE(6,2)       
       ALLOCATE(ATMNAME(NATOMS))
       CALL ATOMNAMES(NATOMS,ZNUC,IZCORE,ATMNAME,Cxyz,1,1)
       DEALLOCATE(ATMNAME)
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Output Basic
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OUTPUTBASIC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If NO1 = -1 calculate NO1 according to true nuclear charges (IAN)
!     NO1: Natural Orbitals with Occupation Numbers equal to one.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NO1==-1)THEN
!      If using ECPotentials (IECP/=0): NO1=0, NO1PT2=0
       IF(IECP/=0)THEN
        NO1 = 0
        NO1PT2 = 0
        WRITE(6,1)
       ELSE
        CALL SETNO1(IAN)
       ENDIF 
      ENDIF 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NO1:  Number of inactive doubly occupied orbitals (OCC=1)         
!     NDOC: Number of strongly doubly occupied MOs                      
!     NSOC: Number of strongly singly occupied MOs                      
!     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)                        
!     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
!     NCWO*NDOC: Active orbitals in the virtual subspace                
!     NO0:  Empty orbitals  (OCC=0)                                      
!     NVIR: Number of weakly occupied MOs + empty MOs                   
!                                                                     
!           NO1 | NDOC + NSOC  |   NCWO*NDOC + NO0  = NBF               
!           NO1 |     NDNS     |          NVIR      = NBF               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL SETORBSPACE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Define Pointers of the USER array for the external CG subroutine
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL POINTERS
!-----------------------------------------------------------------------
    1 FORMAT(/1X,'You are using an ECP: Core Orbitals have been already'&
             ,1X,'excluded.',/1X,'NO1 and NO1PT2 = 0.')
    2 FORMAT(/1X,'Nuclear Coordinates from GCF file:'                   &
             /1X,'----------------------------------')
!-----------------------------------------------------------------------             
      RETURN
      END

! SETORBSPACE
      SUBROUTINE SETORBSPACE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPFILE_NO1PT2/NO1PT2,NEX
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,10)
      WRITE(6,11)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If NBF < NE -> More orbitals have to be excluded in NO1 or NO1PT2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NBF<NE)THEN
       NDIF = NE-NBF
       IF(NO1<NDIF)THEN
        NO1 = NDIF
        WRITE(6,1)
       ENDIF
       IF(NO1PT2<NDIF)THEN
        NO1PT2 = NDIF
        WRITE(6,2)
       ENDIF
       IF(NO1==NBF)THEN
        WRITE(6,3)
        CALL ABRT       
       ENDIF
       IF(NO1PT2==NBF)THEN
        WRITE(6,4)
        CALL ABRT       
       ENDIF
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
!     Frozen orbitals in perturbative calculations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      IF(NO1PT2==-1)NO1PT2 = NO1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                         Set Orbital Space
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NO1:  Number of inactive doubly occupied orbitals (OCC=1)         
!     NDOC: Number of strongly doubly occupied MOs                      
!     NSOC: Number of strongly singly occupied MOs                      
!     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)                        
!     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
!     NCWO*NDOC: Active orbitals in the virtual subspace                
!     NO0:  Empty orbitals  (OCC=0)                                      
!     NVIR: Number of weakly occupied MOs + empty MOs                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!           NO1 | NDOC  + NSOC  |   NCWO*NDOC + NO0  = NBF               
!           NO1 |      NDNS     |          NVIR      = NBF 
!               | -NAC- |       |  -   NAC  - |
!                      NB      NA            NBF5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                               !  CLOSED (NB=NA=NCO,NSOC=0)
      NDOC = NB - NO1           !  NDOC = NCO - NO1, NO1 <= NCO
      NDNS = NDOC + NSOC        !  NDNS = NDOC      
      NA   = NO1 + NDNS         !  NA = NB = NCO
      NVIR = NBF - NA           !  NBF - NCO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NDNS/=0)THEN
       if(NDOC>0)then
        IF(NCWO/=1)THEN                      ! Extended PNOF (NCWO>1)
!- - - - - - - - - - - - - - - - - -       
         if(NCWO<-1)then
          write(6,5)NCWO
          CALL ABRT                 
         else if(NCWO==-1)then
          NCWO = NVIR/NDOC
         else if(NCWO>NVIR/NDOC)then
          write(6,6)NCWO
          NCWO = NVIR/NDOC
         endif
!- - - - - - - - - - - - - - - - - -        
        ELSE                                 ! perfect pairing (NCWO=1)
!- - - - - - - - - - - - - - - - - -       
         write(6,7)                           
!- - - - - - - - - - - - - - - - - -        
        ENDIF
       else
        NCWO = 0
       end if
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NAC: Dimension of the active natural orbital subspace
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NAC = NDOC * ( 1 + NCWO )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NBF5: Occupied Orbitals (ON /= 0), NBFT5, NSQ5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NBF5 = NO1 + NAC + NSOC                ! NBF5 = NA  + NDOC*NCWO
      IF(NBF5>NBF)NBF5 = NBF
      NBFT5 = NBF5*(NBF5+1)/2
      NSQ5 = NBF5*NBF5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NO0: Empty orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NO0 = NBF - NBF5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,8)NO1,NDOC,NSOC,NCWO,NAC,NO0      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
!-----------------------------------------------------------------------
!     Format definitions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(/1X,'Note NBF < NE: More orbitals have to be excluded.',   &
              1X,'NO1 has been set equal to NE-NBF')
    2 FORMAT(/1X,'Note NBF < NE: More orbitals have to be excluded.',   &
              1X,'NO1PT2 has been set equal to NE-NBF')
    3 FORMAT(/1X,'Stop: all orbitals are full occupied (NO1=NBF)')
    4 FORMAT(/1X,'Stop: all orbitals are full occupied (NO1PT2=NBF)')    
    5 FORMAT(/1X,'Stop Program: Incorrect number of NCWO =',I5)
    6 FORMAT(/1X,'Your NCWO =',I5,' exceeds the maximum possible value')
    7 FORMAT(/1X,'You are doing a perfect pairing calculation: NCWO=1')
    8 FORMAT(/1X,'Inactive Doubly occupied orbitals up to NO1  =',I5,   &
             /1X,'No. considered Strongly Doubly occupied MOs  =',I5,   &
             /1X,'No. considered Strongly Singly occupied MOs  =',I5,   &  
             /1X,'NO. of Weakly occ. per St. Doubly occ.  MOs  =',I5,   &
             /1X,'Dimension of the Active Nat. Orb. subspace   =',I5,   &
             /1X,'Secondary Empty orbitals                     =',I5)
   10 FORMAT(/72('-'))
   11 FORMAT(/1X,'Orbital Space',/1X,'-------------')
!-----------------------------------------------------------------------
      END

! POINTERS
      SUBROUTINE POINTERS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,  &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24, &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35, &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46, &
                          N47,N48,N49,N50,N51,NUSER
!-----------------------------------------------------------------------
!     Define Pointers of the USER array
!-----------------------------------------------------------------------
      N1  = 1                    ! USER( N1) = RO(NBF5)
      N2  = N1  + NBF5           ! USER( N2) = CJ12(NBF5,NBF5)
      N3  = N2  + NSQ5           ! USER( N3) = CK12(NBF5,NBF5)
      N4  = N3  + NSQ5           ! USER( N4) = DR(NBF5,NBF5) 
      N5  = N4  + NSQ5           ! USER( N5) = DCJ12r(NBF5,NBF5,NBF5)
      N6  = N5  + NSQ5*NBF5      ! USER( N6) = DCK12r(NBF5,NBF5,NBF5)
      N7  = N6  + NSQ5*NBF5      ! USER( N7) = QD(NBF,NBF,NBF)
      N8  = N7  + NBF*NSQ        ! USER( N8) = HCORE(NBF5)
      N9  = N8  + NBF5           ! USER( N9) = QJ(NBFT5)
      N10 = N9  + NBFT5          ! USER(N10) = QK(NBFT5)
      N11 = N10 + NBFT5          ! USER(N11) = DIPN(3)
      N12 = N11 + 3              ! USER(N12) = ADIPx(NSQ)
      N13 = N12 + NSQ            ! USER(N13) = ADIPy(NSQ)
      N14 = N13 + NSQ            ! USER(N14) = ADIPz(NSQ)
      N15 = N14 + NSQ            ! USER(N15) = DIPx(NSQ5)
      N16 = N15 + NSQ5           ! USER(N16) = DIPy(NSQ5)
      N17 = N16 + NSQ5           ! USER(N17) = DIPz(NSQ5)
      N18 = N17 + NSQ5           ! USER(N18) = QUADN(6)
      N19 = N18 + 6              ! USER(N19) = AQUADxx(NSQ)
      N20 = N19 + NSQ            ! USER(N20) = AQUADyy(NSQ)
      N21 = N20 + NSQ            ! USER(N21) = AQUADzz(NSQ)
      N22 = N21 + NSQ            ! USER(N22) = AQUADxy(NSQ)
      N23 = N22 + NSQ            ! USER(N23) = AQUADxz(NSQ)
      N24 = N23 + NSQ            ! USER(N24) = AQUADyz(NSQ)
      N25 = N24 + NSQ            ! USER(N25) = QUADxx(NSQ5)
      N26 = N25 + NSQ5           ! USER(N26) = QUADyy(NSQ5)
      N27 = N26 + NSQ5           ! USER(N27) = QUADzz(NSQ5)
      N28 = N27 + NSQ5           ! USER(N28) = QUADxy(NSQ5)
      N29 = N28 + NSQ5           ! USER(N29) = QUADxz(NSQ5)
      N30 = N29 + NSQ5           ! USER(N30) = QUADyz(NSQ5)
      N31 = N30 + NSQ5           ! USER(N31) = OCTUN(10)
      N32 = N31 + 10             ! USER(N32) = AOCTxxx(NSQ)
      N33 = N32 + NSQ            ! USER(N33) = AOCTyyy(NSQ)
      N34 = N33 + NSQ            ! USER(N34) = AOCTzzz(NSQ)
      N35 = N34 + NSQ            ! USER(N35) = AOCTxxy(NSQ)
      N36 = N35 + NSQ            ! USER(N36) = AOCTxxz(NSQ)
      N37 = N36 + NSQ            ! USER(N37) = AOCTxyy(NSQ)
      N38 = N37 + NSQ            ! USER(N38) = AOCTyyz(NSQ)
      N39 = N38 + NSQ            ! USER(N39) = AOCTxzz(NSQ)
      N40 = N39 + NSQ            ! USER(N40) = AOCTyzz(NSQ)
      N41 = N40 + NSQ            ! USER(N41) = AOCTxyz(NSQ)
      N42 = N41 + NSQ            ! USER(N42) = OCTXXX(NSQ5)
      N43 = N42 + NSQ5           ! USER(N43) = OCTYYY(NSQ5)
      N44 = N43 + NSQ5           ! USER(N44) = OCTZZZ(NSQ5)
      N45 = N44 + NSQ5           ! USER(N45) = OCTXXY(NSQ5)
      N46 = N45 + NSQ5           ! USER(N46) = OCTXXZ(NSQ5)
      N47 = N46 + NSQ5           ! USER(N47) = OCTXYY(NSQ5)
      N48 = N47 + NSQ5           ! USER(N48) = OCTYYZ(NSQ5)
      N49 = N48 + NSQ5           ! USER(N49) = OCTXZZ(NSQ5)
      N50 = N49 + NSQ5           ! USER(N50) = OCTYZZ(NSQ5)
      N51 = N50 + NSQ5           ! USER(N51) = OCTXYZ(NSQ5)
      NUSER = N51 - N1 + NSQ5
!-----------------------------------------------------------------------
      RETURN
      END
      
! NAMELIST_NOFINP                                                     
      SUBROUTINE NAMELIST_NOFINP(IRUNTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HFDAMP,HFEXTRAP,HFDIIS,DIIS,PERDIIS,RESTART,FROZEN
      LOGICAL PRINTLAG,DIAGLAG,APSG,CHKORTHO,ORTHO,OIMP2,SC2MCPT,HFID
      LOGICAL MBPT,TDHF,TUNEMBPT,MBPTMEM
      LOGICAL HighSpin,SCALING,RHF
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_RHF/IRHFTYP,NCONVRHF,CONVRHFDM,MAXITRHF,RHF
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_HFCONVTECH/HFDAMP,HFEXTRAP,HFDIIS
      COMMON/INPNOF_DIIS_1/DIIS,PERDIIS,NDIIS,NTHDIIS,THDIIS
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200)
      COMMON/INPNOF_LAGRANGE/PRINTLAG,DIAGLAG
      COMMON/INPNOF_APSG/APSG,NTHAPSG,THAPSG
      COMMON/INPNOF_ORTHOGONALITY/CHKORTHO,ORTHO
      COMMON/INPNOF_OIMP2/OIMP2
      COMMON/INPNOF_MBPT/MBPT,TDHF,TUNEMBPT,MBPTMEM 
      COMMON/INPNOF_SC2MCPT/SC2MCPT
      COMMON/INPNOF_HFID/HFID,NTHRESHEID,THRESHEID,MAXITID,KOOPMANS       
      COMMON/INPNOF_EINI/IEINI
      COMMON/INPNOF_EKT/IEKT
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/INPNOF_ARDM/THRESHDM,NOUTRDM,NSQT,NTHRESHDM      
      COMMON/INPNOF_CJK/NOUTCJK,NTHRESHCJK,THRESHCJK      
      COMMON/INPNOF_Tijab/NOUTTijab,NTHRESHTijab,THRESHTijab
      COMMON/INPNOF_CGM/ICGMETHOD
      COMMON/INPNOF_NTHRESH/NTHRESHL,NTHRESHE,NTHRESHEC,NTHRESHEN
      COMMON/INPNOF_THRESH/THRESHL,THRESHE,THRESHEC,THRESHEN
      COMMON/INPNOF_COEFOPT/MAXLOOP
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPNOF_STATIC/Ista
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/INPFILE_NO1PT2/NO1PT2,NEX
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
!
      LOGICAL AUTOZEROS
      INTEGER:: IRUNTYP
!----------------------------------------------------------------------!
!                   --- NOFINP NAMELIST VARIABLES ---                  !
!----------------------------------------------------------------------!
!
!.......... MAXIT               Maximum number of OCC-SCF iterations 
!                      = 1000   (Default)
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Type of Calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... ICOEF               Energy Optimization with respect to NOs
!
!                      = 0      Optimize only with respect to ONs
!                      = 1      Optimize by the ONs and NOs (Default)
!                      = 2      Optimize only by NOs keeping fixed ONs
!                      = 3      Optimize by all ONs and core-fragment 
!                               orbitals. The rest of fragment orbitals 
!                               remain frozen
!
!.......... IEINI               Calculate only the initial energy
!                      = 0      (Default)
!
!.......... NO1                 Max. index of NOs with Occupation = 1
!                      = -1     Consider Core NOs (Default)
!                      = 0      All NOs are considered
!                      = Value  User specifies how many NOs have OCC.=1
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Hartree-Fock
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... RHF                 Restricted Hartree-Fock Calculation
!                      = T      (Default)
!
!.......... NCONVRHF            RHF-SCF Density Convergence Criteria
!                               CONVRHFDM=10.0**(-NCONVRHF)
!                      = 5      (Default)
!
!.......... MAXITRHF            Maximum number of RHF-SCF iterations 
!                      = 100    (Default)
!
!.......... HFDAMP              Damping of the Fock matrix
!                      = T      (Default)
!
!.......... HFEXTRAP            Extrapolation of the Fock matrix
!                      = T      (Default)
!
!.......... HFDIIS              Direct Inversion in the Iterative 
!                               Subspace in the RHF-SCF optimization
!                      = T      (Default)
!
!.......... HFID                Use the Iterative Diagonalization Method 
!                               to generate the HF Orbitals
!                      = F      (Default)
!
!.......... NTHRESHEID          Convergence of the TOTAL ENERGY
!                               THRESHEID=10.0**(-NTHRESHEID)
!                      = 6      (Default)
!
!.......... MAXITID             Maximum number of external iterations 
!                      = 30     (Default)
!
!.......... KOOPMANS            Calculate IPs using Koopmans' Theorem 
!                      = 0      (Default)
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! PNOF Selection
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... IPNOF               Type of Natural Orbital Functional (NOF)
!                      = 5      PNOF5
!                      = 6      PNOF6
!                      = 7      PNOF7 (Default)
!
!.......... Ista                Use Static version of PNOF7 
!                      = 0      PNOF7 (Default)
!                      = 1      PNOF7s
!
!.......... HighSpin            Spin-uncompensated calculation type
!                      = F      (Default) Multiplet state (Ms=0)
!                      = T      High-spin uncompensated state (Ms=S)
!
!.......... NCWO                Number of coupled weakly occupied MOs 
!                               per strongly occupied = Nc -> PNOFi(Nc)
!                      = 1      NCWO = 1 (Default)
!                      = 2,3,...
!                      =-1      NCWO = NVIR/NDOC
!                               NVIR: Number of HF virtual  MOs (OCC=0)
!                               NDOC: Number of strongly occupied MOs
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Convergence Criteria in NOF calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... NTHRESHL            Convergence of the Lagrange Multipliers
!                               THRESHL=10.0**(-NTHRESHL)
!                      = 3      (Default)
!
!.......... NTHRESHE            Convergence of the total energy
!                               THRESHE=10.0**(-NTHRESHE)
!                      = 4      (Default)
!
!.......... NTHRESHEC           Convergence of the total energy (ORBOPT)
!                               THRESHEC=10.0**(-NTHRESHEC)
!                      = 10     (Default)
!
!.......... NTHRESHEN           Convergence of the total energy (OCCOPT)
!                               THRESHEN=10.0**(-NTHRESHEN)
!                      = 10     (Default)
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Options for the Orbital Optimization Program (ID Method)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... MAXLOOP             Maximum Iteration Number for the SCF-
!                               iteration cycle in each ITCALLs 
!                      = 30     (Default)
!
!     The straightforward iterative scheme fails to converge very 
!     often due to the values of some off-diagonal elements Fki. The 
!     latters must be suffciently small and of the same order of 
!     magnitude. A variable factor scales Fki. We establish an upper
!     bound B, in such a way that when the absolute value of the 
!     matrix element Fki is greater than B, it is scaled by a factor 
!     Cki (F'ki = Cki*Fki ), as to satisfy ABS(Fki) <= B.
!
!.......... SCALING             A variable factor scales Fki
!                      = T      (Default)
!
!.......... NZEROS              B = 10.0**(1-NZEROS). 
!                               Initial number of ZEROS in Fij. The 
!                               scaling factor varies until the number 
!                               of ZEROS (.000##) is equal for all 
!                               elements Fij.
!                      = 0      (Default)
!
!.......... NZEROSm             B = 10.0**(1-NZEROSm)
!                               Maximum number of zeros in Fij.
!                      = 5      (Default)
!
!.......... NZEROSr             B = 10.0**(1-NZEROSr)
!                               Number of zeros in Fij to restart 
!                               automatically the calculation.
!                      = 2      (Default)
!
!.......... AUTOZEROS           The code select automatically values
!                               for NZEROS,NZEROSm & NZEROSr
!                               Note: Override previously selected values
!                      = T      (Default)
!
!.......... ITZITER             Number of Iterations for constant scaling
!                      = 10     (Default)
!
!.......... DIIS                Direct Inversion in the Iterative 
!                               Subspace in the orbital optimization if 
!                               DUMEL < THDIIS every NDIIS loops
!                      = T      (Default)
!
!.......... NTHDIIS             Energy threshold to begin DIIS
!                      = 3      THDIIS = 10.0**(-NTHDIIS) (Default)
!
!.......... NDIIS               Number of considered loops to interpolate
!                               the generalized Fock matrix in the DIIS
!                      = 5      (Default)
!
!.......... PERDIIS             Periodic DIIS
!                      = T      Apply DIIS every NDIIS (Default)
!                      = F      DIIS is always applied after NDIIS
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Options for pertubative calculations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... OIMP2               NOF - Orbital Invariant MP2
!                     = F       (Default)
!.......... MBPT                NOF - RPA, NOF - GW, etc. 
!                     = F       (Default)
!.......... TDHF                TDHF, do TDHF instead of TDH 
!                     = F       (Default)
!.......... MBPTMEM             Allocate three times ERIs?
!                     = T       (Default)
!.......... TUNEMBPT            Tune ERIs before solving Casida Eq?
!                     = T       (Default)
!
!.......... NO1PT2              Frozen MOs in perturbative calculations
!                               Maximum index of NOs with Occupation = 1
!                      = -1     = NO1 (Default)
!                      = 0      All NOs are considered
!                      = Value  User specifies how many NOs are frozen
!
!.......... SC2MCPT             SC2-MCPT perturbation theory is used to
!                               correct the PNOF5 Energy. 
!                               2 outputs: PNOF5-SC2-MCPT and PNOF5-PT2
!                     = F       (Default)
!
!.......... NEX                 Number of excluded coupled orbitals 
!                               in the PNOF5-PT2 calculation
!                      = 0      All NOs are included (Default)
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Input Options for Gamma (Occ), C and Diagonal F
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!                     --- Restart Options ---
!
!.......... RESTART             Restart from GCF file (Default=F)
!                      = F      INPUTGAMMA=0,INPUTC=0,INPUTFMIUG=0
!                      = T      INPUTGAMMA=1,INPUTC=1,INPUTFMIUG=1
!
!.......... INPUTGAMMA          Guess for GAMMA variables (ONs)
!                      = 0      Close Fermi-Dirac Distribution (Default)
!                      = 1      Input from file GCF
!
!.......... INPUTC              Guess for Coefficient matrix (NOs)
!                      = 0      Use HCORE or HF Eigenvectors (Default)
!                      = 1      Input from file GCF
!
!.......... INPUTFMIUG          Guess for Diagonal elements (FMIUG0)
!                      = 0      Use single diag. of Lagragian (Default)
!                      = 1      Input from file GCF
!
!.......... INPUTCXYZ           Nuclear Coordinates (CXYZ)
!                      = 0      Input from input file (*.inp) (Default)
!                      = 1      Input from file GCF (only if RESTART=T)
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Output Options
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... NPRINT              Output Option (Default VALUE: 0)
!                      = 0      Short Printing (Occ,Emom,Energies)
!                      = 1      Output at initial and final iterations
!                               including MOs,Pop,APSG,Lag,IPs,DMs,CJK
!                      = 2      Output everything in each iteration
!
!.......... IWRITEC             Output Option for the Coefficient matrix
!                      = 0      No output (Default)
!                      = 1      Output the Coefficient Matrix (NOs)
!
!.......... IMULPOP             Mulliken Population Analysis
!                      = 0      Not do it (Default)
!                      = 1      Do it 
!
!.......... PRINTLAG            Output Option for Lagrange Multipliers
!                      = F      No Output (Default)
!
!.......... DIAGLAG             Diagonalize Lagrange Multipliers
!                               Print new 1e- Energies, Canonical MOs, 
!                               and new diagonal elements of the 1RDM
!                      = F      Not do it (Default)
!
!.......... IEKT                IPs by Ext. Koopmans' Theorem (EKT)
!                      = 0      Not calculate the IPs
!                      = 1      Calculate ionization potentials (IPs) 
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... IAIMPAC             Write information into WFN file 
!                               for the AIMPAC PROGRAM (UNIT 7)
!                      = 0      Don't write
!                      = 1      Write into WFN file (Default)
!
!.......... IFCHK               Write information into Formatted 
!                               Checkpoint (FCHK) file for visualization 
!                               software (UNIT 19)
!                      = 0      Don't write
!                      = 1      Write into FCHK file (Default)
!
!.......... MOLDEN              Write information into MLD file 
!                               for the MOLDEN PROGRAM (UNIT 17)
!                      = 0      Don't write 
!                      = 1      Write into MLD file (Default)
!
!.......... NOUTRDM             Print OPTION for ATOMIC RDMs 
!                      = 0      NO Output (Default)
!                      = 1      Print ATOMIC RDMs IN 1DM and 2DM files
!
!.......... NTHRESHDM           THRESHDM=10.0**(-NTHRESHDM)
!                      = 6      (Default)
!
!.......... NSQT                Print OPTION for 2DM file
!                      = 1      UNforMATTED (Default)
!                      = 0      forMATTED (SEE SUBROUTINE OUTPUTRDMrc)
!
!.......... NOUTCJK             Print OPTION for CJ12 and CK12
!                      = 0      NO Output (Default)
!                      = 1      Print CJ12 and CK12 in file 'CJK'
!
!.......... NTHRESHCJK          THRESHCJK=10.0**(-NTHRESHCJK)
!                      = 6      (Default)
!
!.......... NOUTTijab           Print OPTION for Tijab
!                      = 0      NO Output (Default)
!                      = 1      Print Tijab in file 'Tijab'
!
!.......... NTHRESHTijab        THRESHTijab=10.0**(-NTHRESHTijab)
!                      = 6      (Default)
!
!.......... APSG                Open an APSG file for printing the 
!                               coefficient matrix ($VEC-$END) and the
!                               expansion coefficients of the APSG
!                               generating wavefunction.
!                      = F      Output (Default)
!
!.......... NTHAPSG             Threshold for APSG expansion coefficient
!                               THAPSG = 10.0**(-NTHAPSG)
!                      = 10     (Default)
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Optional Options
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... ORTHO               Orthogonalize the initial orbitals
!                      = F      No 
!                      = T      Yes (Default)
!
!.......... CHKORTHO            Check the Orthonormality of the MOs
!                      = F      No (Default)
!                      = T      Yes
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! Options related to Frozen coordinates in gradient computation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... FROZEN              Is there any fixed coordinate
!                      = F      (Default)
!
!.......... IFROZEN             By pairs, what coordinate of which atom,
!                               e.g. 2,5,1,1 means "y" coordinate of
!                               atom 5 and "x" coor of atom 1 to freeze.
!                               MAXIMUM of frozen coordinates = 10
!                      = 0      (Default)
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!.......... ICGMETHOD           Define the Conjugate Gradient Method in
!                               OCCOPTr, CALTijabIsym and OPTIMIZE
!                      = 1      SUMSL: CGOCUPSUMSLr,OPTSUMSL
!                               SparseSymLinearSystem_CG (Default)
!                      = 2      Use NAG subroutines:
!                               E04DGF: OPTCGNAG,CGOCUPNAGr 
!                               F11JEF: SparseSymLinearSystem_NAG
!                      = 3      LBFGS: OPTLBFGS, LBFGSOCUPr
!
!-----------------------------------------------------------------------
      NAMELIST/NOFINP/MAXIT,ICOEF,IEINI,NO1,RHF,NCONVRHF,MAXITRHF,      &
                      HFDAMP,HFEXTRAP,HFDIIS,HFID,NTHRESHEID,MAXITID,   &
                      KOOPMANS,IPNOF,Ista,HighSpin,NCWO,NTHRESHL,       &
                      NTHRESHE,NTHRESHEC,NTHRESHEN,MAXLOOP,SCALING,     &
                      AUTOZEROS,NZEROS,NZEROSm,NZEROSr,ITZITER,DIIS,    &
                      NTHDIIS,NDIIS,PERDIIS,SC2MCPT,NO1PT2,NEX,OIMP2,   &
                      MBPT,TUNEMBPT,MBPTMEM,TDHF,                       & 
                      RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ,   &
                      NPRINT,IWRITEC,IMULPOP,APSG,NTHAPSG,PRINTLAG,     &
                      DIAGLAG,IAIMPAC,IFCHK,MOLDEN,IEKT,NOUTRDM,        &
                      NTHRESHDM,NSQT,NOUTCJK,NTHRESHCJK,NOUTTijab,      &
                      NTHRESHTijab,ORTHO,CHKORTHO,FROZEN,IFROZEN,       &
                      ICGMETHOD
!-----------------------------------------------------------------------
!     Preset values to namelist variables
!-----------------------------------------------------------------------
      MAXIT=1000

!     Type of Calculation
      ICOEF=1
      IEINI=0
      NO1=-1

!     Hartree-Fock
      RHF=.TRUE.                                  ! AO Basis
      NCONVRHF=5
      MAXITRHF=100
      HFDAMP=.TRUE.
      HFEXTRAP=.TRUE.
      HFDIIS=.TRUE.
      HFID=.FALSE.                                ! MO Basis
      NTHRESHEID=6      
      MAXITID=30
      KOOPMANS=0

!     PNOF Selection
      IPNOF=7
      Ista=0                                      ! PNOF7n            
      HighSpin=.FALSE.                            ! Multiplet      
      NCWO=1                                      ! Perfect Pairing

!     Convergence Criteria in NOF calculation
      NTHRESHL=3
      NTHRESHE=4
      NTHRESHEC=10
      NTHRESHEN=10

!     Options for the Orbital Optimization Program (ID Method)
      MAXLOOP=30
      SCALING=.TRUE.
      NZEROS=0
      NZEROSm=5
      NZEROSr=2      
      AUTOZEROS=.TRUE.      
      ITZITER=10
      DIIS=.TRUE.
      NTHDIIS=3
      NDIIS=5
      PERDIIS=.TRUE.

!     Options for pertubative calculations
      OIMP2=.FALSE.
      MBPT=.FALSE.
      TDHF=.FALSE.
      TUNEMBPT=.TRUE.
      MBPTMEM=.TRUE.
      NO1PT2=-1                  
      SC2MCPT=.FALSE.
      NEX=0      

!     Input Options for Gamma (Occ), C and Diagonal F
      RESTART=.FALSE.
      INPUTGAMMA=0
      INPUTC=0
      INPUTFMIUG=0
      INPUTCXYZ=0

!     Output Options
      NPRINT=0

!     for NPRINT>0
      IWRITEC=0
      IMULPOP=0
      PRINTLAG=.FALSE.
      DIAGLAG=.FALSE.  ! Only in the final Output
      IEKT=0           ! Only in the final Output
!
      IAIMPAC=1
      IFCHK=1
      MOLDEN=1
!
      NOUTRDM=0
      NTHRESHDM=6
      NSQT=1
!      
      NOUTCJK=0
      NTHRESHCJK=6
      NOUTTijab=0
      NTHRESHTijab=6
!
      APSG=.FALSE.
      NTHAPSG=10
      
!     Optional Options
      ORTHO=.TRUE.
      CHKORTHO=.FALSE.

!     Frozen coordinates
      FROZEN=.FALSE.
      IFROZEN=0

!     Options for the Conjugate Gradient Method
      ICGMETHOD=1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     READ NAMELIST VARIABLES
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CONTINUE
#else
      REWIND(5)
#endif
      READ(5,NOFINP,END=1,ERR=1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Automatic selection of NZEROS                
!     Note: Override the selected values in the namelist
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(AUTOZEROS)then
       IF(RESTART)then       ! RESTART=T
        if(NTHRESHL<=3)THEN
         NZEROS  = 2
         NZEROSr = 2
         NZEROSm = 5
        else
         NZEROS  = NTHRESHL - 1
         NZEROSr = NZEROS
         NZEROSm = NTHRESHL + 2
        end if
       ELSE                  ! RESTART=F
        if(NTHRESHL>3)THEN
         NTHRESHL=3
         WRITE(6,'(/1X,79A/)')'Beware of high NTHRESHL with RESTART=F, NTHRESHL has been reduced to 3 !!!'
        end if
        NZEROS  = 1
        NZEROSr = 2
        NZEROSm = NTHRESHL + 2
       END IF
      end if      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NVWO=-1 if NE=2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NE==2.and.NCWO/=-1)THEN
       WRITE(6,3)
       NCWO=-1
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Convergence Criteria
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CONVRHFDM   = 10.0**(-NCONVRHF) 
      THRESHEID   = 10.0**(-NTHRESHEID)
      THRESHL     = 10.0**(-NTHRESHL)
      THRESHE     = 10.0**(-NTHRESHE)
      THRESHEC    = 10.0**(-NTHRESHEC)
      THRESHEN    = 10.0**(-NTHRESHEN)
      THRESHDM    = 10.0**(-NTHRESHDM)
      THRESHCJK   = 10.0**(-NTHRESHCJK)
      THRESHTijab = 10.0**(-NTHRESHTijab)      
      THDIIS      = 10.0**(-NTHDIIS)
      THAPSG      = 10.0**(-NTHAPSG)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Force THRESHEC=1.0d-08 if larger than this value
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(THRESHEC>1.0d-08)THRESHEC=1.0d-08
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Mandatory Options with RUNTYP=OPTGEO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IRUNTYP==3)THEN
       if(HFID.or.RHF)then
        HFID = .FALSE.
         RHF = .FALSE.        
        WRITE(6,'(/,1X,35A,/)')'!OPTGEO: HF has been set equal FALSE'
       end if
       if(OIMP2)then      
        OIMP2 = .FALSE.
        NOUTTijab = 0
        WRITE(6,'(/,1X,38A,/)')'!OPTGEO: OIMP2 has been set equal FALSE'
       end if
       if(MBPT)then      
        MBPT = .FALSE.
        NOUTTijab = 0
        WRITE(6,'(/,1X,38A,/)')'!OPTGEO: MBPT has been set equal FALSE'
       end if
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Mandatory Options with RUNTYP=HESS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IRUNTYP==4)THEN
       if(HFID.or.RHF)then
        HFID = .FALSE.
         RHF = .FALSE.        
        WRITE(6,'(/,1X,39A,/)')'!HESS cal.: HF has been set equal FALSE'
       end if
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Restart Options
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(RESTART)THEN
       INPUTGAMMA=1
       INPUTC=1
       INPUTFMIUG=1
       INPUTCXYZ=1
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Stop if ICGMETHOD=2 to use NAG library (E04DKF,E04DGF,F11JEF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICGMETHOD==2)THEN
       WRITE(6,*)                                                       !nag
       WRITE(6,*)'Stop: To use the NAG library you must uncomment',&    !nag
                 '      the calls to the relevant routines'             !nag
       CALL ABRT                                                        !nag
       NTHRESHEN = 16                                               
       THRESHEN = 10.0**(-NTHRESHEN)                                
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Stop if ICOEF=2 to evaluate only the initial energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==2)THEN
       if(IEINI==1)then
        WRITE(6,*)'STOP: Choose ICOEF/=2 to evaluate the initial energy'
        CALL ABRT       
       else
        IEINI=1          ! IEINI=1 if ICOEF=2 without stopping the code
       endif
      ENDIF
!
      IF(ICOEF==3. .and. IERITYP==2)THEN
       WRITE(6,*)'Sorry: Fragment Calc. is not implemented with RI App.'
       CALL ABRT            
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     STOP if ICOEF > 3
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF>3)THEN
       WRITE(6,*)'STOP: ICOEF must be 0,1,2 or 3'
       CALL ABRT       
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     STOP options if IPNOF/=5 and APSG or SC2MCPT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPNOF/=5)THEN
       IF(APSG)THEN
        WRITE(6,*)'STOP: APSG=T is only valid for PNOF5'
        CALL ABRT       
       ENDIF
       IF(SC2MCPT)THEN
        WRITE(6,*)'STOP: SC2-MCPT is only valid for PNOF5'
        CALL ABRT       
       ENDIF
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
!-----------------------------------------------------------------------
!     Namelist Stop errors
!-----------------------------------------------------------------------
    1 WRITE(6,2)
      STOP
!-----------------------------------------------------------------------
!     Format definitions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    2 FORMAT(/2X,'**************************************',              &
             /2X,'*                                    *',              &
             /2X,'*            SORRY,                  *',              &
             /2X,'*   ERROR IN NAMELIST PARAMETERS     *',              &
             /2X,'*                                    *',              &
             /2X,'**************************************')               
    3 FORMAT(/1X,'!!! Warning: In the case of two electrons,'           &
             /5X,'there is only one electron pair.',                    &
             /5X,'To avoid spurious interpair contributions',           &
             /5X,'NCWO has been set equal to -1 !!! ')
!-----------------------------------------------------------------------
      END

! OUTPUTHEADER
      SUBROUTINE OUTPUTHEADER
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL DIIS,PERDIIS,RESTART,PRINTLAG,DIAGLAG
      LOGICAL APSG,CHKORTHO,ORTHO,HFID,HighSpin,SCALING
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_DIIS_1/DIIS,PERDIIS,NDIIS,NTHDIIS,THDIIS
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_LAGRANGE/PRINTLAG,DIAGLAG
      COMMON/INPNOF_APSG/APSG,NTHAPSG,THAPSG
      COMMON/INPNOF_ORTHOGONALITY/CHKORTHO,ORTHO
      COMMON/INPNOF_HFID/HFID,NTHRESHEID,THRESHEID,MAXITID,KOOPMANS       
      COMMON/INPNOF_EKT/IEKT      
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/INPNOF_ARDM/THRESHDM,NOUTRDM,NSQT,NTHRESHDM      
      COMMON/INPNOF_CJK/NOUTCJK,NTHRESHCJK,THRESHCJK      
      COMMON/INPNOF_Tijab/NOUTTijab,NTHRESHTijab,THRESHTijab
      COMMON/INPNOF_NTHRESH/NTHRESHL,NTHRESHE,NTHRESHEC,NTHRESHEN
      COMMON/INPNOF_COEFOPT/MAXLOOP
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPNOF_STATIC/Ista
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
!-----------------------------------------------------------------------
!     Set NZEROSm equul to NTHRESHL if NZEROSm < NTHRESHL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SCALING)THEN
       IF(NZEROSm<NTHRESHL)THEN
        NZEROSm = NTHRESHL
        WRITE(6,'(/,6X,38A,/)')'NZEROSm has been set equal to NTHRESHL'
       ENDIF
      ENDIF
!-----------------------------------------------------------------------
!     Write NAMELIST parameters on the Output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,3)
      IF(ICOEF==0)THEN
       WRITE(6,4)ICOEF
      ELSEIF(ICOEF==1)THEN
       WRITE(6,51)ICOEF
       WRITE(6,6)MAXIT
      ELSEIF(ICOEF==2)THEN
       WRITE(6,52)ICOEF
       WRITE(6,6)MAXIT
      ELSEIF(ICOEF==3)THEN
       WRITE(6,53)ICOEF
       WRITE(6,6)MAXIT
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write the Functional used
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(3<=IPNOF.and.IPNOF<=7)THEN
       WRITE(6,7)IPNOF
       if(IPNOF==7)THEN
        if(Ista==1)WRITE(6,*)                                           &
      'Static Version of Functional PNOF7s:    (Ista)          1'
       end if
      ELSE
       WRITE(6,*)'Stop Program: Select IPNOF between 3 and 8'
       CALL ABRT       
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - -
      IF(MUL>1)THEN
       IF(.NOT.(IPNOF==5.or.IPNOF==7))THEN
        WRITE(6,'(/A44)')' Stop: IPNOF must be equal 5 or 7 for MULT>1'
        CALL ABRT       
       ENDIF
       IF(HighSpin)THEN
        WRITE(6,*)                                                      &
      'High-Spin State calculation Option:     (HighSpin)      T'        
       ELSE                                                              
        WRITE(6,*)                                                      &
      'Spin-Multiplet, High-Spin State Option: (HighSpin)      F'
       ENDIF
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - 
      WRITE(6,*)
      IF(RESTART)THEN
       WRITE(6,*)                                                       &
      'Restart calculation Option:             (RESTART)       T'        
      ELSE                                                               
       WRITE(6,*)                                                       &
      'Restart calculation Option:             (RESTART)       F'
      ENDIF
      IF(.NOT.RESTART)WRITE(6,8)INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(HFID)THEN
       WRITE(6,85)NTHRESHEID,MAXITID,KOOPMANS
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1)THEN
       WRITE(6,9)NTHRESHL,NTHRESHE,NTHRESHEC,NTHRESHEN,MAXLOOP
      ELSEIF(ICOEF==2)THEN
       WRITE(6,9)NTHRESHL,NTHRESHE,NTHRESHEC,NTHRESHEN,MAXLOOP
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ORTHO)WRITE(6,*)                                               &
      'Orthogonalize the initial Orbitals:     (ORTHO)         T'        
      IF(CHKORTHO)WRITE(6,*)                                            &
      'Check the orthonormality of MOs:        (CHKORTHO)      T'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1.and.SCALING)THEN
       WRITE(6,10)NZEROS,NZEROSm,NZEROSr,ITZITER
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(.not.SCALING)THEN
       WRITE(6,*)
       WRITE(6,*)'Warning: Scaling Technique is not used !'
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1)THEN
       IF(DIIS)THEN
        WRITE(6,*)
        WRITE(6,*)                                                      &
      'DIIS technique is used in Orb. Opt.:    (DIIS)          T'        
        WRITE(6,13)NTHDIIS,NDIIS                                         
        IF(PERDIIS)THEN                                                  
         WRITE(6,*)                                                     &
      'Periodic DIIS every NDIIS:              (PERDIIS)       T'        
         ELSE                                                            
          WRITE(6,*)                                                    &
      'DIIS is always applied after NDIIS      (PERDIIS)       F'        
        ENDIF                                                            
       ELSE                                                              
        WRITE(6,*)                                                      &
      'DIIS Technique is not used:             (DIIS)          F'
       ENDIF
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,11)NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK,MOLDEN,IEKT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(APSG)THEN
       WRITE(6,*)                                                       &
      'Write APSG expansion coefficient file:  (APSG)          T'        
       WRITE(6,14)NTHAPSG                                                
      ELSE                                                               
       WRITE(6,*)                                                       &
      'Write APSG expansion coefficient file:  (APSG)          F'
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1)THEN
       IF(PRINTLAG)THEN
        WRITE(6,*)                                                      &
      'Output option for Lagrange Multipliers: (PRINTLAG)      T'        
       ELSE                                                              
        WRITE(6,*)                                                      &
      'Output option for Lagrange Multipliers: (PRINTLAG)      F'
       ENDIF
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(DIAGLAG)THEN
       WRITE(6,*)                                                       &
      'Diagonalize matrix of Lag. Multipliers: (DIAGLAG)       T'        
      ELSE                                                               
       WRITE(6,*)                                                       &
      'Diagonalize matrix of Lag. Multipliers: (DIAGLAG)       F'
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOUTRDM==1)WRITE(6,12)NOUTRDM,NTHRESHDM
      IF(NOUTCJK==1)WRITE(6,15)NOUTCJK,NTHRESHCJK
      IF(NOUTTijab==1)WRITE(6,16)NOUTTijab,NTHRESHTijab
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
!-----------------------------------------------------------------------
!     Format definitions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    3 FORMAT(/,' Input NOF Options',/,                                  &
               ' -----------------')                                     
    4 FORMAT(                                                           &
       /1X,'Type of calculation = No Coeff. Opt.:   (ICOEF)     ',I5)    
   51 FORMAT(                                                           &
       /1X,'Type of calculation = Iter-Diag-Method: (ICOEF)     ',I5)    
   52 FORMAT(                                                           &
       /1X,'Type of calculation = No Occup. Opt.:   (ICOEF)     ',I5)    
   53 FORMAT(                                                           &
       /1X,'Type of calculation = Fragment Calc.:   (ICOEF)     ',I5)    
    6 FORMAT(                                                           &
        1X,'Maximum Number of Occ-Coef Outer Iter.: (MAXIT)     ',I5)    
    7 FORMAT(                                                           &
        1X,'Natural Orbital Functional Selected:    (IPNOF)     ',I5)    
    8 FORMAT(                                                           &
        1X,'Restart Gamma Matrix from GCF file:     (INPUTGAMMA)',I5,   &
       /1X,'Coefficient Matrix from GCF file:       (INPUTC)    ',I5,   &
       /1X,'Diagonal Elements FMIUG from GCF file:  (INPUTFMIUG)',I5,   &
       /1X,'Cartesian Coordinates from GCF file:    (INPUTCXYZ) ',I5)    
   85 FORMAT(                                                           &
       /1X,'Hartree-Fock Calc. using ID Method:     (HFID)', 10X,'T',   &
       /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHEID)',I5,   &
       /1X,'Max. Number of External Iterations:     (MAXITID)   ',I5,   &
       /1X,'Ion. Potentials by Koopmans Theorem:    (KOOPMANS)  ',I5)    
    9 FORMAT(                                                           &
       /1X,'Threshold Lambda Convergence=10**(-N):  (NTHRESHL)  ',I5,   &
       /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHE)  ',I5,   &
       /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHEC) ',I5,   &
       /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHEN) ',I5,   &
      //1X,'Max. Number of Inner Coef. Iterations:  (MAXLOOP)   ',I5)    
   10 FORMAT(                                                           &
       /1X,'Scaling Parameters:',                                       &
       /1X,'Initial Number of Zeros IN Fij:         (NZEROS)    ',I5,   &
       /1X,'Maximum Number of Zeros IN Fij:         (NZEROSm)   ',I5,   &
       /1X,'Restart Number of Zeros IN Fij:         (NZEROSr)   ',I5,   &
       /1X,'Number of Iter with constant Scaling:   (ITZITER)   ',I5)    
   11 FORMAT(                                                           &
       /1X,'Output Option:                          (NPRINT)    ',I5,   &
       /1X,'Output the Coefficient Matrix:          (IWRITEC)   ',I5,   &
       /1X,'Do a Mulliken Population Analysis:      (IMULPOP)   ',I5,   &
       /1X,'Write Information into a WFN file:      (IAIMPAC)   ',I5,   &
       /1X,'Write Information into a FCHK file:     (IFCHK)     ',I5,   &
       /1X,'Write Information into a MLP file:      (MOLDEN)    ',I5,   &
       /1X,'Calculate IPs using Ext. Koopmans Theo: (IEKT)      ',I5)    
   12 FORMAT(                                                           &
       /1X,'Print atomic RDMs to files 1DM and 2DM: (NOUTRDM)   ',I5,   &
       /1X,'Threshold DMs = 10.0**(-NTHRESHDM):     (NTHRESHDM) ',I5)    
   13 FORMAT(                                                           &
        1X,'Threshold to begin DIIS = 10**(-N):     (NTHDIIS)   ',I5,   &
       /1X,'Number of considered Loops in DIIS:     (NDIIS)     ',I5)    
   14 FORMAT(                                                           &
        1X,'Threshold APSG Exp. Coef. = 10**(-N):   (NTHAPSG)   ',I5)    
   15 FORMAT(                                                           &
       /1X,'Print CJ12 and CK12 to file CJK:        (NOUTCJK)   ',I5,   &
       /1X,'Threshold CJKs = 10.0**(-NTHRESHCJK):   (NTHRESHCJK)',I5)    
   16 FORMAT(                                                           &
       /1X,'Print OIMP2 Ampl. Tijab to file Tijab:  (NOUTTijab) ',I5,   &
       /1X,'Threshold Tijab=10.0**(-NTHRESHTijab):  (NTHRESHTijab)',I3)
!-----------------------------------------------------------------------
      END

! OPENFILES
      SUBROUTINE OPENFILES(IRUNTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL APSG
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_APSG/APSG,NTHAPSG,THAPSG
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/INPNOF_ARDM/THRESHDM,NOUTRDM,NSQT,NTHRESHDM      
      COMMON/INPNOF_CJK/NOUTCJK,NTHRESHCJK,THRESHCJK      
      COMMON/INPNOF_Tijab/NOUTTijab,NTHRESHTijab,THRESHTijab
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
!-----------------------------------------------------------------------
!     NOF Files    CONTENTS
!     ------------------------------------------------------------------
!      1  (ERI)    2e-Integrals File for 1/r12 interaction (DONTW=F)
!      2  (CGM)    Output File for CGM routines (ICGMETHOD=1,2,3)
!      3  (GCF)    GAMMA, Coefficient Matrix (C), Energies (E), FMIUG0
!      4  (BFST)   Basis Function Symbol Table
!      5           Input File
!      6           Output File
!      7  (WFN)    WFN File for AIMPAC Program
!      8  (GCFe)   GCF file corresponding to the minimum energy
!      9  (APSG)   Coefficient Matrix (C) and APSG Wavefunction of PNOF5
!     10  (FRAG)   FRAG file containing the fragment information
!     11  (CGGRAD) Output File for Optimization
!     12  (CJK)    Output File for CJ12 and CK12 (NOUTCJK)
!     13  (CND)    Output File for Non-Dynamic CK12 and MP2 amplitudes
!     14  (2DM)    Output File for atomic 2RDM (NOUTRDM)
!     15  (1DM)    Output File for atomic 1RDM (NOUTRDM)
!     16  (N2DM)   Output File for Record Number if NSQT=1
!     17  (MLD)    Output File for MOLDEN Program
!     18  (XYZ)    Output File with Geometries for MOLDEN Program
!     19  (FCHK)   Formatted checkpoint file for visualization softwares
!
!     50  (BASIS_FILE) Opened in Subroutine ATOMS <- MOLECULE <- START
!-----------------------------------------------------------------------
!                    Open general working files
!-----------------------------------------------------------------------
      OPEN(2,FILE='CGM',STATUS='UNKNOWN',FORM='FORMATTED',              &
             ACCESS='SEQUENTIAL')                                        
      OPEN(3,FILE='GCF',STATUS='UNKNOWN',FORM='FORMATTED',              &
             ACCESS='SEQUENTIAL')                                        
      OPEN(4,FILE='BFST',STATUS='UNKNOWN',FORM='FORMATTED',             &
             ACCESS='SEQUENTIAL')                                        
      IF(IAIMPAC==1)OPEN(7,FILE='WFN',STATUS='UNKNOWN',                 &
                           FORM='FORMATTED',ACCESS='SEQUENTIAL')         
      OPEN(8,FILE='GCFe',STATUS='UNKNOWN',FORM='FORMATTED',             &
             ACCESS='SEQUENTIAL')                                        
      IF(APSG)OPEN(9,FILE='APSG' ,STATUS='UNKNOWN',                     &
                     FORM='FORMATTED',ACCESS='SEQUENTIAL')               
      IF(ICOEF==3)OPEN(10,FILE='FRAG' ,STATUS='OLD',                    &
                          FORM='FORMATTED',ACCESS='SEQUENTIAL')          
      IF(IRUNTYP==3.or.IRUNTYP==4)OPEN(11,FILE='CGGRAD',                &
         STATUS='UNKNOWN',FORM='FORMATTED',ACCESS='SEQUENTIAL')          
      IF(NOUTCJK==1)OPEN(12,FILE='CJK',STATUS='UNKNOWN',                &
                            FORM='UNFORMATTED')                          
      IF(NOUTTijab==1)OPEN(13,FILE='CND',STATUS='UNKNOWN',              &
                              FORM='UNFORMATTED')                        
      IF(NOUTRDM==1)THEN                                                 
       if(NSQT==0)then                                                   
        OPEN(14,FILE='2DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',        &
                FORM='FORMATTED')                                        
        OPEN(15,FILE='1DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',        &
                FORM='FORMATTED')                                        
       else if(NSQT==1)then                                              
        OPEN(14,FILE='2DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',        &
                FORM='UNFORMATTED')                                      
        OPEN(15,FILE='1DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',        &
                FORM='FORMATTED')                                        
        OPEN(16,FILE='N2DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',       &
                FORM='FORMATTED')                                        
       end if                                                            
      END IF                                                             
      IF(MOLDEN==1)THEN                                                  
       OPEN(17,FILE='MLD',STATUS='UNKNOWN',FORM='FORMATTED',            &
               ACCESS='SEQUENTIAL')                                      
       OPEN(18,FILE='XYZ',STATUS='UNKNOWN',FORM='FORMATTED',            &
               ACCESS='SEQUENTIAL')
      ENDIF
      IF(IFCHK==1)OPEN(19,FILE='FCHK',STATUS='UNKNOWN',                 &
                          FORM='FORMATTED',ACCESS='SEQUENTIAL')
!-----------------------------------------------------------------------
      RETURN
      END

! OUTPUTBASIC
      SUBROUTINE OUTPUTBASIC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPFILE_NO1PT2/NO1PT2,NEX
!-----------------------------------------------------------------------
!     NE: Number of Electrons
!     MUL: State Multiplicity
!     NCO: Number of doubly filled molecular orbitals in HF (CLOSED)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NCO = NB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NSOC: Number of strongly singly occupied MOs                      
!     NTWOPAR: 1 => Two-particle case
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NTWOPAR = 0
!     Spin-compensated
      IF( NB==(NE+MUL-1)/2 .and. NA==(NE-MUL+1)/2 )THEN
       NSOC=0  
       MSpin=0
!      Two-particle case
       IF(NB==1)NTWOPAR=1
       IF(NA/=NB)THEN
        WRITE(6,1)NA,NB
        CALL ABRT       
       ENDIF
!     Spin-uncompensated [ NA = NB+MUL-1 ]
      ELSE IF( NB==(NE-MUL+1)/2 .and. NA==(NE+MUL-1)/2 )THEN
       NSOC=NA-NB
       if(HighSpin)then
        MSpin=NSOC
       else
        MSpin=0
       endif
       IF(NB==0.and.NA==2)NTWOPAR=1
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NO1: Number of doubly filled NOs with occupancies equal to one
!     NO1PT2: Number of doubly filled NOs in perturbative calculations
!     Stop Program if NO1 > NB or NO1PT2 >= NB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NO1>NB)THEN
       WRITE(6,2)
       CALL ABRT       
      ENDIF
      IF(NO1PT2>=NB)THEN
       write(6,3)
       CALL ABRT       
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     EVEC: Electric Field components
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EX.ne.0.0d0.or.EY.ne.0.0d0.or.EZ.ne.0.0d0)THEN
       EFIELDL=.TRUE.
      ELSE
       EFIELDL=.FALSE.
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
!-----------------------------------------------------------------------
!     Format definitions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(/'Spin compensated but NA (',I3,') not equal NB (',I3,')'  &
             /' JOB ABANDONED'/)
    2 FORMAT(/,' Error: NO1 > NB (doubly filled NOs) -> Stop Program')
    3 FORMAT(/,' Error: NO1PT2 >= NB (doubly filled NOs)->Stop Program')    
!-----------------------------------------------------------------------
      END

! SETNO1
      SUBROUTINE SETNO1(IAN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      INTEGER,DIMENSION(NATOMS)::IAN
!-----------------------------------------------------------------------
!     Determine NO1 (NOs with ONs equal to 1, according to the true 
!     nuclear charges if NO1=-1.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NO1= 0
      DO I=1,NATOMS
       NUCZ = IAN(I)
       IF( 1<=NUCZ.and.NUCZ<=  2)NO1i =  0          ! H-He
       IF( 3<=NUCZ.and.NUCZ<= 10)NO1i =  1          ! Li-Ne
       IF(11<=NUCZ.and.NUCZ<= 18)NO1i =  5          ! Na-Ar
       IF(19<=NUCZ.and.NUCZ<= 36)NO1i =  9          ! K-Kr
       IF(37<=NUCZ.and.NUCZ<= 49)NO1i = 18          ! Rb-In
       IF(50<=NUCZ.and.NUCZ<= 54)NO1i = 23          ! Sn-Xe
       IF(55<=NUCZ.and.NUCZ<= 71)NO1i = 27          ! Cs-Lu
       IF(72<=NUCZ.and.NUCZ<= 81)NO1i = 30          ! Hf-Tl
       IF(82<=NUCZ.and.NUCZ<= 86)NO1i = 39          ! Pb-Rn
       IF(87<=NUCZ.and.NUCZ<=109)NO1i = 43          ! Fr-Mt
       NO1 = NO1 + NO1i
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                   I N P U T   S U B R O U T I N E S                  !
!                                                                      !
!======================================================================!

! START                                            
      SUBROUTINE START(NATOMS,NATmax,NBF,NBFaux,NUQMT,NELEC,NALP,NBET,  &
                       NSHELL,NSHELLmax,NSHELLSaux,NPRIMI,NPRIMImax,    &
                       ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,KSTART,KATOM,KTYPE, &
                       KNG,KLOC,KMIN,KMAX,INTIPO,ISHPIR,ITIPO,C1,C2,EX, &
                       CS,CP,CD,CF,CG,CH,CI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER(4) :: ERITYP,GEN 
      CHARACTER(8) :: UNITS
      LOGICAL EFLDL,LINEAR                                                  
!
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      COMMON/INFOB/NUMaux,NSHELLaux
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      COMMON/ELPROP/IEMOM      
      COMMON/CONTROL/UNITS  
      COMMON/ZMAT/LINEAR 
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/RUNTYPE/IRUNTYP
      COMMON/WRTGCF/IWRTGCF                                                  
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
!      
      INTEGER,DIMENSION(NATmax) :: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELLmax) :: KSTART,KATOM,KTYPE,KNG
      INTEGER,DIMENSION(NSHELLmax) :: KLOC,KMIN,KMAX,INTIPO
      INTEGER,DIMENSION(NPRIMImax) :: ISHPIR,ITIPO
      DOUBLE PRECISION,DIMENSION(NPRIMImax) :: C1,C2,EX,CS,CP
      DOUBLE PRECISION,DIMENSION(NPRIMImax) :: CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NATmax) :: ZAN,ZMASS
      DOUBLE PRECISION,DIMENSION(3,NATmax) :: Cxyz
      DOUBLE PRECISION,DIMENSION(3) :: VMOI
!
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: COM
!-----------------------------------------------------------------------
!     System                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      MWORDS = 0                                                        
      JRET = 0   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Read the Molecule and its normal basis set
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MOLECULE(NSHELL,NPRIMI,NATmax,NSHELLmax,NPRIMImax,C1,C2,EX,  &
                    CS,CP,CD,CF,CG,CH,CI,KSTART,KATOM,KTYPE,KNG,KLOC,   &
                    KMIN,KMAX,IMIN,IMAX,INTIPO,ISHPIR,ITIPO,ZAN,Cxyz)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     True Nuclear Charges
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,NAT                                                      
       IAN(I) = INT(ZAN(I)+0.001D0)                             
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Atomic Mass Table  ( ZMASS: normal masses )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL AMT(ZAN,ZMASS,NAT)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check for Linear Molecule
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(COM(3,NAT))
      CALL VCLR(VMOI,1,3)                                               
      IF(NAT>0)CALL INRTIA(Cxyz,COM,ZMASS,VMOI,NAT)                    
      LINEAR = .FALSE.                                                    
      IF(VMOI(1)<1.0D-04)LINEAR = .TRUE. 
      IF(NAT==1)LINEAR = .FALSE.               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print Input Run Options
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,1)IRUNTYP,MUL,ICH,IECP,IEMOM,UNITS
      if(EFLDL)then
       WRITE(6,'(/1X,A15,3F10.5)')'Electric Field:',(EVEC(I),I=1,3)
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write GCF file for Restart calculations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IWRTGCF = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ECP Input
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ECPPAR(KTYPE,NSHELL,ZAN,Cxyz)                                                           
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Schwarz inequality on if NAT>5: Integrals < 10.0**(-9) aren't used
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NAT>5)ISCHWZ = 1                                                    
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ERITYP & GEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
      IF(IERITYP==1)THEN
       ERITYP = 'FULL'
       WRITE(6,2)1.0D-09,ISCHWZ,ERITYP       
      ELSE IF(IERITYP==2)THEN
       ERITYP = 'RI'
       if(ISTAR==0)WRITE(GEN,'(A1,I1)')    'A',IGEN
       if(ISTAR==1)WRITE(GEN,'(A1,I1,A1)') 'A',IGEN,'*'
       WRITE(6,3)1.0D-09,ISCHWZ,ERITYP,GEN       
      ELSE IF(IERITYP==3)THEN
       ERITYP = 'MIX'
       if(ISTAR==0)WRITE(GEN,'(A1,I1)')    'A',IGEN
       if(ISTAR==1)WRITE(GEN,'(A1,I1,A1)') 'A',IGEN,'*'
       WRITE(6,3)1.0D-09,ISCHWZ,ERITYP,GEN
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Abort Program if LMAXIMA > 5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      IF(LMAXIMA>5)THEN                                                
       WRITE(6,'(35A)')'Functions with LMAX > 5 not allowed'           
       CALL ABRT                                                      
      END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Passing values to DoNOF through START
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NBF    = NUM
      NATOMS = NAT
      NUQMT  = NQMT
      NELEC  = NE
      NALP   = NA
      NBET   = NB
!     RI
      NBFaux = NUMaux
      NSHELLSaux = NSHELLaux
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(COM)
      RETURN                                                            
!-----------------------------------------------------------------------
    1 FORMAT(/1X,'Input Run Options',/,                                 &
              1X,'-----------------',/,                                 &
       1X,'IRUNTYP =',I2,2X,'MULT =',I2,2X,'ICHARG =',I2,2X,'IECP =',I2,&       
       2X,'IEMOM =',I2,2X,'UNITS = ',A8)                    
    2 FORMAT(/1X,'Integral Options'/,1X,16(1H-)/1X,'CUTOFF =',1P,E8.1,  &
              3X,'ISCHWZ =',I2,3X,'ERITYP =',A5)
    3 FORMAT(/1X,'Integral Options'/,1X,16(1H-)/1X,'CUTOFF =',1P,E8.1,  &
              3X,'ISCHWZ =',I2,3X,'ERITYP =',A5,3X,'GEN =',A5)
!-----------------------------------------------------------------------
      END                                                               

! MOLECULE
      SUBROUTINE MOLECULE(NSHELL,NPRIMI,NATmax,NSHELLmax,NPRIMImax,     &
                          C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,KSTART,KATOM,   &
                          KTYPE,KNG,KLOC,KMIN,KMAX,IMIN,IMAX,INTIPO,    &
                          ISHPIR,ITIPO,ZAN,Cxyz)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/FRAME /U1,U2,U3,V1,V2,V3,WW1,WW2,WW3,X0,Y0,Z0     ! PTGRP            
      CHARACTER(80) :: TITLE, BASIS_FILE
      COMMON/TIT/TITLE
      COMMON/BASIS_FILE/BASIS_FILE
      INTEGER,DIMENSION(NSHELLmax) :: KSTART,KATOM,KTYPE,KNG
      INTEGER,DIMENSION(NSHELLmax) :: KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMImax) :: C1,C2,EX,CS,CP
      DOUBLE PRECISION,DIMENSION(NPRIMImax) :: CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NATmax) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NATmax) :: Cxyz
!
      INTEGER,DIMENSION(NATmax)  :: IMIN,IMAX
      INTEGER,DIMENSION(NSHELLmax) :: INTIPO
      INTEGER,DIMENSION(NPRIMImax) :: ISHPIR,ITIPO 
!
#include "mpip.h"
!-----------------------------------------------------------------------
!     Read Atom Coordinates and Basis from the Input File ($DATA)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CONTINUE
#else
      REWIND(5)
#endif
      CALL FNDGRP(5,' $DATA  ',IEOF)
      IF(IEOF/=0)THEN
       WRITE(6,1)' $DATA  '
       CALL ABRT
      ENDIF
      CALL OPNCRD
      READ (5,'(A80)')TITLE
      WRITE(6,2)TITLE
      READ (5,'(A80)')BASIS_FILE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Read Atoms
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ATOMS(NSHELL,NPRIMI,NATmax,NSHELLmax,NPRIMImax,C1,C2,EX,CS,  &
                 CP,CD,CF,CG,CH,CI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,    &
                 KMAX,IMIN,IMAX,INTIPO,ISHPIR,ITIPO,ZAN,Cxyz)
      CALL SETLAB(KATOM,KMIN,KMAX,NSHELL,ZAN)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
!-----------------------------------------------------------------------
    1 FORMAT(1X,'**** ERROR, NO ',A8,' GROUP WAS FOUND')
    2 FORMAT(/1X,'Run Title',/1X,9(1H-)/1X,A80)
!-----------------------------------------------------------------------
      END

! ATOMS                                            
      SUBROUTINE ATOMS(NSHELL,NPRIMI,NATmax,NSHELLmax,NPRIMImax,C1PIR,  &
                       C2PIR,EX,CS,CP,CD,CF,CG,CH,CI,KSTART,KATOM,KTYPE,&
                       KNG,KLOC,KMIN,KMAX,IMINPIR,IMAXPIR,INTIPO,       &
                       ISHPIR,ITIPO,ZAN,Cxyz)
      USE ISO_C_BINDING      
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION,PARAMETER :: PT2953=29.53125D0
      DOUBLE PRECISION,PARAMETER :: PT1624=162.421875D0
      DOUBLE PRECISION,PARAMETER :: PT75=0.75D0
      DOUBLE PRECISION,PARAMETER :: PT187=1.875D0
      DOUBLE PRECISION,PARAMETER :: TM10=1.0D-10
      DOUBLE PRECISION,PARAMETER :: PT6562=6.5625D0
      DOUBLE PRECISION,PARAMETER :: UNIT=0.52917724924D0
      CHARACTER(8), DIMENSION(103,7) :: ABASIS
      INTEGER, DIMENSION(103,7) :: IAGAUS
      COMMON/INTNAL/NATIN 
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      COMMON/CONV/ACURCY,EN,Etot,EHF,EHF0,DIFF,ITER,ICALP,ICBET                    
      COMMON/INFOB/NUMaux,NSHELLaux
      COMMON/MAPSHEL/MAPSHL(500,48),NT
      COMMON/TRANSF/XP,YP,ZP 
!
      COMMON/USELIBRETA/ILIBRETA
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
!
      INTEGER,DIMENSION(NSHELLmax) :: KSTART,KATOM,KTYPE,KNG
      INTEGER,DIMENSION(NSHELLmax) :: KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMImax) :: C1PIR,C2PIR
      DOUBLE PRECISION,DIMENSION(NPRIMImax) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NATmax) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NATmax) :: Cxyz
!      
      INTEGER,DIMENSION(NATmax)  :: IMINPIR,IMAXPIR
      INTEGER,DIMENSION(NSHELLmax) :: INTIPO
      INTEGER,DIMENSION(NPRIMImax) :: ISHPIR,ITIPO       
      INTEGER,DIMENSION(NATmax,48) :: MAPCTR
      CHARACTER(8),DIMENSION(NATmax) :: ANAM
      CHARACTER(2),DIMENSION(NATmax) :: BNAM
!
      CHARACTER(8) :: BLANK
      DATA BLANK /'        '/
      CHARACTER(8) :: CBASIS                       
      CHARACTER(8),DIMENSION(8) :: LABEL
      DATA LABEL/'S       ','P       ','D       ','F       ',           &
                 'G       ','H       ','I       ','L       '/
      INTEGER,DIMENSION(8) :: NBFS,MINF,MAXF,NANGM
      DATA NBFS / 1, 3,  6, 10, 15, 21, 28, 4/                 
      DATA MINF / 1, 2,  5, 11, 21, 36, 57, 1/                 
      DATA MAXF / 1, 4, 10, 20, 35, 56, 84, 4/                 
      DATA NANGM/ 1, 2,  3,  4,  5,  6, 7,  2/                 
      CHARACTER(8) :: LETK
      DATA LETK/'K       '/ 
      CHARACTER(8) :: BASIS
      CHARACTER(10) :: ATOMNM,ENDWRD
      DATA ENDWRD /'$END      '/                                        
!
      LOGICAL :: SPRKLE,QMCHKA,QMCHKB,FILE_EXISTS      
      CHARACTER(80) :: BASIS_FILE,PREFIX,BASIS_FILE_1
      COMMON/BASIS_FILE/BASIS_FILE
!
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CSINP,CPINP,CDINP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CFINP,CGINP,CHINP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CIINP,EXX,CSS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CPP,CDD,SCFAC
      INTEGER,ALLOCATABLE,DIMENSION(:) :: INTYP,NS,KS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CINP
!-----------------------------------------------------------------------
      ALLOCATE(INTYP(NPRIMImax),NS(NATmax),KS(NATmax))  
      ALLOCATE(EXX(6),CSS(6),CPP(6),CDD(6),SCFAC(4))
      ALLOCATE(CSINP(NPRIMImax),CPINP(NPRIMImax),CDINP(NPRIMImax))
      ALLOCATE(CFINP(NPRIMImax),CGINP(NPRIMImax))
      ALLOCATE(CHINP(NPRIMImax),CIINP(NPRIMImax))
      IF(ILIBRETA==1)ALLOCATE(CINP(NPRIMImax))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NT = 1                         ! No symmetry point group - > C1
      PI = 2.0d0*DASIN(1.0d0)
      PI32 = PI*SQRT(PI)                                              
      CBASIS = BLANK                                                 
      BASIS  = BLANK
      IDUM   = 0                                                          
      IGAUSS = 0                                                        
      NAT    = 0                                                           
      NATIN  = 0                                                         
      NE     = 0                                                            
      NSHELL = 0                                                        
      LOC    = 0                                                           
      NGAUSS = 0                                                        
      DO I = 1,NPRIMImax                                               
       EX(I) = 0.0D0                                                   
       CS(I) = 0.0D0                                                   
       CP(I) = 0.0D0                                                   
       CD(I) = 0.0D0                                                   
       CF(I) = 0.0D0                                                   
       CG(I) = 0.0D0                                                   
       CH(I) = 0.0D0                                                   
       CI(I) = 0.0D0                                                   
       CSINP(I) = 0.0D0                                                
       CPINP(I) = 0.0D0                                                
       CDINP(I) = 0.0D0                                                
       CFINP(I) = 0.0D0                                                
       CGINP(I) = 0.0D0                                                
       CHINP(I) = 0.0D0                                                
       CIINP(I) = 0.0D0                                                
      END DO
      ZNUC = 0.0D0                                                       
      X = 0.0D0                                                          
      Y = 0.0D0                                                          
      Z = 0.0D0                                                          
      SCFAC(1) = 0.0D0                                                   
      SCFAC(2) = 0.0D0                                                   
      SCFAC(3) = 0.0D0                                                   
      SCFAC(4) = 0.0D0                                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                               Read Atoms
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Open Basis Set file if exists
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(LEN_TRIM(BASIS_FILE)>0)THEN
       CALL GETENV( 'HOME', PREFIX ) 
       BASIS_FILE_1 = TRIM(PREFIX)//'/DoNOFsw/basis/'//                 &
                      TRIM(ADJUSTL(BASIS_FILE))//".bas"
       INQUIRE(FILE=BASIS_FILE_1,EXIST=FILE_EXISTS)
       if(FILE_EXISTS)then                            ! in DoNOFsw
        BASIS_FILE = BASIS_FILE_1       
!      DoNOF
       else
        BASIS_FILE_1= TRIM(PREFIX)//'/DoNOF/basis/'//                   &
                      TRIM(ADJUSTL(BASIS_FILE))//".bas"                  
        INQUIRE(FILE=BASIS_FILE_1,EXIST=FILE_EXISTS)                     
        if(FILE_EXISTS)then                           ! in DoNOF         
         BASIS_FILE = BASIS_FILE_1                                       
        else                                                             
         CALL GETENV( 'PWD', PREFIX )                                    
         BASIS_FILE_1 = TRIM(PREFIX)//"/"//                             &
                        TRIM(ADJUSTL(BASIS_FILE))//".bas"                
         INQUIRE(FILE=BASIS_FILE_1,EXIST=FILE_EXISTS)                    
         if(FILE_EXISTS)then                          ! in pwd           
          BASIS_FILE = BASIS_FILE_1                                      
         else                                                            
          BASIS_FILE_1 = TRIM(ADJUSTL(BASIS_FILE))                       
          INQUIRE(FILE=BASIS_FILE_1,EXIST=FILE_EXISTS)                   
          if(FILE_EXISTS)then                         ! in given path    
           BASIS_FILE = BASIS_FILE_1                                     
          else                             ! basis set file not found    
           WRITE(6,*)"Basis File ",TRIM(BASIS_FILE)," does not exist"    
           CALL ABRT                                                     
          endif                                                          
         endif                                                           
        endif                                                            
       endif                                                             
!      Open Basis Set File ( Unit = 50 )                                 
       OPEN(50,FILE=BASIS_FILE,STATUS='UNKNOWN',                        &
               FORM='FORMATTED',ACCESS='SEQUENTIAL')                     
       WRITE(6,'(/1X,A9,/1X,9(1H-)/1X,A80)')'Basis Set',BASIS_FILE       
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INPATM = 0                                                                       
    1 CONTINUE                                                          
      INPATM = INPATM + 1   
      CALL READAT(ATOMNM,ZNUC,X,Y,Z)  
!
      IF(ADJUSTL(ATOMNM)/=ADJUSTL(ENDWRD))THEN
       NAT = NAT+1                                                       
       IF(NAT+1>NATmax)THEN
        WRITE(6,'(/,1X,A22,I6)')'Stop: NAT+1 > NATmax =',NAT                                 
        CALL ABRT                                                         
       ENDIF
       READ(UNIT=ATOMNM,FMT='(A8,A2)')ANAM(NAT),BNAM(NAT) 
!
       if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
        REWIND(50)
        CALL FNDATMBASIS(ANAM(NAT),IEOF)   
       endif
!
       NS(NAT) = 0                                                       
       KS(NAT) = NSHELL+1  
       X = X / UNIT
       Y = Y / UNIT                                                     
       Z = Z / UNIT                                                     
       Cxyz(1,NAT) = X                                                      
       Cxyz(2,NAT) = Y                                                      
       Cxyz(3,NAT) = Z                                                      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ZEXTRA = ABS(ZNUC) - INT(ABS(ZNUC))                               
       SPRKLE = ZEXTRA>1.0D-05                                        
       IF(.NOT.SPRKLE)THEN                                              
        IF(ZNUC>0.0D0)THEN                                          
         ZAN(NAT) = ZNUC                                             
         NE = NE + INT(ZNUC)                                         
        ELSE                                                           
         ZAN(NAT) = 0.0D0                                             
         ZNUC = ABS(ZNUC)                                            
        END IF                                                         
       ELSE                                                              
        ZAN(NAT) = ZNUC                                                
       END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ICNT = 0                                                          
    2  CONTINUE                                                          
       ICNT = ICNT + 1                                                   
       NUCZ = INT(ZNUC)                                                  
       MPCORE = 0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                        
!      Read Basis from the input file or basisname.bas
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IEOF = 0                                                       
       IERR = 0 
       if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
        CALL RDCARD(50,'$DATA 6U',IEOF)  
       else
        CALL RDCARD(5,'$DATA 6U',IEOF)
       endif
       KSIZE = -8
       CALL GSTRNG(CBASIS,KSIZE)
       READ(UNIT=CBASIS,FMT='(A8)')BASIS   
       IF (BASIS==LETK) BASIS=LABEL(1)                           
       IGAUSS = IFIND('NGAUSS  ',IERR)                             
       DO I=1,4                                                   
        SCFAC(I) = RFIND('SCFAC   ',IERR)                           
        IF(IERR/=0)CALL ABRT                          
       END DO
       IF(ICNT==1)THEN                            
        ABASIS(NUCZ,1) = BASIS                                         
        IAGAUS(NUCZ,1) = IGAUSS                                        
       END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      A blank string means this Atom is done
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
       IF(BASIS==BLANK)THEN                                           
        XS = X                                                            
        YS = Y                                                            
        ZS = Z                                                            
        NAT0 = NAT                                                        
        QMCHKA = .FALSE.                                                  
        QMCHKB = .FALSE.                                                  
        GOTO 1                                                         
       END IF  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
       IF(IGAUSS>30)THEN                                        
        WRITE(6,'(/,1X,A17,I6)')'Stop: IGAUSS > 30',IGAUSS                                                                                
        WRITE(6,100) NAT,INPATM,ATOMNM,ZNUC,X*UNIT,Y*UNIT,Z*UNIT                      
        CALL ABRT                                                      
       END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        
       ITYP = 0                                                          
       DO I=1,8                                                         
        IF(BASIS==LABEL(I))ITYP=I                                   
       ENDDO                                                             
       IF(ITYP==0)THEN
!       Stop: Basis is unrecognized
        WRITE(6,'(/1X,A33,A8,1X,A9,I4)')                                &
        'Stop: Illegal basis function type',BASIS,'IGAUSS = ',IGAUSS
        WRITE(6,100) NAT,INPATM,ATOMNM,ZNUC,X/UNIT,Y/UNIT,Z/UNIT                         
        CALL BERROR(4)                                                    
        CALL ABRT                                                         
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!      General Basis Set: 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!      NSHELL- IS THE TOTAL NUMBER OF SHELLS.  A P SHELL MEANS X,Y,Z,
!       D SHELL MEANS XX,YY,ZZ,XY,XY,YZ, AND SO ON FOR F,G,H,I.      
!       CARTESIAN GAUSSIAN SHELLS CONTAIN ALL X**L Y**M Z**N         
!       PRODUCTS WITH L+M+N= CONSTANT, I.E. L+M+N=3 FOR F SHELL.     
!      EX- GAUSSIAN EXPONENTS, FOR EVERY SYMMETRY UNIQUE PRIMITIVE.  
!      CS- THROUGH -CI- ARE S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.  
!       NORMALLY ONLY ONE OF THE -CX- ARRAYS WILL BE NON-ZERO,       
!       FOR ANY GIVEN EXPONENT IN -EX-.  THE EXCEPTION IS "L" SHELLS,
!       WHERE BOTH -CS- AND -CP- WILL HAVE (DIFFERENT) VALUES.       
!                                                                    
!            THE VARIOUS "K"S DEFINE EACH SHELL'S CONTENTS:          
!                                                                    
!      KATOM- TELLS WHICH ATOM THE SHELL IS CENTERED ON, NORMALLY    
!       MORE THAN ONE SHELL EXISTS ON EVERY ATOM.                    
!      KLOC- GIVES THE LOCATION OF THIS SHELL IN THE TOTAL AO BASIS, 
!       PLEASE READ THE EXAMPLE.                                     
!      KSTART- IS THE LOCATION OF THE FIRST EXPONENT AND THE FIRST   
!       CONTRACTION COEFFICIENT CONTAINED IN A PARTICULAR SHELL.     
!       THUS, -KLOC- IS AN AO COUNTER, -KSTART- A PRIMITIVE COUNTER. 
!      KNG- IS THE NUMBER OF GAUSSIANS IN THIS SHELL.  THEIR DATA    
!       ARE STORED CONSECUTIVELY BEGINNING AT THE -KSTART- VALUE.    
!      KTYPE- IS 1,2,3,4,5,6,7 FOR S,P,D,F,G,H,I.  NOTE THAT THE     
!       VALUE STORED IN -KTYPE- FOR AN "L" SHELL IS A 2, SO THAT     
!       BY ITSELF, -KTYPE- CANNOT DISTINGUISH A "P" FROM A "L".      
!       THUS, KTYPE IS ONE HIGHER THAN THE TRUE ANGULAR MOMENTUM.    
!      KMIN- AND -KMAX- ARE THE STARTING AND ENDING INDICES OF THE   
!       SHELL.  THESE ARE DEFINED AS                                 
!                 S    P    D    F   G   H   I   L                   
!          KMIN   1    2    5   11  21  34  57   1                   
!          KMAX   1    4   10   20  35  56  84   4                   
!       SO YOU CAN TELL AN "L" SHELL BY ITS RUNNING FROM 1 TO 4,     
!       NAMELY S,X,Y,Z, WHEREAS A "P" SHELL RUNS 2,3,4 FOR X,Y,Z.    
!       THE TABLE ABOVE IS GENERATED BY WRITING ALL CARTESIAN        
!       PRODUCTS, "MAXIMUM POWERS FIRST", BACK TO BACK:              
!          S,  X,Y,Z,  XX,YY,ZZ,XY,XZ,YZ,                            
!          1   2 3 4    5  6  7  8  9 10                             
!          XXX,YYY,ZZZ,XXY,XXZ,YYX,YYZ,ZZX,ZZY,XYZ, ... G,H,I        
!          11  12  13,  14  15  16  17  18  19  20, ... G,H,I        
!                                                                    
!      AN EXAMPLE, TO TRY TO MAKE THIS CONCRETE, IS A 6-311G(D,P) BASIS 
!      FOR THE MOLECULE CSIH.  JUST THOSE THREE ATOMS, IN THAT ORDER:   
!              S  L  L  L  D    S  L  L  L  L  D    S  S  S  P          
!      KATOM   1  1  1  1  1    2  2  2  2  2  2    3  3  3  3          
!      KNG     6  3  1  1  1    6  6  3  1  1  1    3  1  1  1          
!      KTYPE   1  2  2  2  3    1  2  2  2  2  3    1  1  1  2          
!      KMIN    1  1  1  1  5    1  1  1  1  1  5    1  1  1  2          
!      KMAX    1  4  4  4 10    1  4  4  4  4 10    1  1  1  4          
!      KSTART  1  7 10 11 12   13 19 25 28 29 30   31 34 35 36 (SUM KNG)
!      KLOC    1  2  6 10 14   20 21 25 29 33 37   43 44 45 46          
!                                                                       
!      KLOC- HELPS POINT TO THE RIGHT AO INDEX, E.G. THE D SHELL       
!      OF THE SI ATOM CONTAINS AOS NUMBERED 37,38,39,40,41,42.          
!      KLOC(I) = KLOC(I-1) + KMAX(I) - KMIN(I) + 1                      
!      TOTAL NUMBER OF AOS (NUM IN COMMON -INFOA-) IN THIS EXAMPLE      
!      IS 48, FROM THE HYPOTHETICAL NEXT KLOC OF 46 + 4 - 2 + 1.        
!      CLEARLY -NSHELL- IS 15, THE NUMBER OF COLUMNS GIVEN HERE.        
!                                                                       
!      NOTE THAT THIS EXAMPLE SHOWS YOU HOW TO TELL A -P- FROM A -L-,   
!      EVEN THOUGH -KTYPE- IS 2 FOR EACH.                               
!                                                                       
!      NOTE THAT D SHELLS ALWAYS HAVE 6 MEMBERS, FOR SPHERICAL          
!      HARMONICS ARE NOT TAKEN CARE OF IN THE BASIS (ALWAYS A           
!      CARTESIAN GAUSSIAN BASIS IS SET UP) BUT RATHER AT THE TIME       
!      OF VARYING THE MOS       
!                                                                       
!      IF OUR MOLECULE WAS REALLY CSIH3, WITH C3V SYMMETRY, SO THAT     
!      THE INPUT GAVE ONLY ONE OF THE HYDROGENS, HOW DOES -NSHEL-       
!      CHANGE?  IT WOULD BE EXTENDED BY TWO MORE ATOMS,                 
!              S  S  S  P      S  S  S  P                               
!      KATOM   4  4  4  4      5  5  5  5                               
!      KNG     3  1  1  1      3  1  1  1                               
!      KTYPE   1  1  1  2      1  1  1  2                               
!      KMIN    1  1  1  2      1  1  1  2                               
!      KMAX    1  1  1  4      1  1  1  4                               
!      KSTART 31 34 35 36     31 34 35 36                               
!      KLOC   49 50 51 52     55 56 57 58                               
!                                                                       
!      NOTE THAT SINCE THESE ARE SYMMETRY EQUIVALENT, -KSTART-          
!      POINTS TO THE ORIGINAL GAUSSIAN DETAILS IN -EX- AND -CX-,        
!      BUT THESE ARE ADDITIONAL AOS, SO -KLOC- DOES GO UP.              
!      NSHELL- IS NOW 24, AND -NUM- IS NOW 60.                         
!                                                                       
!      A MOLECULE MAY VERY WELL HAVE MANY HYDROGENS, PERHAPS USING      
!      IDENTICAL BASIS SETS, BUT EVERY DIFFERENT SET OF EQUIVALENT      
!      HYDROGENS GETS SEPARATE STORAGE OF ITS EXPONENTS/CONTRACTION     
!      COEFFICIENTS (STORED AT DIFFERENT -KSTART- VALUES).              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       NSHELL = NSHELL + 1                                               
       IF(NSHELL>500)THEN
        WRITE(6,'(1X,A30,I6,A16)')                                      &
         'Stop: No more than NSHELLmax (',NSHELLmax,') shells allowed'                                   
        CALL ABRT                                                        
       ENDIF                                                         
!                                                                        
       KMIN(NSHELL)  = MINF(ITYP)                                          
       KMAX(NSHELL)  = MAXF(ITYP)                                          
       KSTART(NSHELL)= NGAUSS+1                                          
       KATOM(NSHELL) = NAT                                                
       KTYPE(NSHELL) = NANGM(ITYP)                                        
       INTYP(NSHELL) = ITYP                                               
       KNG(NSHELL)   = IGAUSS                                               
       KLOC(NSHELL)  = LOC+1                                               
       NGAUSS = NGAUSS + IGAUSS                                             
       IF(NGAUSS>NPRIMImax)THEN                                               
        WRITE(6,'(1X,A30,I6,A19)')                                      &
         'Stop: No more than NPRIMImax (',NPRIMImax,') Gaussians allowed'                                   
        CALL ABRT                                                        
       ENDIF                                                             
!                                                                        
       LOC = LOC + NBFS(ITYP)                                            
       IF(LOC>8192)THEN                                                  
        WRITE(6,'(1X,A18,I6,A24)')                                      &
        'Stop: No more than',8192,' basis functions allowed'                                  
        CALL ABRT
       END IF                                                         
       K1 = KSTART(NSHELL)                                               
       K2 = K1 + KNG(NSHELL) - 1                                             
       NS(NAT) = NS(NAT) + 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     
!      S, P, D, F, G, H, I, or L Basis Sets
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(ITYP<=8)THEN
        IF(SCFAC(1) <= 0.0D0) SCFAC(1) = 1.0D0                             
        IDUM=0                                                            
        DO K = K1,K2                                                  
         C1 = 0.0D0                                                      
         C2 = 0.0D0                                                      
         IEOF = 0                                                    
         IERR = 0
         if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
          CALL RDCARD(50,'$DATA 7U',IEOF)  
         else
          CALL RDCARD(5,'$DATA 7U',IEOF)
         endif
         IDUM = IFIND('IDUM    ',IERR)                               
         IF(IERR/=0)CALL ABRT                           
         EX(K) = RFIND('ZETA    ',IERR)                               
         IF(IERR/=0) CALL ABRT                           
         IF(EX(K)==0.0D0) THEN                            
          WRITE(6,'(1X,A10,I4,A39,A4)')'Stop: Atom',NATIN,              &
                ' has 0 exponent for basis function type',LABEL(ITYP)
          CALL ABRT                                      
         END IF                                            
         C1 = RFIND('C1      ',IERR)                                  
         IF(IERR/=0) CALL ABRT                           
         C2 = RFIND('C2      ',IERR)                                  
         IF(IERR/=0) CALL ABRT                           
         IF(C1==0.0D0.and.EX(K)==1.0D0) THEN                    
          WRITE(6,*)'Stop: Contraction Coefficient not found'      
          WRITE(6,100)NAT,INPATM,ATOMNM,ZNUC,X*UNIT,Y*UNIT,Z*UNIT                
          CALL ABRT                                                
         END IF                                                      
         IF(IGAUSS==1)C1=1.0D0                                      
         IF(IGAUSS==1)C2=1.0D0                                      
         EX(K) = EX(K)*SCFAC(1)**2                                    
         IF(ITYP==1) CSINP(K) = C1                                    
         IF(ITYP==2) CPINP(K) = C1                                    
         IF(ITYP==3) CDINP(K) = C1                                    
         IF(ITYP==4) CFINP(K) = C1                                    
         IF(ITYP==5) CGINP(K) = C1                                    
         IF(ITYP==6) CHINP(K) = C1                                    
         IF(ITYP==7) CIINP(K) = C1                                    
         IF(ITYP==8) CSINP(K) = C1                                    
         IF(ITYP==8) CPINP(K) = C2                                    
         CS(K) = CSINP(K)                                               
         CP(K) = CPINP(K)                                               
         CD(K) = CDINP(K)                                               
         CF(K) = CFINP(K)                                               
         CG(K) = CGINP(K)                                               
         CH(K) = CHINP(K)                                               
         CI(K) = CIINP(K)
!        Store unnormalized coefficients for libreta
         IF(ILIBRETA==1) CINP(K) = C1
        END DO
!       Create basis in libreta
        if(ILIBRETA==1)then
!lib         CALL CREATEBASIS(BASLIB(NSHELL),EX(K1:K2),CINP(K1:K2),         &
!lib                          Cxyz(1:3,NAT),ITYP-1,K2-K1+1)
        end if                  
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
!      Normalize Primitive Basis Functions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
       DO IG = K1,K2                                                 
        EE = EX(IG)+EX(IG)                                             
        FACS = PI32/(EE*SQRT(EE))                                      
        FACP = 0.5D0*FACS/EE                                          
        FACD = PT75  *FACS/(EE*EE)                                     
        FACF = PT187 *FACS/(EE**3)                                     
        FACG = PT6562*FACS/(EE**4)                                     
        FACH = PT2953*FACS/(EE**5)                                     
        FACI = PT1624*FACS/(EE**6)                                     
        CS(IG) = CS(IG)/SQRT(FACS)                                     
        CP(IG) = CP(IG)/SQRT(FACP)                                     
        CD(IG) = CD(IG)/SQRT(FACD)                                     
        CF(IG) = CF(IG)/SQRT(FACF)                                     
        CG(IG) = CG(IG)/SQRT(FACG)                                     
        CH(IG) = CH(IG)/SQRT(FACH)                                     
        CI(IG) = CI(IG)/SQRT(FACI)                                     
       END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
!      Normalize the contracted basis functions to Unity
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
       FACS = 0.0D0                                                       
       FACP = 0.0D0                                                       
       FACD = 0.0D0                                                       
       FACF = 0.0D0                                                       
       FACG = 0.0D0                                                       
       FACH = 0.0D0                                                       
       FACI = 0.0D0                                                       
       DO IG = K1,K2                                                 
        DO JG = K1,IG                                              
         EE = EX(IG)+EX(JG)                                          
         FAC = EE*SQRT(EE)                                           
         DUMS = CS(IG)*CS(JG)/FAC                                    
         DUMP = 0.5D0*CP(IG)*CP(JG)/(EE*FAC)                        
         DUMD = PT75  *CD(IG)*CD(JG)/(EE*EE*FAC)                     
         DUMF = PT187 *CF(IG)*CF(JG)/(EE**3*FAC)                     
         DUMG = PT6562*CG(IG)*CG(JG)/(EE**4*FAC)                     
         DUMH = PT2953*CH(IG)*CH(JG)/(EE**5*FAC)                     
         DUMI = PT1624*CI(IG)*CI(JG)/(EE**6*FAC)                     
         IF(IG /= JG) THEN                                         
          DUMS = DUMS+DUMS                                         
          DUMP = DUMP+DUMP                                         
          DUMD = DUMD+DUMD                                         
          DUMF = DUMF+DUMF                                         
          DUMG = DUMG+DUMG                                         
          DUMH = DUMH+DUMH                                         
          DUMI = DUMI+DUMI                                         
         END IF                                                      
         FACS = FACS+DUMS                                            
         FACP = FACP+DUMP                                            
         FACD = FACD+DUMD                                            
         FACF = FACF+DUMF                                            
         FACG = FACG+DUMG                                            
         FACH = FACH+DUMH                                            
         FACI = FACI+DUMI                                            
        END DO
       END DO
       IF(FACS < TM10) THEN                                           
        FACS = 0.0D0                                                      
       ELSE                                                              
        FACS = 1.0D0/SQRT(FACS*PI32)                                     
       END IF                                                            
       IF(FACP < TM10) THEN                                           
        FACP=0.0D0                                                      
       ELSE                                                              
        FACP = 1.0D0/SQRT(FACP*PI32)                                     
       END IF                                                            
       IF(FACD < TM10) THEN                                           
        FACD=0.0D0                                                      
       ELSE                                                              
        FACD = 1.0D0/SQRT(FACD*PI32)                                     
       END IF                                                            
       IF(FACF < TM10) THEN                                           
        FACF=0.0D0                                                      
       ELSE                                                              
        FACF = 1.0D0/SQRT(FACF*PI32)                                     
       END IF                                                            
       IF(FACG < TM10) THEN                                           
        FACG=0.0D0                                                      
       ELSE                                                              
        FACG = 1.0D0/SQRT(FACG*PI32)                                     
       END IF                                                            
       IF(FACH < TM10) THEN                                           
        FACH=0.0D0                                                      
       ELSE                                                              
        FACH = 1.0D0/SQRT(FACH*PI32)                                     
       END IF                                                            
       IF(FACI < TM10) THEN                                           
        FACI=0.0D0                                                      
       ELSE                                                              
        FACI = 1.0D0/SQRT(FACI*PI32)                                     
       END IF                                                            
       DO IG = K1,K2                                                 
        CS(IG) = CS(IG) * FACS                                         
        CP(IG) = CP(IG) * FACP                                         
        CD(IG) = CD(IG) * FACD                                         
        CF(IG) = CF(IG) * FACF                                         
        CG(IG) = CG(IG) * FACG                                         
        CH(IG) = CH(IG) * FACH                                         
        CI(IG) = CI(IG) * FACI                                         
        CSINP(IG) = CSINP(IG) * FACS                                   
        CPINP(IG) = CPINP(IG) * FACP                                   
        CDINP(IG) = CDINP(IG) * FACD                                   
        CFINP(IG) = CFINP(IG) * FACF                                   
        CGINP(IG) = CGINP(IG) * FACG                                   
        CHINP(IG) = CHINP(IG) * FACH                                   
        CIINP(IG) = CIINP(IG) * FACI                                   
       END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       GO TO 2                                                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!      Generate equivalent Atoms
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       XS = X                                                            
       YS = Y                                                            
       ZS = Z                                                            
       NAT0 = NAT                                                        
       QMCHKA = .FALSE.                                                  
       QMCHKB = .FALSE.                                                  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       GO TO 1                                                         
      END IF      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NGAUSS==0.or.NSHELL==0)THEN    
       WRITE(6,'(32A)')'Stop: No basis functions defined' 
       CALL ABRT                                                      
      END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!             Form Transformation Tables for Atoms and Shells
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO IAT = 1,NAT                                               
       NS1 = KS(IAT)-1                                                
       NS2 = NS(IAT)                                                  
       X = Cxyz(1,IAT)                                                   
       Y = Cxyz(2,IAT)                                                   
       Z = Cxyz(3,IAT)                                                   
       XS = X                                                         
       YS = Y                                                         
       ZS = Z                                                         
       DO IT = 1,NT                                              
        NN = 9*(IT-1)                                               
        XP = XS
        YP = YS
        ZP = ZS
        ICTR = -2**20                                               
        DO 1010 I = 1,NAT                                           
         TEST = (XP-Cxyz(1,I))**2+(YP-Cxyz(2,I))**2+(ZP-Cxyz(3,I))**2      
         IF(TEST>TM10 .OR. (QMCHKA.NEQV.QMCHKB)) GO TO 1010
         ICTR = I                                                 
         GO TO 1020                                               
 1010   CONTINUE                                                    
 1020   MAPCTR(IAT,IT) = ICTR                                       
        NS3 = KS(ICTR)-1                                            
        DO ISH = 1,NS2                                         
         MAPSHL(NS1+ISH,IT) = NS3+ISH                             
        END DO
       END DO
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print atomic coordinates
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE (6,200)                                             
      DO IAT = 1,NAT                                         
       WRITE(6,300)ANAM(IAT),BNAM(IAT),ZAN(IAT),                        &
                   Cxyz(1,IAT),Cxyz(2,IAT),Cxyz(3,IAT)
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print Basis Functions
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --                                                   
      WRITE(6,'(/1X,A16,/1X,16(1H-))')'Atomic Basis Set'                                                 
      WRITE(6,'(1X,A52)')                                               &
       'The contracted primitive functions were unnormalized'                                         
      WRITE(6,'(1X,A58)')                                               &
       'The contracted basis functions are now normalized to unity'       
      WRITE(6,'(/2X,A21,9X,A33)')'Shell Type  Primitive',               &
                                 'Exponent  Contraction Coefficient'                          
      MLDUDF=0                                                          
      MLDNDA=0
!-----------------------------------------------------------------------
      IMINPIR(1)=1                                                      
!-----------------------------------------------------------------------
      DO IAT = 1,NAT                                               
       DO IT = 1,NT                                              
        IF(MAPCTR(IAT,IT) > IAT) GO TO 20                      
       END DO
       WRITE(6,'(/1X,A8,A2)')ANAM(IAT),BNAM(IAT)                                  
       NS1 = KS(IAT)                                                  
       NS2 = NS1+NS(IAT)-1                                            
       MLDNDA=MLDNDA+1                                                
       DO ISH = NS1,NS2                                          
        WRITE(6,*)                                             
        I1 = KSTART(ISH)                                            
        I2 = I1+KNG(ISH)-1                                          
        ITYP = INTYP(ISH)                                           
        DO IG = I1,I2                                          
         GOTO(11,12,13,14,15,16,17,18)ITYP                   
   11    CONTINUE                                                 
         C1=CSINP(IG)                                             
!--------S--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   12    CONTINUE                                                 
         C1=CPINP(IG)                                             
!--------P--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   13    CONTINUE                                                 
         C1=CDINP(IG)                                             
!--------D--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   14    CONTINUE                                                 
         C1=CFINP(IG)                                             
!--------F--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   15    CONTINUE                                                 
         C1=CGINP(IG)                                             
!--------G--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   16    CONTINUE                                                 
         C1=CHINP(IG)                                             
!--------H--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   17    CONTINUE                                                 
         C1=CIINP(IG)                                             
!--------I--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   18    CONTINUE                                                 
         C1=CSINP(IG)                                             
         C2=CPINP(IG)                                             
!--------L--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITIPO(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         C2PIR(IG)=C2                                             
         NPRIMI=IG                                                
!-----------------------------------------------------------------------
         WRITE (6,400) ISH,LABEL(ITYP),IG,EX(IG),C1,C2          
         GO TO 19                                               
          WRITE(6,*) 'These shells do not exist'     
         CALL ABRT                                                
   19    CONTINUE                                                    
        END DO
       END DO
!-----------------------------------------------------------------------
       IMAXPIR(IAT)=I2                                                  
       IMINPIR(IAT+1)=IMAXPIR(IAT)+1                                    
!-----------------------------------------------------------------------
   20  CONTINUE
      END DO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --                                                          
!     NE: Number of Electrons
!     NA: Number of Alpha Electrons
!     NB: Number of Beta Electrons
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      NUM  = LOC                                                        
      NQMT = LOC                                                        
      NE = NE-ICH                                                       
      NA = (NE+MUL-1)/2                                                 
      NB = (NE-MUL+1)/2 
      IF(NA+NB/=NE)THEN
       WRITE(6,'(/,1X,19A)')'Number of Electrons'      
       WRITE(6,'(/,1X,I6)')NE
       WRITE(6,'(/,1X,34A)')'Check your Charge and Multiplicity'
       WRITE(6,'(/,1X,2I3,/)')ICH,MUL 
       CALL ABRT                                                   
      END IF
      IMULNE=MUL+NE                                                    
      IF(MUL>NE+1 .or. MUL<0 .or. 2*INT(IMULNE/2)==IMULNE)THEN  
       WRITE(6,'(28A)')'Impossible Spin Multiplicity'     
       CALL ABRT                                                    
      END IF                                                         
!-----------------------------------------------------------------------
      DO I=1,NSHELL                                                     
       INTIPO(I)=INTYP(I)                                             
      ENDDO
!-----------------------------------------------------------------------
      WRITE(6,500)NSHELL,NPRIMI,NUM
      IF (IERITYP==2 .or. IERITYP==3) THEN
       if(ILIBRETA==0)then
        CALL AUXGEN(NAT,NPRIMI,ITIPO,IMINPIR,IMAXPIR,NSHELLaux,NUMaux,  &
                    IGEN,ISTAR,EX,ZAN)       
       else if(ILIBRETA==1)then
        CALL AUXGENlib(NAT,NPRIMI,ITIPO,IMINPIR,IMAXPIR,NSHELLaux,      &
                       NUMaux,EX,ZAN,Cxyz)
       end if
       WRITE(6,550)NSHELLaux,NUMaux
      END IF
      WRITE(6,600)NE,ICH,MUL,NA,NB,NAT                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Nuclear Energy with true nuclear charges
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      EN = ENUC(NAT,ZAN,Cxyz)            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     IECP /=0 -> Write a warning with respect to NE and ENUC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IECP/=0)WRITE(6,'(/1X,A16,F20.10/,/1X,A59,/1X,A63)')           &
      'Nuclear Energy = ',EN,                                           &
      'Note: This calculation is using an effective core potential',    &
      'so NE and ENUC will be adjusted later after removal of the Core'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(CSINP,CPINP,CDINP,CFINP,CGINP,CHINP,CIINP)
      DEALLOCATE(INTYP,NS,KS,EXX,CSS,CPP,CDD,SCFAC)
      IF(ILIBRETA==1)DEALLOCATE(CINP)      
!-----------------------------------------------------------------------                                                                       
  100 FORMAT(1X,'ERROR OCCURED READING ATOM NO.',I4,                    &
                ', INPUT ATOM NO.',I5,', NAME=',A10/                    &
             1X,'CHARGE=',F5.1,' X,Y,Z=',3F15.8)                         
  200 FORMAT(/1X,'Atom',6X,'Charge',16X,'Coordinates (Bohr)'/           &
               27X,'x',13X,'y',13X,'z')                                  
  300 FORMAT(1X,A8,A2,F5.1,3F14.4)                                       
  400 FORMAT(1X,I6,3X,A2,I7,F22.7,2F18.12)                               
  500 FORMAT(/1X,'Total Number of Basis Set Shells             =',I5/   &
              1X,'Total Number of Primitives                   =',I5/   &
              1X,'Number of Cartesian Gaussian Basis Functions =',I5)
  550 FORMAT( 1X,'Total Number of Auxiliary Basis Set Shells   =',I5/   &
              1X,'Number of Cart. Gaussian Auxiliary Set Func. =',I5)
  600 FORMAT( 1X,'Number of Electrons                          =',I5/   &
              1X,'Charge of Molecule                           =',I5/   &
              1X,'Spin Multiplicity                            =',I5/   &
              1X,'Number of Occupied Orbitals (Alpha)          =',I5/   &
              1X,'Number of Occupied Orbitals (Beta )          =',I5/   &
              1X,'Total Number of Atoms                        =',I5) 
!-----------------------------------------------------------------------  
      RETURN                                                            
      END                                                               

! FNDATMBASIS
      SUBROUTINE FNDATMBASIS(ATOMNAME,IEOF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 PREVWORD,WORD,ATOMNAME
      IEOF = 0
      WORD = "        "
    1 CONTINUE
      PREVWORD = WORD
      READ(50,'(A2)',END=2)WORD
      IF(WORD==ATOMNAME .and. LEN(TRIM(PREVWORD))==0)GO TO 3
      CALL UPRCAS(WORD,8)
      IF(WORD==ATOMNAME .and. LEN(TRIM(PREVWORD))==0)GO TO 3
      GOTO 1
    2 CONTINUE
      IEOF = 1
    3 CONTINUE
      RETURN
      END
            
! READAT                                           
      SUBROUTINE READAT(ATOMNM,ZNUC,X,Y,Z)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      COMMON/INFO  /IUNTRD            
      COMMON/INTNAL/NATIN            
      CHARACTER*10 ATOMNM,ENDWRD,BLANK10                                  
      DATA ENDWRD,BLANK10/'$END      ','          '/
!-----------------------------------------------------------------------
!     Read Cartesian Coordinates: READ(5,*) ATOMNM,ZNUC,X,Y,Z                                      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      DFACT = 1.0D0                                                       
      IF(IUNTRD==-1)DFACT = 0.52917724924D0                                     
!                                         
      IEOF = 0                                                          
      IERR = 0                                                          
      CALL RDCARD(5,'$DATA 5U',IEOF)                                      
      IF(IEOF==1) CALL ABRT                                        
!                                                                       
      KSIZE = -10                                                       
      CALL GSTRNG(ATOMNM,KSIZE)                                         
      IF (ADJUSTL(ATOMNM)==ADJUSTL(ENDWRD)) RETURN                                      
!                                                                       
      NATIN = NATIN+1                                                   
      IF (ATOMNM==BLANK10) THEN                                         
         WRITE(6,1) NATIN                               
         CALL ABRT                                                      
      END IF                                                            
!                                                                       
      ZNUC = RFIND('ZNUC    ',IERR)                                     
             IF(IERR/=0) CALL ABRT                                    
      X = DFACT*RFIND('X       ',IERR)                                  
             IF(IERR/=0) CALL ABRT                                    
      Y = DFACT*RFIND('Y       ',IERR)                                  
             IF(IERR/=0) CALL ABRT                                    
      Z = DFACT*RFIND('Z       ',IERR)                                  
             IF(IERR/=0) CALL ABRT
!-----------------------------------------------------------------------
    1 FORMAT(//1X,'*** ERROR!'/                                         &
               1X,'BLANK CARD FOUND WHILE TRYING TO READ INPUT ATOM',I5/&     
               1X,'POSSIBLE ERRORS INCLUDE:'/                           &     
               1X,'1. C1 GROUP SHOULD NOT HAVE A BLANK CARD AFTER IT.'/ &     
               1X,'2. BOTH $BASIS GROUP AND BASIS SET IN $DATA GIVEN?'/ &     
               1X,'3. EXTRANEOUS BLANK CARDS IN $DATA?')                     
!-----------------------------------------------------------------------                                    
      RETURN                                                            
      END                                                               

! SETLAB
      SUBROUTINE SETLAB(KATOM,KMIN,KMAX,NSHELL,ZAN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      COMMON/RUNLAB/BFLAB(8192)
      INTEGER,DIMENSION(NSHELL) :: KATOM,KMIN,KMAX
      CHARACTER*4 :: LABEL                                               
      CHARACTER*8 :: BFL                                                 
      CHARACTER*4, DIMENSION(35) :: BFNAM1                               
      DATA BFNAM1/'  S ','  X ','  Y ','  Z ',                          &
                  ' XX ',' YY ',' ZZ ',' XY ',' XZ ',' YZ ',            &
                  ' XXX',' YYY',' ZZZ',' XXY',' XXZ',                   &
                  ' YYX',' YYZ',' ZZX',' ZZY',' XYZ',                   &
                  'XXXX','YYYY','ZZZZ','XXXY','XXXZ',                   &
                  'YYYX','YYYZ','ZZZX','ZZZY','XXYY',                   &
                  'XXZZ','YYZZ','XXYZ','YYXZ','ZZXY'/                    
      CHARACTER*6, DIMENSION(49) :: BFNAM2                               
      DATA BFNAM2/' XXXXX',' YYYYY',' ZZZZZ',' XXXXY',' XXXXZ',         &
                  ' YYYYX',' YYYYZ',' ZZZZX',' ZZZZY',' XXXYY',         &
                  ' XXXZZ',' YYYXX',' YYYZZ',' ZZZXX',' ZZZYY',         &
                  ' XXXYZ',' YYYXZ',' ZZZXY',' XXYYZ',' XXZZY',         &
                  ' YYZZX',                                             &
                  '    X6','    Y6','    Z6','   X5Y','   X5Z',         &
                  '   Y5X','   Y5Z','   Z5X','   Z5Y','  X4Y2',         &
                  '  X4Z2','  Y4X2','  Y4Z2','  Z4X2','  Z4Y2',         &
                  '  X4YZ','  Y4XZ','  Z4XY','  X3Y3','  X3Z3',         &
                  '  Y3Z3',' X3Y2Z',' X3Z2Y',' Y3X2Z',' Y3Z2X',         &
                  ' Z3X2Y',' Z3Y2X','X2Y2Z2'/                            
      CHARACTER*4 :: BONDF                                               
      DATA BONDF/' BF '/                                                 
      CHARACTER*4,DIMENSION(106) :: ATMLAB                               
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',            &
                  'N   ','O   ','F   ','NE  ','NA  ','MG  ',            &
                  'AL  ','SI  ','P   ','S   ','CL  ','AR  ',            &
                  'K   ','CA  ','SC  ','TI  ','V   ','CR  ',            &
                  'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',            &
                  'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',            &
                  'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',            &
                  'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',            &
                  'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',            &
                  'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',            &
                  'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',            &
                  'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',            &
                  'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',            &
                  'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',            &
                  'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',            &
                  'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',            &
                  'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',            &
                  'LR  ','RF  ','X   ','BQ  '/
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Basis Function Table
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      N = 0
      DO III = 1,NSHELL
       IAT = KATOM(III)
       J = INT(ZAN(IAT))
       IF(J<=0)THEN
        LABEL = BONDF
       ELSE
        IF(J>106)J = 106
        LABEL = ATMLAB(J)
       ENDIF
       MINI = KMIN(III)
       MAXI = KMAX(III)
       DO I = MINI,MAXI
        N = N+1
        IF(I<=35) THEN
         WRITE(UNIT=BFL,FMT='(A2,I2,A4)')LABEL,MOD(IAT,100),BFNAM1(I)
        ELSE
         WRITE(UNIT=BFL,FMT='(A2,A6)')LABEL,BFNAM2(I-35)
        END IF
        READ(UNIT=BFL,FMT='(A8)')BFLAB(N)
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

! AMT
      SUBROUTINE AMT(ZAN,ZMASS,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION, DIMENSION(106) :: AMS
      DOUBLE PRECISION, DIMENSION(NAT) :: ZAN,ZMASS,AMASS
!-----------------------------------------------------------------------
!     Mass of most abundant Isotopes
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DATA (AMS(I),I=1,106)  /                                          &
         1.007825D0,4.0026D0,7.01600D0,9.01218D0,11.00931D0,            &
         12.0D0,14.00307D0,15.99491D0,18.99840D0,19.99244D0,            &
         22.9898D0,23.98504D0,26.98153D0,27.97693D0,                    &
         30.97376D0,31.97207D0,34.96885D0,39.948D0,                     &
         38.96371D0,39.96259D0,44.95592D0,47.90D0,50.9440D0,            &
         51.9405D0,54.9381D0,55.9349D0,58.9332D0,57.9353D0,             &
         62.9298D0,63.9291D0,68.9257D0,73.9219D0,74.9216D0,             &
         79.9165D0,78.9183D0,83.9115D0,                                 &
         84.9117D0,87.9056D0,89.9054D0,89.9043D0,92.9060D0,             &
         97.9055D0,97.0D0,101.9037D0,102.9048D0,105.9032D0,             &
         106.9041D0,113.9036D0,114.9041D0,119.9022D0,                   &
         120.9038D0,129.9067D0,126.9044D0,131.9042D0,                   &
         132.9054D0,137.9052D0,138.9063D0,139.9054D0,                   &
         140.9076D0,141.9077D0,144.9127D0,151.9197D0,                   &
         152.9212D0,157.9241D0,158.9253D0,163.9292D0,                   &
         164.9303D0,165.9303D0,168.9342D0,173.9389D0,                   &
         174.9408D0,179.9465D0,180.9480D0,183.9509D0,                   &
         186.9557D0,191.9615D0,192.9629D0,194.9648D0,                   &
         196.9665D0,201.9706D0,                                         &
         204.9744D0,207.9766D0,208.9804D0,208.9824D0,                   &
         209.9871D0,222.0176D0,                                         &
         223.0197D0,226.0254D0,                                         &
         227.0278D0,232.0381D0,231.0359D0,238.0508D0,                   &
         237.0482D0,244.0642D0,243.0614D0,247.0703D0,                   &
         247.0703D0,251.0796D0,252.0829D0,257.0751D0,                   &
         258.0986D0,259.1009D0,260.1053D0,261.1087D0,                   &
         2*0.0D0/
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Note: ZAN is the True Charge because this input is before ECP
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO IAT = 1,NAT
       ZNUC = ZAN(IAT)
       NUCZ = INT(ZNUC)
       IF(NUCZ>=1.and.NUCZ<=106)THEN
        AMASS(IAT) = AMS(NUCZ)
       ELSE
        AMASS(IAT) = 0.0D0
       END IF
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Returns Normal Masses
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,NAT
       ZMASS(I) = AMASS(I)
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

! INRTIA
      SUBROUTINE INRTIA(C,COM,ZMASS,VMOI,NPART)
      IMPLICIT NONE
      DOUBLE PRECISION :: Xcm,Ycm,Zcm
      COMMON/CMCoord/Xcm,Ycm,Zcm
!     ARGUMENTS
      INTEGER,INTENT(IN) :: NPART
      DOUBLE PRECISION,DIMENSION(3,NPART),INTENT(IN) :: C
      DOUBLE PRECISION,DIMENSION(3,NPART),INTENT(OUT) :: COM
      DOUBLE PRECISION,DIMENSION(3),INTENT(OUT) :: VMOI
      DOUBLE PRECISION,DIMENSION(NPART),INTENT(IN) :: ZMASS
!     VARIABLES
      DOUBLE PRECISION,DIMENSION(3):: CMASS,WRK
      DOUBLE PRECISION,DIMENSION(3,3):: TROT,TMOIsq
      DOUBLE PRECISION,DIMENSION(6):: TMOI
      DOUBLE PRECISION :: XX,YY,ZZ,XY,XZ,YZ,WEIGHT,TOTWT,XC,YC,ZC
      INTEGER :: I,J
!-----------------------------------------------------------------------
!     C: Nuclear Coordinates
!     ZMASS: Nuclear Masses
!     COM: Center of Mass Coordinates
!     VMOI: Products of Inertia (Eigenvalues)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Center of Mass
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TOTWT=0.0D0
      CMASS(1)=0.0D0
      CMASS(2)=0.0D0
      CMASS(3)=0.0D0
      DO I=1,NPART
       WEIGHT=ZMASS(I)
       TOTWT=TOTWT+WEIGHT
       DO J=1,3
        CMASS(J)=CMASS(J)+WEIGHT*C(J,I)
       END DO
      END DO
      DO I=1,3
       CMASS(I)=CMASS(I)/TOTWT
      END DO
!
      Xcm = CMASS(1)
      Ycm = CMASS(2)
      Zcm = CMASS(3)
!
      DO I=1,NPART
       DO J=1,3
        COM(J,I) = C(J,I)-CMASS(J)
       END DO
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Moment of Inertia Tensor
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XX=0.0D0
      YY=0.0D0
      ZZ=0.0D0
      XY=0.0D0
      XZ=0.0D0
      YZ=0.0D0
      DO I=1,NPART
       WEIGHT=ZMASS(I)
       XC = COM(1,I)
       YC = COM(2,I)
       ZC = COM(3,I)
       XX = XX + WEIGHT*(YC*YC+ZC*ZC)
       YY = YY + WEIGHT*(XC*XC+ZC*ZC)
       ZZ = ZZ + WEIGHT*(XC*XC+YC*YC)
       XY = XY - WEIGHT*XC*YC
       XZ = XZ - WEIGHT*XC*ZC
       YZ = YZ - WEIGHT*YC*ZC
      END DO
      TMOI(1) = XX
      TMOI(2) = XY
      TMOI(3) = YY
      TMOI(4) = XZ
      TMOI(5) = YZ
      TMOI(6) = ZZ
!
      CALL CPYTSQ(TMOI,TMOIsq,3)            
      CALL DIAG(3,TMOIsq,TROT,VMOI,WRK)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! ENUC                                             
      DOUBLE PRECISION FUNCTION ENUC(N,Z,Cxyz)  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      DIMENSION Z(N),Cxyz(3,N)                                             
!-----------------------------------------------------------------------                                                        
      REPNUC = 0.0d0                                                     
!                                                        
      IF(N/=1)THEN
       DO I = 2,N                                             
        NI = I-1                                                    
        DO J = 1,NI                                         
         RR = 0.0d0                                                
         DO K = 1,3                                           
          RR = RR+(Cxyz(K,I)-Cxyz(K,J))**2                            
         END DO
         IF(RR/=0.0d0) REPNUC = REPNUC + Z(I)*Z(J)/SQRT(RR)        
        END DO
       END DO
      END IF                                                        
!
      IF(EFLDL)THEN                                                   
       ANUCF = 0.0d0                                                   
       DO J = 1,N                                                 
        DO I = 1,3                                              
         ANUCF = ANUCF - EVEC(I)*Cxyz(I,J)*Z(J)                      
        END DO
       END DO
       REPNUC = REPNUC + ANUCF                                        
      END IF 
!                                                           
      ENUC = REPNUC 
!-----------------------------------------------------------------------                                                                                                            
      RETURN                                                            
      END                                                               

! BASCHK                                           
      SUBROUTINE BASCHK(LMAXIMA,KTYPE,NSHELL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NSHELL) :: KTYPE
!-----------------------------------------------------------------------
!     Return the highest angular momentum in the basis
!-----------------------------------------------------------------------                                                     
      KANG = 0                                                          
      DO N=1,NSHELL                                                 
       IF(KTYPE(N)>KANG)KANG = KTYPE(N)                          
      ENDDO
      LMAXIMA = KANG-1
!-----------------------------------------------------------------------                                                     
      RETURN                                                            
      END                                                               

! BERROR
      SUBROUTINE BERROR(K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER(8), DIMENSION(4) :: BASIS
      DATA BASIS /'MINIMAL ','EXTENDED','GENERAL ','        '/
!-----------------------------------------------------------------------
      WRITE(6,1)BASIS(K)
      CALL ABRT
      RETURN
!-----------------------------------------------------------------------
    1 FORMAT(/2X,'Stop: illegal ',A8,' basis function')
!-----------------------------------------------------------------------
      END
      
! FNDGRP
      SUBROUTINE FNDGRP(LUIN,GRPNAM,IEOF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*8 WORD,GRPNAM
      IEOF = 0
    1 CONTINUE
      READ(LUIN,'(A8)',END=2)WORD
      CALL UPRCAS(WORD,8)
      IF(ADJUSTL(WORD)==ADJUSTL(GRPNAM))GO TO 3
      GOTO 1
    2 CONTINUE
      IEOF = 1
    3 CONTINUE
      RETURN
      END

! UPRCAS
      SUBROUTINE UPRCAS(STRING,LENSTR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*(*) STRING
      CHARACTER*26 UCASE,LCASE
      DATA UCASE /'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA LCASE /'abcdefghijklmnopqrstuvwxyz'/
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Lower Case -> Upper Case
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,LENSTR
       IC = INDEX(LCASE,STRING(I:I))
       IF (IC>0) STRING(I:I) = UCASE(IC:IC)
      END DO
      RETURN
      END

! OPNCRD
      SUBROUTINE OPNCRD
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*1 LCONT,LEOD,LEOC
      CHARACTER*80 CARD
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUOUT,LUERR,KOLSV
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Free format: Read from 5, output to 6
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      MAXCOL= 80
      KEOF  = 0
      KERR  = 0
      LUOUT = 6
      LUERR = 6
      LCONT = '>'
      LEOD  = '!'
      LEOC  = ';'
      RETURN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      END

! RDCARD
      SUBROUTINE RDCARD(LUIN,ROUTIN,IEOF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL FIRST
      CHARACTER*8 ROUTIN,ROUTNE,STAR,STARS
      CHARACTER*4 KEYWRD,KCOL,KSET,KEOD,KEOC
      CHARACTER*1 LCONT,LEOD,LEOC
      CHARACTER*80 CARD
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUOUT,LUERR,KOLSV
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC
      CHARACTER(80) :: BASIS_FILE
      COMMON/BASIS_FILE/BASIS_FILE
      DATA FIRST/.TRUE./
      SAVE FIRST,MORE,STAR,STARS,KCOL,KSET,KEOD,KEOC,LASTC
!-----------------------------------------------------------------------
      IZERO = 0
      IONE = 1
      KEOF = IEOF
      IF(FIRST) THEN
       MORE=0
       STAR='   *    '
       STARS='   **   '
       KCOL='COL '
       KSET='SET '
       KEOD='EOD '
       KEOC='EOC '
       FIRST=.FALSE.
      END IF
      IF(KEOF==1) GO TO 170
         ROUTNE=ROUTIN
         KPRNT=1
         IF(KEOF==(-1)) GO TO 160
            KPRNT=2
            IF(MORE==1) GO TO 120
  105          KPRNT=0
               NSTART=MAXCOL+1
               LSTCOL=MAXCOL
               KEOF=1
               READ(LUIN,900,END=180) CARD
!              IF(LUOUT>0)WRITE(LUOUT,901) ROUTNE,CARD
               IF(ROUTNE==STAR) GO TO 118
!
!                   RECURSIVE CALLS TO GSTRNG AND DECODN WILL BE AVOIDED
!
                  NSET=0
                  NCOL=1
  112             CONTINUE
                  KEYWRD='   *'
                  LGSTR=-4
                  CALL GSTRNG(KEYWRD,LGSTR)
                  IF(KEYWRD/=KSET) GO TO 117
                     LGSTR=-4
                     CALL GSTRNG(KEYWRD,LGSTR)
                     IF(KEYWRD/=KCOL) GO TO 113
                        IERR=0
                        MAXCOL=IFIND('MAXCOL  ',IERR)
                        NSET=NSET+1
                        GO TO 112
!
  113                IF(KEYWRD/=KEOD) GO TO 114
                        LGSTR=-4
                        CALL GSTRNG(LEOD,LGSTR)
                        NSET=NSET+1
                        GO TO 112
!
  114                IF(KEYWRD/=KEOC) GO TO 115
                        LGSTR=-4
                        CALL GSTRNG(LEOC,LGSTR)
                        NSET=NSET+1
                        GO TO 112
!
  115                IF(KEYWRD/=LCONT) GO TO 117
                        LGSTR=-4
                        CALL GSTRNG(LCONT,LGSTR)
                        NSET=NSET+1
                        GO TO 112
!
  117             IF(NSET==0) GO TO 118
                     IF(LUOUT>0) WRITE(LUOUT,904)                       &
                        NSET,MAXCOL,LEOD,LEOC,LCONT
                     ROUTNE=STARS
                     GO TO 105
!
  118          CONTINUE
               LASTC=0
  120       CONTINUE
!
!           CHECK FOR DATA FIELD TERMINATION
!
            MORE=1
            NSTART=LASTC+1
            LASTC=MAXCOL+1
            DO 130 N=NSTART,MAXCOL
               IF(CARD(N:N)==LEOD) LASTC=N
               IF(CARD(N:N)==LEOC) GO TO 150
  130       CONTINUE
            N=LASTC
            MORE=0
  150       LSTCOL=MIN(LASTC,N)-1
            LASTC=N
  160    CONTINUE
         IF(KPRNT==1 .AND. LUOUT>0)                                     &
            WRITE(LUOUT,902) ROUTNE                                      
         IF(KPRNT==2 .AND. LUOUT>0)                                     &
            WRITE(LUOUT,903) NSTART,LSTCOL,ROUTNE                        
         KEOF=0                                                          
  170 CONTINUE                                                           
      NCOL=NSTART                                                        
      KOLSV=NCOL                                                         
      IEOF = KEOF                                                        
      RETURN                                                             
  180 CONTINUE                                                           
      NCOL=NSTART                                                        
      KOLSV=NCOL                                                         
      IEOF = KEOF                                                        
      RETURN
!                                                                        
  900 FORMAT(A80)                                                        
  902 FORMAT(10X,10HREREAD AT ,A8)                                       
  903 FORMAT(10X,8HCOLUMNS ,I2,3H - ,I2,1X,8HREAD AT ,A8)                
  904 FORMAT(/6X,I2,' CARD PARAMETERS HAVE BEEN RESET --'/1X,           &
             7H  COL =,I3,3X,7H EOD = ,A4,7H EOC = ,A4,8H CONT = ,A4/)
      END

! RFIND
      FUNCTION RFIND(VARABL,IERR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*8 VARABL
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUOUT,LUERR,KOLSV
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      KOLSV = NCOL
      KERR = IERR
      CALL DECODN(VARABL,VALUE,ISIGN,FIXPNT,FRACT,IEXPFR,ISIGNE,IEXP)
      RFIND = VALUE
      IERR = KERR
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN
      END

! DECODN
      SUBROUTINE DECODN(VARABL,VALUE,ISIGN,FIXPNT,FRACT,IEXPFR,ISIGNE,  &
                        IEXP)                                            
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                 
      LOGICAL FIRST                                                      
      CHARACTER*8 VARABL                                                 
      CHARACTER*1 BLANK,PLUS,DECPT,SLASH,COMMA,EQUALS,RPAREN,TAB,       &
                  MINUS,LPAREN,LETE,LETD,LETS,LETQ,LETR,LETT,           &
                  NUM(10),LETTER                                         
      CHARACTER*1 LCONT,LEOD,LEOC                                        
      CHARACTER*80 CARD                                                  
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUOUT,LUERR,KOLSV     
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC                               
      CHARACTER(80) :: BASIS_FILE                                        
      COMMON/BASIS_FILE/BASIS_FILE                                       
      DATA FIRST/.TRUE./                                                 
      SAVE FIRST,TAB,NUM,BLANK,PLUS,MINUS,DECPT,SLASH,COMMA,EQUALS,     &
           LPAREN,RPAREN,LETE,LETD,LETS,LETQ,LETR,LETT
!-----------------------------------------------------------------------
      IF(FIRST) THEN
       TAB = CHAR(9)
       NUM(1) = '0'
       NUM(2) = '1'
       NUM(3) = '2'
       NUM(4) = '3'
       NUM(5) = '4'
       NUM(6) = '5'
       NUM(7) = '6'
       NUM(8) = '7'
       NUM(9) = '8'
       NUM(10)= '9'
       BLANK = ' '
       PLUS =  '+'
       MINUS = '-'
       DECPT = '.'
       SLASH = '/'
       COMMA = ','
       EQUALS= '='
       LPAREN= '('
       RPAREN= ')'
       LETE =  'E'
       LETD  = 'D'
       LETS  = 'S'
       LETQ  = 'Q'
       LETR  = 'R'
       LETT  = 'T'
       FIRST = .FALSE.
      END IF
      TNUM=0.0D0
      ISQRT=0
  110 LSIGN=1
      ICOMMA=0
      NEWCRD=0
      X=0.0D0
      LSTERR=KERR
      KERR = 0
      NDECPT=0
      KINDST=1
      ISIGN=1
      ISIGNE=1
      VALUE=0.0D0
      FIXPNT=0.0D0
      FRACT=0.0D0
      IEXPFR=0
      IEXP=0
      LEND=0
      LAST=KOLSV
!
  120 LFIRST=0
  130 IF (NCOL>LSTCOL) GO TO 240
      LETTER=CARD(NCOL:NCOL)
      CALL UPRCAS(LETTER,1)
      IF(LETTER==PLUS  ) GO TO 170
      IF(LETTER==MINUS ) GO TO 190
      IF((LFIRST==0  .AND.  LAST<=KOLSV)  .AND.                         &
         (LETTER==LETD  .OR.  LETTER==LETE)) GO TO 290
      IF(LETTER==LETE  ) GO TO 200
      IF(LETTER==LETD  ) GO TO 200
      IF(LETTER==LCONT ) GO TO 208
      IF(LETTER==COMMA ) GO TO 210
      IF(LETTER==LPAREN) GO TO 210
      IF(LETTER==RPAREN) GO TO 210
      IF(LETTER==DECPT ) GO TO 220
      IF(LETTER==SLASH ) GO TO 230
      IF(LETTER==BLANK ) GO TO 250
      IF(LETTER==TAB  ) GO TO 250
      IF(LETTER==EQUALS) GO TO 250
      DO 140 J=1,10
      IF(LETTER==NUM(J)) GO TO 150
  140 CONTINUE
      LAST=NCOL
      IF(LETTER/=LETS) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LETQ) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LETR) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LETT) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LPAREN) GO TO 290
      NCOL=LAST+1
      ISQRT=1
      GO TO 130
!
  150 IF (LFIRST==0) LFIRST=NCOL
      IF(NCOL==MAXCOL) NEWCRD=1
  160 LEND=1
  170 NCOL=NCOL+1
      GO TO 130
!
  180 IF (LEND>0) GO TO 350
      GO TO 170
!
  190 LSIGN=-1
      GO TO 170
!
  200 IF (LFIRST/=0) GO TO 260
      IF (LEND==0) FIXPNT=1.0D0
      IF (CARD(NCOL+1:NCOL+1)==BLANK) NCOL=NCOL+1
      LSIGN=1
      KINDST=3
      GO TO 160
!
  208 NEWCRD=1
      IF(LFIRST/=0) GO TO 260
      IF(LEND>0) GO TO 350
      if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
       CALL RDCARD(50,'   *    ',KEOF)  
      else
       CALL RDCARD(5,'   *    ',KEOF)
      endif
      NEWCRD=0
      GO TO 130
!
  210 ICOMMA=1
      IF(LFIRST/=0) GO TO 260
      GO TO 350
!
  220 CONTINUE
      IF(NDECPT>1) GO TO 290
      NDECPT=NDECPT+1
      IF (LFIRST/=0) GO TO 260
      ISIGN=LSIGN
      KINDST=2
      GO TO 160
!
  230 IF(LFIRST/=0) GO TO 260
      TNUM=(FIXPNT+FRACT*(10.0D0**IEXPFR))*(10.0D0**(ISIGNE*IEXP))
      IF(ISIGN<0) TNUM=-TNUM
      NCOL=NCOL+1
      GO TO 110
!
  240 IF (LEND==0) NCOL=LSTCOL+1
      LEND=1
  250 IF (LFIRST==0) GO TO 180
!                  DECODE DIGIT STRING AND STORE IN X
  260 LAST=NCOL-1
      X=0.0D0
      FAC=1.0D0
  270 CONTINUE
      DO 280 J=1,10
         IF (CARD(LAST:LAST)==NUM(J)) GO TO 300
  280 CONTINUE
!
  290 CONTINUE
      IF(LSTERR/=30 .AND. LUOUT>0) THEN
            WRITE(LUOUT,900) VARABL,LAST
            WRITE(LUOUT,910) CARD,(I,I=1,8)
      END IF
      IF(LSTERR/=30 .AND. LUERR>0 .AND. LUOUT<0)THEN
            WRITE(LUERR,900) VARABL,LAST
            WRITE(LUERR,910) CARD,(I,I=1,8)
      END IF
      KERR = 1
      RETURN
!
  300 X=X+FAC*(J-1)
      IF (LAST==LFIRST) GO TO 310
      LAST=LAST-1
      FAC = 10.0D0 * FAC
      GO TO 270
!
  310 CONTINUE
      IF(KINDST==3) GO TO 340
         IF(KINDST==2) GO TO 330
            FIXPNT=X
            ISIGN=LSIGN
            GO TO 120
!
  330    FRACT=X
         IEXPFR=LFIRST-NCOL
         GO TO 120
!
  340 IEXP=INT(X)
      ISIGNE=LSIGN
      GO TO 120
!
  350 CONTINUE
      VALUE=(FIXPNT+FRACT*(10.0D0**IEXPFR))*(10.0D0**(ISIGNE*IEXP))
      IF(TNUM/=0.0D0) VALUE=TNUM/VALUE
      IF(ISQRT==1) VALUE=SQRT(VALUE)
      IF(ISIGN<0) VALUE=-VALUE
      NCOL=NCOL+ICOMMA
      IF(NEWCRD==1)THEN
       if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
        CALL RDCARD(50,'   *    ',KEOF)  
       else
        CALL RDCARD(5,'   *    ',KEOF)
       endif
      ENDIF
      RETURN
!
  900 FORMAT(1X,'**** ERROR READING VARIABLE ',A8,' CHECK COLUMN',I3)
  910 FORMAT(1X,A80/1X,8('....V....',I1))
      END

! GSTRNG
      SUBROUTINE GSTRNG(STRING,LENGTH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL FIRST
      CHARACTER*(*) STRING
      CHARACTER*1 BLANK,TAB,QUOTE,EQUAL,COMMA,LPAREN
      CHARACTER*1 LCONT,LEOD,LEOC
      CHARACTER*80 CARD
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUOUT,LUERR,KOLSV
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC
      CHARACTER(80) :: BASIS_FILE
      COMMON/BASIS_FILE/BASIS_FILE
      DATA FIRST/.TRUE./
      SAVE FIRST,BLANK,QUOTE,EQUAL,COMMA,LPAREN,TAB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      KOLSV = NCOL
      IF(FIRST) THEN
       BLANK = ' '
       QUOTE = ''''
       EQUAL = '='
       COMMA = ','
       LPAREN = '('
       TAB= CHAR(9)
       FIRST=.FALSE.
      END IF
!
  100 CONTINUE
      NOCHAR=MAX(IABS(LENGTH),4)
      NCC=0
      NBC=NOCHAR
      IF(NCOL>LSTCOL) GO TO 320
!
      LSTART=NCOL-1
      LSTOP=LSTART+NOCHAR
!
      DO 110 N=NCOL,LSTCOL
         IF(CARD(N:N)==TAB) GO TO 110
         IF(CARD(N:N)/=BLANK) GO TO 120
  110 CONTINUE
      NCOL=LSTCOL+1
      GO TO 300
!
  120 CONTINUE
      IF(CARD(N:N)/=LCONT) GO TO 130
!
      IF(STRING(1:4)=='   *') RETURN
      if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
       CALL RDCARD(50,'   *    ',KEOF)  
      else
       CALL RDCARD(5,'   *    ',KEOF)
      endif
      GO TO 100
!
  130 CONTINUE
      NCOL=LSTOP+1
      IF(LENGTH<0) GO TO 200
      IF(LENGTH>0) GO TO 300
!
      NCOL=N
      IF(CARD(N:N)/=QUOTE) GO TO 300
!
      LSTART=NCOL-1
  140 CONTINUE
      NCOL=NCOL+1
!
      DO 150 N=NCOL,LSTCOL
         CARD(N-1:N-1)=CARD(N:N)
  150 CONTINUE
      CARD(LSTCOL:LSTCOL)=BLANK
!
      DO 160 N=NCOL,LSTCOL
         IF(CARD(N:N)==QUOTE) GO TO 170
  160 CONTINUE
      N=LSTCOL
  170 CONTINUE
      NCOL=N+1
!
      IF(NCOL<LSTCOL .AND. CARD(NCOL:NCOL)==QUOTE) GO TO 140
      LSTOP=N-1
      LENGTH=LSTOP-LSTART
      NOCHAR=MAX(LENGTH,4)
      GO TO 300
!
  200 CONTINUE
      NCOL=N
      LSTART=NCOL-1
!
      DO 210 N=NCOL,LSTCOL
         IF(CARD(N:N)==BLANK) GO TO 220
         IF(CARD(N:N)==EQUAL) GO TO 220
         IF(CARD(N:N)==COMMA) GO TO 220
         IF(CARD(N:N)==LPAREN) GO TO 220
  210 CONTINUE
      N=LSTCOL+1
  220 CONTINUE
      NCOL=N+1
      LSTOP=MIN(LSTART+NOCHAR,N-1)
!
  300 CONTINUE
      NCC=MIN(LSTOP,LSTCOL) - LSTART
      NBC=NOCHAR - NCC
      IF(NCC<=0) GO TO 320
         DO 310 N=1,NCC
            STRING(N:N)=CARD(LSTART+N:LSTART+N)
  310    CONTINUE
  320 CONTINUE
      IF(NBC==0) GO TO 340
!
         DO 330 N=1,NBC
            STRING(NCC+N:NCC+N)=BLANK
  330    CONTINUE
  340 CONTINUE
!
      IF(LENGTH<0) CALL UPRCAS(STRING,IABS(LENGTH))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN
      END

! IFIND
      FUNCTION IFIND(VARABL,IERR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*8 VARABL
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUOUT,LUERR,KOLSV
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      KOLSV = NCOL
      KERR = IERR
      CALL DECODN(VARABL,VALUE,ISIGN,FIXPNT,FRACT,IEXPFR,ISIGNE,IEXP)
!
      IFRACT=INT(FRACT)
      INTT=INT(FIXPNT)
      I1=10**IEXP
      I2=IEXPFR+ISIGNE*IEXP
      I3=10**IABS(I2)
      IF (ISIGNE<0) GO TO 130
!
      IF (I2<0) THEN
         I5=IFRACT/I3
      ELSE
         I5=IFRACT*I3
      END IF
!
      IFIND=ISIGN*(INTT*I1+I5)
      IERR = KERR
      RETURN
!
  130 IFIND=ISIGN*INTT/I1
      IERR = KERR
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN
      END

! ECPPAR
      SUBROUTINE ECPPAR(KTYPE,NSHELL,ZAN,Cxyz)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/INTOPT/ISCHWZ,IECP,NECP
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB                                    
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),KLAST(100,6), &
                  LMAX(100),LPSKIP(100),IZCORE(100)                                          
      COMMON/ECPDIM/NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN      
      CHARACTER(80) ::  BASIS_FILE
      COMMON/BASIS_FILE/BASIS_FILE
!
      INTEGER,DIMENSION(NSHELL) :: KTYPE
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      CHARACTER(8) :: PPNAME,PPTYPE,PTYPE
      CHARACTER(8), DIMENSION(100) :: TYPELP
      CHARACTER(8) :: ANONE,GEN,BLANK,ENDWRD
      DATA ANONE /'NONE    '/, GEN   /'GEN     '/
      DATA BLANK /'        '/, ENDWRD/'$END    '/
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NECP: Number of electrons removed
!     IZCORE: Number of electrons removed by each atom
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NECP = 0
      DO I=1,NAT
       IZCORE(I)= 0
       LMAX(I)  = 0
       LPSKIP(I)= 1
      END DO
      IF(IECP==0)RETURN                           ! No ECP is used
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,'(/1X,A14,/1X,14(1H-))')'ECP Potentials'
      PPNAME = BLANK
      PPTYPE = BLANK
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Find Group $ECP in the Input File ( IECP = 1 )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IECP==1) THEN
#ifdef MPI
       CONTINUE
#else
       if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
        REWIND(50)
       else
        REWIND(5)
       endif
#endif
       if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
        CALL FNDGRP(50,'$ECP    ',JEOF)  
       else
        CALL FNDGRP(5,'$ECP    ',JEOF)
       endif
!
       IF(JEOF==1)THEN
        WRITE(6,'(/36A)')'Stop: No ECP group found, IECP=1'
        CALL ABRT
       END IF
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IADD= 0
      PTYPE= ANONE
      DO ICNTR=1,NAT
       NUCZ = INT(ZAN(ICNTR))
       LPSKIP(ICNTR) = 0
       IEOF= 0
!- - - - - - - - - - - - - - - - - - - - - - - - -
!      IECP = 1
!- - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IECP==1)THEN
        IEOF= 0
        IERR= 0
        if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
         CALL RDCARD(50,'$ECP   1',IEOF)  
        else
         CALL RDCARD(5,'$ECP   1',IEOF)
        endif
        KSIZE=-8
        CALL GSTRNG(PPNAME,KSIZE)
        IF(ADJUSTL(PPNAME)==ADJUSTL(ENDWRD)) THEN
         WRITE(6,'(A32)')'Stop: An unexpected $END in $ECP'
         CALL ABRT
        END IF
        READ(UNIT=PPNAME,FMT='(A8)')TYPELP(ICNTR)
        KSIZE=-8
        CALL GSTRNG(PPTYPE,KSIZE)
        READ(UNIT=PPTYPE,FMT='(A8)') PTYPE
        IZCORE(ICNTR)= IFIND('IZCORE  ',IERR)
        IF(IERR/=0) CALL ABRT
        LMAX(ICNTR)= IFIND('LMAX    ',IERR)
        IF(IERR/=0) CALL ABRT
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - -
!      No ECP Type
!- - - - - - - - - - - - - - - - - - - - - - - - -
       IF(PTYPE==ANONE) THEN
        LPSKIP(ICNTR)=1
        IZCORE(ICNTR)=0
        LMAX(ICNTR)=0
        GO TO 1
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - -
!       Type
!- - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - -
!      Check if PP has occured before
!- - - - - - - - - - - - - - - - - - - - - - - - -
       IF(ICNTR/=1)THEN
        NCNTR = ICNTR-1
        DO JCNTR=1,NCNTR
         IF(TYPELP(ICNTR)/=TYPELP(JCNTR)) GO TO 3
         LMN = 1
         LMX = LMAX(JCNTR)+1
         DO  L=LMN,LMX
          KFRST(ICNTR,L)= KFRST(JCNTR,L)
          KLAST(ICNTR,L)= KLAST(JCNTR,L)
         END DO
         LMAX(ICNTR)= LMAX(JCNTR)
         IZCORE(ICNTR)= IZCORE(JCNTR)
         GO TO 2
    3    CONTINUE
        END DO
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - -
!      GEN Type
!- - - - - - - - - - - - - - - - - - - - - - - - -
       IF(PTYPE==GEN) THEN
        LMN = 1
        LMX = LMAX(ICNTR)+1
        DO L=LMN,LMX
         IEOF= 0
         IERR= 0
         if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
          CALL RDCARD(50,'$ECP   2',IEOF)  
         else
          CALL RDCARD(5,'$ECP   2',IEOF)
         endif
         NGPOT = IFIND('NGPOT   ',IERR)
         KF = IADD+1
         KL = IADD+NGPOT
         IF(KL>400) THEN
          WRITE(6,*)'Stop: KL > 400'
          CALL ABRT
         END IF
         KFRST(ICNTR,L)= KF
         KLAST(ICNTR,L)= KL
         DO K=KF,KL
          IEOF= 0
          IERR= 0
          if(LEN_TRIM(BASIS_FILE)>0)then      ! read from file.bas
           CALL RDCARD(50,'$ECP   3',IEOF)  
          else
           CALL RDCARD(5,'$ECP   3',IEOF)
          endif
          CLP(K)= RFIND('ECP COEF',IERR)
          IF(IERR/=0) CALL ABRT
          NLP(K)= IFIND('POLYNO N',IERR)
          IF(IERR/=0) CALL ABRT
          ZLP(K)= RFIND('ECP EXP.',IERR)
          IF(IERR/=0) CALL ABRT
         END DO
         IADD = KL
        END DO
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - -
    2  CONTINUE
!- - - - - - - - - - - - - - - - - - - - - - - - -
!      Number of Electrons and Nuclear Charge
!- - - - - - - - - - - - - - - - - - - - - - - - -
       NE = NE-IZCORE(ICNTR)
       NA = NA-IZCORE(ICNTR)/2
       NB = NB-IZCORE(ICNTR)/2
       ZAN(ICNTR) = ZAN(ICNTR)-IZCORE(ICNTR)
    1  CONTINUE
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print the Pseudo Potentials
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NUMECP = 0
      DO ICNTR=1,NAT
       IF(LPSKIP(ICNTR)==1) GOTO 4
       NUMECP = NUMECP+1
       NCNTR  = ICNTR-1
       DO JCNTR=1,NCNTR
        IF(TYPELP(ICNTR)/=TYPELP(JCNTR)) GO TO 5
         WRITE(6,10) TYPELP(ICNTR),ICNTR,JCNTR
        GOTO 4
    5   CONTINUE
       END DO

       WRITE(6,20)TYPELP(ICNTR),ICNTR,IZCORE(ICNTR),LMAX(ICNTR)
       LMN = 1
       LMX = LMAX(ICNTR)+1
       DO L=LMN,LMX
        LM1=L-2
        IF(L==LMN) LM1=LMX-1
         WRITE(6,30) LM1
        KF = KFRST(ICNTR,L)
        KL = KLAST(ICNTR,L)
        KK= 1
        DO K=KF,KL
          WRITE(6,40) KK,CLP(K),NLP(K),ZLP(K)
         KK = KK+1
        ENDDO
       END DO
    4  CONTINUE
      END DO

      IF(NUMECP==0) THEN
       WRITE(6,*)'Stop: This run has no atoms with ECP'
       CALL ABRT
      END IF

      NECP= 0
      DO I=1,NAT
       NECP = NECP+IZCORE(I)
      END DO
      WRITE(6,50)NECP,NECP,NE,NA,NB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Adjusted Nuclear Energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      Vnn = ENUC(NAT,ZAN,Cxyz)
      WRITE(6,'(/A26,F20.10/)')' Adjusted Nuclear Energy =',Vnn
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check the Basis
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL BASCHK(MAXANG,KTYPE,NSHELL)
      IF(MAXANG>=5)THEN
       WRITE(6,*)'Stop: ECP integrals only for S,P,D,F,G'
       CALL ABRT
      END IF
      NLIM = MAXANG+1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check the Potential Type
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      LLIM = 0
      DO IAT=1,NAT
       LLIM = MAX0(LMAX(IAT),LLIM)
      END DO
      NLIM= MAX0(NLIM,LLIM)
      IF(LLIM>=5) THEN
       WRITE(6,*)'Stop: ECP integrals only for S,P,D,F,G'
       CALL ABRT
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Test NLIM
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NTLIM=(NLIM*(NLIM+1)*(NLIM+2))/6
      NCOEF1 = 8520
      NCOEF2 = 3424
      IF(NLIM==5) THEN
       NCOEF1 = 71660
       NCOEF2 = 10555
      ELSE IF(NLIM==6) THEN
       NCOEF1 = 280000
       NCOEF2 = 28940
      ELSE IF(NLIM==7) THEN
       NCOEF1= 892584
       NCOEF2= 60382
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      J1LEN = (NTLIM*NTLIM+NTLIM)/2+1
      J2LEN = (LLIM-1)*(LLIM+1)*NTLIM+NTLIM+1
      J4LEN = J2LEN-1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   10 FORMAT(' Parameters for "',A8,'" on Atom',I3,                     &
             ' are the same as atom',I3)                                 
   20 FORMAT(' Parameters for "',A8,'" on Atom',I3,                     &
             ' with ZCORE',I3,' and LMAX',I2,' are'/)                    
   30 FORMAT(' for L=',I2,6X,'COEFF',4X,'N',11X,'ZETA')                  
   40 FORMAT(I5,F15.5,I5,F15.5)                                          
   50 FORMAT(/' The ECP removes',I4,' core electrons and',I4,' protons'/&
             /' Number of electrons kept in the run =',I5               &
             /' Number of occupied orbitals (Alpha) =',I5               &
             /' Number of occupied orbitals (Beta)  =',I5)
!-----------------------------------------------------------------------
      END

!======================================================================!
!======================================================================!
!                                                                      !
!   ENERGRAD: Calculate Energy and Gradient (IRUNTYP=1,2)              !
!                                                                      !
!   OPTIMIZE: Routine to carry out geometry optimization (IRUNTYP=3)   !
!                                                                      !
!   HESSCAL : Calculate Hessian from analytic gradients (IRUNTYP=4)    !
!                                                                      !
!======================================================================!
!======================================================================!

! ENERGRAD
      SUBROUTINE ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,    &
                          NPRIMI,ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,   &
                          KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,   &
                          C2,EX,CS,CP,CD,CF,CG,CH,CI,GRADS,IRUNTYP,     &
                          DIPS,NOPTCG,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL RESTART
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/USELIBRETA/ILIBRETA                  
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
#include "mpip.h"
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      INTEGER,DIMENSION(NAT):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI) :: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: C1,C2,EX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3*NAT) :: GRADS
      DOUBLE PRECISION,DIMENSION(3) :: DIPS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IBUF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: H,S,EiHF,CHF,BUF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DIPN,QUADN,OCTUN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DQOInt,AUX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AHCORE,OVERLAP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: XINTS            
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: BUFaux
!-----------------------------------------------------------------------
!     Allocate necessary arrays for 1e- and 2e- integrals + Guess
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NSQ = NBF*NBF
      NBFT = (NBF*NBF+NBF)/2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     1e Integrals: H, S ; Initial Orbitals: CHF, EiHF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(H(NBFT),S(NBFT),EiHF(NBF),CHF(NSQ))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     2e- Integrals (BUF,IBUF)
!     NINTEGtm: Maximum numbers of distinct two-electron integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IDONTW==1)THEN
       NINTEGtm = 0
       NINTEGAUXtm = 0
       if(IERITYP==1)then
        NINTEGtm = NBF*(NBF+1)*(NBF*NBF+NBF+2)/8
       else if(IERITYP==2)then
        NINTEGAUXtm = NBF*(NBF+1)/2*NBFaux
       else if(IERITYP==3)then
        NINTEGtm = NBF*(NBF+1)*(NBF*NBF+NBF+2)/8       
        NINTEGAUXtm = NBF*(NBF+1)/2*NBFaux        
       end if
      ELSE
       NINTEGtm = NINTEG
      ENDIF
      ALLOCATE(BUF(NINTEGtm),IBUF(NINTEGtm),BUFaux(NINTEGAUXtm))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Integrals & Guess & RHF
!     Note: NINTEGt<NINTEGtm due to the CUTOFF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
      ALLOCATE(XINTS(NSH2))
      CALL GuessHJKRHF(KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,EX,CS,     &
                       CP,CD,CF,CG,CH,CI,NPRIMI,Cxyz,H,S,EiHF,CHF,      &
                       BUF,IBUF,BUFaux,NSHELL,NAT,NBF,NSQ,NBFT,NINTEGtm,&
                       NINTEGAUXtm,NINTEGt,NREC,XINTS,NSH2,IDONTW,      &
                       INPUTC,IPRINTOPT,ZAN)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Preparing for RunNOF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IDONTW==0)REWIND(1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Square Matrices AHCORE, OVERLAP
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(AHCORE(NBF,NBF),OVERLAP(NBF,NBF))
      CALL CPYTSQ(H,AHCORE,NBF)
      CALL CPYTSQ(S,OVERLAP,NBF)            
      DEALLOCATE(H,S)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Multipole Moment Integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DIPN(3),QUADN(6),OCTUN(10))
      CALL DQONuclear(DIPN,QUADN,OCTUN,Cxyz,ZAN,NAT)
!
      IF(IEMOM==1)THEN
       NVAL=3                                             
      ELSE IF(IEMOM==2)THEN
       NVAL=3+6                                             
      ELSE IF(IEMOM==3)THEN
       NVAL=3+6+10                                            
      END IF                                                            
      ALLOCATE(DQOInt(NVAL*NBFT),AUX(NVAL*784))
      if(ILIBRETA==0)then
       CALL PRCALC(DQOInt,AUX,NVAL,NBFT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI, &
                   KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz) 
      else if(ILIBRETA==1)then
       CALL PRCALClib(DQOInt,AUX,NVAL,NBFT,KATOM,KLOC,KMIN,KMAX,NSHELL)
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     PNOF Calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL RunNOF(NAT,NBF,NBFT,NSHELL,NPRIMI,ZAN,Cxyz,IAN,IMIN,IMAX,    &
                  KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP, &
                  C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,AHCORE,OVERLAP,CHF,EiHF,&
                  DIPN,QUADN,OCTUN,NVAL,DQOInt,NINTEG,NREC,IBUF,BUF,    &
                  BUFaux,NINTEGt,NINTEGAUXtm,IDONTW,GRADS,IRUNTYP,DIPS, &
                  XINTS,IPRINTOPT)
      DEALLOCATE(AHCORE,OVERLAP,CHF,EiHF,DIPN,QUADN,OCTUN,DQOInt,AUX)
      DEALLOCATE(IBUF,BUF,BUFaux,XINTS)
      NOPTCGMPI = NOPTCG
#ifdef MPI
      CALL DEACTIVATEERIs
      DO I=1,NPROCS-1
       K=0
       CALL MPI_SEND(K,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NOPTCGMPI,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif    
!-----------------------------------------------------------------------
      RETURN
      END

! OPTIMIZE
      SUBROUTINE OPTIMIZE(NINTEG,IDONTW,NAT,ZAN,Cxyz,IAN,IMIN,IMAX,     &
                 ZMASS,KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,     &
                 ISH,ITYP,C1,C2,EX1,CS,CP,CD,CF,CG,CH,CI,DIPS,          &
                 GRADS,IRUNTYP,IHSSCAL,IPROJECT,ISIGMA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL RESTART
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_CGM/ICGMETHOD
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/USELIBRETA/ILIBRETA
      COMMON/ELPROP/IEMOM
!
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN,ZMASS
      INTEGER,DIMENSION(NAT) :: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI) :: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMI)::C1,C2,EX1,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT):: Cxyz
      DOUBLE PRECISION,DIMENSION(3*NAT):: GRADS
      DOUBLE PRECISION,DIMENSION(3):: DIPS
!-----------------------------------------------------------------------
      EELEC_MIN = 1.0d20
!     Generate an initial GCF if RESTART=F setting ICOEF=0
      IF (RESTART .eqv. .FALSE.) THEN
       ICOEFORI = ICOEF
       ICOEF = 0
!      Update coordinates of shells if use libreta library for ERIs
       if(ILIBRETA==1)CALL UPDCOOSHELL(NSHELL,KATOM,Cxyz,NAT)
       CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,  &
                     ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,    &
                     INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP,CD,   &
                     CF,CG,CH,CI,GRADS,IRUNTYP,DIPS,0,0)
       RESTART = .TRUE.
       ICOEF = ICOEFORI
      ENDIF
!     Select CG Method     
      IF(ICGMETHOD==1)THEN
       CALL OPTSUMSL(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,  &
                     ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,KSTART,KATOM,KTYPE,   &
                     KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP, &
                     CD,CF,CG,CH,CI,IRUNTYP,GRADS,DIPS)                    
      ELSE IF(ICGMETHOD==2)THEN                                         
       CALL OPTCGNAG(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,  &
                     ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,KSTART,KATOM,KTYPE,   &
                     KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,    &
                     CP,CD,CF,CG,CH,CI,IRUNTYP,GRADS,DIPS)                    
      ELSE IF(ICGMETHOD==3)THEN                                         
       CALL OPTLBFGS(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,  &
                     ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,    &
                     INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP,CD,   &
                     CF,CG,CH,CI,IRUNTYP,GRADS,DIPS,NPRINT)             
      ENDIF                                                             
!     Compute Hessian from analytic gradients at stationary point       
      if(IHSSCAL==1)then                                                
       CALL HESSCAL(NINTEG,IDONTW,NAT,ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,     &
                    KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,    &
                    ITYP,C1,C2,EX1,CS,CP,CD,CF,CG,CH,CI,DIPS,           &
                    GRADS,IRUNTYP,IPROJECT,ISIGMA)
      end if
!-----------------------------------------------------------------------
      RETURN
      END
      
! HESSCAL
      SUBROUTINE HESSCAL(NINTEG,IDONTW,NAT,ZAN,Cxyz,IAN,IMIN,IMAX,      &
                 ZMASS,KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,    &
                 ISH,ITYP,C1,C2,EX1,CS,CP,CD,CF,CG,CH,CI,DIPS,         &
                 GRADS,IRUNTYP,IPROJECT,ISIGMA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/WRTGCF/IWRTGCF 
      COMMON/ELPROP/IEMOM      
      INTEGER,DIMENSION(NAT) :: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI) :: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN,ZMASS      
      DOUBLE PRECISION,DIMENSION(NPRIMI)::C1,C2,EX1,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT):: Cxyz
      DOUBLE PRECISION,DIMENSION(3*NAT):: GRADS
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE:: HESSIANO,DDM
      DOUBLE PRECISION,DIMENSION(3):: DIPS
      COMMON/USELIBRETA/ILIBRETA      
!-----------------------------------------------------------------------
      IF (IRUNTYP==4) THEN
!      Update coordinates of shells if use libreta library for ERIs
       if(ILIBRETA==1)CALL UPDCOOSHELL(NSHELL,KATOM,Cxyz,NAT)
       CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,  &
                     ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,    &
                     INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP,CD,   &
                     CF,CG,CH,CI,GRADS,IRUNTYP,DIPS,0,1)
!      Write Coordinates on File CGGRAD (Unit=11)
       WRITE(11,1)
       DO I=1,NAT
        WRITE(11,2)I,Cxyz(1,I),Cxyz(2,I),Cxyz(3,I)
       ENDDO
!      Internuclear distances       
       CALL NUCDIST(3*NAT,NAT,Cxyz)     
      ENDIF      
!     Compute Hessian from analytic gradients at stationary point
      IWRTGCF = 0
      ALLOCATE (HESSIANO(3*NAT,3*NAT),DDM(9,NAT))
      CALL HSSNUMd(HESSIANO,3*NAT,Cxyz,GRADS,DIPS,DDM,NINTEG,IDONTW,   &
                   ZAN,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,INTYP,    &
                   KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP,CD,CF,CG,    &
                   CH,CI,IRUNTYP)
!     Carry out normal mode vibrational analysis
      CALL FGMTRXd(Cxyz,HESSIANO,GRADS,3*NAT,ZAN,ZMASS,DDM,IPROJECT,   &
                   ISIGMA)
      DEALLOCATE (HESSIANO,DDM)
      RETURN      
!-----------------------------------------------------------------------
    1 FORMAT(/1X,'Atom',16X,'Coordinates (Bohr)',/16X,                 &
                 'x',13X,'y',13X,'z')                     
    2 FORMAT(1X,I4,3F14.4)
!-----------------------------------------------------------------------    
      END

!======================================================================!
!                                                                      !
!             G U E S S   &  R H F    S U B R O U T I N E S            !
!                                                                      !
!======================================================================!

! GuessHJKRHF
      SUBROUTINE GuessHJKRHF(KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,     &
                             EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,Cxyz,H,S,   &
                             EIG,VEC,XInteg,IXInteg,XIntegaux,NSHELL,   &
                             NAT,NBF,NSQ,NBFT,NINTEGtm,NINTEGAUXtm,     &
                             NINTEGt,NREC,XINTS,NSH2,IDONTW,INPUTC,     &
                             IPRINTOPT,ZAN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                                
!      
      LOGICAL RHF                                                        
      COMMON/INPNOF_RHF/IRHFTYP,NCONVRHF,CONVRHFDM,MAXITRHF,RHF      
      COMMON/INFOA/NATOMS,ICH,MUL,NUM,NQMT,NE,NA,NB 
      COMMON/CONV/ACURCY,EN,Etot,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
!      
      INTEGER :: IPRINTOPT
      INTEGER,DIMENSION(NINTEGtm) :: IXInteg      
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz                                                         
      DOUBLE PRECISION,DIMENSION(NBF) :: EIG
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: XInteg
      DOUBLE PRECISION,DIMENSION(NINTEGAUXtm) :: XIntegaux
      DOUBLE PRECISION,DIMENSION(NSH2) :: XINTS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: TKIN,DipoInt,Q
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: OCCa,OCCb,DENa,DENb
!-----------------------------------------------------------------------
!     IRHFTYP=1: Restricted Closed HF
!     IRHFTYP=2: Restricted Open HF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(RHF)THEN
       if(IERITYP==2)then
        WRITE(6,*)'Sorry: RHF is not possible yet with ERITYP=RI'
        CALL ABRT
       end if
       IF(NA==NB)THEN
        IRHFTYP=1
       ELSE IF(NA>NB)THEN
        IRHFTYP=2
       END IF
      ELSE
       IRHFTYP=0      
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     1e Integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(TKIN(NBFT),DipoInt(3*NBFT))
      CALL OneElecInt(Cxyz,H,S,TKIN,DipoInt,NBFT,IPRINTOPT,             &
                      EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,            &
                      KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,ZAN)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Initial Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(OCCa(NBF),OCCb(NBF),DENa(NBFT),DENb(NBFT),Q(NSQ))
      if(INPUTC==0.or.IRHFTYP>0)then
       CALL GuessCore(OCCa,OCCb,DENa,DENb,EIG,VEC,Q,H,S,NBF,NSQ,NBFT,   &
                      IPRINTOPT)
      endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     2e- Integrals
!     NINTEGtm & NINTEGAUXtm: Maximum numbers of distinct 2e- Integrals 
!     Note: NINTEGt<NINTEGtm due to the CUTOFF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(IERITYP==1 .or. IERITYP==3)then   ! FULL or MIX
       CALL JandK(XInteg,IXInteg,NINTEGtm,NINTEGt,NREC,XINTS,NSH2,      &
                  IDONTW,IPRINTOPT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,      &
                  KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,         &
                  Cxyz,NAT)
      end if
      if(IERITYP==2 .or. IERITYP==3)then   ! RI or MIX
       CALL JandKaux(XIntegaux,NINTEGAUXtm,IDONTW,IPRINTOPT,NBF,        &
                     EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,KATOM,       &
                     KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz,NAT)
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate the Restricted HF Energy of Molecule
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
      IF(IRHFTYP==1)THEN
       CALL RHFCL(OCCa,DENa,EIG,VEC,Q,H,S,NBF,NSQ,NBFT,XInteg,          &
                  IXInteg,NINTEGtm,NINTEGt,NREC,IDONTW,IPRINTOPT,       &
                  ZAN,Cxyz)        
       DENb = DENa                                                       
      END IF                                                             
      IF(IRHFTYP==2)THEN                                                 
       CALL RHFOP(OCCa,OCCb,DENa,DENb,EIG,VEC,Q,H,S,NBF,NSQ,NBFT,       &
                  XInteg,IXInteg,NINTEGtm,NINTEGt,NREC,IDONTW,          &
                  IPRINTOPT,ZAN,Cxyz)
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Energy Analysis
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(IRHFTYP>0)CALL EnergyComp(EN,Etot,KATOM,KLOC,DENa,DENb,H,TKIN, &
                                   S,NSHELL,NAT,NBF,NBFT,NE,IRHFTYP)
!-----------------------------------------------------------------------
      DEALLOCATE(TKIN,DipoInt,OCCa,OCCb,DENa,DENb,Q)
      RETURN
      END

! GuessCore
      SUBROUTINE GuessCore(OCCa,OCCb,DENa,DENb,EIG,VEC,                 &
                           Q,H,S,NBF,NSQ,NBFT,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER:: IPRINTOPT
      LOGICAL HFID
      COMMON/INPNOF_HFID/HFID,NTHRESHEID,THRESHEID,MAXITID,KOOPMANS       
!
      DOUBLE PRECISION,DIMENSION(NBF) :: OCCa,OCCb,EIG
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC,Q
      DOUBLE PRECISION,DIMENSION(NBFT) :: DENa,DENb,H,S
      DOUBLE PRECISION, ALLOCATABLE,DIMENSION(:,:) :: OVERLAP
!-----------------------------------------------------------------------
!     Initial Molecular Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPRINTOPT==1)WRITE(6,'(A22)')' Guess for MOs = HCORE'
      CALL HCORE(EIG,H,S,VEC,Q,NBF,NBFT,NSQ)
      CALL CLENMO(VEC,NBF,NBF,1.0D-08,1.0D-05,IPRINTOPT)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Orthonormalize initial MOs if necessary
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(HFID)then
       ALLOCATE(OVERLAP(NBF,NBF))
       CALL CPYTSQ(S,OVERLAP,NBF)       
       CALL CHECKORTHO(VEC,OVERLAP,IVIOORTHO,IPRINTOPT)
       if(IVIOORTHO/=0)then
        IF(IPRINTOPT==1)WRITE(6,'(A27)')' Orthogonalize the orbitals'
        CALL ORTHONORMAL(NBF,NBF,NBFT,OVERLAP,VEC,1,IPRINTOPT)
       endif
       DEALLOCATE(OVERLAP)
      endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Initial Density Matrix
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL INIDEN(VEC,OCCa,OCCb,DENa,DENb,NBF,NBFT,NSQ)
!-----------------------------------------------------------------------
      RETURN
      END

! HCORE
      SUBROUTINE HCORE(EIG,H,S,VEC,Q,NBF,NBFT,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      DOUBLE PRECISION,DIMENSION(NBF) :: EIG
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC,Q
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: H0,HH,W
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: SCR,Hsq
      ALLOCATE(H0(NBFT),HH(NBFT),SCR(NBF,NBF))
!-----------------------------------------------------------------------
!         Initial orbitals by diagonalization of 1e Hamiltonian
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Q-matrix and NQMT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      H0 = S
      CALL QMTSYM(H0,VEC,Q,EIG,SCR,NBF,NQMT,NBFT,NSQ) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     HH = Q*H0*Q (H0=HCORE)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      H0 = H
      CALL TFTRI(HH,H0,Q,SCR,NQMT,NBF,NBF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Diagonalize HH (HH->Hsq)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(Hsq(NBF,NBF),W(NBF))
      CALL CPYTSQ(HH,Hsq,NBF)      
      CALL DIAG(NBF,Hsq,VEC,EIG,W)
      DEALLOCATE(Hsq,W)      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Back Transform
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL TFSQB(VEC,Q,SCR,NQMT,NBF,NBF)    
!-----------------------------------------------------------------------
      DEALLOCATE(H0,HH,SCR)
      RETURN
      END

! CLENMO                                           
      SUBROUTINE CLENMO(VEC,NAO,NMO,TOLZ,TOLE,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION VEC(NAO,NMO)                                            
      INTEGER :: IPRINTOPT
!-----------------------------------------------------------------------
      NZER = 0                                                            
      NEQU = 0                                                            
      DO J=1,NMO                                                    
       DO 1 I=1,NAO                                                 
        VAL1 = ABS(VEC(I,J))                                          
        IF(VAL1==0.0D0)GO TO 1                                  
!       Zero teeny MOs
        IF(VAL1<=TOLZ)THEN
         VEC(I,J)=0.0D0                                            
         NZER = NZER+1                                              
         GO TO 1                                                
        END IF
!       equal magnitudes for nonzero orbitals
        IF(I==NAO)GO TO 1                                      
        KMIN = I+1                                                    
        DO K=KMIN,NAO                                           
         VAL2 = ABS(VEC(K,J))                                       
         TEST = ABS(1.0d0-VAL2/VAL1)                                
         IF(TEST<=TOLE)THEN
          VEC(K,J) = SIGN(VAL1,VEC(K,J))                        
          NEQU = NEQU+1                                           
         END IF
        END DO                                                    
    1  CONTINUE                                                       
      END DO
      IF(IPRINTOPT==1)WRITE(6,10)NEQU,NZER
   10 FORMAT(I10,' MOs were matched and',I10,' equalized to zero')
!-----------------------------------------------------------------------       
      RETURN                                                            
      END                                                               
      
! INIDEN
      SUBROUTINE INIDEN(V,OCCa,OCCb,DENa,DENb,NBF,NBFT,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      CHARACTER*4,ALLOCATABLE,DIMENSION(:) :: RLABMO
      DOUBLE PRECISION,DIMENSION(NBF) :: OCCa,OCCb
      DOUBLE PRECISION,DIMENSION(NSQ) :: V
      DOUBLE PRECISION,DIMENSION(NBFT) :: DENa,DENb
      ALLOCATE(RLABMO(NBF))
!-----------------------------------------------------------------------
      IF(NA>NBF)THEN
       WRITE(6,*)'Stop: NA > NBF for initial density matrix'
       CALL ABRT
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF( NB==(NE+MUL-1)/2 .and. NA==(NE-MUL+1)/2 )THEN     ! Closed
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL VCLR(OCCa,1,NBF)
       DO I=1,NA
        OCCa(I) = 2.0D+00      ! Occupation Numbers
       END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Symmetry (C1)
       CALL SYMMOS(RLABMO,V,NBF,NQMT,NBF)
       CALL DMTX(DENa,V,OCCa,NA,NBF,NBF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE IF( NB==(NE-MUL+1)/2 .and. NA==(NE+MUL-1)/2 )THEN   ! Open
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Alpha Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL VCLR(OCCa,1,NBF)
       DO I=1,NA
        OCCa(I) = 1.0D+00
       END DO
!      Symmetry (C1)
       CALL SYMMOS(RLABMO,V,NBF,NQMT,NBF)
       CALL DMTX(DENa,V,OCCa,NA,NBF,NBF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Beta Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL VCLR(OCCb,1,NBF)
       DO I=1,NB
        OCCb(I) = 1.0D+00
       END DO
!      Symmetry (C1)
       CALL SYMMOS(RLABMO,V,NBF,NQMT,NBF)
       CALL DMTX(DENb,V,OCCb,NB,NBF,NBF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -       
      END IF
!-----------------------------------------------------------------------
      DEALLOCATE(RLABMO)
      RETURN
      END

! DMTX                                             
      SUBROUTINE DMTX(D,V,X,M,N,NDIM)                                   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION D(*),V(NDIM,M),X(M)                                     
!-----------------------------------------------------------------------
      DO I = 1,N                                                    
       IJ = I*(I-1)/2                                                 
       DO J = 1,I                                                 
        IJ = IJ + 1                                                 
        DUM = 0.0D+00                                                  
        DO K = 1,M                                              
         DUM = DUM + X(K)*V(I,K)*V(J,K)                             
        END DO
        D(IJ) = DUM                                                 
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               
     
! QMTSYM
      SUBROUTINE QMTSYM(S,WRK,Q,EE,SCR,NBF,NQMT,NBFT,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF) :: EE
      DOUBLE PRECISION,DIMENSION(NBFT) :: S
      DOUBLE PRECISION,DIMENSION(NSQ) :: WRK
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: Q,SCR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: WRKq
!-----------------------------------------------------------------------
!     Symmetry Adapted Orthonormal Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      Q = 0.0D+00
      DO I=1,NBF
       Q(I,I) = 1.0D+00
      END DO
      CALL TFTRI(WRK,S,Q,SCR,NBF,NBF,NBF)
!      
      ALLOCATE(WRKq(NBF,NBF))
      CALL CPYTSQ(WRK,WRKq,NBF)            
      CALL DIAG(NBF,WRKq,Q,EE,SCR)
      DEALLOCATE(WRKq)      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Small Eigenvalues -> Eliminate eigenvectors
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      EWARN  = 1.0D-05
      QMTTOL = 1.0D-06                !  Linear Dependence Threshhold
      IRPZER=0
      DO ISALC=1,NBF
       IF(EE(ISALC)<QMTTOL)IRPZER=IRPZER+1
      END DO
!
      ESMALL= 1.0D+09
      NSMALL= 0
      NWARN = 0
      JSALC =0
      DO ISALC=1,NBF
       IF(EE(ISALC)<ESMALL)ESMALL=EE(ISALC)
       IF(EE(ISALC)<EWARN) NWARN = NWARN+1
       IF(EE(ISALC)>=QMTTOL)THEN
        JSALC=JSALC+1
        EE(JSALC)=1.0D+00/SQRT(EE(ISALC))
        DO I=1,NBF
         Q(I,JSALC)=Q(I,ISALC)
        END DO
       ELSE
        NSMALL=NSMALL+1
       END IF
      END DO
      NQMT = NBF-NSMALL
      NWARN = NWARN-NSMALL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Canonical Orthonormal Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO J=1,NBF
       DO I=1,NBF
        IF(J>NQMT)Q(I,J) = 0.0D+00
        Q(I,J) = Q(I,J)*EE(J)
       END DO
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Back Transform to AO Space
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRK = 0.0D+00
      DO I=1,NBF
       IDIAG = I + (I-1)*NBF
       WRK(IDIAG) = 1.0D+00
      END DO
      CALL TFSQB(Q,WRK,SCR,NBF,NBF,NBF)
!-----------------------------------------------------------------------
      RETURN
      END

! TFTRI                                            
      SUBROUTINE TFTRI(H,FMAT,TMAT,WRK,M,N,LDT) 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      DIMENSION H(*),FMAT(*),TMAT(LDT,M),WRK(N)                               
!-----------------------------------------------------------------------
!     Transform triangular matrix FMAT: H = TMAT+ * FMAT * TMAT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IJ = 0                                                            
      DO J = 1,M,5                                             
       JJMAX = MIN(M,J+4)                                      
       DO JJ=J,JJMAX                                              
        IK = 0                                                      
        DO I = 1,N                                              
         IM1 = I-1                                                
         DUM = 0.0D+00                                               
         TDUM = TMAT(I,JJ)                                           
         IF(IM1>0)THEN                                       
          DO K = 1,IM1                                      
           IK = IK+1                                          
           WRK(K) = WRK(K)+FMAT(IK)*TDUM                         
           DUM = DUM+FMAT(IK)*TMAT(K,JJ)                            
          END DO
         END IF                                                   
         IK = IK+1                                                
         WRK(I) = DUM+FMAT(IK)*TDUM                                  
        END DO
        DO I = 1,JJ                                             
         IJ = IJ+1                                                
         HIJ = DDOT(N,TMAT(1,I),1,WRK,1)                             
         IF(ABS(HIJ)<1.0D-11) HIJ = 0.0D+00                           
         H(IJ) = HIJ                                                
        END DO
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! TFSQB                                            
      SUBROUTINE TFSQB(V,Q,WRK,M,N,LDQV)  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(LDQV,M),Q(LDQV,M),WRK(N)  
!-----------------------------------------------------------------------
!     Back Transform: V = Q*V                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO J = 1,M,5
       JJMAX = MIN(M,J+4)                                      
       DO JJ=J,JJMAX                                              
        DO I = 1,N                                              
         W = DDOT(M,Q(I,1),LDQV,V(1,JJ),1)                        
         IF(ABS(W)<1.0D-11)W = 0.0D+00                               
         WRK(I)=W                                                 
        END DO
        DO I = 1,N                                              
         V(I,JJ) = WRK(I)                                         
        END DO
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! SYMMOS
      SUBROUTINE SYMMOS(RLABMO,V,NAO,NMO,LDQV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION V(LDQV,NMO)
      CHARACTER*4,DIMENSION(NMO) :: RLABMO
!-----------------------------------------------------------------------
      CALL STFASEd(V,LDQV,NAO,NMO)
      DO I=1,NMO
       RLABMO(I) = 'A   '
      END DO
!-----------------------------------------------------------------------
      RETURN
      END
      
! STFASEd        
      SUBROUTINE STFASEd(A,LDA,N,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,INTENT(IN) :: LDA,M,N
      DOUBLE PRECISION,DIMENSION(LDA,M),INTENT(INOUT):: A
      INTEGER:: I,J
!-----------------------------------------------------------------------      
!     SET THE PHASE OF EACH COLUMN OF A MATRIX SO THE LARGEST
!     ELEMENT IS POSITIVE
!-----------------------------------------------------------------------
      DO I = 1,M
       LARGE = IDAMAX(N,A(1,I),1)
       IF(LARGE<=0)LARGE=1
       IF(LARGE>N)LARGE=1
       IF(A(LARGE,I)<0.0D+00)THEN
        DO J = 1,N
         A(J,I) = -A(J,I)
        END DO
       END IF
      END DO
!-----------------------------------------------------------------------            
      RETURN
      END

! CPYTSQ                                           
      SUBROUTINE CPYTSQ(A,B,NA)                                    
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(*),B(NA,NA)                                           
!-----------------------------------------------------------------------    
!     ---- COPY TRIANGULAR A TO SQUARE B (NA BY NA) ----                
!-----------------------------------------------------------------------    
      IJ=1                                                              
      DO I=1,NA                                                     
       DO J=1,I                                                   
        B(I,J) = A(IJ)                                              
        B(J,I) = A(IJ)                                              
        IJ = IJ + 1                                              
       END DO
      END DO
!-----------------------------------------------------------------------    
      RETURN                                                            
      END                                                               

! VCLR                                             
      SUBROUTINE VCLR(A,INCA,N)                                         
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(*)                                                    
!-----------------------------------------------------------------------
!     ZERO OUT VECTOR -A-, USING INCREMENT -INCA- 
!-----------------------------------------------------------------------
      IF(INCA==1)THEN
       DO L=1,N                                                      
        A(L) = 0.0d0                                                    
       ENDDO
       RETURN                                                            
      ENDIF
      LA = 1-INCA                                                         
      DO L=1,N                                                      
       LA = LA+INCA                                                     
       A(LA) = 0.0d0                                                   
      ENDDO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ! 
!                         R H F : NA = NB                              !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ! 

! RHFCL      
      SUBROUTINE RHFCL(OCC,DEN,EIG,VEC,Q,H,S,NBF,NSQ,NBFT,XInteg,       &
                       IXInteg,NINTEGtm,NINTEGt,NREC,IDONTW,IPRINTOPT,  &
                       ZAN,Cxyz)   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                                
      LOGICAL RHF,HFDAMP,HFEXTRAP,HFDIIS                                     
      COMMON/INPNOF_HFCONVTECH/HFDAMP,HFEXTRAP,HFDIIS 
      COMMON/INPNOF_RHF/IRHFTYP,NCONVRHF,CONVRHFDM,MAXITRHF,RHF
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      COMMON/DIISSO/ETHRSH,MAXDII,IRAF
      COMMON/ACONV /RRSHFT,EXTTOL,DMPTOL,VSHTOL,IEXTIN                
      COMMON/CONV  /ACURCY,EN,Etot,EHF,EHF0,DIFF,ITER,ICALP,ICBET
!
      LOGICAL PRVEC,CVGED,CVDENS,CVENGY,CVDIIS,NOTOPN     
      INTEGER :: IPRINTOPT
      INTEGER,DIMENSION(NINTEGtm) :: IXInteg
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NBF) :: OCC,EIG
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC,Q
      DOUBLE PRECISION,DIMENSION(NBFT) :: DEN,H,S
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: XInteg
!
      CHARACTER*4,ALLOCATABLE,DIMENSION(:) :: AWRK      
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IPDIIS,IODII      
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: FAO,QFQ,WRK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: Fsq,Ssq,ERR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: ADIIS,XDIIS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: BDIIS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: WRK1,WRK2,WRK3
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: FAO0,FAO1,FAO2
!-----------------------------------------------------------------------
!     Nuclear Energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      EN = ENUC(NAT,ZAN,Cxyz)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Initialize Variables
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      PRVEC  = .FALSE.
      CVGED  = .FALSE.                                                        
!
      CVDENS = .FALSE.
      ACURCY = CONVRHFDM                                                      
      DTOL   = 2.0d0 * ACURCY      
      DIFFP  = 0.0d0                                                       
      DIFF   = 0.0d0                                                       
!      
      CVENGY = .FALSE.
      ETOL   = 1.0D-08      
      ENGTOL = 1.0D-10
      EHF    = 0.0d0                                                        
      Etot   = 0.0d0
      DELE   = 0.0d0                                                       
!      
      CVDIIS = .FALSE. 
      DIITOL = 1.0D-07      
      NOTOPN = .TRUE.                                                   
      ETHRSH = 0.5d0                                                         
      ITDIIS = 1 
      ERDIIS = 0.0d0      
      MAXDII = 10      
!      
      DAMP   = 0.0d0                                                       
      DAMP0  = 0.0d0                                                      
      ITERV  = 0                                                                
      RRSHFT = 0.0d0
      EXTTOL = 1.0D-03                                                  
      DMPTOL = 1.0D-04                                                  
      VSHTOL = 0.4D+00
      IEXTIN = 4                                                              
      ICALP  = 0
      ICBET  = 0                                                               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!     Header
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,10)'RHF SCF Calculation'
      WRITE(6,20)HFEXTRAP,HFDAMP,HFDIIS 
      WRITE(6,30)ACURCY,ETOL
      WRITE(6,35)ENGTOL,DTOL
      IF(HFDIIS)WRITE(6,36)DIITOL,DTOL                                                         
      IF(HFDAMP)DAMP=1.0d0
      IF(HFDIIS)THEN
       WRITE(6,40)
      ELSE
       WRITE(6,50)
      END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
      ALLOCATE(FAO(NBFT),QFQ(NBFT),Fsq(NBF,NBF),WRK(NBF))
      IF(HFDIIS)THEN
       ALLOCATE(Ssq(NBF,NBF),ERR(NBF,NBF))
       MAXIT2 = (MAXITRHF*MAXITRHF+MAXITRHF)/2                                             
       ALLOCATE(ADIIS(MAXDII*MAXDII),XDIIS(MAXITRHF),IPDIIS(MAXITRHF))
       ALLOCATE(BDIIS(MAXIT2),IODII(4*MAXDII)) 
      END IF       
      IF(HFDAMP.or.HFEXTRAP)THEN      
       ALLOCATE(WRK1(NSQ),WRK2(NSQ),WRK3(NSQ))
       ALLOCATE(FAO0(NBFT),FAO1(NBFT),FAO2(NBFT))      
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!                            RHF Iterations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                             
      DO ITER=1,MAXITRHF                                               
!      Skeleton 2e- Fock matrix                           
       CALL HSTAR(NBF,DEN,FAO,NBFT,XInteg,IXInteg,NINTEGt,NREC,IDONTW)
!      Add H to form Fock Matrix
       FAO = FAO + H
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       IF(.not.CVGED)THEN
!- - - - - - - - - - - - - - - - - -
!       HF Energy
!- - - - - - - - - - - - - - - - - -
        EHF0 = EHF 
        EHF1 = TRACEP(DEN,FAO,NBF)                                   
        EHF2 = TRACEP(DEN,H,NBF)                                    
        EHF = (EHF1+EHF2)/2.0d0                                                        
        Etot0 = Etot                                                      
        Etot  = EHF + EN
        DELE0 = DELE                                                      
        DELE  = Etot-Etot0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       DIIS Interpolation (ERR=F*D*S-S*D*F)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        IF(HFDIIS)THEN
         CALL CPYTSQ(FAO,Fsq,NBF)    ! FAO->Fsq
         CALL CPYTSQ(S,Ssq,NBF)      ! S->Ssq                 
         CALL DIISER(Fsq,DEN,Ssq,ERR,WRK,NBF,NBFT)                                      
         CALL DIISInter(ITDIIS,Q,FAO,ERR,Fsq,ADIIS,XDIIS,IPDIIS,BDIIS,  &
         IODII,WRK,NBF,NBFT,NSQ,MAXITRHF,MAXIT2,4*MAXDII,ERDIIS,NOTOPN)
         IF(ITDIIS>1)THEN                                           
          IF(HFDAMP)DAMP=1.0d0                                                   
          RRSHFT=0.0d0                                                 
         END IF                                                         
        END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   
!       Damping and Extrapolation of the Fock matrix
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(ITER==2)DEAVG = ABS(DELE)                                   
        IF(ITDIIS==1)THEN
         IF(HFDAMP.and.ITER>2)THEN
          DEAVG = (ABS(DELE)+ABS(DELE0)+0.2d0*DEAVG)/2.2D0          
          CALL DAMPD(DELE,DELE0,DEAVG,DAMP,ACURCY,DIFF,DIFFP,1.0D-02)
         END IF
         IF(DAMP<0.0d0)DAMP = 0.0d0
         IF(HFDAMP.or.HFEXTRAP)THEN
          CALL EXTRAPOL(DELE,DAMP,DAMP0,FAO,WRK1,WRK2,WRK3,             &
                        FAO0,FAO1,FAO2,NBF,NBFT,ITERV,1,1)
         END IF
        END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       Transform the Fock matrix to the Q-basis: QFQ = Q*FAO*Q
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
        CALL TFTRI(QFQ,FAO,Q,WRK,NQMT,NBF,NBF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                      
!       Diagonalize F' (QFQ->Fsq)                              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        CALL CPYTSQ(QFQ,Fsq,NBF)      
        CALL DIAG(NBF,Fsq,VEC,EIG,WRK)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       Back-transfrom the eigenvectors to the AO-basis
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        CALL TFSQB(VEC,Q,WRK,NQMT,NBF,NBF) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       New Density Matrix (DEN), QFQ = Previous Density Matrix
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        CALL DCOPY(NBFT,DEN,1,QFQ,1) 
        CALL DMTX(DEN,VEC,OCC,NA,NBF,NBF)   ! NOC=NA=NB
        DIFFP = DIFF                                                      
        CALL DDIFF(QFQ,DEN,NBFT,DIFF)                                
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       Printing iteration                                               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        IF(HFDIIS)THEN
         WRITE(6,60)ITER,Etot,DELE,DIFF,ERDIIS                              
        ELSE
         WRITE(6,70)ITER,Etot,DELE,DIFF
        END IF
        ICALP = ICALP+1                                                   
        ICBET = ICBET+1                                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Convergence: CVDENS, CVENGY, CVGED
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CVDENS = DIFF<ACURCY  .and.  ABS(DELE)<ETOL                       
        CVENGY = ABS(DELE)<ENGTOL  .and.  DIFF<DTOL                
        IF(HFDIIS) CVDIIS = ERDIIS<DIITOL  .and.  DIFF<DTOL 
        CVGED  = CVDENS .or. CVENGY .or. CVDIIS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
       END IF
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      Check Convergence
!-- -- -- -- -- -- -- -- --
       IF(CVGED)THEN                                                    
        IF(CVDENS)THEN                                                
         WRITE(6,80)                                   
         GO TO 1                                                   
        END IF                                                         
        IF(CVDIIS) THEN                                                
         WRITE(6,90)                                   
         GO TO 1                                                   
        END IF                                                         
        IF(CVENGY) THEN                                                
         WRITE(6,100)                                   
         GO TO 1                                                   
        END IF                                                         
       END IF                                                            
      END DO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     SCF is unconverged
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      WRITE(6,'(/1X,A24)')'Stop: SCF is unconverged'
      STOP                                                         
!-- -- -- -- -- -- -- -- -- --
!     Succesful Convergence
!-- -- -- -- -- -- -- -- -- --
    1 CONTINUE                                                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!     Print Final Results
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,110)Etot,ITER  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      ALLOCATE(AWRK(NQMT))
      CALL SYMMOS(AWRK,VEC,NBF,NQMT,NBF)      
      IF(PRVEC.and.IPRINTOPT==1)THEN
       WRITE(6,120)
       CALL PRINTEVECS(VEC,EIG,AWRK,NQMT,NBF)
      END IF      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
      IF(.not.NOTOPN)CLOSE(UNIT=20,STATUS='DELETE')
      NOTOPN = .TRUE.     
!-----------------------------------------------------------------------
      DEALLOCATE(FAO,QFQ,Fsq,WRK,AWRK)
      IF(HFDIIS)DEALLOCATE(Ssq,ERR,ADIIS,XDIIS,IPDIIS,BDIIS,IODII)
      IF(HFDAMP.or.HFEXTRAP)THEN
       DEALLOCATE(WRK1,WRK2,WRK3,FAO0,FAO1,FAO2)
      ENDIF
      RETURN
!-----------------------------------------------------------------------     
   10 FORMAT(/1X,A19,/1X,19(1H-))  
   20 FORMAT(1X,'EXTRAP=',L1,'  DAMP=',L1,'  DIIS=',L1)  
   30 FORMAT(1X,'DMat Conv =',1P,E8.1,2X,                               &
                'Ener Tol =',1P,E8.1)                                    
   35 FORMAT(1X,'Ener Conv =',1P,E8.1,2X,                               &
                'DMat Tol =',1P,E8.1)                                    
   36 FORMAT(1X,'DIIS Conv =',1P,E8.1,2X,                               &
                'DMat Tol =',1P,E8.1)                                    
   40 FORMAT(/' ITER      TOTAL ENERGY        E CHANGE     ',           &
              'DEN. CHANGE    DIIS ERROR')                               
   50 FORMAT(/' ITER      TOTAL ENERGY        E CHANGE     ',           &
              'DEN. CHANGE')                                             
   60 FORMAT(1X,I3,F20.10,F17.10,2F14.9)                                 
   70 FORMAT(1X,I3,F20.10,F17.10, F14.9)                                 
   80 FORMAT(/10X,17(1H-)/10X,17HDENSITY CONVERGED/10X,17(1H-))          
   90 FORMAT(/10X,14(1H-)/10X,14HDIIS CONVERGED/10X,14(1H-))             
  100 FORMAT(/10X,16(1H-)/10X,16HENERGY CONVERGED/10X,16(1H-))           
  110 FORMAT(/1X,'FINAL RHF ENERGY IS',F20.10,' AFTER',I4,              &
                 ' ITERATIONS')
  120 FORMAT(/10X,12HEigenvectors/10X,12(1H-))                   
!-----------------------------------------------------------------------           
      END

! HSTAR                                            
      SUBROUTINE HSTAR(NBF,Den,Skeleton,NBFT,XInteg,IXInteg,NINTEGt,    &
                       NREC,IDONTW)                  
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/INTFIL/NINTMX                 
      DOUBLE PRECISION,DIMENSION(NBFT) :: Den,Skeleton
      INTEGER,DIMENSION(NINTEGt) :: IXInteg
      DOUBLE PRECISION,DIMENSION(NINTEGt) :: XInteg    
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IBUF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: BUF
!-----------------------------------------------------------------------
!             Form the Skeleton of the Fock matrix for RHF
!-----------------------------------------------------------------------
      IF(IDONTW==0)THEN
       REWIND(1)
       ALLOCATE(IBUF(NINTMX),BUF(NINTMX))
      END IF
!      
      CALL VCLR(Skeleton,1,NBFT)                             
      I = 0                                                             
      J = 0                                                             
      K = 0                                                             
      L = 0                                                             
      NXInteg = 0                                                           
      IRECORD = 0 
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
    1 CONTINUE
      IF(IDONTW==1)THEN        ! IDONTW=1  (IXInteg,XInteg)
       IRECORD = IRECORD + 1
       IJBUF = (IRECORD-1)*NINTMX
       if(IRECORD<NREC)then               
        NINTEG = NINTMX
        NXInteg = NINTEG
       else
        NINTEG = NINTEGt - (NREC-1)*NINTMX
        NXInteg = -NINTEG
       end if
       IF(NXInteg==0)GO TO 2 
       IF(NINTEG>NINTMX)CALL ABRT 
!       
       DO M = 1,NINTEG
        LABEL = IXInteg(IJBUF+M)
        CALL LABELIJKL(LABEL,I,J,K,L)
        VAL = XInteg(IJBUF+M)
        NIJ = (I*I-I)/2+J                                                  
        NKL = (K*K-K)/2+L                                                  
        NIK = (I*I-I)/2+K                                                  
        NIL = (I*I-I)/2+L                                                  
        IF(J<K)GO TO 32                                         
        NJK = (J*J-J)/2+K                                                  
        NJL = (J*J-J)/2+L                                                  
        GO TO 42                                                      
   32   NJK = (K*K-K)/2+J                                                  
        IF(J<L) GO TO 52                                         
        NJL = (J*J-J)/2+L                                                  
        GO TO 42                                                      
   52   NJL = (L*L-L)/2+J                                                  
   42   CONTINUE                                                       
        VAL4 = 4.0d0*VAL
        Skeleton(NIJ) = Skeleton(NIJ) + VAL4*Den(NKL)                                    
        Skeleton(NKL) = Skeleton(NKL) + VAL4*Den(NIJ)                                    
        Skeleton(NIK) = Skeleton(NIK) - VAL*Den(NJL)                                     
        Skeleton(NIL) = Skeleton(NIL) - VAL*Den(NJK)                                     
        Skeleton(NJK) = Skeleton(NJK) - VAL*Den(NIL)                                     
        Skeleton(NJL) = Skeleton(NJL) - VAL*Den(NIK)                                     
       END DO
      ELSE                    ! IDONTW=0 (IBUF,XBUF)
       READ(1)NXInteg,IBUF,BUF
       IF(NXInteg==0)GO TO 2                                        
       NINTEG = IABS(NXInteg)                                                
       IF(NINTEG>NINTMX)CALL ABRT
!       
       DO M = 1,NINTEG                                                 
        LABEL = IBUF(M) 
        CALL LABELIJKL(LABEL,I,J,K,L)                                          
        VAL = BUF(M)                                                
        NIJ = (I*I-I)/2+J                                                  
        NKL = (K*K-K)/2+L                                                  
        NIK = (I*I-I)/2+K                                                  
        NIL = (I*I-I)/2+L                                                  
        IF(J < K) GO TO 31                                         
        NJK = (J*J-J)/2+K                                                  
        NJL = (J*J-J)/2+L                                                  
        GO TO 41                                                      
   31   NJK = (K*K-K)/2+J                                                  
        IF(J<L) GO TO 51                                         
        NJL = (J*J-J)/2+L                                                  
        GO TO 41                                                      
   51   NJL = (L*L-L)/2+J                                                  
   41   CONTINUE                                                       
        VAL4 = (VAL+VAL)+(VAL+VAL)  
        Skeleton(NIJ) = Skeleton(NIJ) + VAL4*Den(NKL)                                    
        Skeleton(NKL) = Skeleton(NKL) + VAL4*Den(NIJ)                                    
        Skeleton(NIK) = Skeleton(NIK) - VAL*Den(NJL)                                     
        Skeleton(NIL) = Skeleton(NIL) - VAL*Den(NJK)                                     
        Skeleton(NJK) = Skeleton(NJK) - VAL*Den(NIL)                                     
        Skeleton(NJL) = Skeleton(NJL) - VAL*Den(NIK)                                     
       END DO
      END IF
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
      IF(NXInteg>0)GO TO 1
    2 CONTINUE
!-----------------------------------------------------------------------                                                
      IF(IDONTW==0)THEN
       REWIND(1)
       DEALLOCATE(IBUF,BUF)
      END IF
!
      CALL DSCAL(NBFT,0.5d0,Skeleton,1)                                       
      II = 0                                                            
      DO I=1,NBF                                                       
       II = II + I                                                    
       Skeleton(II) = Skeleton(II) + Skeleton(II)                                            
      ENDDO 
!-----------------------------------------------------------------------  
      RETURN                                                            
      END                                                               

! DDIFF                                            
      SUBROUTINE DDIFF(D0,D1,L2,DIFF)                                   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION D0(L2),D1(L2)                                             
!     Largest Absolute Change in Density Matrix
      DIFF = 0.0D+00                                                    
      DO I = 1,L2                                                   
       DIFIJ = ABS(D0(I)-D1(I))                                          
       IF (DIFIJ > DIFF) DIFF = DIFIJ
      END DO                                 
      RETURN                                                            
      END

! PRINTEVECS                                            
      SUBROUTINE PRINTEVECS(V,EE,RLABMO,NMO,NBF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                      
      COMMON/RUNLAB/BFLAB(8192)            
      DIMENSION V(NBF,NMO),EE(NMO)
      CHARACTER*4 RLABMO(NMO)                                               
!-----------------------------------------------------------------------    
      MAX = 5                                                           
      IMAX = 0
    1 IMIN = IMAX+1                                                     
      IMAX = IMAX+MAX                                                   
      IF (IMAX > NMO) IMAX = NMO                                     
      WRITE (6,*)                                                   
      WRITE (6,'(15X,10(4X,I4,3X))')(I,I=IMIN,IMAX)                            
      WRITE (6,'(15X,10F11.4)')(EE(I),I=IMIN,IMAX)                            
      WRITE (6,'(16X,10(5X,A4,2X))')(RLABMO(I),I=IMIN,IMAX)                            
      DO J = 1,NBF                                                  
       WRITE (6,'(I5,2X,A8,10F11.6)')J,BFLAB(J),(V(J,I),I=IMIN,IMAX)              
      END DO
      IF(IMAX < NMO)GO TO 1                                      
!-----------------------------------------------------------------------
      RETURN                                                                                                                                   
      END                                                               

! EnergyComp
      SUBROUTINE EnergyComp(EN,Etot,KATOM,KLOC,DENa,DENb,H,TKIN,S,      &
                            NSHELL,NAT,NBF,NBFT,NE,ITYP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/VirialRatio/Virial                             ! RHF
      INTEGER,DIMENSION(NSHELL) :: KATOM,KLOC      
      DOUBLE PRECISION,DIMENSION(NBFT) :: DENa,DENb,H,TKIN,S
      INTEGER,ALLOCATABLE,DIMENSION(:) :: LIMLOW,LIMSUP            
!-----------------------------------------------------------------------
!     Basis Functions per Atom: Determine LIMLOW & LIMSUP
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(LIMLOW(NAT),LIMSUP(NAT))
      CALL AOLIM(NBF,NAT,NSHELL,LIMLOW,LIMSUP,KATOM,KLOC)

      Eone = TRACEP(DENa,H,NBF)
      IF(ITYP==2)Eone = Eone + TRACEP(DENb,H,NBF)

      Ecin = TRACEP(DENa,TKIN,NBF)
      IF(ITYP==2)Ecin = Ecin + TRACEP(DENb,TKIN,NBF)

      PSINRM = TRACEP(DENa,S,NBF)
      IF(ITYP==2)PSINRM = PSINRM + TRACEP(DENb,S,NBF)
      
      PSINRM = PSINRM/NE

      Vee = Etot - Eone - EN
      Vne = Eone - Ecin
      Vnn = EN
      Vtot = Vne + Vnn + Vee
      Virial = -Vtot/Ecin

      WRITE(6,10) PSINRM
      WRITE(6,20) Eone,Vee,Vnn,Etot
      WRITE(6,30) Vee,Vne,Vnn,Vtot,Ecin,Virial

      DEALLOCATE(LIMLOW,LIMSUP)
      RETURN
!-----------------------------------------------------------------------
   10 FORMAT(/1X,'        WAVEFUNCTION NORMALIZATION =',F19.10)
   20 FORMAT(/1X,'               ONE ELECTRON ENERGY =',F19.10/         &
              1X,'               TWO ELECTRON ENERGY =',F19.10/         &
              1X,'          NUCLEAR REPULSION ENERGY =',F19.10/         &
             38X,18(1H-)/                                               &
              1X,'                  RHF TOTAL ENERGY =',F19.10)          
   30 FORMAT(/1X,'ELECTRON-ELECTRON POTENTIAL ENERGY =',F19.10/         &
              1X,' NUCLEUS-ELECTRON POTENTIAL ENERGY =',F19.10/         &
              1X,'  NUCLEUS-NUCLEUS POTENTIAL ENERGY =',F19.10/         &
             38X,18(1H-)/                                               &
              1X,'            TOTAL POTENTIAL ENERGY =',F19.10/         &
              1X,'              TOTAL KINETIC ENERGY =',F19.10/         &
              1X,'                VIRIAL RATIO (V/T) =',F19.10)
!-----------------------------------------------------------------------              
      END

! AOLIM
      SUBROUTINE AOLIM(NBF,NAT,NSHELL,LIMLOW,LIMSUP,KATOM,KLOC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER,DIMENSION(NAT) :: LIMLOW,LIMSUP
      INTEGER,DIMENSION(NSHELL) :: KATOM,KLOC
!-----------------------------------------------------------------------
      LIMLOW(1) = 1
      LAT = 1
      J = 1
      DO I = 1,NSHELL
       IAT = KATOM(I)
       IF (LAT == IAT) GO TO 10
       LAT = IAT
       LIMSUP(J) = KLOC(I)-1
       J = J+1
       LIMLOW(J) = KLOC(I)
   10  CONTINUE
      END DO
      LIMSUP(J) = NBF
      IF(J<NAT)THEN
       JP1=J+1
       DO J=JP1,NAT
        LIMLOW(J)=NBF
        LIMSUP(J)=1
       END DO
      END IF
!-----------------------------------------------------------------------
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ! 
!                       R O H F : NA > NB                              !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ! 

! RHFOP                                            
      SUBROUTINE RHFOP(OCCa,OCCb,DENa,DENb,EIG,VEC,Q,H,S,NBF,NSQ,NBFT,  &
                       XInteg,IXInteg,NINTEGtm,NINTEGt,NREC,            &
                       IDONTW,IPRINTOPT,ZAN,Cxyz)                                 
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                 
      LOGICAL RHF,HFDAMP,HFEXTRAP,HFDIIS                                     
      COMMON/INPNOF_HFCONVTECH/HFDAMP,HFEXTRAP,HFDIIS 
      COMMON/INPNOF_RHF/IRHFTYP,NCONVRHF,CONVRHFDM,MAXITRHF,RHF      
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      COMMON/DIISSO/ETHRSH,MAXDII,IRAF
      COMMON/ACONV /RRSHFT,EXTTOL,DMPTOL,VSHTOL,IEXTIN                
      COMMON/CONV  /ACURCY,EN,Etot,EHF,EHF0,DIFF,ITER,ICALP,ICBET
!
      LOGICAL PRVEC,CVGED,CVDENS,CVENGY,CVDIIS,NOTOPN          
      INTEGER,DIMENSION(NINTEGtm) :: IXInteg
      INTEGER :: IPRINTOPT
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NBF) :: OCCa,OCCb,EIG
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC,Q
      DOUBLE PRECISION,DIMENSION(NBFT) :: DENa,DENb,H,S
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: XInteg
!
      CHARACTER*4,ALLOCATABLE,DIMENSION(:) :: AWRK      
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IPDIIS,IODII            
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: FA,FB,FMO,QFQ,WRK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: Fsq,Ssq,ERR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: ADIIS,XDIIS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: BDIIS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: WRK1,WRK2,WRK3
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: FAO0,FAO1,FAO2
!-----------------------------------------------------------------------
!     Nuclear Energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      EN = ENUC(NAT,ZAN,Cxyz)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Initialize Variables
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      PRVEC  = .FALSE.
      CVGED  = .FALSE.                                                        
!
      CVDENS = .FALSE.
      ACURCY = CONVRHFDM                                                      
      DTOL   = 2.0d0 * ACURCY      
      DIFFP  = 0.0d0                                                       
      DIFF   = 0.0d0
      DIFFA  = 0.0d0                                                       
      DIFFB  = 0.0d0                                                       
!      
      CVENGY = .FALSE.
      ETOL   = 1.0D-08      
      ENGTOL = 1.0D-10
      EHF    = 0.0d0                                                        
      Etot   = 0.0d0
      DELE   = 0.0d0                                                       
!      
      CVDIIS = .FALSE. 
      DIITOL = 1.0D-07      
      NOTOPN = .TRUE.                                                   
      ETHRSH = 0.5d0                                                         
      ITDIIS = 1 
      ERDIIS = 0.0d0      
      MAXDII = 10      
!      
      DAMP   = 0.0d0                                                       
      DAMP0  = 0.0d0                                                      
      ITERV  = 0                                                                
      RRSHFT = 0.0d0
      EXTTOL = 1.0D-03                                                  
      DMPTOL = 1.0D-04                                                  
      VSHTOL = 0.4D+00
      IEXTIN = 4                                                              
      ICALP  = 0
      ICBET  = 0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!     Header
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,10)'ROHF SCF Calculation'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,20)HFEXTRAP,HFDAMP,HFDIIS 
      WRITE(6,30)ACURCY,ETOL
      WRITE(6,35)ENGTOL,DTOL
      IF(HFDIIS)WRITE(6,36)DIITOL,DTOL                                                         
      IF(HFDAMP)DAMP=1.0d0
      IF(HFDIIS)THEN
       WRITE(6,40)
      ELSE
       WRITE(6,50)
      END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
      ALLOCATE(FA(NBFT),FB(NBFT),FMO(NBFT),QFQ(NBFT))
      ALLOCATE(Fsq(NBF,NBF),WRK(NBF),WRK1(NSQ))
      IF(HFDIIS)THEN
       ALLOCATE(Ssq(NBF,NBF),ERR(NBF,NBF))
       MAXIT2 = (MAXITRHF*MAXITRHF+MAXITRHF)/2                                             
       ALLOCATE(ADIIS(MAXDII*MAXDII),XDIIS(MAXITRHF),IPDIIS(MAXITRHF))
       ALLOCATE(BDIIS(MAXIT2),IODII(4*MAXDII)) 
      END IF       
      IF(HFDAMP.or.HFEXTRAP)THEN      
       ALLOCATE(WRK2(NSQ),WRK3(NSQ))
       ALLOCATE(FAO0(NBFT),FAO1(NBFT),FAO2(NBFT))      
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!                            ROHF Iterations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO ITER=1,MAXITRHF
!      Skeletons 2e- Fock matrix  (FA,FB)                         
       CALL HSTARRO(NBF,DENa,FA,DENb,FB,NBFT,XInteg,IXInteg,            &
                    NINTEGt,NREC,IDONTW)    
!      Add H to form Alpha and Beta Fock Matrices in AO basis 
       FA = FA + H
       FB = FB + H       
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       IF(.not.CVGED)THEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       HF Energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
        EHF0 = EHF                                                        
        EHFA = TRACEP(DENa,H,NBF) + TRACEP(DENa,FA,NBF)        
        EHFB = TRACEP(DENb,H,NBF) + TRACEP(DENb,FB,NBF)        
        EHF  = (EHFA+EHFB)/2.0d0                                            
        Etot0= Etot                                                       
        Etot = EHF + EN                                                     
        DELE0 = DELE                                                       
        DELE = Etot-Etot0                                                 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       High Spin Total MO Fock Matrix (FMO) -> Output: FA in AO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL ROFOCK(FA,FB,FMO,VEC,WRK,S,WRK1,NA,NB,NQMT,NBF,NBFT,NSQ)                  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
!       DIIS Interpolation (ERR=F*D*S-S*D*F,D=DA+DB)   (F=FA)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
        IF(HFDIIS)THEN
         DENa = DENa + DENb         ! D = DENa
         CALL CPYTSQ(FA,Fsq,NBF)    ! FA->Fsq
         CALL CPYTSQ(S,Ssq,NBF)     ! S->Ssq                 
         CALL DIISER(Fsq,DENa,Ssq,ERR,WRK,NBF,NBFT)                                      
         DENa = DENa - DENb         
         CALL DIISInter(ITDIIS,Q,FA,ERR,Fsq,ADIIS,XDIIS,IPDIIS,BDIIS,   &
         IODII,WRK,NBF,NBFT,NSQ,MAXITRHF,MAXIT2,4*MAXDII,ERDIIS,NOTOPN)
         IF(ITDIIS>1)THEN                                           
          IF(HFDAMP)DAMP=1.0d0                                                   
          RRSHFT=0.0d0                                                 
         END IF                                                         
        END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
!       Damping and Extrapolation of the Fock Matrix (FA)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(ITER==2)DEAVG = ABS(DELE)                                   
        IF(ITDIIS==1)THEN
         IF(HFDAMP.and.ITER>2)THEN
          DEAVG = (ABS(DELE)+ABS(DELE0)+0.2d0*DEAVG)/2.2D0          
          CALL DAMPD(DELE,DELE0,DEAVG,DAMP,ACURCY,DIFF,DIFFP,1.0D-02)
         END IF
         IF(DAMP<0.0d0)DAMP = 0.0d0
         IF(HFDAMP.or.HFEXTRAP)THEN
          CALL EXTRAPOL(DELE,DAMP,DAMP0,FA,WRK1,WRK2,WRK3,              &
                        FAO0,FAO1,FAO2,NBF,NBFT,ITERV,1,1)
         END IF
        END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       Transform the Fock matrix to the Q-basis: QFQ = Q*FA*Q
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
        CALL TFTRI(QFQ,FA,Q,WRK,NQMT,NBF,NBF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                      
!       Diagonalize F' (QFQ->Fsq)                              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        CALL CPYTSQ(QFQ,Fsq,NBF)      
        CALL DIAG(NBF,Fsq,VEC,EIG,WRK)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       Back-transfrom the eigenvectors to the AO-basis
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        CALL TFSQB(VEC,Q,WRK,NQMT,NBF,NBF) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       New Density Matrix (DEN), QFQ = Previous Density Matrix
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        CALL DCOPY(NBFT,DENa,1,QFQ,1) 
        CALL DMTX(DENa,VEC,OCCa,NA,NBF,NBF)
        CALL DDIFF(QFQ,DENa,NBFT,DIFFA) 
!        
        IF(NB>0)THEN                                                  
         CALL DCOPY(NBFT,DENb,1,WRK1,1)                             
         CALL DMTX(DENb,VEC,OCCb,NB,NBF,NBF)                      
         CALL DDIFF(WRK1,DENb,NBFT,DIFFB)                           
        ELSE                                                              
         WRK1  = 0.0d0
         DENb  = 0.0d0
         DIFFB = 0.0d0                                                     
        END IF
!        
        DIFFP = DIFF                                                      
        DIFF  = DIFFA + DIFFB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
!       Printing iteration                                               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
        IF(HFDIIS)THEN
         WRITE(6,60)ITER,Etot,DELE,DIFF,ERDIIS                              
        ELSE
         WRITE(6,70)ITER,Etot,DELE,DIFF
        END IF
        ICALP = ICALP+1                                                   
        ICBET = ICBET+1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Convergence: CVDENS, CVENGY, CVGED
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CVDENS = DIFF<ACURCY  .and.  ABS(DELE)<ETOL                       
        CVENGY = ABS(DELE)<ENGTOL  .and.  DIFF<DTOL                
        IF(HFDIIS) CVDIIS = ERDIIS<DIITOL  .and.  DIFF<DTOL 
        CVGED  = CVDENS .or. CVENGY .or. CVDIIS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                              
       END IF
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --       
!      Check Convergence
!-- -- -- -- -- -- -- -- --
       IF(CVGED)THEN                                                    
        IF(CVDENS)THEN                                                
         WRITE(6,80)                                   
         GO TO 1                                                   
        END IF                                                         
        IF(CVDIIS) THEN                                                
         WRITE(6,90)                                   
         GO TO 1                                                   
        END IF                                                         
        IF(CVENGY) THEN                                                
         WRITE(6,100)                                   
         GO TO 1                                                   
        END IF                                                         
       END IF                                                            
      END DO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     SCF is unconverged
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      WRITE(6,'(/1X,A24)')'Stop: SCF is unconverged'
      STOP                                                         
!-- -- -- -- -- -- -- -- -- --
!     Succesful Convergence
!-- -- -- -- -- -- -- -- -- --
    1 CONTINUE                                                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                 
!     Print Final Results
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,110)Etot,ITER  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!     Spin values
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SPINZ = 0.0d0                                                         
      S2 = 0.0d0
      CALL SPIN(SPINZ,S2,DENa,DENb,S,WRK1,WRK,NA,NB,NBF,NBFT)                                         
      WRITE(6,120)SPINZ,S2                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      ALLOCATE(AWRK(NQMT))
      CALL SYMMOS(AWRK,VEC,NBF,NQMT,NBF)
      IF(PRVEC.and.IPRINTOPT==1)THEN
       WRITE(6,130)                                                 
       CALL PRINTEVECS(VEC,EIG,AWRK,NQMT,NBF)                  
      END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(.not.NOTOPN)CLOSE(UNIT=20,STATUS='DELETE')           
      NOTOPN = .TRUE.                                                     
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(FA,FB,FMO,QFQ,Fsq,WRK,WRK1,AWRK)
      IF(HFDIIS)DEALLOCATE(Ssq,ERR,ADIIS,XDIIS,IPDIIS,BDIIS,IODII)
      IF(HFDAMP.or.HFEXTRAP)THEN
       DEALLOCATE(WRK2,WRK3,FAO0,FAO1,FAO2)
      ENDIF
      RETURN                                                            
!-----------------------------------------------------------------------
   10 FORMAT(/1X,A20,/1X,20(1H-)) 
   20 FORMAT(1X,'EXTRAP=',L1,'  DAMP=',L1,'  DIIS=',L1)  
   30 FORMAT(1X,'DMat Conv =',1P,E8.1,2X,                               &
                'Ener Tol =',1P,E8.1)                                    
   35 FORMAT(1X,'Ener Conv =',1P,E8.1,2X,                               &
                'DMat Tol =',1P,E8.1)                                    
   36 FORMAT(1X,'DIIS Conv =',1P,E8.1,2X,                               &
                'DMat Tol =',1P,E8.1)                                    
   40 FORMAT(/' ITER      TOTAL ENERGY        E CHANGE     ',           &
              'DEN. CHANGE    DIIS ERROR')                               
   50 FORMAT(/' ITER      TOTAL ENERGY        E CHANGE     ',           &
              'DEN. CHANGE')                                             
   60 FORMAT(1X,I3,F20.10,F17.10,2F14.9)                                 
   70 FORMAT(1X,I3,F20.10,F17.10, F14.9)                                 
   80 FORMAT(/10X,17(1H-)/10X,17HDENSITY CONVERGED/10X,17(1H-))          
   90 FORMAT(/10X,14(1H-)/10X,14HDIIS CONVERGED/10X,14(1H-))             
  100 FORMAT(/10X,16(1H-)/10X,16HENERGY CONVERGED/10X,16(1H-))           
  110 FORMAT(/1X,'FINAL ROHF ENERGY IS',F20.10,' AFTER',I4,             &
                 ' ITERATIONS')                                          
  120 FORMAT(/10X,20(1H-)/10X,12HSPIN SZ   = ,F8.3/                     &
              10X,12HS-SQUARED = ,F8.3/10X,20(1H-))                     
  130 FORMAT(/10X,12HEigenvectors/10X,12(1H-))              
!-----------------------------------------------------------------------
      END                                                               

! HSTARRO                                           
      SUBROUTINE HSTARRO(NBF,DAlpha,FA,DBeta,FB,NBFT,XInteg,IXInteg,    &
                         NINTEGt,NREC,IDONTW)     
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                     
      COMMON/INTFIL/NINTMX               
      DOUBLE PRECISION,DIMENSION(NBFT) :: DAlpha,FA,DBeta,FB
      INTEGER,DIMENSION(NINTEGt) :: IXInteg
      DOUBLE PRECISION,DIMENSION(NINTEGt) :: XInteg    
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IBUF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: BUF
!-----------------------------------------------------------------------
!     Form the Skeletons of the Fock matrices FA & FB for ROHF
!-----------------------------------------------------------------------
      IF(IDONTW==0)THEN
       REWIND(1)
       ALLOCATE(IBUF(NINTMX),BUF(NINTMX))
      END IF
!      
      CALL VCLR(FA,1,NBFT)                                            
      CALL VCLR(FB,1,NBFT)                                            
      I = 0                                                             
      J = 0                                                             
      K = 0                                                             
      L = 0                                                             
      NXInteg = 0                                                           
      IRECORD = 0 
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-      
    1 CONTINUE                                                          
      IF(IDONTW==1)THEN        ! IDONTW=1  (IXInteg,XInteg)      
       IRECORD = IRECORD + 1
       IJBUF = (IRECORD-1)*NINTMX
       if(IRECORD<NREC)then               
        NINTEG = NINTMX
        NXInteg = NINTEG
       else
        NINTEG = NINTEGt - (NREC-1)*NINTMX
        NXInteg = -NINTEG
       end if
       IF(NXInteg==0)GO TO 2                                        
       IF(NINTEG>NINTMX)CALL ABRT
!       
       DO M = 1,NINTEG
        LABEL = IXInteg(IJBUF+M)       
        CALL LABELIJKL(LABEL,I,J,K,L) 
        VAL = XInteg(IJBUF+M)        
        NIJ = (I*I-I)/2+J                                                  
        NKL = (K*K-K)/2+L                                                  
        NIK = (I*I-I)/2+K                                                  
        NIL = (I*I-I)/2+L                                                  
        IF(J<K) GO TO 32                                           
        NJK = (J*J-J)/2+K                                                  
        NJL = (J*J-J)/2+L                                                  
        GO TO 42                                                      
   32   NJK = (K*K-K)/2+J                                                  
        IF(J<L) GO TO 52                                           
        NJL = (J*J-J)/2+L                                                  
        GO TO 42                                                      
   52   NJL = (L*L-L)/2+J                                                  
   42   CONTINUE                                                       
        VAL2 = VAL+VAL                                                 
        VAL4 = VAL2+VAL2                                               
        DUM = VAL4*(DAlpha(NKL)+DBeta(NKL))                                   
        FA(NIJ) = FA(NIJ)+DUM                                          
        FB(NIJ) = FB(NIJ)+DUM                                          
        DUM = VAL4*(DAlpha(NIJ)+DBeta(NIJ))                                   
        FA(NKL) = FA(NKL)+DUM                                          
        FB(NKL) = FB(NKL)+DUM                                          
        FA(NIK) = FA(NIK)-VAL2*DAlpha(NJL)                                 
        FB(NIK) = FB(NIK)-VAL2*DBeta(NJL)                                 
        FA(NIL) = FA(NIL)-VAL2*DAlpha(NJK)                                 
        FB(NIL) = FB(NIL)-VAL2*DBeta(NJK)                                 
        FA(NJK) = FA(NJK)-VAL2*DAlpha(NIL)                                 
        FB(NJK) = FB(NJK)-VAL2*DBeta(NIL)                                 
        FA(NJL) = FA(NJL)-VAL2*DAlpha(NIK)                                 
        FB(NJL) = FB(NJL)-VAL2*DBeta(NIK)                                 
       END DO
      ELSE    
       READ(1)NXInteg,IBUF,BUF
       IF(NXInteg==0)GO TO 2                                               
       NINTEG = IABS(NXInteg)                                                
       IF(NINTEG>NINTMX)CALL ABRT 
!       
       DO M = 1,NINTEG                                                 
        LABEL = IBUF(M)
        CALL LABELIJKL(LABEL,I,J,K,L)                                                                                     
        VAL = BUF(M)                                                
        NIJ = (I*I-I)/2+J                                                  
        NKL = (K*K-K)/2+L                                                  
        NIK = (I*I-I)/2+K                                                  
        NIL = (I*I-I)/2+L                                                  
        IF(J<K) GO TO 31                                           
        NJK = (J*J-J)/2+K                                                  
        NJL = (J*J-J)/2+L                                                  
        GO TO 41                                                      
   31   NJK = (K*K-K)/2+J                                                  
        IF(J<L) GO TO 51                                           
        NJL = (J*J-J)/2+L                                                  
        GO TO 41                                                      
   51   NJL = (L*L-L)/2+J                                                  
   41   CONTINUE                                                       
        VAL2 = VAL+VAL                                                 
        VAL4 = VAL2+VAL2                                               
        DUM = VAL4*(DAlpha(NKL)+DBeta(NKL))                                   
        FA(NIJ) = FA(NIJ)+DUM                                          
        FB(NIJ) = FB(NIJ)+DUM                                          
        DUM = VAL4*(DAlpha(NIJ)+DBeta(NIJ))                                   
        FA(NKL) = FA(NKL)+DUM                                          
        FB(NKL) = FB(NKL)+DUM                                          
        FA(NIK) = FA(NIK)-VAL2*DAlpha(NJL)                                 
        FB(NIK) = FB(NIK)-VAL2*DBeta(NJL)                                 
        FA(NIL) = FA(NIL)-VAL2*DAlpha(NJK)                                 
        FB(NIL) = FB(NIL)-VAL2*DBeta(NJK)                                 
        FA(NJK) = FA(NJK)-VAL2*DAlpha(NIL)                                 
        FB(NJK) = FB(NJK)-VAL2*DBeta(NIL)                                 
        FA(NJL) = FA(NJL)-VAL2*DAlpha(NIK)                                 
        FB(NJL) = FB(NJL)-VAL2*DBeta(NIK)                                 
       END DO
      END IF       
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
      IF(NXInteg>0)GO TO 1
    2 CONTINUE                                                                
!----------------------------------------------------------------------- 
      IF(IDONTW==0)THEN
       REWIND(1)
       DEALLOCATE(IBUF,BUF)
      END IF
!
      CALL DSCAL(NBFT,0.5d0,FA,1)                                          
      CALL DSCAL(NBFT,0.5d0,FB,1)                                          
      II = 0                                                            
      DO I=1,NBF                                                 
       II = II + I                                                    
       FA(II) = FA(II)+FA(II)                                         
       FB(II) = FB(II)+FB(II)                                         
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END
                                                               
! ROFOCK                                           
      SUBROUTINE ROFOCK(FA,FB,FMO,V,WRK,S,WRK1,NA,NB,L0,L1,L2,L3)  
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)            
      DIMENSION FA(L2),FB(L2),FMO(L2),V(L3),WRK(L1),S(L2),WRK1(L3)         
      LOGICAL JA,JB,JC,JO,JV,IA,IB,IC,IO,IV
!-----------------------------------------------------------------------
!              FORM THE ROHF FOCK MATRIX IN MO BASIS
!-----------------------------------------------------------------------
!                                                                       
!     FA AND FB ARE ALPHA AND BETA FOCK MATRICES IN AO BASIS. 
!     V IS THE CURRENT MO VECTORS. S IS OVERLAP MATRIX.
!     FMO IS THE COMBINED FOCK OPERATOR IN THE MO BASIS.
!                                                                       
!     GUEST AND SAUNDERS FMO (MolPhys 28, 819, 1974) :
!
!                 CLOSED         OPEN         VIRTUAL                   
!                                                                       
!     CLOSED    (FA + FB)/2 |     FB      | (FA + FB)/2                 
!               ---------------------------------------                 
!     OPEN          FB      | (FA + FB)/2 |     FA                      
!               ---------------------------------------                 
!     VIRTUAL   (FA + FB)/2 |     FA      | (FA + FB)/2                  
!
!-----------------------------------------------------------------------
!     Transform Fock Matrices to MO basis 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL TFTRI(FMO,FA,V,WRK,L0,L1,L1)   ! FMO=V*FA*V                              
      CALL DCOPY(L2,FMO,1,FA,1)           ! FMO -> FA                              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NB/=0)THEN
       CALL TFTRI(FMO,FB,V,WRK,L0,L1,L1)  ! FMO=V*FB*V
       CALL DCOPY(L2,FMO,1,FB,1)          ! FMO -> FB                              
       IJ = 0                                                            
       DO J = 1,L0                                                   
        JA = J<=NA                                                   
        JB = J<=NB                                                   
        JC = JA.and.JB                                                 
        JV = .not.JA.and..not.JB                                       
        JO = .not.JC.and..not.JV                                       
        DO I = 1,J                                                 
         IJ = IJ + 1                                                 
         IA = I<=NA                                                
         IB = I<=NB                                                
         IC = IA.and.IB                                              
         IV = .not.IA.and..not.IB                                    
         IO = .not.IC.and..not.IV                                    
         FMO(IJ) = 0.0d0                                                  
         IF(IC.and.JC) FMO(IJ) = (FA(IJ)+FB(IJ))/2.0d0               
         IF(IC.and.JO) FMO(IJ) = FB(IJ)                                  
         IF(IC.and.JV) FMO(IJ) = (FA(IJ)+FB(IJ))/2.0d0
         IF(IO.and.JO) FMO(IJ) = (FA(IJ)+FB(IJ))/2.0d0                 
         IF(IO.and.JV) FMO(IJ) = FA(IJ)                                  
         IF(IV.and.JV) FMO(IJ) = (FA(IJ)+FB(IJ))/2.0d0                 
        END DO
       END DO
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Back-transform to AO Basis FA = SV * FMO * (SV)+             
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     
      CALL TFTRIB(FA,FMO,S,V,WRK1,WRK,L0,L1,L2,L3)   ! Output: FA                      
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! SPIN                                             
      SUBROUTINE SPIN(SZ,S2,DAlpha,DBeta,S,D,T,NA,NB,L1,L2)                 
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION DAlpha(L2),DBeta(L2),S(L2),D(L2),T(L1)                  
!-----------------------------------------------------------------------
!     Spin Expectation Values
!-----------------------------------------------------------------------
      IJ=0                                                              
      DO J=1,L1                                                     
       DO I=1,L1                                                  
        DUM = 0.0d0                                                  
        DO K = 1,L1                                             
         IK = (I*I-I)/2+K                                             
         IF(K>I) IK=(K*K-K)/2+I                                    
         JK = (J*J-J)/2+K                                             
         IF(K>J) JK = (K*K-K)/2+J                                  
         DUM = DUM+DAlpha(IK)*S(JK)                                   
        END DO
        T(I) = DUM                                                  
       END DO
       DO I = 1,J                                                 
        DUM = 0.0d0                                                  
        DO K = 1,L1                                             
         IK = (I*I-I)/2+K                                             
         IF(K>I) IK=(K*K-K)/2 + I                                  
         DUM = DUM+S(IK)*T(K)                                     
        END DO
        IJ = IJ+1                                                   
        D(IJ) = DUM                                                 
       END DO
      END DO
!                                                                       
      SZ = (NA-NB)/2.0d0
      S2 = SZ*SZ + (NA+NB)/2.0d0  -  TRACEP(DBeta,D,L1)                     
!-----------------------------------------------------------------------      
      RETURN                                                            
      END                                                               

! TFTRIB                                           
      SUBROUTINE TFTRIB(FAO,FMO,S,V,SV,WRK,L0,L1,L2,L3)                 
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION FAO(L2),FMO(L2),S(L2),V(L3),SV(L3),WRK(L1)              
!-----------------------------------------------------------------------
!     Transform from MO basis to AO basis: FAO = SV * FMO * (SV)t                                
!-----------------------------------------------------------------------
      CALL MTARBR(S,L1,V,L0,SV,L1,1)        ! SV  = S*V                            
      CALL TRPOSQ(SV,L1)                    ! SV  = (SV)t                                              
      CALL TFTRI(FAO,FMO,SV,WRK,L1,L0,L1)   ! FAO = SV*FMO*(SV)t                           
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! MTARBR                                           
      SUBROUTINE MTARBR(A,NA,B,MB,AB,NAB,INCA)                          
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(*),B(NA,MB),AB(NAB,MB)                                
!-----------------------------------------------------------------------
!     MULTIPLY SYMMETRIC MATRIX A TIMES RECTANGULAR MATRIX B                          
!     AND GET RECTANGULAR MATRIX AB   ( AB = A * B )
!-----------------------------------------------------------------------
      INC=INCA                                                          
!     PROCESS DIAGONAL ELEMENTS OF INPUT MATRIX A                    
      IJ=1-INC                                                          
      DO I=1,NA                                                     
       IJ=IJ+I*INC                                                    
       AIJ=A(IJ)                                                      
       DO K=1,MB                                                  
        AB(I,K)=AIJ*B(I,K)                                          
       END DO
      END DO
      IF(NA==1)RETURN                                                
!     PROCESS OFF-DIAGONAL ELEMENTS OF INPUT MATRIX A                
      IJ=1-INC                                                          
      DO I=2,NA                                                     
       IJ=IJ+INC                                                      
       IM1=I-1                                                        
       DO J=1,IM1                                                 
        IJ=IJ+INC                                                   
        AIJ=A(IJ)                                                   
        IF(AIJ/=0.0d0)THEN
         CALL DAXPY(MB,AIJ,B(I,1),NA,AB(J,1),NAB)                 
         CALL DAXPY(MB,AIJ,B(J,1),NA,AB(I,1),NAB)                 
        END IF
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! TRPOSQ                                           
      SUBROUTINE TRPOSQ(A,N)                                            
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(N,N)
!-----------------------------------------------------------------------
!     TRANSPOSE SQUARE MATRIX IN PLACE                                  
!-----------------------------------------------------------------------
      DO J = 2,N                                                    
       JMO = J - 1                                                    
       DO I = 1,JMO                                               
        TMP = A(I,J)                                                
        A(I,J) = A(J,I)                                             
        A(J,I) = TMP
       END DO
      END DO                                                
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !                                                         
!                       D I I S Interpolation                          !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !                                                 

! DIISER                                           
      SUBROUTINE DIISER(F,D,S,ERR,WRK,L1,L2)                
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION F(L1,L1),D(L2),S(L1,L1),ERR(L1,L1),WRK(L1)              
!-----------------------------------------------------------------------    
!     ERR = FDS - SDF
!-----------------------------------------------------------------------    
      DO I = 1,L1,5                                            
       IIMAX = MIN(L1,I+4)                                     
       DO II=I,IIMAX                                              
        KL = 0                                                      
        DO L = 1,L1                                             
         LM1 = L-1                                                
         DUM = 0.0d0                                               
         FDUM = F(L,II)                                           
         IF(LM1>0) THEN                                       
          DO K = 1,LM1                                      
           KL = KL+1                                          
           WRK(K) = WRK(K)+D(KL)*FDUM                         
           DUM = DUM+D(KL)*F(K,II)                            
          END DO                                                         
         END IF                                                   
         KL = KL+1                                                
         WRK(L) = DUM+D(KL)*FDUM                                  
        END DO                                                         
        DO J = 1,L1                                          
         DUM = DDOT(L1,WRK,1,S(1,J),1)                         
         IF(ABS(DUM)<1.0D-15)DUM=0.0d0                      
         ERR(II,J) = DUM                                       
        END DO                                                         
       END DO                                                         
      END DO                                                         
!     Substracting (F*D*S)t from itself
      DO J=1,L1                                                    
       DO I=1,J-1                                                 
        DIFF = ERR(I,J)-ERR(J,I)                                      
        ERR(I,J) =  DIFF                                               
        ERR(J,I) = -DIFF                                               
       END DO
       ERR(J,J) = 0.0d0                                                    
      END DO
!-----------------------------------------------------------------------    
      RETURN                                                            
      END 
      
! DIISInter                                             
      SUBROUTINE DIISInter(ITDIIS,Q,FCKA,ERR,WRK,A,X,IPVT,B,IODIIS,SCR, &
                           L1,L2,L3,MAXITRHF,MAXIT2,MAXIO,ERDIIS,NOTOPN)                       
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      COMMON/DIISSO/ETHRSH,MAXDII,IRAF      
      DIMENSION Q(L3),FCKA(L2),ERR(L3),WRK(L3),IODIIS(MAXIO),           &
                X(MAXITRHF),IPVT(MAXITRHF),B(MAXIT2),SCR(L1)
      LOGICAL NOTOPN
      DIMENSION A(MAXDII,MAXDII)                        
!-----------------------------------------------------------------------
!             Direct Inversion in the Iterative Procedure
!     PULAY, JCC 3, 556 (1982); CPL 73, 393 (1980), JCP 84, 5728 (1986)     
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     DIIS DATA IS SAVED ON DIRECT FILE -IRAF- IN CYCLIC ORDER,         
!                 1,2,3,...,MAXDII = LAST MAXDII ERROR MATRICES         
!        MAXDII + 1,2,3,...,MAXDII = LAST MAXDII ERROR MATRICES (BETA)  
!      2*MAXDII + 1,2,3,...,MAXDII = LAST MAXDII ALPHA FOCK MATRICES    
!      3*MAXDII + 1,2,3,...,MAXDII = LAST MAXDII BETA  FOCK MATRICES    
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      LRAFEA = 0                                                         
      LRAFEB = MAXDII                                                    
      LRAFFA = MAXDII*2                                                  
      LRAFFB = MAXDII*3                                                  
!                                                                       
!     ----- IF WE ARE ON THE LAST SCF CYCLE, SHUT DIIS DOWN -----       
!                                                                       
      IF(ITDIIS>=MAXITRHF)THEN                                          
       IF(.not.NOTOPN)CLOSE(UNIT=IRAF,STATUS='DELETE')
       NOTOPN = .TRUE.                                                
       RETURN                                                         
      END IF                                                            
!                                                                       
      IF(NOTOPN) THEN                                                   
       NOTOPN = .FALSE.                                               
       IRAF   = 20                                                    
       NDAF20 = MAXIO                                                 
       LEN20  = L3                                                    
       CALL RAOPEN(IRAF,IODIIS,0,NDAF20,LEN20)                     
      END IF                                                            
!                                                                       
!     ----- PUT ERROR MATRIX INTO CONSISTENT O.N.B. -----               
!     PULAY USES S**-1/2, BUT HERE WE USE Q, Q OBEYS Q-DAGGER*S*Q=I     
!     E-ORTH = Q-DAGGER * E * Q, FCKA IS USED AS A SCRATCH -L1- VECTOR  
!                                                                       
      CALL DCOPY(L3,ERR,1,WRK,1)                                        
      CALL TFSQU(ERR,WRK,Q,SCR,L1,L1)                                   
!                                                                       
!     ----- START DIIS PROCEDURE IF ERDIIS < ETHRSH -----               
!                                                                       
      IMAX   = IDAMAX(L3,ERR,1)                                         
      ERDIIS = ABS(ERR(IMAX))                                           
      IF(ERDIIS>ETHRSH  .and.  ITDIIS==1) RETURN                   
!                                                                       
!     ----- SAVE THE CURRENT FOCK MATRIX -----                          
!                                                                       
      LFCKA = LRAFFA + MOD(ITDIIS-1,MAXDII) + 1                         
      LFCKB = LRAFFB + MOD(ITDIIS-1,MAXDII) + 1                         
      CALL RAWRIT(IRAF,IODIIS,FCKA,L2,LFCKA,0)                          
!                                                                       
!     ----- SAVE THE CURRENT ERROR MATRIX -----                         
!                                                                       
      LERR = LRAFEA + MOD(ITDIIS-1,MAXDII) + 1                          
      CALL RAWRIT(IRAF,IODIIS,ERR,L3,LERR,0)                            
      ITDIIS = ITDIIS+1                                                 
!                                                                       
!        FORM LAST ROW (ROW ITDIIS) OF TRIANGULAR MATRIX B,             
!        FIRST DOING THE DIAGONAL AND THE FIRST ELEMENT OF THE ROW.     
!        THE TRANSPOSE IN PULAY'S STEP (2) IS JUST A SIGN CHANGE        
!        BECAUSE ERROR MATRICES ARE ANTISYMMETRIC BY CONSTRUCTION.      
!        THE SIGN IS IGNORED BECAUSE IT DOESN'T AFFECT THE LINEAR       
!        EQUATION'S SOLUTION.                                           
!                                                                       
      BJJ=DDOT(L3,ERR,1,ERR,1)                                          
!                                                                       
      IF(ITDIIS==2) THEN                                              
       CALL VCLR(B,1,MAXIT2)                                          
       B(1)=0.0d0                                                      
       B(2)=-1.0d0                                                      
       B(3)= BJJ                                                      
       RETURN                                                         
      ELSE                                                              
       J1   = (ITDIIS*ITDIIS-ITDIIS)/2 + 1                            
       JJ   = (ITDIIS*ITDIIS+ITDIIS)/2                                
       B(J1)= -1.0d0                                                    
       B(JJ)= BJJ                                                     
      END IF                                                            
!                                                                       
!        THE REST OF THE BIJ'S.                                         
!        NOTE THAT WE ONLY COMPUTE THE NA-2 VALUES NEXT TO THE          
!        DIAGONAL, SO THAT THE OTHER ELEMENTS (EXCEPT THE FIRST         
!        COLUMN) ARE RANDOM VALUES.                                     
!                                                                       
      NA=MIN(ITDIIS,MAXDII)                                             
      NAM1=NA-1                                                         
      IJ=JJ-NA+1                                                        
      DO IX=2,NAM1                                                  
       LERR = LRAFEA + MOD(ITDIIS-NA+IX-2,MAXDII) + 1                 
       CALL RAREAD(IRAF,IODIIS,WRK,L3,LERR,0)                         
       BIJ=DDOT(L3,ERR,1,WRK,1)                                       
       IJ=IJ+1                                                        
       B(IJ)=BIJ                                                      
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     DIIS Linear Equations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 CONTINUE                                                          
      CALL DIISEQ(A,NA,B,JJ,ITDIIS)                                     
      CALL VCLR(X,1,NA)                                                 
      X(1)=-1.0d0                                                         
      IERR=0                                                            
      CALL SLVLEQ(A,X,IPVT,NA,NA,0,IERR)                                
      IF(IERR/=0)THEN                                                
       NA = NA - 1                                                    
        WRITE(6,*)                                                      &
        'REDUCING DIIS EQUATION SIZE BY 1 FOR NUMERICAL STABILITY'  
       IF(NA/=1)GO TO 1                                       
       WRITE(6,*)'DIIS EQUATIONS ARE SINGULAR, BOMBING'  
       CALL ABRT                                                      
      END IF                                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Interpolated Fock Matrix: Add C(I)*F(I)                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL VCLR(FCKA,1,L2)                                              
      DO IX=2,NA                                                    
       LFCKA = LRAFFA + MOD(ITDIIS-NA+IX-2,MAXDII) + 1                
       CALL RAREAD(IRAF,IODIIS,WRK,L2,LFCKA,0)                        
       CI = X(IX)                                                     
       CALL DAXPY(L2,CI,WRK,1,FCKA,1)                                 
      END DO
!-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END                                                               

! DIISEQ                                           
      SUBROUTINE DIISEQ(A,NA,B,NTT,NB)                                  
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(NA,NA),B(NTT)                                        
!-----------------------------------------------------------------------                                                                       
      NSKP1=NB-NA+1                                                     
      IB=0                                                              
      JA=0                                                              
      DO J=1,NB                                                     
       IA=0                                                           
       DO I=1,J                                                   
        IB=IB+1                                                     
        IF(I==1.or.I>NSKP1) THEN                             
         IF(J==1.or.J>NSKP1) THEN                          
          IA=IA+1                                               
          IF(IA==1) JA=JA+1                                   
          BIB=B(IB)                                             
          A(IA,JA)=BIB                                          
          A(JA,IA)=BIB                                          
         END IF                                                   
        END IF                                                      
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               
            
! TFSQU                                            
      SUBROUTINE TFSQU(H,F,T,WRK,N,M)                                   
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION H(M,M),F(N,N),T(N,M),WRK(N) 
!-----------------------------------------------------------------------               
!     H = T+ * F * T
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I = 1,M,5                                             
       IIMAX = MIN(M,I+4)                                      
       DO II=I,IIMAX                                              
        DO L=1,N                                                
         WRK(L) = DDOT(N,T(1,II),1,F(1,L),1)                      
        END DO
        DO J=1,M                                                
         H(II,J) = DDOT(N,WRK,1,T(1,J),1)                         
        END DO
       END DO
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN                                                            
      END                                                               
      
! SLVLEQ                                           
      SUBROUTINE SLVLEQ(A,X,IPVT,N,LDA,JOB,IERR)                        
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(LDA,N),X(N),IPVT(N)                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Solve Linear equations: A*X=B (JOB=0) or At*X=B (JOB/=0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IERR=0                                                            
      CALL DGEFA(A,LDA,N,IPVT,IERR)                                     
      IF(IERR/=0) RETURN                                              
      CALL DGESL(A,LDA,N,IPVT,X,JOB)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN                                                            
      END                                                               

! DGEFA                                            
      SUBROUTINE DGEFA(A,LDA,N,IPVT,INFO)                               
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(LDA,*),IPVT(*)                                        
!                                                                       
!     DGEFA FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION.  
!                                                                       
!     DGEFA IS USUALLY CALLED BY DGECO, BUT IT CAN BE CALLED            
!     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.          
!     (TIME FOR DGECO) = (1 + 9/N)*(TIME FOR DGEFA) .                   
!                                                                       
!     ON ENTRY                                                          
!                                                                       
!        A       DOUBLE PRECISION(LDA, N)                               
!                THE MATRIX TO BE FACTORED.                             
!                                                                       
!        LDA     INTEGER                                                
!                THE LEADING DIMENSION OF THE ARRAY  A .                
!                                                                       
!        N       INTEGER                                                
!                THE ORDER OF THE MATRIX  A .                           
!                                                                       
!     ON RETURN                                                         
!                                                                       
!        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS         
!                WHICH WERE USED TO OBTAIN IT.                          
!                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE       
!                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER          
!                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.       
!                                                                       
!        IPVT    INTEGER(N)                                             
!                AN INTEGER VECTOR OF PIVOT INDICES.                    
!                                                                       
!        INFO    INTEGER                                                
!                = 0  NORMAL VALUE.                                     
!                = K  IF  U(K,K) == 0.0 .  THIS IS NOT AN ERROR       
!                     CONDITION FOR THIS ROUTINE, BUT IT DOES           
!                     INDICATE THAT DGESL OR DGEDI WILL DIVIDE BY ZERO  
!                     IF CALLED.  USE  RCOND  IN DGECO FOR A RELIABLE   
!                     INDICATION OF SINGULARITY.                        
!                                                                       
!     LINPACK. THIS VERSION DATED 08/14/78 .                            
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.      
!                                                                       
!     ROUTINES AND FUNCTIONS                                            
!                                                                       
!     BLAS DAXPY,DSCAL,IDAMAX                                           
!                                                                       
!     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING                        
!                                                                       
      INFO = 0                                                          
      NM1 = N - 1                                                       
      IF (NM1 < 1) GO TO 70                                          
      DO 60 K = 1, NM1                                                  
         KP1 = K + 1                                                    
!                                                                       
!        FIND L = PIVOT INDEX                                           
!                                                                       
         L = IDAMAX(N-K+1,A(K,K),1) + K - 1                             
         IPVT(K) = L                                                    
!                                                                       
!        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED          
!                                                                       
         IF (A(L,K) == 0.0D+00) GO TO 40                              
!                                                                       
!           INTERCHANGE IF NECESSARY                                    
!                                                                       
            IF (L == K) GO TO 10                                      
               T = A(L,K)                                               
               A(L,K) = A(K,K)                                          
               A(K,K) = T                                               
   10       CONTINUE                                                    
!                                                                       
!           COMPUTE MULTIPLIERS                                         
!                                                                       
            T = -1.0D+00/A(K,K)                                         
            CALL DSCAL(N-K,T,A(K+1,K),1)                                
!                                                                       
!           ROW ELIMINATION WITH COLUMN INDEXING                        
!                                                                       
            DO 30 J = KP1, N                                            
               T = A(L,J)                                               
               IF (L == K) GO TO 20                                   
                  A(L,J) = A(K,J)                                       
                  A(K,J) = T                                            
   20          CONTINUE                                                 
               CALL DAXPY(N-K,T,A(K+1,K),1,A(K+1,J),1)                  
   30       CONTINUE                                                    
         GO TO 50                                                       
   40    CONTINUE                                                       
            INFO = K                                                    
   50    CONTINUE                                                       
   60 CONTINUE                                                          
   70 CONTINUE                                                          
      IPVT(N) = N                                                       
      IF (A(N,N) == 0.0D+00) INFO = N                                 
      RETURN                                                            
      END                                                               

! DGESL                                            
      SUBROUTINE DGESL(A,LDA,N,IPVT,B,JOB)                              
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(LDA,N),B(N),IPVT(N)                                   
!                                                                       
!     DGESL SOLVES THE DOUBLE PRECISION SYSTEM                          
!     A * X = B  OR  TRANS(A) * X = B                                   
!     USING THE FACTORS COMPUTED BY DGECO OR DGEFA.                     
!                                                                       
!     ON ENTRY                                                          
!                                                                       
!        A       DOUBLE PRECISION(LDA, N)                               
!                THE OUTPUT FROM DGECO OR DGEFA.                        
!                                                                       
!        LDA     INTEGER                                                
!                THE LEADING DIMENSION OF THE ARRAY  A .                
!                                                                       
!        N       INTEGER                                                
!                THE ORDER OF THE MATRIX  A .                           
!                                                                       
!        IPVT    INTEGER(N)                                             
!                THE PIVOT VECTOR FROM DGECO OR DGEFA.                  
!                                                                       
!        B       DOUBLE PRECISION(N)                                    
!                THE RIGHT HAND SIDE VECTOR.                            
!                                                                       
!        JOB     INTEGER                                                
!                = 0         TO SOLVE  A*X = B ,                        
!                = NONZERO   TO SOLVE  TRANS(A)*X = B  WHERE            
!                            TRANS(A)  IS THE TRANSPOSE.                
!                                                                       
!     ON RETURN                                                         
!                                                                       
!        B       THE SOLUTION VECTOR  X .                               
!                                                                       
!     ERROR CONDITION                                                   
!                                                                       
!        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A   
!        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY  
!        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER       
!        SETTING OF LDA .  IT WILL NOT OCCUR IF THE ROUTINES ARE        
!        CALLED CORRECTLY AND IF DGECO HAS SET RCOND > 0.0           
!        OR DGEFA HAS SET INFO == 0 .                                 
!                                                                       
!     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX                 
!     WITH  P  COLUMNS                                                  
!           CALL DGECO(A,LDA,N,IPVT,RCOND,Z)                            
!           IF (RCOND IS TOO SMALL) GO TO ...                           
!           DO 10 J = 1, P                                              
!              CALL DGESL(A,LDA,N,IPVT,C(1,J),0)                        
!        10 CONTINUE                                                    
!                                                                       
!     LINPACK. THIS VERSION DATED 08/14/78 .                            
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.      
!                                                                       
!     ROUTINES AND FUNCTIONS                                            
!                                                                       
!     BLAS DAXPY,DDOT                                                   
!                                                                       
      NM1 = N - 1                                                       
      IF (JOB /= 0) GO TO 50                                          
!                                                                       
!        JOB = 0 , SOLVE  A * X = B                                     
!        FIRST SOLVE  L*Y = B                                           
!                                                                       
         IF (NM1 < 1) GO TO 30                                       
         DO 20 K = 1, NM1                                               
            L = IPVT(K)                                                 
            T = B(L)                                                    
            IF (L == K) GO TO 10                                      
               B(L) = B(K)                                              
               B(K) = T                                                 
   10       CONTINUE                                                    
            CALL DAXPY(N-K,T,A(K+1,K),1,B(K+1),1)                       
   20    CONTINUE                                                       
   30    CONTINUE                                                       
!                                                                       
!        NOW SOLVE  U*X = Y                                             
!                                                                       
         DO 40 KB = 1, N                                                
            K = N + 1 - KB                                              
            B(K) = B(K)/A(K,K)                                          
            T = -B(K)                                                   
            CALL DAXPY(K-1,T,A(1,K),1,B(1),1)                           
   40    CONTINUE                                                       
      GO TO 100                                                         
   50 CONTINUE                                                          
!                                                                       
!        JOB = NONZERO, SOLVE  TRANS(A) * X = B                         
!        FIRST SOLVE  TRANS(U)*Y = B                                    
!                                                                       
         DO 60 K = 1, N                                                 
            T = DDOT(K-1,A(1,K),1,B(1),1)                               
            B(K) = (B(K) - T)/A(K,K)                                    
   60    CONTINUE                                                       
!                                                                       
!        NOW SOLVE TRANS(L)*X = Y                                       
!                                                                       
         IF (NM1 < 1) GO TO 90                                       
         DO 80 KB = 1, NM1                                              
            K = N - KB                                                  
            B(K) = B(K) + DDOT(N-K,A(K+1,K),1,B(K+1),1)                 
            L = IPVT(K)                                                 
            IF (L == K) GO TO 70                                      
               T = B(L)                                                 
               B(L) = B(K)                                              
               B(K) = T                                                 
   70       CONTINUE                                                    
   80    CONTINUE                                                       
   90    CONTINUE                                                       
  100 CONTINUE                                                          
      RETURN                                                            
      END                                                               

! RAOPEN                                           
      SUBROUTINE RAOPEN(IRAFX,IORA,LPHYS,NUMREC,LENREC) 
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                      
      COMMON/DAIOLN/IRECLN
      COMMON/RAIOLN/JRECLN(10),JRECST(10)
      DIMENSION IORA(NUMREC)                                            
!-----------------------------------------------------------------------
!     Record Length
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                     
      IRECLN = 2048                                                 
      IF(LPHYS/=0.AND.LENREC<IRECLN)IRECLN=LENREC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -             
!     Physical Records Needed
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      JRECST(IRAFX/10) = 1                                                 
      JRECLN(IRAFX/10) = IRECLN                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Open File in UNIT=IRAFX
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      OPEN(UNIT=IRAFX,STATUS='UNKNOWN',ACCESS='DIRECT',                 &
           FORM='UNFORMATTED',RECL=8*IRECLN)                                              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I = 1,NUMREC                                               
       IORA(I) = -1                                                   
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN                                                            
      END                                                               
            
! RAREAD                                           
      SUBROUTINE RAREAD(IRAFX,IORA,V,LEN,NRECORD,NAVX)                       
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                      
      COMMON/DAIOLN/IRECLN
      COMMON/RAIOLN/JRECLN(10),JRECST(10)      
      DIMENSION V(*),IORA(*)                                            
!     Read a logical record from IRAFX
      IF(IRAFX<0)WRITE(6,*) 'BOGUS RAREAD, NAV=',NAVX                 
      IRECLN = JRECLN(IRAFX/10)                                            
      N = IORA(NRECORD)                                                    
      IS = -IRECLN + 1                                                  
      NS = N                                                            
      LENT = LEN                                                        
    1 CONTINUE                                                          
      IS = IS + IRECLN                                               
      IF = IS + LENT - 1                                             
      IF ((IF-IS+1) > IRECLN) IF = IS + IRECLN - 1                
      NSP = NS                                                       
      LENW = IF - IS + 1                                             
      CALL RARD(V(IS),LENW,IRAFX,NSP)                                 
      LENT = LENT - IRECLN                                           
      NS = NS + 1                                                    
      N = NS                                                         
      IF(LENT>=1)GO TO 1                                        
      RETURN                                                            
      END                                                               

! RARD                                             
      SUBROUTINE RARD(V,LEN,IRAF,NS)                                    
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION V(LEN)                                                  
      READ(UNIT=IRAF,REC=NS) V                 
      RETURN                                                            
      END                                                               

! RAWRIT                                           
      SUBROUTINE RAWRIT(IRAFX,IORA,V,LEN,NRECORD,NAVM)                      
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                      
      COMMON/DAIOLN/IRECLN
      COMMON/RAIOLN/JRECLN(10),JRECST(10)      
      DIMENSION V(*),IORA(*)                                            
!     Write a logical record on IRAFX
      IF(IRAFX<0) WRITE(6,*) 'BOGUS RAWRIT, NAVM=',NAVM               
      IRECST=JRECST(IRAFX/10)                                            
      IRECLN=JRECLN(IRAFX/10)                                            
      N = IORA(NRECORD)                                                    
      IF(N<=0) THEN                                                   
       IORA(NRECORD) = IRECST                                            
       IRECST = IRECST + (LEN-1)/IRECLN + 1                           
       N = IORA(NRECORD)                                                 
      END IF                                                            
      JRECST(IRAFX/10)=IRECST                                            
      IST = -IRECLN + 1                                                 
      NS = N                                                            
      LENT = LEN                                                        
    1 CONTINUE                                                          
         IST = IST + IRECLN                                             
         IF = IST + LENT - 1                                            
         IF ((IF-IST+1) > IRECLN) IF = IST+IRECLN-1                  
         NSP = NS                                                       
         LENW = IF - IST + 1                                            
         CALL RAWRT(V(IST),LENW,IRAFX,NSP)                               
         LENT = LENT - IRECLN                                           
         NS = NS + 1                                                    
         N = NS                                                         
      IF (LENT >= 1) GO TO 1                                        
      RETURN                                                            
      END                                                               

! RAWRT                                            
      SUBROUTINE RAWRT(V,LEN,IRAF,NS)                                   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION V(LEN)                                                  
      WRITE(UNIT=IRAF,REC=NS) V                                       
      RETURN                                                            
      END                                                               

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ! 
!                       Damping and Extrapolation                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ! 
      
! DAMPD                                            
      SUBROUTINE DAMPD(DE,DEP,DEAVG,DAMP,ACURCY,DIFF,DIFFP,DMPTLC)      
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      PARAMETER (FAC=16.0D0)              
!-----------------------------------------------------------------------
      DAMPO = DAMP                                                      
      ETEST = ACURCY*ACURCY                                             
      IF(ABS(DE) < ETEST .and. ABS(DEP) < ETEST) GO TO 300       
      IF(ABS(DE) < ETEST) GO TO 320                                 
      IF(ABS(DEP) < ETEST) GO TO 340                                
      IF((DIFFP-DIFF) < 0.0d0) GO TO 100                             
      IF( ABS(DE) >= ACURCY .or. DE > 0.0d0) GO TO 100             
!                                                                       
      DAMP = DAMP/FAC                                                   
      GO TO 280                                                         
!                                                                       
  100 CONTINUE                                                          
      IF ( DE > 0.0d0) GO TO 200                                      
      IF (DEP > 0.0d0) GO TO 180                                      
      IF ( DE > DEP) GO TO 140                                       
!                                                                       
!     ----- DE < 0. , DEP < 0. , DE < DEP -----                         
!                                                                       
      IF ( ABS(DE) < 2.0d0*DEAVG) GO TO 120                            
      DAMP = FAC*MAX(DAMP,DEAVG)                                        
      GO TO 280                                                         
!                                                                       
  120 IF ( ABS(DE) > 0.5d0*DEAVG) GO TO 280                            
      DAMP = DAMP/FAC                                                   
      GO TO 280                                                         
!                                                                       
  140 CONTINUE                                                          
!                                                                       
!     ----- DE < 0. , DEP < 0. , DE > DEP -----                         
!                                                                       
      IF (DE > 0.25d0*DEP) GO TO 160                                   
      DAMP = (DE/DEP)**2*MAX(DAMP,DEAVG)                                
      GO TO 280                                                         
!                                                                       
  160 DAMP = DAMP/FAC                                                   
      GO TO 280                                                         
!                                                                       
  180 CONTINUE                                                          
!                                                                       
!     ----- DE < 0. , DEP > 0. -----                                    
!                                                                       
      DAMP = 4.0d0*MAX(DAMP,DEAVG)                                       
      IF (-DE > DEAVG) DAMP = DAMP*FAC                               
      IF (-DE+DEP >= DEAVG) GO TO 280                                 
      DAMP = DAMP/FAC                                                   
      GO TO 280                                                         
!                                                                       
  200 CONTINUE                                                          
      IF (DEP > 0.0d0) GO TO 220                                      
!                                                                       
!     ----- DE > 0. , DEP < 0. -----                                    
!                                                                       
      DAMP = 4.0d0*MAX(DAMP,DEAVG)                                       
      IF (DE > 0.5d0*DEAVG) DAMP = DAMP*FAC                            
      IF (DE-DEP >= 0.2d0*DEAVG) GO TO 280                              
      DAMP = DAMP/FAC                                                   
      GO TO 280                                                         
!                                                                       
  220 CONTINUE                                                          
!                                                                       
!     ----- DE > 0. , DEP > 0. -----                                    
!                                                                       
      DAMP = 4.0d0*MAX(DAMP,DEAVG)                                       
      IF (DE < 4.0d0*DEP) GO TO 240                                   
      DAMP = FAC*MAX(DAMP,DEAVG)                                        
      GO TO 280                                                         
!                                                                       
  240 IF (DE > 0.25d0*DEP) GO TO 260                                   
      DAMP = DAMP/FAC                                                   
      GO TO 280                                                         
!                                                                       
  260 DAMP = (DE/DEP)**2*MAX(DAMP,DEAVG)                                
  280 CONTINUE                                                          
!                                                                       
!     ----- IF THE DENSITY CONVERGENCE WORSENED - MAKE SURE             
!           THAT THE DAMPING CAN'T DECREASE -----                       
!                                                                       
      IF ((DIFFP-DIFF) < 0.0d0) DAMP = MAX(DAMP,DAMPO)                
      GO TO 360                                                         
!                                                                       
  300 CONTINUE                                                          
!                                                                       
!        DE < ETEST AND DEP < ETEST                                     
      DAMP = DAMP/FAC                                                   
      GO TO 360                                                         
!                                                                       
  320 CONTINUE                                                          
!        DE < ETEST  DEP > ETEST                                        
      DAMP = DAMP/FAC                                                   
      GO TO 360                                                         
!                                                                       
  340 CONTINUE                                                          
!        DEP < ETEST  DE > ETEST                                        
      DAMP = DAMPO                                                      
      IF (DE > 0.0d0) DAMP = MAX(2.0d0*DAMP,DMPTLC)                     
!                                                                       
  360 CONTINUE 
!-----------------------------------------------------------------------                                                         
      RETURN                                                            
      END                                                               

! EXTRAPOL                                           
      SUBROUTINE EXTRAPOL(DE,DAMP,DAMP0,FA0,FA1,FA2,FA3,FAO0,FAO1,      &
                          FAO2,NBF,NBFT,ITERV,NCALL,ITYP)                                     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HFDAMP,HFEXTRAP,HFDIIS
      COMMON/INPNOF_HFCONVTECH/HFDAMP,HFEXTRAP,HFDIIS
      COMMON/ACONV /RRSHFT,EXTTOL,DMPTOL,VSHTOL,IEXTIN                
      COMMON/CONV  /ACURCY,EN,Etot,EHF,EHF0,DIFF,ITER,ICALP,ICBET 
!
      DIMENSION FA0(NBFT),FA1(NBFT),FA2(NBFT),FA3(NBFT)
      DIMENSION FAO0(NBFT),FAO1(NBFT),FAO2(NBFT)
      LOGICAL EXTPRE,DAMPRE                         
      SAVE DAMPRE,EXTPRE                                                
      DATA DAMPRE,EXTPRE/.FALSE.,.FALSE./                               
!-----------------------------------------------------------------------
      ICOUNT = ICALP                                                    
      IF(NCALL==2)ICOUNT = ICBET                                  
      IF(ITER>1)GO TO 140                                        
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ITER = 1                                              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I = 1,NBFT                                                   
       FA1(I) = FA0(I)                                                     
       FA2(I) = FA0(I)                                                     
      END DO
      GO TO 660                                                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Previous Fock Matrices FAO0, FAO1, FAO2 -> FA1, FA2, FA3
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  140 CONTINUE
      FA1 = FAO0
      FA2 = FAO1
      FA3 = FAO2
      IF(ITER>2)GO TO 160                                        
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ITER = 2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF (HFDAMP) GO TO 320                                              
      GO TO 420                                      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ITER > 2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  160 IF (DAMPRE) GO TO 200                                             
      IF ( .not. HFDAMP) GO TO 420                                       
      IF (ABS(DE) > EXTTOL) GO TO 180                                
      IF (DE > 0.0d0 .and. ICOUNT > IEXTIN) GO TO 180              
      GO TO 420                                                         
!                                                                       
  180 DMPTOL = DMPTOL/100.0d0                                            
      EXTTOL = EXTTOL/100.0d0                                            
      GO TO 300                                                         
!                                                                       
  200 IF (ABS(DE) > DMPTOL) GO TO 300                                
      IF (DE > 0.0d0) GO TO 300                                       
      IF (DAMP > 0.01d0) GO TO 300                                   
      GO TO 420                                                         
!                                                                       
      IF ( .not. EXTPRE) GO TO 260                                      
      IF (ABS(DE) > EXTTOL) GO TO 240                                
      IF (DE > 0.0d0 .and. ICOUNT > IEXTIN) GO TO 240              
      GO TO 420                                                         
!                                                                       
  240 EXTTOL = EXTTOL/100.0d0                                            
      DMPTOL = DMPTOL/100.0d0                                            
      RRSHFT = 0.8d0                                                    
      ITERV = 0                                                         
      IF (HFDAMP) GO TO 300                                              
      GO TO 620                                                         
!                                                                       
  260 IF (ABS(DE) > DMPTOL) GO TO 280                                
      IF (DE > 0.0d0) GO TO 280                                       
      IF (HFDAMP .and. DAMP > 0.01d0) GO TO 280                       
      IF ( .not. HFEXTRAP) GO TO 280                                      
      IF (RRSHFT >= VSHTOL) GO TO 280                                 
      IF (ITERV == 0) GO TO 280                                       
      GO TO 420                                                         
!                                                                       
  280 IF (HFDAMP) GO TO 300                                              
      IF (ITERV < 2) GO TO 620                                       
      IF ( .not. HFEXTRAP) GO TO 620                                      
      GO TO 440                                                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Davidson's Damping
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  300 IF (ICOUNT < IEXTIN) GO TO 320                                 
      GO TO 360                    
!                                                                       
  320 DO I = 1,NBFT                                                   
       FA0(I) = (FA0(I)+DAMP*FA1(I))/(1.0d0+DAMP)                             
      END DO
      GO TO 400                                                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ITER > 2: Damping
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  360 CUTOFF = 0.5d0-DAMP0                                                
      DO I = 1,NBFT                                                   
       FA0(I) = (FA0(I)+DAMP*FA1(I))/(1.0d0+DAMP)                             
      END DO
      IF ( .not. HFEXTRAP .or. CUTOFF < 0.0d0) GO TO 400                
      DAMPRE = .TRUE.                                                   
      EXTPRE = .TRUE.                                                   
      GO TO 460                                                         
!                                                                       
  400 IF (NCALL /= 1) GO TO 660                                       
      DAMPRE = .TRUE.                                                   
      EXTPRE = .FALSE.                                                  
      GO TO 660                                                         
!                                                                       
  420 IF ( .not. HFEXTRAP) GO TO 620                                      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Pople's Extrapolation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF (NCALL /= 1) GO TO 460                                       
      DAMPRE = .FALSE.                                                  
      EXTPRE = .TRUE.                                                   
  440 DAMP = 0.0d0                                                       
  460 CONTINUE
      FAO0 = FA0
      FAO1 = FA1
      FAO2 = FA2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Extrapolation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I = 1,NBFT                                                   
       FA3(I) = FA2(I) - FA3(I)                                               
       FA2(I) = FA1(I) - FA2(I)                                               
       FA1(I) = FA0(I) - FA1(I)                                               
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Return after Extrapolation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOUNT < IEXTIN .or. ITER < 4) GO TO 680                
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Displacements
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ITYP==2)GO TO 500                                        
      SP11 = TRACEP(FA1,FA1,NBF)                                           
      SP12 = TRACEP(FA2,FA1,NBF)                                           
      SP13 = TRACEP(FA3,FA1,NBF)                                           
      SP22 = TRACEP(FA2,FA2,NBF)                                           
      SP23 = TRACEP(FA3,FA2,NBF)                                           
      SP33 = TRACEP(FA3,FA3,NBF)                                           
      GO TO 520                                                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  500 CONTINUE                                                          
      SP11 = DDOT(NBFT,FA1,1,FA1,1)                                         
      SP12 = DDOT(NBFT,FA2,1,FA1,1)                                         
      SP13 = DDOT(NBFT,FA3,1,FA1,1)                                         
      SP22 = DDOT(NBFT,FA2,1,FA2,1)                                         
      SP23 = DDOT(NBFT,FA3,1,FA2,1)                                         
      SP33 = DDOT(NBFT,FA3,1,FA3,1)                                         
  520 CONTINUE                                                          
      DP1 = SQRT(SP11)                                                  
      DP2 = SQRT(SP22)                                                  
      DP3 = SQRT(SP33)                                                  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(DP1<1.0D-10) GO TO 680                                      
      IF(DP2<1.0D-10) GO TO 680                                      
      IF(DP3<1.0D-10) GO TO 680                                      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Find angle PHI between successive displacements
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      COSPHI = SP12/(DP1*DP2)                                           
!
      Z = SP11*SP22-SP12*SP12                                           
      IF ( ABS(Z) < 1.0D-17 ) GO TO 680                                 
      X = (SP13*SP22-SP12*SP23)/Z                                       
      Y = (SP23*SP11-SP12*SP13)/Z                                       
      COSPSI = SQRT(X*X*SP11+Y*Y*SP22+2.0d0*X*Y*SP12)/DP3                 
!                                                                       
      IF(COSPSI<=1.0D-07)GO TO 680                                    
      IF(DAMP>0.01d0)GO TO 680                                   
!                                                                       
      Y = -Y/X                                                          
      X = 1.0d0/X                                                         
!                                                                       
      XY = Y*Y + 4.0d0*X                                                   
      IF (XY < 0.0d0) GO TO 680                                       
      XY = ABS(Y)+SQRT(XY)                                              
      IF (XY <= 1.9d0) GO TO 560                                       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If 4-point extrapolation is not possible, try 3-point extrap.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF (ABS(COSPHI) <= 0.99d0) GO TO 680                              
      X = DP1/(DP2*COSPHI-DP1)                                          
      DO I = 1,NBFT                                                   
       FA0(I) = FA0(I) + X*FA1(I)                                             
      END DO
      GO TO 600                                                         
!                                                                       
  560 XXX = X/(1.0d0-X-Y)                                                 
      YYY = (X+Y)/(1.0d0-X-Y)                                             
      DO I = 1,NBFT                                                   
       FA0(I) = FA0(I) + XXX*FA2(I)+YYY*FA1(I)                                 
      END DO
!                                                                       
  600 CONTINUE                                                          
      IF(NCALL==1)ICALP=0                                            
      IF(NCALL==2)ICBET=0
      FAO0 = FA0
      GO TO 680                                                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     No Damping or Extrapolation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  620 IF (NCALL /= 1) GO TO 640                                       
      DAMPRE = .FALSE.                                                  
      EXTPRE = .FALSE.                                                  
  640 DAMP = 0.0d0                                                       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Save Modified Fockians in FAO-matrices
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                     
  660 CONTINUE
      FAO0 = FA0
      FAO1 = FA1
      FAO2 = FA2
!----------------------------------------------------------------------- 
  680 RETURN
      END                                                               
            
!======================================================================!
!                                                                      !
!               I N T E G R A L   S U B R O U T I N E S                !
!                                                                      !
!======================================================================!

! OneElecInt                                           
      SUBROUTINE OneElecInt(Cxyz,H,S,TKIN,DInteg,NBFT,IPRINTOPT,        &
                            EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,      &
                            KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,ZAN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/USELIBRETA/ILIBRETA      
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB                        
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3)
      INTEGER :: IPRINTOPT
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz                                                         
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S,TKIN    
      DOUBLE PRECISION,DIMENSION(3*NBFT) :: DInteg
!-----------------------------------------------------------------------
      IF(IPRINTOPT==1)WRITE(6,'(/1X,A13/,1X,13(1H-))')'1e- integrals'
      call cpu_time(timestartoneE)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!     H, S & T integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(ILIBRETA==0)then
       CALL HSandT(H,S,TKIN,NBFT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,        &
                   KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,        &
                   ZAN,Cxyz)
      else if(ILIBRETA==1)then
       CALL HSandTlib(H,S,TKIN,NBFT,KATOM,KLOC,KMIN,KMAX,NSHELL,        &
                      ZAN,Cxyz)      
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ECP integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF( 1<=IECP .and. IECP<=3 )THEN
       CALL ECPINT(H,NBFT,EX,CS,CP,CD,CF,CG,NPRIMI,KSTART,KATOM,KNG,    &
                   KLOC,KMIN,KMAX,NSHELL,Cxyz)
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Add Electric Field Contribution to 1e Hamiltonian
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EFLDL)THEN
       CALL DipInt(DInteg,NBFT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,          &
                   KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,        &
                   Cxyz,NAT)
       CALL ElecFieldInt(H,DInteg,NBFT)              
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      call cpu_time(timefinishoneE)
      DeltaToneE = timefinishoneE - timestartoneE 
      IF(IPRINTOPT==1)                                                  &
       WRITE(6,'(1X,A22,F10.2)')'Time to do integrals =',DeltaToneE                                                                                                    
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! DipInt                                           
      SUBROUTINE DipInt(DInteg,NBFT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,     &
                        KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,   &
                        Cxyz,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/USELIBRETA/ILIBRETA            
      COMMON/ELPROP/IEMOM      
      COMMON/TRANSF/XP,YP,ZP
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(3*NBFT) :: DInteg
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Dipole integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XP = 0.0d0                                                           
      YP = 0.0d0
      ZP = 0.0d0                                                        
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEMSV = IEMOM                                                  
      IEMOM = 1    
      ALLOCATE(AUX(3*784))
      if(ILIBRETA==0)then
       CALL PRCALC(DInteg,AUX,3,NBFT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,    &
                   KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz)                   
      else if(ILIBRETA==1)then
       CALL PRCALClib(DInteg,AUX,3,NBFT,KATOM,KLOC,KMIN,KMAX,NSHELL)      
      end if
      IEMOM = IEMSV                                                  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(AUX)                                                                                  
      RETURN                                                            
      END                                                               

! ElecFieldInt
      SUBROUTINE ElecFieldInt(H,DInteg,NBFT)   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      DOUBLE PRECISION,DIMENSION(NBFT) :: H
      DOUBLE PRECISION,DIMENSION(3*NBFT) :: DInteg
!-----------------------------------------------------------------------
      WRITE(6,'(1X,A16,3F10.5)')'Electric Field =',(EVEC(I),I=1,3)                     
      IF(EVEC(1)/=0.0d0)CALL DAXPY(NBFT,EVEC(1),DInteg(1       ),1,H,1)              
      IF(EVEC(2)/=0.0d0)CALL DAXPY(NBFT,EVEC(2),DInteg(1+  NBFT),1,H,1)              
      IF(EVEC(3)/=0.0d0)CALL DAXPY(NBFT,EVEC(3),DInteg(1+2*NBFT),1,H,1)              
!----------------------------------------------------------------------- 
      RETURN                                                            
      END                                                               

! JandK                                            
      SUBROUTINE JandK(BUFP2,IX2,NINTEGtm,NINTEGt,NRECO,XINTS,NSH2,     &
                       IDONTW,IPRINTOPT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI, &
                       KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,    &
                       Cxyz,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/USELIBRETA/ILIBRETA      
      COMMON/INTFIL/NINTMX           
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/RESTAR/NREC,IST,JST,KST,LST           
      LOGICAL SCHWRZ
      INTEGER :: IPRINTOPT
      INTEGER,DIMENSION(NINTEGtm) :: IX2
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      DOUBLE PRECISION,DIMENSION(NSH2) :: XINTS
!
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: BUFP,GHONDOLIB
!-----------------------------------------------------------------------                                                                       
!     Driver for 2e integrals 
!-----------------------------------------------------------------------
      call cpu_time(timestarttwoE)
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      MAXG = 4**4                                                                                  
      IF(LMAXIMA==2)MAXG =  6**4                                                                                  
      IF(LMAXIMA==3)MAXG = 10**4                                                                                  
      IF(LMAXIMA==4)MAXG = 15**4                                                                                  
      IF(LMAXIMA==5)MAXG = 21**4                                                                                  
      IF(LMAXIMA==6)MAXG = 28**4
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Debut
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL Debut(IDONTW,IPRINTOPT,KATOM,NSHELL,Cxyz)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Schwarz inequality
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(GHONDOLIB(MAXG))
      SCHWRZ = ISCHWZ>0 
      IF(SCHWRZ)THEN
       if(ILIBRETA==0)then
        CALL ExchangeInt(XINTS,GHONDOLIB,NSH2,MAXG,EX,CS,CP,CD,CF,CG,   &
                         CH,CI,NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN, &
                         KMAX,NSHELL,Cxyz,NAT)                          
       else if(ILIBRETA==1)then
        CALL ExchangeIntlib(XINTS,GHONDOLIB,NSH2,MAXG,KTYPE,KMIN,KMAX,  &
                            NSHELL)
       end if
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     2e integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(BUFP(NINTMX),IX(NINTMX))
      CALL TwoERI(SCHWRZ,NINTEGtm,NINTEGt,NSCHWZ,BUFP,IX,BUFP2,IX2,     &
                  XINTS,NSH2,GHONDOLIB,MAXG,IDONTW,IPRINTOPT,EX,CS,     &
                  CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,KATOM,KTYPE,KNG,      &
                  KLOC,KMIN,KMAX,NSHELL,Cxyz,NAT)
      DEALLOCATE(BUFP,IX,GHONDOLIB)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NRECO = NREC
      call cpu_time(timefinishtwoE)
      DeltaTtwoE = timefinishtwoE - timestarttwoE                                          
      IF(IPRINTOPT==1)                                                  &
       WRITE(6,'(1X,A22,F10.2)')'Time to do integrals =',DeltaTtwoE
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! Debut                                            
      SUBROUTINE Debut(IDONTW,IPRINTOPT,KATOM,NSHELL,Cxyz)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INTFIL/NINTMX           
      COMMON/RESTAR/NREC,IST,JST,KST,LST           
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      COMMON/SHLT/SHLTOL,CUTOFF,ICOUNT
      INTEGER :: IPRINTOPT
      INTEGER,DIMENSION(NSHELL) :: KATOM
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz   
      DOUBLE PRECISION,DIMENSION(NSHELL,3) :: CO
!-----------------------------------------------------------------------
!     Initialize 2e- integral Calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                                                                              
      SHLTOL = 20*2.30258D0   
      CUTOFF = 1.0D-09
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!     ERI Initializations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      IF(IPRINTOPT==1)WRITE(6,10)                                              
      NBYTES = 16
      IF(IDONTW==1)THEN
       IF(IPRINTOPT==1)WRITE(6,20)
      ELSE
       IF(IPRINTOPT==1)WRITE(6,30)NINTMX,NBYTES
       REWIND(1)                             
      END IF
      DO I=1,NSHELL                                                 
       ICC = KATOM(I)                                                 
       CO(I,1)= Cxyz(1,ICC)                                              
       CO(I,2)= Cxyz(2,ICC)                                              
       CO(I,3)= Cxyz(3,ICC)                                              
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                                                                              
!     Normal Start
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IST = 1                                              
      JST = 1                                              
      KST = 1                                              
      LST = 1                                              
      NREC   = 1                                                        
      ICOUNT = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                                                               
!     Format Statements
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
   10 FORMAT(/1X,'2e- integrals'/1X,13(1H-))      
   20 FORMAT(' DONTW option skips storage 2e- integrals on Unit 1')      
   30 FORMAT(' Storing',I8,' integrals/record on disk, using',I3,       &
             ' Bytes/integral')                                        
!-----------------------------------------------------------------------                                       
      RETURN                                                            
      END                                                               

! TwoERI                                            
      SUBROUTINE TwoERI(SCHWRZ,NINTEGtm,NINTEGt,NSCHWZ,BUFP,IX,BUFP2,   &
                        IX2,XINTS,NSH2,GHONDOLIB,MAXG,IDONTW,IPRINTOPT, &
                        EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,KATOM,    &
                        KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz,NAT)
      USE ISO_C_BINDING
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
      COMMON/USELIBRETA/ILIBRETA      
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
!
      LOGICAL SCHWRZ,SCHSKP,SKIPA,SKIPB,SKIPC,NPSYM                                   
      COMMON/INTFIL/NINTMX  
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)
      COMMON/RESTAR/NREC,IST,JST,KST,LST           
      COMMON/SHLNOS1/QQ4,IJKL 
      INTEGER :: IPRINTOPT
      INTEGER,DIMENSION(NINTEGtm) :: IX2
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DIMENSION BUFP(NINTMX),IX(NINTMX),XINTS(NSH2),GHONDOLIB(MAXG)
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX
!-----------------------------------------------------------------------
!     2e- Integrals (S,P,D,F,G & L Shells)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CUTOFF = 1.0D-09
      ALLOCATE(AUX(49*900))                                                   
!
      IF(ILIBRETA==0)THEN
       CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
       NANGM =  4                                          
       IF(LMAXIMA==2) NANGM =  6                                          
       IF(LMAXIMA==3) NANGM = 10                                          
       IF(LMAXIMA==4) NANGM = 15                                          
       IF(LMAXIMA==5) NANGM = 21                                          
       IF(LMAXIMA==6) NANGM = 28                                          
       NGTH(4) = 1                                                       
       NGTH(3) = NGTH(4) * NANGM                                         
       NGTH(2) = NGTH(3) * NANGM                                         
       NGTH(1) = NGTH(2) * NANGM                                         
       DO I=1,3                                                       
        NORGSH(I) = 0                                               
        NORGSP(I) = 0                                               
       ENDDO
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NINTEGt  = 0                                                         
      NSCHWZ= 0                                                         
      SCHSKP=.FALSE.                                                    
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO II = IST,NSHELL                            ! II Shell
       J0 = JST                                     ! JJ Shell                                            
       DO JJ = J0,II                                                 
        JST = 1                                                           
        K0 = KST                                                          
        DO KK = K0,JJ                               ! KK Shell                                                 
         KST = 1                                                           
         L0 = LST                                                          
         DO LL = L0,KK                              ! LL Shell
          LST = 1                                                           
          SKIPA =  JJ==KK                                                 
          SKIPB = (II==KK) .or. (JJ==LL)                                
          SKIPC = (II==JJ) .or. (KK==LL)                                
          NPSYM = .FALSE.                                                   
          IF(SKIPA.or.SKIPB.or.SKIPC)GO TO 1                        
          NPSYM = .TRUE.
          IH = II                                                       
          JH = JJ                                                       
          IF(JH<=IH)THEN                                              
           ID = IH                                                     
           JD = JH                                                     
          ELSE                                                           
           ID = JH                                                     
           JD = IH                                                     
          END IF                                                         
          IF(.NOT.SKIPA)                                                &
          SKIPA = (ID==II .and. JD==KK) .or. (ID==JJ .and. JD==LL)               
          IF(.NOT.SKIPB)                                                &
          SKIPB = (ID==II .and. JD==LL) .or. (ID==JJ .and. JD==KK)               
          IF(SKIPA .and. SKIPB)GO TO 2                               
          KH = KK
          IF(KH<=IH) THEN                                              
           ID = IH                                                     
           KD = KH                                                     
          ELSE                                                           
           ID = KH                                                     
           KD = IH                                                     
          END IF                                                         
          IF(.NOT.SKIPC)                                                &
          SKIPC = (ID==II .and. KD==LL) .or. (ID==JJ .and. KD==KK)               
          IF(SKIPA .and. SKIPC) GO TO 3                                
          IF(SKIPB .and. SKIPC) GO TO 4                                
          GO TO 1                                                         
    2     SKIPC = .TRUE.                                                    
          GO TO 1                                                         
    3     SKIPB = .TRUE.                                                    
          GO TO 1                                                         
    4     SKIPA = .TRUE.                                                    
!- - - - - - - - - - - - - - - - - - - - - - - -
!         (II,JJ//KK,LL)                                        
!- - - - - - - - - - - - - - - - - - - - - - - -                            
    1     CONTINUE                                                          
          IEXCH = 1                                                         
          ISH = II                                                          
          JSH = JJ                                                          
          KSH = KK                                                          
          LSH = LL                                                          
          QQ4 = 1                                                          
          IF(SKIPA .and. NPSYM) QQ4 = QQ4+1                                
          IF(SKIPB .and. NPSYM) QQ4 = QQ4+1                                
          GO TO 5                                                         
!- - - - - - - - - - - - - - - - - - - - - - - -
!         (II,KK//JJ,LL)
!- - - - - - - - - - - - - - - - - - - - - - - -                            
    6     IF (SKIPA)GO TO 7                                              
          IEXCH = 2                                                         
          ISH = II                                                          
          JSH = KK                                                          
          KSH = JJ                                                          
          LSH = LL                                                          
          QQ4 = 1                                                          
          IF (SKIPC .and. NPSYM) QQ4 = QQ4+1                               
          GO TO 5                                                         
!- - - - - - - - - - - - - - - - - - - - - - - -
!         (II,LL//JJ,KK)
!- - - - - - - - - - - - - - - - - - - - - - - -                            
    7     IF(SKIPB .or. SKIPC)GO TO 8                                   
          IEXCH = 3                                                         
          ISH = II                                                          
          JSH = LL                                                          
          KSH = JJ                                                          
          LSH = KK                                                          
          QQ4 = 1                                                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!         Compute 2e- Integrals                      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
    5     CONTINUE    
          IF(SCHWRZ)THEN                       ! Schwarz Inequality
           IJIJ = (ISH*ISH-ISH)/2 + JSH                                   
           KLKL = (KSH*KSH-KSH)/2 + LSH                                   
           TEST = QQ4*XINTS(IJIJ)*XINTS(KLKL)                             
           SCHSKP = TEST<CUTOFF                                        
           IF(SCHSKP)NSCHWZ = NSCHWZ + 1                                 
          END IF        
          IF(SCHSKP)GO TO 9                                              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!         Select integral code for ERI calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          if(ILIBRETA==0)then
           LQSUM = KTYPE(ISH) + KTYPE(JSH) + KTYPE(KSH) + KTYPE(LSH) - 4     
           CALL SHELLS(1,ISH,JSH,KSH,LSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,&
                       NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,    &
                       NSHELL,Cxyz)                           
           CALL SHELLS(2,ISH,JSH,KSH,LSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,&
                       NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,    &
                       NSHELL,Cxyz)                           
           CALL IJPRIM(AUX)                                          
           NORGH = NORGSH(IEXCH)                                           
           CALL ZQOUT(GHONDOLIB,MAXG)                                
           IF(LQSUM==0) THEN                                             
            CALL S0000(GHONDOLIB(1+NORGH),AUX)                        
           ELSE                                                            
            CALL ERISPDFGHIL(GHONDOLIB(1+NORGH),AUX)                       
           END IF
          else if(ILIBRETA==1)then
!lib           CALL ERISVAL(BASLIB,ISH,JSH,KSH,LSH,GHONDOLIB)
          end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!         Write Label & Integral on File 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          if(ILIBRETA==0)then
           CALL QOUT(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,GHONDOLIB,IDONTW,&
                     KLOC,KMIN,KMAX,NSHELL)
          else if(ILIBRETA==1)then
           CALL QOUTlib(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,GHONDOLIB,    &
                        IDONTW,ISH,JSH,KSH,LSH,KLOC,KMIN,KMAX,NSHELL)
          endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    9     CONTINUE                                                          
          GO TO (6,7,8),IEXCH                                         
    8     CONTINUE                                                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         END DO
        END DO
       END DO
      END DO
      DEALLOCATE(AUX)                                                                                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Final Record on File 1. Calculate NINTEGt.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL FINAL(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,NINTEGt,IDONTW,      &
                 IPRINTOPT)            
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! FINAL                                            
      SUBROUTINE FINAL(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,NINTEGt,       &
                       IDONTW,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION BUFP(NINTMX),IX(NINTMX)
      COMMON /RESTAR/ NREC,IST,JST,KST,LST          
      INTEGER,DIMENSION(NINTEGtm) :: IX2
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
!-----------------------------------------------------------------------                                                                       
      IST = 1                                                           
      JST = 1                                                           
      KST = 1                                                           
      LST = 1                                                           
      NXInteg = ICOUNT-1                                                    
      IF(NXInteg>=0) THEN                                            
       IF(IDONTW==1)THEN
        IJBUFi = (NREC-1)*NINTMX
        do ibuf=1,NXInteg
         IX2  (IJBUFi+ibuf) = IX(ibuf)
         BUFP2(IJBUFi+ibuf) = BUFP(ibuf)
        end do
       ELSE
        NXInteg = -NXInteg 
        WRITE(1)NXInteg,IX,BUFP
       END IF
       NINTEGt = NINTMX*(NREC-1) + ICOUNT-1
      ELSE                                                              
       NINTEGt = NXInteg                                                     
      ENDIF                                                             
      IF(IPRINTOPT==1)WRITE(6,10)NINTEGt,NREC                                 
      RETURN                                                            
!-----------------------------------------------------------------------                                                                       
   10 FORMAT(I20,' 2e- integrals in ',I5,' records')
!-----------------------------------------------------------------------                                                                       
      END                                                               

! OTTOINTEGR
      SUBROUTINE OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
!-----------------------------------------------------------------------
!     TRANSFORM INTO INTSCF INTEGRALS
!-----------------------------------------------------------------------
      IF(I==J)XJ=XJ*2.0
      IF(K==L)XJ=XJ*2.0
      IF(NIJ==NKL)XJ=XJ*2.0
!-----------------------------------------------------------------------
      RETURN
      END

!----------------------------------------------------------------------!
!                                                                      !
!                    M P I   S U B R O U T I N E S                     !
!                                                                      !
!      2013 Four-index transformation of the electron repulsion        !
!           integrals was parallelized by Eduard Matito                !
!                                                                      !
!          04/26/2013 module developed by Eduard Matito                !
!          06/28/2017 module modified by Ion Mitxelena                 !
!          11/15/2020 module modified by Juan Felipe Huan Lew Yee      !                                                                     !                                                                      !                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
!                                                                      !
!   INIMPI: Initializion of the parallel or serial version of the code !
!   Abortx: Abort if OPT-MPI fatal error occurs.                       !
!   SlaveDvr: Slave driver                                             !
!   SlvInt: Calculation of the integrals in the slave nodes.           !
!   SLVHSTJ: HSTARJ subroutine adapted for Slaves                      !
!   SLVHSTK: HSTARK subroutine adapted for Slaves                      !
!   SLVFORM2JK: FORM2JK subroutine adapted for Slaves                  !
!   SLVFORMJK: FORMJK adapted for Slaves                               !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

! INIMPI
      Subroutine INIMPI()
      Implicit None
#include "mpip.h"
#ifdef MPI
      Write(6,'(A)')' This is the parallel version of the code'
      CALL MPI_INIT (IERR)
      CALL MPI_COMM_RANK (MPI_COMM_WORLD,MY_ID,IERR)
      CALL MPI_COMM_SIZE (MPI_COMM_WORLD,NPROCS,IERR)
      LMASTR=(MY_ID.EQ.MASTER)
      IF (LMASTR) Write(6,'(A,I4,A,I8)') 'Master: ',MY_ID
     
      IF (NPROCS<2) THEN
        Call Abortx ("OPT-MPI Fatal error! Use at least 2 cores!")
      ELSE IF (.NOT.LMASTR) THEN
        Call SlaveDvr()
      ENDIF

#else
      Write(6,'(A)')' This is the serial version of the code'
      NPROCS=1
      MY_ID=0
      LMASTR=.True.
#endif
      End

! Abortx
      Subroutine Abortx(String)
      Implicit None
#include "mpip.h"
      Character*(*) String
#ifdef MPI
      CALL MPI_ABORT(MPI_COMM_WORLD,1,IERR)
#endif     
      Write(6,'(A,A)') 'Error... Aborting!',String
      Stop 'Error: Aborting!'
      End

#ifdef MPI

! SlaveDvr
      Subroutine SlaveDvr()
      Implicit None
#include "mpip.h"
      INTEGER NINTCR,INTTYPE,ID,K
      ID=MY_ID
      K=MASTER
   10 CALL MPI_BCAST(INTTYPE,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_RECV(NINTCR,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      IF(INTTYPE==1) THEN
        Call SlvInt(NINTCR)
        GOTO 10
      ELSE IF(INTTYPE==2) THEN
        Call SlvIntRI(NINTCR)
        GOTO 10
      ELSE IF(INTTYPE==3) THEN
        RETURN
      END IF
      GOTO 10
      End

! SlvInt
      Subroutine SlvInt(NINTCR)
      Implicit None
#include "mpip.h"
      INTEGER NINTCR,N,K,JJ,IERI,ID,NOPT,IER,NOPTCG
      Double Precision ERI
      ALLOCATABLE::ERI(:),IERI(:)
      ALLOCATE(IERI(NINTCR),ERI(NINTCR),STAT=IER)
      IF(IER/=0)CALL ERRORMEM(NINTCR)
      ID=MY_ID
      K=MASTER
      JJ=1
   10 CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      IF (N<0) GOTO 20
      CALL MPI_RECV(ERI(JJ),N,MPI_REAL8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(IERI(JJ),N,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS, &
                    IERR)
 
      JJ=JJ+N
      GOTO 10
!
!     Now it has all the integrals in the node, waits for wake-up signal
!     and call the pertinent subroutine (either form J or K integrals)
!
   20 CALL MPI_RECV(NOPT,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      IF (NOPT==0) THEN
       CALL MPI_RECV(NOPTCG,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,         &
                     STATUS,IERR)
       IF (NOPTCG==0) GOTO 30   
       CALL MPI_FINALIZE(IERR)
      ELSE IF (NOPT==1) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVHSTJ(N,JJ-1,IERI,ERI)
      ELSE IF (NOPT==2) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVHSTK(N,JJ-1,IERI,ERI)
      ELSE IF (NOPT==3) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVFORM2JK(N,JJ-1,IERI,ERI)
      ELSE IF (NOPT==4) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVFORMJK(N,JJ-1,IERI,ERI)
      ELSE
       Call Abortx ("I do not know this MPI option!")
      ENDIF    
      GOTO 20
   30 CONTINUE

      End

! SlvIntRI
      Subroutine SlvIntRI(NINTCR)
      Implicit None
#include "mpip.h"
      INTEGER NINTCR,K,JJ,ID,NOPT,IER,NOPTCG
      INTEGER NBF,NBF5,NBFaux,IAUXDIM
      Double Precision ERIaux
      ALLOCATABLE::ERIaux(:)
      ALLOCATE(ERIaux(NINTCR),STAT=IER)
      IF(IER/=0)CALL ERRORMEM(NINTCR)
      ID=MY_ID
      K=MASTER
      JJ=1
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(NBF5,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(NBFaux,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      IAUXDIM = NINTCR/(NBF*(NBF+1)/2)
      CALL MPI_RECV(ERIaux(JJ),NINTCR,MPI_REAL8,K,ID,MPI_COMM_WORLD,    &
                    STATUS,IERR)
!
!     Now it has all the integrals in the node, waits for wake-up signal
!     and call the pertinent subroutine (either form J or K integrals)
!
   20 CALL MPI_RECV(NOPT,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      IF (NOPT==0) THEN
       CALL MPI_RECV(NOPTCG,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,         &
                     STATUS,IERR)
       IF (NOPTCG==0) GOTO 30
       CALL MPI_FINALIZE(IERR)
      ELSE IF (NOPT==1) THEN
       CALL SLVHSTJKRI(NBF,IAUXDIM,ERIaux)
      ELSE IF (NOPT==2) THEN
       CALL SLVQJKMATmRI(NBF,NBF5,IAUXDIM,ERIaux)
      ELSE
       Call Abortx ("I do not know this MPI option!")
      ENDIF
      GOTO 20
   30 DEALLOCATE(ERIaux)
      CONTINUE
!
      End
      
! SLVHSTJKRI
      SUBROUTINE SLVHSTJKRI(NBF,IAUXDIM,ERIaux)
!     HSTARJKRI adapted for Slaves 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
#include "mpip.h"
      INTEGER NBF,IAUXDIM
      DIMENSION ERIaux(NBF*(NBF+1)/2,IAUXDIM)
      DOUBLE PRECISION,DIMENSION(NBF)::C
      DOUBLE PRECISION,DIMENSION(NBF*(NBF+1)/2)::FJ,FK,FFJ,FFK
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,DIMENSION(NBF)::B_IN
      DOUBLE PRECISION::B_II
!
!     Get C matrix from Master node
!
      CALL MPI_BCAST(C,NBF,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)

      FJ = 0.0d0
      FK = 0.0d0
      FFJ = 0.0d0
      FFK = 0.0d0

      DO K=1,IAUXDIM
        B_IN(1:NBF) = 0.0d0
        B_II = 0.0d0

        DO N=1,NBF
          DO M=1,N
            MN = M + N*(N-1)/2
            B_IN(N) = B_IN(N) + C(M)*ERIaux(MN,K)
            IF(M.NE.N) B_IN(M) = B_IN(M)+C(N)*ERIaux(MN,K)
          END DO
        END DO

        DO N=1,NBF
          B_II = B_II + C(N)*B_IN(N)
        END DO

        DO N=1,NBF
          DO M=1,N
            MN = M + N*(N-1)/2
            FJ(MN) = FJ(MN) + B_II*ERIaux(MN,K)
          END DO
        END DO

        DO N=1,NBF
          DO M=1,N
            MN = M + N*(N-1)/2
            FK(MN) = FK(MN) + B_IN(M)*B_IN(N)
          END DO
        END DO
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send pieces to master
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(FJ,FFJ,NBF*(NBF+1)/2,MPI_REAL8,MPI_SUM,MASTER,    &
                      MPI_COMM_WORLD,IERR)                               
      CALL MPI_REDUCE(FK,FFK,NBF*(NBF+1)/2,MPI_REAL8,MPI_SUM,MASTER,    &
                      MPI_COMM_WORLD,IERR)
!-----------------------------------------------------------------------
      RETURN
      END

! SLVQJKMATmRI
      SUBROUTINE SLVQJKMATmRI(NBF,NBF5,IAUXDIM,XIJKAUX)
!     QJKMATmRI adapted for Slaves 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
#include "mpip.h"
      INTEGER NBF,NBF5,IAUXDIM
      DIMENSION XIJKAUX(NBF*(NBF+1)/2,IAUXDIM)
      DIMENSION C(NBF,NBF)
      DOUBLE PRECISION,DIMENSION(NBF5*(NBF5+1)/2)::QJ,QK,QQJ,QQK
      DIMENSION B_IN(NBF5,NBF) 
      DIMENSION B_IJ(NBF5,NBF5) 
!
!     Get C matrix from Master node
!
      CALL MPI_BCAST(C,NBF*NBF,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)


      QJ = 0.0d0
      QK = 0.0d0
      QQJ = 0.0d0
      QQK = 0.0d0

      DO K=1,IAUXDIM

        B_IN(1:NBF5,1:NBF) = 0.0d0
        DO I=1,NBF5
          DO N=1,NBF
            DO M=1,N
              MN = M + N*(N-1)/2
              B_IN(I,N) = B_IN(I,N) + C(M,I)*XIJKAUX(MN,K)
              IF(M.NE.N) B_IN(I,M) = B_IN(I,M)+C(N,I)*XIJKAUX(MN,K)
            END DO
          END DO
        END DO

        B_IJ(1:NBF5,1:NBF5) = 0.0d0
        DO J=1,NBF5
          DO N=1,NBF
            DO I=1,J
              B_IJ(I,J) = B_IJ(I,J) + C(N,J)*B_IN(I,N)
            END DO
          END DO
        END DO

        DO J=1,NBF5
          DO I=1,J
            IJ=I+J*(J-1)/2
            QJ(IJ) = QJ(IJ) + B_IJ(I,I)*B_IJ(J,J)
          END DO
        END DO

        DO J=1,NBF5
          DO I=1,J
            IJ=I+J*(J-1)/2
            QK(IJ) = QK(IJ) + B_IJ(I,J)*B_IJ(I,J)
          END DO
        END DO

      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send pieces to master
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(QJ,QQJ,NBF5*(NBF5+1)/2,MPI_REAL8,MPI_SUM,MASTER,  &
                      MPI_COMM_WORLD,IERR)                               
      CALL MPI_REDUCE(QK,QQK,NBF5*(NBF5+1)/2,MPI_REAL8,MPI_SUM,MASTER,  &
                      MPI_COMM_WORLD,IERR)
!-----------------------------------------------------------------------
      RETURN
      END

! SLVHSTJ
      SUBROUTINE SLVHSTJ(N,NN,IERI,ERI)
!     HSTARJ adapted for Slaves 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      DIMENSION IERI(NN),ERI(NN)
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
!
!     Get P matrix from Master node
!
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
!
      F  = 0.0d0
      FF = 0.0d0
      DO M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
                   F(NIJ)=F(NIJ)+0.5d0*P(NKL)*XJ
       IF(NIJ/=NKL)F(NKL)=F(NKL)+0.5d0*P(NIJ)*XJ
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send pieces to master
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,MASTER,MPI_COMM_WORLD,   &
                      IERR)
!-----------------------------------------------------------------------
      DEALLOCATE(P,F,FF)
      RETURN
      END

! SLVHSTK
      SUBROUTINE SLVHSTK(N,NN,IERI,ERI)
!     HSTARK adapted for Slaves
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      INTEGER,DIMENSION(NN)::IERI
      DOUBLE PRECISION,DIMENSION(NN)::ERI
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get P matrix from Master node
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)

      F = 0.0d0
      FF = 0.0d0

      DO 1 M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       XJ = 0.25*XJ
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L)XK=XK+XK
                       F(NIK)=F(NIK)+P(NJL)*XK
       IF(NIK/=NJL)    F(NJL)=F(NJL)+P(NIK)*XK
       IF(I==J.OR.K==L)GOTO 1
       NIL = I*(I-1)/2 + L
       NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
       IF(I==L.OR.J==K)XJ=XJ+XJ
                       F(NIL)=F(NIL)+P(NJK)*XJ
       IF(NIL/=NJK)    F(NJK)=F(NJK)+P(NIL)*XJ
    1 CONTINUE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send pieces to master
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,MASTER,MPI_COMM_WORLD,   &
     &                IERR)
!-----------------------------------------------------------------------
      DEALLOCATE(FF,P,F)
      RETURN
      END

! SLVFORM2JK
      SUBROUTINE SLVFORM2JK(N,NN,IERI,ERI)
!     FORM2JK adapted for Slaves
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      INTEGER,DIMENSION(NN)::IERI
      DOUBLE PRECISION,DIMENSION(NN)::ERI
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get P matrix from Master node
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)

      F = 0.0d0
      FF = 0.0d0

      DO M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
!-----------------------------------------------------------------------
!      2*J
!-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
                   F(NIJ)=F(NIJ)+P(NKL)*XJ
       IF(NIJ/=NKL)F(NKL)=F(NKL)+P(NIJ)*XJ
!-----------------------------------------------------------------------
!      -K
!-----------------------------------------------------------------------
       XJ = 0.25d0*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send pieces to master
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,MASTER,MPI_COMM_WORLD,   &
                      IERR)
!-----------------------------------------------------------------------
      DEALLOCATE(P,F,FF)
      RETURN
      END

! SLVFORMJK
      SUBROUTINE SLVFORMJK(N,NN,IERI,ERI)
!     FORMJK adapted for Slaves
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      INTEGER,DIMENSION(NN)::IERI
      DOUBLE PRECISION,DIMENSION(NN)::ERI
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get P matrix from Master node
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)

      F = 0.0d0
      FF = 0.0d0

      DO M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
!-----------------------------------------------------------------------
!      J
!-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
                   F(NIJ)=F(NIJ)+0.5d0*P(NKL)*XJ
       IF(NIJ/=NKL)F(NKL)=F(NKL)+0.5d0*P(NIJ)*XJ
!-----------------------------------------------------------------------
!      -K
!-----------------------------------------------------------------------
       XJ = 0.25d0*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send pieces to master
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,MASTER,MPI_COMM_WORLD,   &
                      IERR)
!-----------------------------------------------------------------------
      DEALLOCATE(P,F,FF)
      RETURN
      END

#endif

! ERRORMEM
      SUBROUTINE ERRORMEM(NMEMORY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER :: NMEMORY
      DOUBLE PRECISION :: GBNUMBER
      GBNUMBER = DFLOAT(NMEMORY*8)/(1024.0d0**3)
      WRITE(6,1)NMEMORY,GBNUMBER
    1 FORMAT(//10X,'Sorry, You need more Memory!, NMEMORY =',I20,2X,    &
                   '=',F10.2,' GB')
      STOP
      END

!----------------------------------------------------------------------!
!                                                                      !
!                        H O N D O  Calculator                         !
!                                                                      !
!----------------------------------------------------------------------!

! HSandT                                           
      SUBROUTINE HSandT(H,S,TKIN,NBFT,EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,   &
                        KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,   &
                        ZAN,C)        
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,PARAMETER :: PI212 = 1.1283791670955D0      
      LOGICAL DOBLE
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S,TKIN
      INTEGER,DIMENSION(84) :: IX,IY,IZ,JX,JY,JZ
      LOGICAL     LINEAR
      COMMON/ZMAT/LINEAR      
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB                            
      COMMON/HERMIT/H1(55),W1(55)                                        
      COMMON/ROOT/XXROOT,U(13),W(13),NROOTS    ! XX = XXROOT             
      COMMON/SHLNRM/PNRM(84)                                             
      COMMON/STV/XINTT,YINTT,ZINTT,TAA,X0X0,Y0Y0,Z0Z0,                  &       
                 XIXI,YIYI,ZIZI,XJXJ,YJYJ,ZJZJ,NINI,NJNJ 
      LOGICAL                                         IIANDJJ
      COMMON/SYMIND/II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IIANDJJ            
      INTEGER,ALLOCATABLE,DIMENSION(:)::IJX,IJY,IJZ
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: C      
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: Z,ESP1E,SBLK,TBLK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: VBLK,ZBLK,FT
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DIJ,XIN,YIN,ZIN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CONI,CONJ
      ALLOCATE(IJX(784),IJY(784),IJZ(784))
      ALLOCATE(Z(NBFT),ESP1E(NBFT))
      ALLOCATE(SBLK(784),TBLK(784),VBLK(784),ZBLK(784),FT(784),DIJ(784))
      ALLOCATE(XIN(343),YIN(343),ZIN(343),CONI(84),CONJ(84))
!-----------------------------------------------------------------------
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,                           &
               22, 1, 1,15,15, 8, 1, 8, 1, 8,                           &
               29, 1, 1,22,22, 8, 1, 8, 1,15,                           &
               15, 1,15, 8, 8,                                          &
               36, 1, 1,29,29, 8, 1, 8, 1,22,                           &
               22,15, 1,15, 1,22, 8, 8,15,15,                           &
                8,                                                      &
               43, 1, 1,36,36, 8, 1, 8, 1,29,                           &
               29,15, 1,15, 1,29, 8, 8,22,22,                           &
                1,22,22,15, 8,15, 8,15/                                  
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,                           &
                1,22, 1, 8, 1,15,15, 1, 8, 8,                           &
                1,29, 1, 8, 1,22,22, 1, 8,15,                           &
                1,15, 8,15, 8,                                          &
                1,36, 1, 8, 1,29,29, 1, 8,15,                           &
                1,22,22, 1,15, 8,22, 8,15, 8,                           &
               15,                                                      &
                1,43, 1, 8, 1,36,36, 1, 8,15,                           &
                1,29,29, 1,15, 8,29, 8,22, 1,                           &
               22,15, 8,22,22, 8,15,15/                                  
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,                           &
                1, 1,22, 1, 8, 1, 8,15,15, 8,                           &
                1, 1,29, 1, 8, 1, 8,22,22, 1,                           &
               15,15, 8, 8,15,                                          &
                1, 1,36, 1, 8, 1, 8,29,29, 1,                           &
               15, 1,15,22,22, 8, 8,22, 8,15,                           &
               15,                                                      &
                1, 1,43, 1, 8, 1, 8,36,36, 1,                           &
               15, 1,15,29,29, 8, 8,29, 1,22,                           &
               22, 8,15, 8,15,22,22,15/                                  
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,                           &
                3, 0, 0, 2, 2, 1, 0, 1, 0, 1,                           &
                4, 0, 0, 3, 3, 1, 0, 1, 0, 2,                           &
                2, 0, 2, 1, 1,                                          &
                5, 0, 0, 4, 4, 1, 0, 1, 0, 3,                           &
                3, 2, 0, 2, 0, 3, 1, 1, 2, 2,                           &
                1,                                                      &
                6, 0, 0, 5, 5, 1, 0, 1, 0, 4,                           &
                4, 2, 0, 2, 0, 4, 1, 1, 3, 3,                           &
                0, 3, 3, 2, 1, 2, 1, 2/                                  
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,                           &
                0, 3, 0, 1, 0, 2, 2, 0, 1, 1,                           &
                0, 4, 0, 1, 0, 3, 3, 0, 1, 2,                           &
                0, 2, 1, 2, 1,                                          &
                0, 5, 0, 1, 0, 4, 4, 0, 1, 2,                           &
                0, 3, 3, 0, 2, 1, 3, 1, 2, 1,                           &
                2,                                                      &
                0, 6, 0, 1, 0, 5, 5, 0, 1, 2,                           &
                0, 4, 4, 0, 2, 1, 4, 1, 3, 0,                           &
                3, 2, 1, 3, 3, 1, 2, 2/                                  
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,                           &
                0, 0, 3, 0, 1, 0, 1, 2, 2, 1,                           &
                0, 0, 4, 0, 1, 0, 1, 3, 3, 0,                           &
                2, 2, 1, 1, 2,                                          &
                0, 0, 5, 0, 1, 0, 1, 4, 4, 0,                           &
                2, 0, 2, 3, 3, 1, 1, 3, 1, 2,                           &
                2,                                                      &
                0, 0, 6, 0, 1, 0, 1, 5, 5, 0,                           &
                2, 0, 2, 4, 4, 1, 1, 4, 0, 3,                           &
                3, 1, 2, 1, 2, 3, 3, 2/                                 
!-----------------------------------------------------------------------
!                      H, S & TKIN integrals
!-----------------------------------------------------------------------
      TOL = 20*2.30258D0     
      ZBLK = 0.0D+00
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     I SHELL                                               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO III = 1,NSHELL                                           
       I = KATOM(III)                                                  
       XIXI = C(1,I)                                                    
       YIYI = C(2,I)                                                    
       ZIZI = C(3,I)                                                    
       I1 = KSTART(III)                                                
       I2 = I1+KNG(III)-1                                              
       LIT = KTYPE(III)                                                
       MINI = KMIN(III)                                                
       MAXI = KMAX(III)                                                
       LOCI = KLOC(III)-MINI                                     
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      J SHELL                                               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO JJ = 1,III                                          
        J = KATOM(JJ)                                               
        XJXJ = C(1,J)                                                 
        YJYJ = C(2,J)                                                 
        ZJZJ = C(3,J)                                                 
        J1 = KSTART(JJ)                                             
        J2 = J1+KNG(JJ)-1                                           
        LJT = KTYPE(JJ)                                             
        MINJ = KMIN(JJ)                                             
        MAXJ = KMAX(JJ)                                             
        LOCJ = KLOC(JJ)-MINJ                                  
        NROOTS = (LIT+LJT-2)/2+1                                    
        RR = (XIXI-XJXJ)**2+(YIYI-YJYJ)**2+(ZIZI-ZJZJ)**2                       
        IIANDJJ = III == JJ                                          
        IJ = 0                                                      
        MAX = MAXJ                                                  
        DO I = MINI,MAXI                                        
         NXNX = IX(I)                                               
         NYNY = IY(I)                                               
         NZNZ = IZ(I)                                               
         IF (IIANDJJ) MAX = I                                       
         DO J = MINJ,MAX                                      
          IJ = IJ+1                                             
          IJX(IJ) = NXNX+JX(J)                                    
          IJY(IJ) = NYNY+JY(J)                                    
          IJZ(IJ) = NZNZ+JZ(J)                                    
          FT (IJ) = 2*(JX(J)+JY(J)+JZ(J)) + 3                   
         END DO
        END DO
        CALL VCLR( SBLK,1,IJ)                                       
        CALL VCLR( TBLK,1,IJ)                                       
        CALL VCLR( VBLK,1,IJ)                                       
        JGMAX = J2                                                  
        DO IG = I1,I2                                           
         AI = EX(IG)                                              
         ARRI = AI*RR                                             
         AXI = AI*XIXI                                              
         AYI = AI*YIYI                                              
         AZI = AI*ZIZI                                              
         CALL SETCONI(CONI,IG,CS,CP,CD,CF,CG,CH,CI,NPRIMI)                                    
         IF (IIANDJJ) JGMAX = IG                                    
         DO JG = J1,JGMAX                                     
          AJ = EX(JG)                                           
          AA = AI+AJ                                            
          AA1 = 1.0d0/AA                                          
          DUM = AJ*ARRI*AA1                                     
          IF(DUM<=TOL)THEN
           FAC = EXP(-DUM)                                       
           CALL SETCONI(CONJ,JG,CS,CP,CD,CF,CG,CH,CI,NPRIMI)                                 
           AX = (AXI+AJ*XJXJ)*AA1                                  
           AY = (AYI+AJ*YJYJ)*AA1                                  
           AZ = (AZI+AJ*ZJZJ)*AA1                                  
           DOBLE = IIANDJJ.and.IG/=JG                             
           MAX = MAXJ                                            
           NN = 0                                                
           DTWO = 1.0d0                                              
           IF(DOBLE)DTWO = 2.0D0                                   
           SPDIJ = CS(IG)*CP(JG)*FAC                               
           DO I = MINI,MAXI                                  
            IF (IIANDJJ) MAX = I                                 
            FACI=FAC*CONI(I)*PNRM(I)*DTWO                      
            NN1=NN+1                                           
            DO J = MINJ,MAX                                
             NN = NN+1                                       
             DIJ(NN)=FACI*CONJ(J)*PNRM(J)                    
            END DO
            IF(MINJ<=1.and.I>1.and.DOBLE)DIJ(NN1)=DIJ(NN1)*0.5D0+SPDIJ
           END DO
            TAA = SQRT(AA1)                                       
            T1 = -2.0D0*AJ*AJ*TAA                                   
            T2 = -0.5D0*TAA                                         
            X0X0 = AX                                               
            Y0Y0 = AY                                               
            Z0Z0 = AZ                                               
            IN = -7                                               
            DO I = 1,LIT                                      
             IN = IN+7                                          
             NINI = I                                             
             DO J = 1,LJT                                   
              JN = IN+J                                       
              NJNJ = J                                          
              CALL STVINT(H1,W1)                                     
              XIN(JN) = XINTT*TAA                              
              YIN(JN) = YINTT*TAA                              
              ZIN(JN) = ZINTT*TAA                              
              NJNJ = J+2                                        
              CALL STVINT(H1,W1)                                     
              XIN(JN+49) = XINTT*T1                            
              YIN(JN+49) = YINTT*T1                            
              ZIN(JN+49) = ZINTT*T1                            
              NJNJ = J-2                                        
              IF (NJNJ > 0) THEN                             
               CALL STVINT(H1,W1)                                  
              ELSE                                            
               XINTT = 0.0D+00                                  
               YINTT = 0.0D+00                                  
               ZINTT = 0.0D+00                                  
              END IF                                          
              N = (J-1)*(J-2)                                 
              DUM = N * T2                                    
              XIN(JN+98) = XINTT*DUM                           
              YIN(JN+98) = YINTT*DUM                           
              ZIN(JN+98) = ZINTT*DUM                           
              IF(LINEAR)THEN                                  
               NJNJ = J+1                                     
               CALL STVINT(H1,W1)                                  
               XIN(JN+147) = XINTT*TAA                       
               YIN(JN+147) = YINTT*TAA                       
               NJNJ = J-1                                     
               IF(NJNJ>0)THEN                          
                CALL STVINT(H1,W1)                               
               ELSE                                         
                XINTT = 0.0D+00                               
                YINTT = 0.0D+00                               
               END IF                                       
               XIN(JN+196) = XINTT*TAA*NJNJ                    
               YIN(JN+196) = YINTT*TAA*NJNJ                    
              END IF                                          
             END DO
            END DO
            DO I = 1,IJ                                       
             NXNX = IJX(I)                                        
             NYNY = IJY(I)                                        
             NZNZ = IJZ(I)                                        
             DUM   = XIN(NXNX)*YIN(NYNY)*ZIN(NZNZ)    
             DUM1X = (XIN(NXNX+49)+XIN(NXNX+98))*YIN(NYNY)*ZIN(NZNZ)    
             DUM1Y = (YIN(NYNY+49)+YIN(NYNY+98))*XIN(NXNX)*ZIN(NZNZ)    
             DUM1Z = (ZIN(NZNZ+49)+ZIN(NZNZ+98))*XIN(NXNX)*YIN(NYNY)    
             DUM1  = DUM1X + DUM1Y + DUM1Z                      
              SBLK(I) =  SBLK(I) + DIJ(I)* DUM                  
              TBLK(I) =  TBLK(I) + DIJ(I)*(DUM*AJ*FT(I)+DUM1) 
             IF(LINEAR)THEN                                     
              DUM2 = XIN(NXNX+147)*YIN(NYNY+196)                        &
                   - XIN(NXNX+196)*YIN(NYNY+147)   
              ZBLK(I) = ZBLK(I) + DIJ(I)*DUM2*ZIN(NZNZ)         
             END IF                                             
            END DO
            DUM = PI212*AA1                                    
            DO I = 1,IJ                                    
             DIJ(I) = DIJ(I)*DUM                             
            END DO
           AAX = AA*AX                                           
           AAY = AA*AY                                           
           AAZ = AA*AZ                                           
           DO IC = 1,NAT 
            ZNUC = -ZAN(IC)                                 
            CX = C(1,IC)                                    
            CY = C(2,IC)                                    
            CZ = C(3,IC)                                    
            XXROOT = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)         
            IF (NROOTS<=3) CALL RT123                        
            IF (NROOTS==4) CALL ROOT4                        
            IF (NROOTS==5) CALL ROOT5                        
            IF (NROOTS>=6) CALL ROOT6                        
            MM = 0                                             
            DO K = 1,NROOTS                                
             UU = AA*U(K)                                    
             WW = W(K)*ZNUC                                  
             TT = 1.0d0/(AA+UU)                                
             TAA = SQRT(TT)                                  
             X0X0 = (AAX+UU*CX)*TT                             
             Y0Y0 = (AAY+UU*CY)*TT                             
             Z0Z0 = (AAZ+UU*CZ)*TT                             
             IN = -7+MM                                      
             J0 = 2                                          
             XIN(IN+8) = W1(1)                                  
             YIN(IN+8) = W1(1)
             ZIN(IN+8) = W1(1)*WW                               
             DO I = 1,LIT                                
              IN = IN+7                                    
              NINI = I                                       
              DO J = J0,LJT                            
               JN = IN+J                                 
               NJNJ = J                                    
               CALL STVINT(H1,W1)                               
               XIN(JN) = XINTT                            
               YIN(JN) = YINTT                            
               ZIN(JN) = ZINTT*WW                         
              END DO
              J0 = 1                                       
             END DO
             MM = MM+49                                      
            END DO
            DO I = 1,IJ                                    
              NXNX = IJX(I)                                     
              NYNY = IJY(I)                                     
              NZNZ = IJZ(I)                                     
              DUM = 0.0D+00                                      
              MM = 0                                          
              DO K = 1,NROOTS                             
               DUM = DUM+XIN(NXNX+MM)*YIN(NYNY+MM)*ZIN(NZNZ+MM)   
               MM = MM+49                                   
              END DO
              VBLK(I) = VBLK(I) + DUM*DIJ(I)               
             END DO
           END DO
          END IF                                             
         END DO
        END DO
        MAX = MAXJ                                                  
        NN = 0                                                      
        DO I = MINI,MAXI                                        
         LI = LOCI+I                                              
         IN = (LI*(LI-1))/2                                       
         IF (IIANDJJ) MAX = I                                       
         DO J = MINJ,MAX                                      
          LJ = LOCJ+J                                           
          JN = LJ+IN                                            
          NN = NN+1                                             
          H(JN) =  TBLK(NN) + VBLK(NN)                         
          S(JN) =  SBLK(NN)                                    
          TKIN(JN) =  TBLK(NN)                                    
          IF(LINEAR) Z(JN) = ZBLK(NN)                            
         END DO
        END DO
       END DO
      END DO
!-----------------------------------------------------------------------
      DEALLOCATE(IJX,IJY,IJZ)
      DEALLOCATE(Z,ESP1E,SBLK,TBLK,VBLK,ZBLK,FT)
      DEALLOCATE(DIJ,XIN,YIN,ZIN,CONI,CONJ)              
      RETURN                                                            
      END                                                               
      
! PRCALC                                           
      SUBROUTINE PRCALC(XVAL,WINT,NVAL,L2,EX,CS,CP,CD,CF,CG,CH,CI,      &
                 NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,   &
                 Cxyz)                
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL                                         IIANDJJ
      COMMON/SYMIND/II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IIANDJJ  
      COMMON/XYZORB/TXYZ,X00,Y00,Z00,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB                     
      LOGICAL IIIandJJJ,NORMA,DOUBLE
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DIMENSION XVAL(NVAL*L2),WINT(*)                                   
      DIMENSION DIJ(784),IJX(784),IJY(784),IJZ(784)      
      DIMENSION IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,                           &
               22, 1, 1,15,15, 8, 1, 8, 1, 8,                           &
               29, 1, 1,22,22, 8, 1, 8, 1,15,                           &
               15, 1,15, 8, 8,                                          &
               36, 1, 1,29,29, 8, 1, 8, 1,22,                           &
               22,15, 1,15, 1,22, 8, 8,15,15,                           &
                8,                                                      &
               43, 1, 1,36,36, 8, 1, 8, 1,29,                           &
               29,15, 1,15, 1,29, 8, 8,22,22,                           &
                1,22,22,15, 8,15, 8,15/                                  
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,                           &
                1,22, 1, 8, 1,15,15, 1, 8, 8,                           &
                1,29, 1, 8, 1,22,22, 1, 8,15,                           &
                1,15, 8,15, 8,                                          &
                1,36, 1, 8, 1,29,29, 1, 8,15,                           &
                1,22,22, 1,15, 8,22, 8,15, 8,                           &
               15,                                                      &
                1,43, 1, 8, 1,36,36, 1, 8,15,                           &
                1,29,29, 1,15, 8,29, 8,22, 1,                           &
               22,15, 8,22,22, 8,15,15/                                  
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,                           &
                1, 1,22, 1, 8, 1, 8,15,15, 8,                           &
                1, 1,29, 1, 8, 1, 8,22,22, 1,                           &
               15,15, 8, 8,15,                                          &
                1, 1,36, 1, 8, 1, 8,29,29, 1,                           &
               15, 1,15,22,22, 8, 8,22, 8,15,                           &
               15,                                                      &
                1, 1,43, 1, 8, 1, 8,36,36, 1,                           &
               15, 1,15,29,29, 8, 8,29, 1,22,                           &
               22, 8,15, 8,15,22,22,15/                                  
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,                           &
                3, 0, 0, 2, 2, 1, 0, 1, 0, 1,                           &
                4, 0, 0, 3, 3, 1, 0, 1, 0, 2,                           &
                2, 0, 2, 1, 1,                                          &
                5, 0, 0, 4, 4, 1, 0, 1, 0, 3,                           &
                3, 2, 0, 2, 0, 3, 1, 1, 2, 2,                           &
                1,                                                      &
                6, 0, 0, 5, 5, 1, 0, 1, 0, 4,                           &
                4, 2, 0, 2, 0, 4, 1, 1, 3, 3,                           &
                0, 3, 3, 2, 1, 2, 1, 2/                                  
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,                           &
                0, 3, 0, 1, 0, 2, 2, 0, 1, 1,                           &
                0, 4, 0, 1, 0, 3, 3, 0, 1, 2,                           &
                0, 2, 1, 2, 1,                                          &
                0, 5, 0, 1, 0, 4, 4, 0, 1, 2,                           &
                0, 3, 3, 0, 2, 1, 3, 1, 2, 1,                           &
                2,                                                      &
                0, 6, 0, 1, 0, 5, 5, 0, 1, 2,                           &
                0, 4, 4, 0, 2, 1, 4, 1, 3, 0,                           &
                3, 2, 1, 3, 3, 1, 2, 2/                                  
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,                           &
                0, 0, 3, 0, 1, 0, 1, 2, 2, 1,                           &
                0, 0, 4, 0, 1, 0, 1, 3, 3, 0,                           &
                2, 2, 1, 1, 2,                                          &
                0, 0, 5, 0, 1, 0, 1, 4, 4, 0,                           &
                2, 0, 2, 3, 3, 1, 1, 3, 1, 2,                           &
                2,                                                      &
                0, 0, 6, 0, 1, 0, 1, 5, 5, 0,                           &
                2, 0, 2, 4, 4, 1, 1, 4, 0, 3,                           &
                3, 1, 2, 1, 2, 3, 3, 2/
!
      PARAMETER (SQRT3 = 1.73205080756887729353D+00)
      PARAMETER (SQRT5 = 2.23606797749978969641D+00)
      PARAMETER (SQRT7 = 2.64575131106459059050D+00) 
      PARAMETER (SQRT11= 3.31662479035539984911D+00)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NIJ = 784*NVAL                                                    
      TOL = 20*2.30258D0
      NORMA = .TRUE.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO III=1,NSHELL                                               
       I    = KATOM(III)                                                  
       XI   = Cxyz(1,I)                                                     
       YI   = Cxyz(2,I)                                                     
       ZI   = Cxyz(3,I)                                                     
       I1   = KSTART(III)                                                 
       I2   = I1 + KNG(III) - 1                                           
       LIT  = KTYPE(III)                                                  
       MINI = KMIN(III)                                                   
       MAXI = KMAX(III)                                                   
       LOCI = KLOC(III) - MINI                                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                      
       DO JJ=1,III                                                   
        J    = KATOM(JJ)                                                  
        XJ   = Cxyz(1,J)                                                     
        YJ   = Cxyz(2,J)                                                     
        ZJ   = Cxyz(3,J)                                                     
        J1   = KSTART(JJ)                                                 
        J2   = J1 + KNG(JJ) - 1                                           
        LJT  = KTYPE(JJ)                                                  
        MINJ = KMIN(JJ)                                                   
        MAXJ = KMAX(JJ)                                                   
        LOCJ = KLOC(JJ) - MINJ                                            
        RR = (XI-XJ)**2 + (YI-YJ)**2 + (ZI-ZJ)**2                     
        IIIandJJJ = III==JJ                                                 
        CALL VCLR(WINT,1,NIJ)                                             
        IJ = 0                                                            
        MAX = MAXJ                                                        
        DO I=MINI,MAXI                                               
         NIX = IX(I)                                                     
         NIY = IY(I)                                                     
         NIZ = IZ(I)                                                     
         IF (IIIandJJJ) MAX = I                                             
         DO J=MINJ,MAX                                             
          IJ = IJ+1                                                   
          IJX(IJ) = NIX+JX(J)                                          
          IJY(IJ) = NIY+JY(J)                                          
          IJZ(IJ) = NIZ+JZ(J)                                          
         END DO
        END DO
!
        JGMAX = J2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                        
        DO IG=I1,I2                                                   
         AI  = EX(IG)                                                      
         CSI = CS(IG)                                                      
         CPI = CP(IG)                                                      
         CDI = CD(IG)                                                      
         CFI = CF(IG)                                                      
         CGI = CG(IG)                                                      
         CHI = CH(IG)                                                      
         CII = CI(IG)                                                      
         IF(IIIandJJJ)JGMAX = IG                                             
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         DO JG=J1,JGMAX                                                
          AJ  = EX(JG)                                                      
          CSJ = CS(JG)                                                      
          CPJ = CP(JG)                                                      
          CDJ = CD(JG)                                                      
          CFJ = CF(JG)                                                      
          CGJ = CG(JG)                                                      
          CHJ = CH(JG)                                                      
          CIJ = CI(JG)                                                      
          AA  = AI + AJ                                                     
          AA1 = 1.0d0/AA                                                      
          AX  = (AI*XI + AJ*XJ)*AA1                                         
          AY  = (AI*YI + AJ*YJ)*AA1                                         
          AZ  = (AI*ZI + AJ*ZJ)*AA1                                         
          DUM = AI*AJ*RR*AA1                                                
          IF(DUM<=TOL)THEN
           FAC = EXP(-DUM)                                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!          Density Factors
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           DOUBLE = IIIandJJJ.and.IG/=JG                                       
           MAX = MAXJ                                                        
           NN  = 0                                                           
           DUM1 = 0.0D+00                                                       
           DUM2 = 0.0D+00                                                       
           DO I = MINI,MAXI                                              
            IF( I==1)            DUM1 = CSI*FAC                          
            IF( I==2)            DUM1 = CPI*FAC                          
            IF( I==5)            DUM1 = CDI*FAC                          
            IF( I==8  .and.NORMA)DUM1 = DUM1*SQRT3                       
            IF( I==11)           DUM1 = CFI*FAC                          
            IF((I==14).and.NORMA)DUM1 = DUM1*SQRT5                       
            IF((I==20).and.NORMA)DUM1 = DUM1*SQRT3                       
            IF( I==21)           DUM1 = CGI*FAC                          
            IF((I==24).and.NORMA)DUM1 = DUM1*SQRT7                       
            IF((I==30).and.NORMA)DUM1 = DUM1*SQRT5/SQRT3                 
            IF((I==33).and.NORMA)DUM1 = DUM1*SQRT3                       
            IF( I==36)           DUM1 = CHI*FAC                          
            IF((I==39).and.NORMA)DUM1 = DUM1*3.0d0                       
            IF((I==45).and.NORMA)DUM1 = DUM1*SQRT7/SQRT3                 
            IF((I==51).and.NORMA)DUM1 = DUM1*SQRT3                       
            IF((I==54).and.NORMA)DUM1 = DUM1*SQRT5/SQRT3                 
            IF( I==57)           DUM1 = CII*FAC                          
            IF((I==60).and.NORMA)DUM1 = DUM1*SQRT11                      
            IF((I==66).and.NORMA)DUM1 = DUM1*3.0d0/SQRT3                 
            IF((I==72).and.NORMA)DUM1 = DUM1*SQRT3                       
            IF((I==75).and.NORMA)DUM1 = DUM1*SQRT7/(SQRT3*SQRT5)         
            IF((I==78).and.NORMA)DUM1 = DUM1*SQRT5                       
            IF((I==84).and.NORMA)DUM1 = DUM1*SQRT5/SQRT3                 
            IF(IIIandJJJ)MAX = I                                              
!---------------------------------------------------------------
            DO J = MINJ,MAX                                            
             NN = NN+1                                                   
             IF(J==1) THEN                                             
               DUM2 = DUM1*CSJ                                           
               IF(DOUBLE .and. I==1) DUM2 = DUM2 + DUM2                
               IF(DOUBLE .and. I>1) DUM2 = DUM2 + CSI*CPJ*FAC         
             ELSE IF( J==2) THEN                                       
               DUM2 = DUM1*CPJ                                           
               IF(DOUBLE) DUM2 = DUM2 + DUM2                             
             ELSE IF( J==5) THEN                                       
               DUM2 = DUM1*CDJ                                           
               IF(DOUBLE) DUM2 = DUM2 + DUM2                             
             ELSE IF((J==8).and.NORMA) THEN                             
               DUM2 = DUM2*SQRT3                                         
             ELSE IF (J==11) THEN                                      
               DUM2 = DUM1*CFJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==14).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5                                         
             ELSE IF((J==20).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF(J==21) THEN                                       
               DUM2 = DUM1*CGJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==24).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT7                                         
             ELSE IF((J==30).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5/SQRT3                                   
             ELSE IF((J==33).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF( J==36) THEN                                      
               DUM2 = DUM1*CHJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==39).and.NORMA) THEN                            
               DUM2 = DUM2*3.0d0                                         
             ELSE IF((J==45).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT7/SQRT3                                   
             ELSE IF((J==51).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF((J==54).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5/SQRT3                                   
             ELSE IF( J==57) THEN                                      
               DUM2 = DUM1*CIJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==60).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT11                                        
             ELSE IF((J==66).and.NORMA) THEN                            
               DUM2 = DUM2*3.0d0/SQRT3                                   
             ELSE IF((J==72).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF((J==75).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT7/(SQRT3*SQRT5)                           
             ELSE IF((J==78).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5                                         
             ELSE IF((J==84).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5/SQRT3                                   
             END IF                                                      
             DIJ(NN) = DUM2                                              
            END DO
!---------------------------------------------------------------
           END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!          Integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
           CALL INTMOM(LIT,LJT,IJ,IJX,IJY,IJZ,DIJ,WINT,AA,AX,AY,AZ)        
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
          END IF
         END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        MAX = MAXJ                                                        
        DO K=1,NVAL                                                  
         NL2 = (K-1)*L2                                                 
         NN  = (K-1)*IJ                                                 
         DO I=MINI,MAXI                                            
          LI = LOCI + I                                               
          IN = LI*(LI-1)/2 + NL2                                      
          IF (IIIandJJJ) MAX = I                                          
          DO J=MINJ,MAX                                          
           LJ = LOCJ + J                                            
           JN = LJ + IN                                             
           NN = NN+1                                                
           XVAL(JN) = WINT(NN)                                      
          END DO
         END DO
        END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! INIINTQUAD
      SUBROUTINE INIINTQUAD
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DOUBLE PRECISION,PARAMETER :: SQRT3 = 1.73205080756887729353D0
      DOUBLE PRECISION,PARAMETER :: SQRT5 = 2.23606797749978969641D0
      DOUBLE PRECISION,PARAMETER :: SQRT7 = 2.64575131106459059050D0
      DOUBLE PRECISION,PARAMETER :: SQRT9 = 3.00000000000000000000D0
      DOUBLE PRECISION,PARAMETER :: SQRT11 = 3.31662479035539984911D0
      DOUBLE PRECISION,PARAMETER :: PI = 3.141592653589793238D0      
      COMMON/HERMIT/H1(55),W1(55)
      COMMON/RYSPAR/XASYMP(13),RTSASY(13,13),WTSASY(13,13),             &
                    NAUXS(13),MAPRYS(13),RTSAUX(55,8),WTSAUX(55,8)
      COMMON/SHLNRM/PNRM(84)     
      DOUBLE PRECISION,DIMENSION(55)::RTS,WTS,WRK
      DOUBLE PRECISION,DIMENSION(0:54)::ALPHA1,BETA1
!-----------------------------------------------------------------------
!     Set up the primitive factors for the 1e- integrals.
!     Initialize for the integral quadratures.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SQRT53 = SQRT5/SQRT3
      SQRT73 = SQRT7/SQRT3
      SQRT75 = SQRT7/SQRT5
      SQRT753 = SQRT75/SQRT3
      do i=1,84
       if(i==1.or.i==2.or.i==5.or.i==11.or.i==21.or.i==36.or.i==57)then
        PNRMi = 1.0D0
       elseif(i==8.or.i==20.or.i==33)then
        PNRMi = PNRMi*SQRT3
       elseif(i==14)then
        PNRMi = PNRMi*SQRT5
       elseif(i==24)then
        PNRMi = PNRMi*SQRT7
       elseif(i==30)then
        PNRMi = PNRMi*SQRT53
       elseif(i==39)then
        PNRMi = PNRMi*SQRT9
       elseif(i==45)then
        PNRMi = PNRMi*SQRT73
       elseif(i==51)then
        PNRMi = PNRMi*SQRT3
       elseif(i==54)then
        PNRMi = PNRMi*SQRT53
       elseif(i==60)then
        PNRMi = PNRMi*SQRT11
       elseif(i==66)then
        PNRMi = PNRMi*SQRT3
       elseif(i==72)then
        PNRMi = PNRMi*SQRT3
       elseif(i==75)then
        PNRMi = PNRMi*SQRT753
       elseif(i==78)then
        PNRMi = PNRMi*SQRT5
       elseif(i==84)then
        PNRMi = PNRMi*SQRT53
       endif
       PNRM(i) = PNRMi
      enddo
!-----------------------------------------------------------------------
!     Initialize the RYS quadrature procedure
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      QUART = 0.25D0
      EPS   = 1.0D-14
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Roots of the Hermite Polynomials of order 2n
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XASYMP( 1)=29.0D0
      XASYMP( 2)=37.0D0
      XASYMP( 3)=43.0D0
      XASYMP( 4)=49.0D0
      XASYMP( 5)=55.0D0
      XASYMP( 6)=60.0D0
      XASYMP( 7)=65.0D0
      XASYMP( 8)=71.0D0
      XASYMP( 9)=76.0D0
      XASYMP(10)=81.0D0
      XASYMP(11)=86.0D0
      XASYMP(12)=91.0D0
      XASYMP(13)=96.0D0
!
      DO I=1,13
       N=2*I
       DO J=0,N-1
        ALPHA1(J) = 0.0D0
       ENDDO
       BETA1(0)=SQRT(PI)
       DO J=1,N-1
        BETA1(J) = J/2.0D0
       END DO
!      QL Procedure
       CALL RYSGW(N,ALPHA1,BETA1,EPS,RTS,WTS,IERR,WRK)
       DO J=1,I
        RTSASY(J,I) = RTS(I+J)*RTS(I+J)
        WTSASY(J,I) = WTS(I+J)
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Auxiliary Grids
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NAUXS( 1)=20
      NAUXS( 2)=25
      NAUXS( 3)=30
      NAUXS( 4)=30
      NAUXS( 5)=35
      NAUXS( 6)=40
      NAUXS( 7)=40
      NAUXS( 8)=40
      NAUXS( 9)=45
      NAUXS(10)=50
      NAUXS(11)=50
      NAUXS(12)=55
      NAUXS(13)=55
!
      MAPRYS( 1)=1
      MAPRYS( 2)=2
      MAPRYS( 3)=3
      MAPRYS( 4)=3
      MAPRYS( 5)=4
      MAPRYS( 6)=5
      MAPRYS( 7)=5
      MAPRYS( 8)=5
      MAPRYS( 9)=6
      MAPRYS(10)=7
      MAPRYS(11)=7
      MAPRYS(12)=8
      MAPRYS(13)=8
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Auxiliary Quadrature = Shifted Legendre
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NAUXSV=0
      IGRID=0
      DO 1 M=1,13
       NAUX=NAUXS(M)
       IF(NAUX==NAUXSV)GOTO 1
       IGRID=IGRID+1
       NAUXSV=NAUX
       DO I=0,NAUX-1
        ALPHA1(I) = 0.5D0
       ENDDO
       BETA1(0)= 1.0D0
       DO I=1,NAUX-1
        BETA1(I) = QUART/(4.0D0-(1.0D0/(I*I)))
       END DO
!      QL Procedure
       CALL RYSGW(NAUX,ALPHA1,BETA1,EPS,RTS,WTS,IERR,WRK)
       DO I=1,NAUX
        RTSAUX(I,IGRID) = RTS(I)
        WTSAUX(I,IGRID) = WTS(I)
       ENDDO
    1 CONTINUE
!-----------------------------------------------------------------------
!     Initialize Roots and Weights for Gauss-Hermite quadrature
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL SETHERMITE(H1,W1)
!-----------------------------------------------------------------------
      RETURN
      END
      
! SETHERMITE
      SUBROUTINE SETHERMITE(HTOTAL,WTOTAL)                                             
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION,DIMENSION(55),INTENT(OUT)::HTOTAL,WTOTAL
!                                                                       
      HTOTAL(1)=  0.0D0
!                                                                       
      HTOTAL(2)= -0.70710678118654752440D0                                  
      HTOTAL(3)=  0.70710678118654752440D0                                  
!                                                                       
      HTOTAL(4)= -1.22474487139158904910D0                                  
      HTOTAL(5)=  0.0D0                                                        
      HTOTAL(6)=  1.22474487139158904910D0                                  
!                                                                       
      HTOTAL(7)= -1.65068012388578455588D0                                  
      HTOTAL(8)= -0.52464762327529031788D0                                  
      HTOTAL(9)=  0.52464762327529031788D0                                  
      HTOTAL(10)=  1.65068012388578455588D0                                  
!                                                                       
      HTOTAL(11)= -2.02018287045608563293D0                                  
      HTOTAL(12)= -0.95857246461381850711D0                                  
      HTOTAL(13)=  0.0D0                                                        
      HTOTAL(14)=  0.95857246461381850711D0                                  
      HTOTAL(15)=  2.02018287045608563293D0                                  
!                                                                       
      HTOTAL(16)= -2.35060497367449222283D0                                  
      HTOTAL(17)= -1.33584907401369694971D0                                  
      HTOTAL(18)= -0.43607741192761650868D0                                  
      HTOTAL(19)=  0.43607741192761650868D0                                  
      HTOTAL(20)=  1.33584907401369694971D0                                  
      HTOTAL(21)=  2.35060497367449222283D0                                  
!                                                                       
      HTOTAL(22)= -2.65196135683523349245D0                                  
      HTOTAL(23)= -1.67355162876747144503D0                                  
      HTOTAL(24)= -0.81628788285896466304D0                                  
      HTOTAL(25)= 0.0D0                                                         
      HTOTAL(26)=  0.81628788285896466304D0                                  
      HTOTAL(27)=  1.67355162876747144503D0                                  
      HTOTAL(28)=  2.65196135683523349245D0                                  
!                                                                       
      HTOTAL(29)= -2.93063742025724401922D0                                  
      HTOTAL(30)= -1.98165675669584292585D0                                  
      HTOTAL(31)= -1.15719371244678019472D0                                  
      HTOTAL(32)= -0.38118699020732211685D0                                  
      HTOTAL(33)=  0.38118699020732211685D0                                  
      HTOTAL(34)=  1.15719371244678019472D0                                  
      HTOTAL(35)=  1.98165675669584292585D0                                  
      HTOTAL(36)=  2.93063742025724401922D0                                  
!
      HTOTAL(37)= -3.19099320178152760723D0                                  
      HTOTAL(38)= -2.26658058453184311180D0                                  
      HTOTAL(39)= -1.46855328921666793167D0                                  
      HTOTAL(40)= -0.72355101875283757332D0                                  
      HTOTAL(41)= 0.0D0                                                         
      HTOTAL(42)=  0.72355101875283757332D0                                  
      HTOTAL(43)=  1.46855328921666793167D0                                  
      HTOTAL(44)=  2.26658058453184311180D0                                  
      HTOTAL(45)=  3.19099320178152760723D0                                  
!                                                                       
      HTOTAL(46)=  -3.43615911883773760333D0                                
      HTOTAL(47)=  -2.53273167423278979641D0                                
      HTOTAL(48)=  -1.75668364929988177345D0                                
      HTOTAL(49)=  -1.03661082978951365418D0                                
      HTOTAL(50)=  -0.34290132722370460879D0                                
      HTOTAL(51)=   0.34290132722370460879D0                                
      HTOTAL(52)=   1.03661082978951365418D0                                
      HTOTAL(53)=   1.75668364929988177345D0                                
      HTOTAL(54)=   2.53273167423278979641D0                                
      HTOTAL(55)=  3.43615911883773760333D0                                
!                                                                       
      WTOTAL(1)= 1.77245385090551602730D0  ! SQRT(PI)                       
!                                                                       
      WTOTAL(2)= 8.86226925452758013649D-01                                   
      WTOTAL(3)= 8.86226925452758013649D-01                                   
!                                                                       
      WTOTAL(4)= 2.95408975150919337883D-01                                   
      WTOTAL(5)= 1.18163590060367735153D0                                   
      WTOTAL(6)= 2.95408975150919337883D-01                                   
!                                                                       
      WTOTAL(7)= 8.13128354472451771430D-02                                   
      WTOTAL(8)= 8.04914090005512836506D-01                                   
      WTOTAL(9)= 8.04914090005512836506D-01                                   
      WTOTAL(10)= 8.13128354472451771430D-02                                   
!                                                                       
      WTOTAL(11)= 1.99532420590459132077D-02                                   
      WTOTAL(12)= 3.93619323152241159828D-01                                   
      WTOTAL(13)= 9.45308720482941881226D-01                                   
      WTOTAL(14)= 3.93619323152241159828D-01                                   
      WTOTAL(15)= 1.99532420590459132077D-02                                   
!                                                                       
      WTOTAL(16)= 4.53000990550884564086D-03                                   
      WTOTAL(17)= 1.57067320322856643916D-01                                   
      WTOTAL(18)= 7.24629595224392524092D-01                                   
      WTOTAL(19)= 7.24629595224392524092D-01                                   
      WTOTAL(20)= 1.57067320322856643916D-01                                   
      WTOTAL(21)= 4.53000990550884564086D-03                                   
!                                                                       
      WTOTAL(22)= 9.71781245099519154149D-04                                   
      WTOTAL(23)= 5.45155828191270305922D-02                                   
      WTOTAL(24)= 4.25607252610127800520D-01                                   
      WTOTAL(25)= 8.10264617556807326765D-01                                   
      WTOTAL(26)= 4.25607252610127800520D-01                                   
      WTOTAL(27)= 5.45155828191270305922D-02                                   
      WTOTAL(28)= 9.71781245099519154149D-04                                   
!                                                                      
      WTOTAL(29)= 1.99604072211367619206D-04                                   
      WTOTAL(30)= 1.70779830074134754562D-02                                   
      WTOTAL(31)= 2.07802325814891879543D-01                                   
      WTOTAL(32)= 6.61147012558241291030D-01                                   
      WTOTAL(33)= 6.61147012558241291030D-01                                   
      WTOTAL(34)= 2.07802325814891879543D-01                                   
      WTOTAL(35)= 1.70779830074134754562D-02                                   
      WTOTAL(36)= 1.99604072211367619206D-04                                   
!                                                                       
      WTOTAL(37)= 3.96069772632643819046D-05                                   
      WTOTAL(38)= 4.94362427553694721722D-03                                   
      WTOTAL(39)= 8.84745273943765732880D-02                                   
      WTOTAL(40)= 4.32651559002555750200D-01                                   
      WTOTAL(41)= 7.20235215606050957124D-01                                   
      WTOTAL(42)= 4.32651559002555750200D-01                                   
      WTOTAL(43)= 8.84745273943765732880D-02                                   
      WTOTAL(44)= 4.94362427553694721722D-03                                   
      WTOTAL(45)= 3.96069772632643819046D-05                                   
!                                                                       
      WTOTAL(46)= 7.64043285523262062916D-06                                 
      WTOTAL(47)= 1.34364574678123269220D-03                                 
      WTOTAL(48)= 3.38743944554810631362D-02                                 
      WTOTAL(49)= 2.40138611082314686417D-01                                 
      WTOTAL(50)= 6.10862633735325798784D-01                                 
      WTOTAL(51)= 6.10862633735325798784D-01                                 
      WTOTAL(52)= 2.40138611082314686417D-01                                 
      WTOTAL(53)= 3.38743944554810631362D-02                                 
      WTOTAL(54)= 1.34364574678123269220D-03                                 
      WTOTAL(55)= 7.64043285523262062916D-06                                 
!-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END        

! STVINT                                           
      SUBROUTINE STVINT(HH,WW)                                                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION HH(28),WW(28),MINIMO(7),MAXIMO(7)  
      COMMON/STV/XINTT,YINTT,ZINTT,TAA,X0X0,Y0Y0,Z0Z0,                  &
                 XIXI,YIYI,ZIZI,XJXJ,YJYJ,ZJZJ,NINI,NJNJ      
      DATA MINIMO /1,2,4,7,11,16,22/                                       
      DATA MAXIMO /1,3,6,10,15,21,28/                                      
!-----------------------------------------------------------------------
!     Gauss-Hermite Quadrature
!-----------------------------------------------------------------------
      XINTT = 0.0D0                                                       
      YINTT = 0.0D0                                                       
      ZINTT = 0.0D0                                                       
      NPTS = (NINI+NJNJ-2)/2+1                                              
      IMIN = MINIMO(NPTS)                                                  
      IMAX = MAXIMO(NPTS)                                                  
      DO I = IMIN,IMAX                                              
       DUM = WW(I)                                                     
       PX = DUM                                                       
       PY = DUM                                                       
       PZ = DUM                                                       
       DUM = HH(I)*TAA                                                   
       IF(NINI>1) THEN                                               
        AX = DUM+X0X0-XIXI                                              
        AY = DUM+Y0Y0-YIYI                                              
        AZ = DUM+Z0Z0-ZIZI                                              
        GO TO (16,15,14,13,12,11,10),NINI                         
   10   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   11   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   12   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   13   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   14   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   15   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
       END IF                                                         
   16  CONTINUE                                                       
       IF(NJNJ>1) THEN                                               
        BX = DUM+X0X0-XJXJ                                              
        BY = DUM+Y0Y0-YJYJ                                              
        BZ = DUM+Z0Z0-ZJZJ                                              
        GO TO (27,26,25,24,23,22,21,20),NJNJ                  
   20   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   21   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   22   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   23   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   24   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   25   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   26   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
       END IF                                                         
   27  CONTINUE                                                       
       XINTT = XINTT + PX                                           
       YINTT = YINTT + PY                                           
       ZINTT = ZINTT + PZ                                           
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! SETCONI
      SUBROUTINE SETCONI(CONI,IPP,CS,CP,CD,CF,CG,CH,CI,NPRIMI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION CONI(*),KARTEN(0:6)
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: CS,CP,CD,CF,CG,CH,CI
      DATA KARTEN/1,3,6,10,15,21,28/
!-----------------------------------------------------------------------
      CONI(1) = CS(IPP)
      CALL DACOPY(KARTEN(1),CP(IPP),CONI(2),1)
      CALL DACOPY(KARTEN(2),CD(IPP),CONI(5),1)
      CALL DACOPY(KARTEN(3),CF(IPP),CONI(11),1)
      CALL DACOPY(KARTEN(4),CG(IPP),CONI(21),1)
      CALL DACOPY(KARTEN(5),CH(IPP),CONI(36),1)
      CALL DACOPY(KARTEN(6),CI(IPP),CONI(57),1)
!-----------------------------------------------------------------------
      RETURN
      END
            
! DACOPY                                           
      SUBROUTINE DACOPY(N,DA,DX,INCX)                                   
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION DX(*)                                                   
!-----------------------------------------------------------------------
!     INITIALISES A VECTOR WITH A CONSTANT: DX(I) <== DA                                                
!-----------------------------------------------------------------------
      IF(N<=0)RETURN                                                  
      IF(INCX/=1)THEN
       IX = 1                                                            
       IF(INCX<0)IX=(-N+1)*INCX + 1                                 
       DO I = 1,N                                                     
        DX(IX) = DA                                                     
        IX = IX + INCX                                                  
       END DO
       RETURN                                                            
      END IF
      M = MOD(N,7)                                                      
      IF(M/=0)THEN
       DO I = 1,M                                                     
        DX(I)=DA                                                        
       END DO
       IF(N<7)RETURN
      END IF                                             
      MP1 = M + 1                                                       
      DO I = MP1,N,7                                                 
       DX(I)=DA                                                        
       DX(I + 1)=DA                                                    
       DX(I + 2)=DA                                                    
       DX(I + 3)=DA                                                    
       DX(I + 4)=DA                                                    
       DX(I + 5)=DA                                                    
       DX(I + 6)=DA                                                    
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! Calling by HSandT & ERISPDFGHIL: RT123 
      SUBROUTINE RT123
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROOT  / X,U(13),W(13),NROOTS
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
      DATA R12,PIE4/2.75255128608411D-01, 7.85398163397448D-01/
      DATA R22,W22/ 2.72474487139158D+00, 9.17517095361369D-02/
      DATA R13/     1.90163509193487D-01/
      DATA R23,W23/ 1.78449274854325D+00, 1.77231492083829D-01/
      DATA R33,W33/ 5.52534374226326D+00, 5.11156880411248D-03/
!
      IF (X > 5.0D+00) GO TO 400
      IF (X > 1.0D+00) GO TO 280
      IF (X > 3.0D-07) GO TO 180
!     X IS APPROXIMATELY 0.0d0.         NROOTS=1,2, OR 3
      IF (NROOTS-2) 120,140,160
  120 RT1 = 0.5D+00 -X/5.0D+00
      WW1 = 1.0D+00 -X/3.0D+00
      RETURN
  140 RT1 = 1.30693606237085D-01 -2.90430236082028D-02 *X
      RT2 = 2.86930639376291D+00 -6.37623643058102D-01 *X
      WW1 = 6.52145154862545D-01 -1.22713621927067D-01 *X
      WW2 = 3.47854845137453D-01 -2.10619711404725D-01 *X
      RETURN
  160 RT1 = 6.03769246832797D-02 -9.28875764357368D-03 *X
      RT2 = 7.76823355931043D-01 -1.19511285527878D-01 *X
      RT3 = 6.66279971938567D+00 -1.02504611068957D+00 *X
      WW1 = 4.67913934572691D-01 -5.64876917232519D-02 *X
      WW2 = 3.60761573048137D-01 -1.49077186455208D-01 *X
      WW3 = 1.71324492379169D-01 -1.27768455150979D-01 *X
      RETURN
!     X = 0.0 TO 1.0                   NROOTS=1,2, OR 3
  180 IF (NROOTS == 3) GO TO 220
      F1 = ((((((((-8.36313918003957D-08*X+1.21222603512827D-06 )*X-    &
           1.15662609053481D-05 )*X+9.25197374512647D-05 )*X-           &
           6.40994113129432D-04 )*X+3.78787044215009D-03 )*X-           &
           1.85185172458485D-02 )*X+7.14285713298222D-02 )*X-           &
           1.99999999997023D-01 )*X+3.33333333333318D-01                 
      WW1 = (X+X)*F1+EXP(-X)                                             
      IF (NROOTS == 2) GO TO 200                                         
      RT1 = F1/(WW1-F1)                                                  
      RETURN                                                             
  200 RT1 = (((((((-2.35234358048491D-09*X+2.49173650389842D-08)*X-     &
           4.558315364581D-08)*X-2.447252174587D-06)*X+                 &
           4.743292959463D-05)*X-5.33184749432408D-04 )*X+              &
           4.44654947116579D-03 )*X-2.90430236084697D-02 )*X+           &
           1.30693606237085D-01                                          
      RT2 = (((((((-2.47404902329170D-08*X+2.36809910635906D-07)*X+     &
           1.835367736310D-06)*X-2.066168802076D-05)*X-                 &
           1.345693393936D-04)*X-5.88154362858038D-05 )*X+              &
           5.32735082098139D-02 )*X-6.37623643056745D-01 )*X+           &
           2.86930639376289D+00                                          
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                    
      WW1 = WW1-WW2                                                      
      RETURN                                                             
  220 RT1 = ((((((-5.10186691538870D-10*X+2.40134415703450D-08)*X-      &
           5.01081057744427D-07 )*X+7.58291285499256D-06 )*X-           &
           9.55085533670919D-05 )*X+1.02893039315878D-03 )*X-           &
           9.28875764374337D-03 )*X+6.03769246832810D-02                 
      RT2 = ((((((-1.29646524960555D-08*X+7.74602292865683D-08)*X+      &
           1.56022811158727D-06 )*X-1.58051990661661D-05 )*X-           &
           3.30447806384059D-04 )*X+9.74266885190267D-03 )*X-           &
           1.19511285526388D-01 )*X+7.76823355931033D-01                 
      RT3 = ((((((-9.28536484109606D-09*X-3.02786290067014D-07)*X-      &
           2.50734477064200D-06 )*X-7.32728109752881D-06 )*X+           &
           2.44217481700129D-04 )*X+4.94758452357327D-02 )*X-           &
           1.02504611065774D+00 )*X+6.66279971938553D+00                 
      F2 = ((((((((-7.60911486098850D-08*X+1.09552870123182D-06 )*X-    &
           1.03463270693454D-05 )*X+8.16324851790106D-05 )*X-           &
           5.55526624875562D-04 )*X+3.20512054753924D-03 )*X-           &
           1.51515139838540D-02 )*X+5.55555554649585D-02 )*X-           &
           1.42857142854412D-01 )*X+1.99999999999986D-01                 
  240 E = EXP(-X)                                                        
      F1 = ((X+X)*F2+E)/3.0D+00                                          
      WW1 = (X+X)*F1+E                                                   
  260 T1 = RT1/(RT1+1.0D+00)                                             
      T2 = RT2/(RT2+1.0D+00)                                             
      T3 = RT3/(RT3+1.0D+00)                                             
      A2 = F2-T1*F1                                                      
      A1 = F1-T1*WW1                                                     
      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1))                                 
      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1))                                 
      WW1 = WW1-WW2-WW3                                                  
      RETURN                                                             
  280 IF (X > 3.0D+00) GO TO 340                                         
!     X = 1.0 TO 3.0                   NROOTS=1,2, OR 3                  
      Y = X-2.0D+00                                                      
      IF (NROOTS == 3) GO TO 320                                         
      F1 = ((((((((((-1.61702782425558D-10*Y+1.96215250865776D-09 )*Y-  &
           2.14234468198419D-08 )*Y+2.17216556336318D-07 )*Y-           &
           1.98850171329371D-06 )*Y+1.62429321438911D-05 )*Y-           &
           1.16740298039895D-04 )*Y+7.24888732052332D-04 )*Y-           &
           3.79490003707156D-03 )*Y+1.61723488664661D-02 )*Y-           &
           5.29428148329736D-02 )*Y+1.15702180856167D-01                 
      WW1 = (X+X)*F1+EXP(-X)                                             
      IF (NROOTS == 2) GO TO 300                                         
      RT1 = F1/(WW1-F1)                                                  
      RETURN                                                             
  300 RT1 = (((((((((-6.36859636616415D-12*Y+8.47417064776270D-11)*Y-   &
           5.152207846962D-10)*Y-3.846389873308D-10)*Y+                 &
           8.472253388380D-08)*Y-1.85306035634293D-06 )*Y+              &
           2.47191693238413D-05 )*Y-2.49018321709815D-04 )*Y+           &
           2.19173220020161D-03 )*Y-1.63329339286794D-02 )*Y+           &
           8.68085688285261D-02                                          
      RT2 = ((((((((( 1.45331350488343D-10*Y+2.07111465297976D-09)*Y-   &
           1.878920917404D-08)*Y-1.725838516261D-07)*Y+                 &
           2.247389642339D-06)*Y+9.76783813082564D-06 )*Y-              &
           1.93160765581969D-04 )*Y-1.58064140671893D-03 )*Y+           &
           4.85928174507904D-02 )*Y-4.30761584997596D-01 )*Y+           &
           1.80400974537950D+00                                          
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                    
      WW1 = WW1-WW2                                                      
      RETURN                                                             
  320 RT1 = (((((((( 1.44687969563318D-12*Y+4.85300143926755D-12)*Y-    &
           6.55098264095516D-10 )*Y+1.56592951656828D-08 )*Y-           &
           2.60122498274734D-07 )*Y+3.86118485517386D-06 )*Y-           &
           5.13430986707889D-05 )*Y+6.03194524398109D-04 )*Y-           &
           6.11219349825090D-03 )*Y+4.52578254679079D-02                 
      RT2 = ((((((( 6.95964248788138D-10*Y-5.35281831445517D-09)*Y-     &
           6.745205954533D-08)*Y+1.502366784525D-06)*Y+                 &
           9.923326947376D-07)*Y-3.89147469249594D-04 )*Y+              &
           7.51549330892401D-03 )*Y-8.48778120363400D-02 )*Y+           &
           5.73928229597613D-01                                          
      RT3 = ((((((((-2.81496588401439D-10*Y+3.61058041895031D-09)*Y+    &
           4.53631789436255D-08 )*Y-1.40971837780847D-07 )*Y-           &
           6.05865557561067D-06 )*Y-5.15964042227127D-05 )*Y+           &
           3.34761560498171D-05 )*Y+5.04871005319119D-02 )*Y-           &
           8.24708946991557D-01 )*Y+4.81234667357205D+00                 
      F2 = ((((((((((-1.48044231072140D-10*Y+1.78157031325097D-09 )*Y-  &
           1.92514145088973D-08 )*Y+1.92804632038796D-07 )*Y-           &
           1.73806555021045D-06 )*Y+1.39195169625425D-05 )*Y-           &
           9.74574633246452D-05 )*Y+5.83701488646511D-04 )*Y-           &
           2.89955494844975D-03 )*Y+1.13847001113810D-02 )*Y-           &
           3.23446977320647D-02 )*Y+5.29428148329709D-02                 
      GO TO 240                                                          
!     X = 3.0 TO 5.0                   NROOTS =1,2, OR 3                 
  340 Y = X-4.0D+00                                                      
      IF (NROOTS == 3) GO TO 380                                         
      F1 = ((((((((((-2.62453564772299D-11*Y+3.24031041623823D-10 )*Y-  &
           3.614965656163D-09)*Y+3.760256799971D-08)*Y-                 &
           3.553558319675D-07)*Y+3.022556449731D-06)*Y-                 &
           2.290098979647D-05)*Y+1.526537461148D-04)*Y-                 &
           8.81947375894379D-04 )*Y+4.33207949514611D-03 )*Y-           &
           1.75257821619926D-02 )*Y+5.28406320615584D-02                 
      WW1 = (X+X)*F1+EXP(-X)                                             
      IF (NROOTS == 2) GO TO 360                                         
      RT1 = F1/(WW1-F1)                                                  
      RETURN                                                             
  360 RT1 = ((((((((-4.11560117487296D-12*Y+7.10910223886747D-11)*Y-    &
           1.73508862390291D-09 )*Y+5.93066856324744D-08 )*Y-           &
           9.76085576741771D-07 )*Y+1.08484384385679D-05 )*Y-           &
           1.12608004981982D-04 )*Y+1.16210907653515D-03 )*Y-           &
           9.89572595720351D-03 )*Y+6.12589701086408D-02                 
      RT2 = (((((((((-1.80555625241001D-10*Y+5.44072475994123D-10)*Y+   &
           1.603498045240D-08)*Y-1.497986283037D-07)*Y-                 &
           7.017002532106D-07)*Y+1.85882653064034D-05 )*Y-              &
           2.04685420150802D-05 )*Y-2.49327728643089D-03 )*Y+           &
           3.56550690684281D-02 )*Y-2.60417417692375D-01 )*Y+           &
           1.12155283108289D+00                                          
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                    
      WW1 = WW1-WW2                                                      
      RETURN                                                             
  380 RT1 = ((((((( 1.44265709189601D-11*Y-4.66622033006074D-10)*Y+     &
           7.649155832025D-09)*Y-1.229940017368D-07)*Y+                 &
           2.026002142457D-06)*Y-2.87048671521677D-05 )*Y+              &
           3.70326938096287D-04 )*Y-4.21006346373634D-03 )*Y+           &
           3.50898470729044D-02                                          
      RT2 = ((((((((-2.65526039155651D-11*Y+1.97549041402552D-10)*Y+    &
           2.15971131403034D-09 )*Y-7.95045680685193D-08 )*Y+           &
           5.15021914287057D-07 )*Y+1.11788717230514D-05 )*Y-           &
           3.33739312603632D-04 )*Y+5.30601428208358D-03 )*Y-           &
           5.93483267268959D-02 )*Y+4.31180523260239D-01                 
      RT3 = ((((((((-3.92833750584041D-10*Y-4.16423229782280D-09)*Y+    &
           4.42413039572867D-08 )*Y+6.40574545989551D-07 )*Y-           &
           3.05512456576552D-06 )*Y-1.05296443527943D-04 )*Y-           &
           6.14120969315617D-04 )*Y+4.89665802767005D-02 )*Y-           &
           6.24498381002855D-01 )*Y+3.36412312243724D+00                 
      F2 = ((((((((((-2.36788772599074D-11*Y+2.89147476459092D-10 )*Y-  &
           3.18111322308846D-09 )*Y+3.25336816562485D-08 )*Y-           &
           3.00873821471489D-07 )*Y+2.48749160874431D-06 )*Y-           &
           1.81353179793672D-05 )*Y+1.14504948737066D-04 )*Y-           &
           6.10614987696677D-04 )*Y+2.64584212770942D-03 )*Y-           &
           8.66415899015349D-03 )*Y+1.75257821619922D-02                 
      GO TO 240                                                          
  400 IF (X > 15.0D+00) GO TO 560                                        
      E = EXP(-X)                                                        
      IF (X > 10.0D+00) GO TO 480                                        
!     X = 5.0 TO 10.0                  NROOTS =1,2, OR 3                 
      WW1 = (((((( 4.6897511375022D-01/X-6.9955602298985D-01)/X +       &
           5.3689283271887D-01)/X-3.2883030418398D-01)/X +              &
           2.4645596956002D-01)/X-4.9984072848436D-01)/X -              &
           3.1501078774085D-06)*E + SQRT(PIE4/X)                         
      F1 = (WW1-E)/(X+X)                                                 
      IF (NROOTS-2) 420,440,460                                          
  420 RT1 = F1/(WW1-F1)                                                  
      RETURN                                                             
  440 Y = X-7.5D+00                                                      
      RT1 = (((((((((((((-1.43632730148572D-16*Y+2.38198922570405D-16)* &
           Y+1.358319618800D-14)*Y-7.064522786879D-14)*Y-               &
           7.719300212748D-13)*Y+7.802544789997D-12)*Y+                 &
           6.628721099436D-11)*Y-1.775564159743D-09)*Y+                 &
           1.713828823990D-08)*Y-1.497500187053D-07)*Y+                 &
           2.283485114279D-06)*Y-3.76953869614706D-05 )*Y+              &
           4.74791204651451D-04 )*Y-4.60448960876139D-03 )*Y+           &
           3.72458587837249D-02                                          
      RT2 = (((((((((((( 2.48791622798900D-14*Y-1.36113510175724D-13)*Y-&
           2.224334349799D-12)*Y+4.190559455515D-11)*Y-                 &
           2.222722579924D-10)*Y-2.624183464275D-09)*Y+                 &
           6.128153450169D-08)*Y-4.383376014528D-07)*Y-                 &
           2.49952200232910D-06 )*Y+1.03236647888320D-04 )*Y-           &
           1.44614664924989D-03 )*Y+1.35094294917224D-02 )*Y-           &
           9.53478510453887D-02 )*Y+5.44765245686790D-01                 
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                    
      WW1 = WW1-WW2                                                      
      RETURN                                                             
  460 F2 = (F1+F1+F1-E)/(X+X)                                            
      Y = X-7.5D+00                                                      
      RT1 = ((((((((((( 5.74429401360115D-16*Y+7.11884203790984D-16)*Y- &
           6.736701449826D-14)*Y-6.264613873998D-13)*Y+                 &
           1.315418927040D-11)*Y-4.23879635610964D-11 )*Y+              &
           1.39032379769474D-09 )*Y-4.65449552856856D-08 )*Y+           &
           7.34609900170759D-07 )*Y-1.08656008854077D-05 )*Y+           &
           1.77930381549953D-04 )*Y-2.39864911618015D-03 )*Y+           &
           2.39112249488821D-02                                          
      RT2 = ((((((((((( 1.13464096209120D-14*Y+6.99375313934242D-15)*Y- &
           8.595618132088D-13)*Y-5.293620408757D-12)*Y-                 &
           2.492175211635D-11)*Y+2.73681574882729D-09 )*Y-              &
           1.06656985608482D-08 )*Y-4.40252529648056D-07 )*Y+           &
           9.68100917793911D-06 )*Y-1.68211091755327D-04 )*Y+           &
           2.69443611274173D-03 )*Y-3.23845035189063D-02 )*Y+           &
           2.75969447451882D-01                                          
      RT3 = (((((((((((( 6.66339416996191D-15*Y+1.84955640200794D-13)*Y-&
           1.985141104444D-12)*Y-2.309293727603D-11)*Y+                 &
           3.917984522103D-10)*Y+1.663165279876D-09)*Y-                 &
           6.205591993923D-08)*Y+8.769581622041D-09)*Y+                 &
           8.97224398620038D-06 )*Y-3.14232666170796D-05 )*Y-           &
           1.83917335649633D-03 )*Y+3.51246831672571D-02 )*Y-           &
           3.22335051270860D-01 )*Y+1.73582831755430D+00                 
      GO TO 260                                                          
!     X = 10.0 TO 15.0                 NROOTS=1,2, OR 3                  
  480 WW1 = (((-1.8784686463512D-01/X+2.2991849164985D-01)/X -          &
           4.9893752514047D-01)/X-2.1916512131607D-05)*E + SQRT(PIE4/X)  
      F1 = (WW1-E)/(X+X)                                                 
      IF (NROOTS-2) 500,520,540                                          
  500 RT1 = F1/(WW1-F1)                                                  
      RETURN                                                             
  520 RT1 = ((((-1.01041157064226D-05*X+1.19483054115173D-03)*X -       &
           6.73760231824074D-02)*X+1.25705571069895D+00)*X + (((-       &
           8.57609422987199D+03/X+5.91005939591842D+03)/X -             &
           1.70807677109425D+03)/X+2.64536689959503D+02)/X -            &
           2.38570496490846D+01)*E + R12/(X-R12)                         
      RT2 = ((( 3.39024225137123D-04*X-9.34976436343509D-02)*X -        &
           4.22216483306320D+00)*X + (((-2.08457050986847D+03/X -       &
           1.04999071905664D+03)/X+3.39891508992661D+02)/X -            &
           1.56184800325063D+02)/X+8.00839033297501D+00)*E + R22/(X-R22) 
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                    
      WW1 = WW1-WW2                                                      
      RETURN                                                             
  540 F2 = (F1+F1+F1-E)/(X+X)                                            
      Y = X-12.5D+00                                                     
      RT1 = ((((((((((( 4.42133001283090D-16*Y-2.77189767070441D-15)*Y- &
           4.084026087887D-14)*Y+5.379885121517D-13)*Y+                 &
           1.882093066702D-12)*Y-8.67286219861085D-11 )*Y+              &
           7.11372337079797D-10 )*Y-3.55578027040563D-09 )*Y+           &
           1.29454702851936D-07 )*Y-4.14222202791434D-06 )*Y+           &
           8.04427643593792D-05 )*Y-1.18587782909876D-03 )*Y+           &
           1.53435577063174D-02                                          
      RT2 = ((((((((((( 6.85146742119357D-15*Y-1.08257654410279D-14)*Y- &
           8.579165965128D-13)*Y+6.642452485783D-12)*Y+                 &
           4.798806828724D-11)*Y-1.13413908163831D-09 )*Y+              &
           7.08558457182751D-09 )*Y-5.59678576054633D-08 )*Y+           &
           2.51020389884249D-06 )*Y-6.63678914608681D-05 )*Y+           &
           1.11888323089714D-03 )*Y-1.45361636398178D-02 )*Y+           &
           1.65077877454402D-01                                          
      RT3 = (((((((((((( 3.20622388697743D-15*Y-2.73458804864628D-14)*Y-&
           3.157134329361D-13)*Y+8.654129268056D-12)*Y-                 &
           5.625235879301D-11)*Y-7.718080513708D-10)*Y+                 &
           2.064664199164D-08)*Y-1.567725007761D-07)*Y-                 &
           1.57938204115055D-06 )*Y+6.27436306915967D-05 )*Y-           &
           1.01308723606946D-03 )*Y+1.13901881430697D-02 )*Y-           &
           1.01449652899450D-01 )*Y+7.77203937334739D-01                 
      GO TO 260                                                          
  560 IF (X > 33.0D+00) GO TO 660                                        
!     X = 15.0 TO 33.0                 NROOTS=1,2, OR 3                  
      E = EXP(-X)                                                        
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -           &
           6.0156581186481D-05)*E + SQRT(PIE4/X)                         
      F1 = (WW1-E)/(X+X)                                                 
      IF (NROOTS-2) 580,600,620                                          
  580 RT1 = F1/(WW1-F1)                                                  
      RETURN                                                             
  600 RT1 = ((((-1.14906395546354D-06*X+1.76003409708332D-04)*X -       &
           1.71984023644904D-02)*X-1.37292644149838D-01)*X + (-         &
           4.75742064274859D+01/X+9.21005186542857D+00)/X -             &
           2.31080873898939D-02)*E + R12/(X-R12)                         
      RT2 = ((( 3.64921633404158D-04*X-9.71850973831558D-02)*X -        &
           4.02886174850252D+00)*X + (-1.35831002139173D+02/X -         &
           8.66891724287962D+01)/X+2.98011277766958D+00)*E + R22/(X-R22) 
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                    
      WW1 = WW1-WW2                                                      
      RETURN                                                             
  620 F2 = (F1+F1+F1-E)/(X+X)                                            
      IF (X > 20.0D+00) GO TO 640                                        
      RT1 = ((((((-2.43270989903742D-06*X+3.57901398988359D-04)*X -     &
           2.34112415981143D-02)*X+7.81425144913975D-01)*X -            &
           1.73209218219175D+01)*X+2.43517435690398D+02)*X + (-         &
           1.97611541576986D+04/X+9.82441363463929D+03)/X -             &
           2.07970687843258D+03)*E + R13/(X-R13)                         
      RT2 = (((((-2.62627010965435D-04*X+3.49187925428138D-02)*X -      &
           3.09337618731880D+00)*X+1.07037141010778D+02)*X -            &
           2.36659637247087D+03)*X + ((-2.91669113681020D+06/X +        &
           1.41129505262758D+06)/X-2.91532335433779D+05)/X +            &
           3.35202872835409D+04)*E + R23/(X-R23)                         
      RT3 = ((((( 9.31856404738601D-05*X-2.87029400759565D-02)*X -      &
           7.83503697918455D-01)*X-1.84338896480695D+01)*X +            &
           4.04996712650414D+02)*X + (-1.89829509315154D+05/X +         &
           5.11498390849158D+04)/X-6.88145821789955D+03)*E + R33/(X-R33) 
      GO TO 260                                                          
  640 RT1 = ((((-4.97561537069643D-04*X-5.00929599665316D-02)*X +       &
           1.31099142238996D+00)*X-1.88336409225481D+01)*X -            &
           6.60344754467191D+02 /X+1.64931462413877D+02)*E + R13/(X-R13) 
      RT2 = ((((-4.48218898474906D-03*X-5.17373211334924D-01)*X +       &
           1.13691058739678D+01)*X-1.65426392885291D+02)*X -            &
           6.30909125686731D+03 /X+1.52231757709236D+03)*E + R23/(X-R23) 
      RT3 = ((((-1.38368602394293D-02*X-1.77293428863008D+00)*X +       &
           1.73639054044562D+01)*X-3.57615122086961D+02)*X -            &
           1.45734701095912D+04 /X+2.69831813951849D+03)*E + R33/(X-R33) 
      GO TO 260                                                          
!     X = 33.0 TO INFINITY             NROOTS=1,2, OR 3                  
  660 WW1 = SQRT(PIE4/X)                                                 
      IF (NROOTS-2) 680,700,720                                          
  680 RT1 = 0.5D+00/(X-0.5D+00)                                          
      RETURN                                                             
  700 IF (X > 40.0D+00) GO TO 740                                        
      E = EXP(-X)                                                        
      RT1 = (-8.78947307498880D-01*X+1.09243702330261D+01)*E + R12/(X-  &
           R12)                                                          
      RT2 = (-9.28903924275977D+00*X+8.10642367843811D+01)*E + R22/(X-  &
           R22)                                                          
      WW2 = ( 4.46857389308400D+00*X-7.79250653461045D+01)*E + W22*WW1   
      WW1 = WW1-WW2                                                      
      RETURN                                                             
  720 IF (X > 47.0D+00) GO TO 760                                        
      E = EXP(-X)                                                        
      RT1 = ((-7.39058467995275D+00*X+3.21318352526305D+02)*X -         &
           3.99433696473658D+03)*E + R13/(X-R13)                         
      RT2 = ((-7.38726243906513D+01*X+3.13569966333873D+03)*X -         &
           3.86862867311321D+04)*E + R23/(X-R23)                         
      RT3 = ((-2.63750565461336D+02*X+1.04412168692352D+04)*X -         &
           1.28094577915394D+05)*E + R33/(X-R33)                         
      WW3 = ((( 1.52258947224714D-01*X-8.30661900042651D+00)*X +        &
           1.92977367967984D+02)*X-1.67787926005344D+03)*E + W33*WW1     
      WW2 = (( 6.15072615497811D+01*X-2.91980647450269D+03)*X +         &
           3.80794303087338D+04)*E + W23*WW1
      WW1 = WW1-WW2-WW3
      RETURN
  740 RT1 = R12/(X-R12)
      RT2 = R22/(X-R22)
      WW2 = W22*WW1
      WW1 = WW1-WW2
      RETURN
  760 RT1 = R13/(X-R13)
      RT2 = R23/(X-R23)
      RT3 = R33/(X-R33)
      WW2 = W23*WW1
      WW3 = W33*WW1
      WW1 = WW1-WW2-WW3
      RETURN
      END

! Calling by HSandT & ERISPDFGHIL: ROOT4 
      SUBROUTINE ROOT4
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROOT  / X,U(13),W(13),NROOTS
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
      DATA R14,PIE4/1.45303521503316D-01, 7.85398163397448D-01/
      DATA R24,W24/ 1.33909728812636D+00, 2.34479815323517D-01/
      DATA R34,W34/ 3.92696350135829D+00, 1.92704402415764D-02/
      DATA R44,W44/ 8.58863568901199D+00, 2.25229076750736D-04/
!
      IF (X > 15.0D+00) GO TO 180
      IF (X > 5.0D+00) GO TO 140
      IF (X > 1.0D+00) GO TO 120
      IF (X > 3.0D-07) GO TO 100
!     X IS APPROXIMATELY 0.0d0.                   NROOTS = 4
      RT1 = 3.48198973061471D-02 -4.09645850660395D-03 *X
      RT2 = 3.81567185080042D-01 -4.48902570656719D-02 *X
      RT3 = 1.73730726945891D+00 -2.04389090547327D-01 *X
      RT4 = 1.18463056481549D+01 -1.39368301742312D+00 *X
      WW1 = 3.62683783378362D-01 -3.13844305713928D-02 *X
      WW2 = 3.13706645877886D-01 -8.98046242557724D-02 *X
      WW3 = 2.22381034453372D-01 -1.29314370958973D-01 *X
      WW4 = 1.01228536290376D-01 -8.28299075414321D-02 *X
      RETURN
!
!     X=0.0 TO 1.0                               NROOTS = 4
  100 RT1 = ((((((-1.95309614628539D-10*X+5.19765728707592D-09)*X-      &
           1.01756452250573D-07 )*X+1.72365935872131D-06 )*X-           &
           2.61203523522184D-05 )*X+3.52921308769880D-04 )*X-           &
           4.09645850658433D-03 )*X+3.48198973061469D-02                 
      RT2 = (((((-1.89554881382342D-08*X+3.07583114342365D-07)*X+       &
           1.270981734393D-06)*X-1.417298563884D-04)*X+                 &
           3.226979163176D-03)*X-4.48902570678178D-02 )*X+              &
           3.81567185080039D-01                                          
      RT3 = (((((( 1.77280535300416D-09*X+3.36524958870615D-08)*X-      &
           2.58341529013893D-07 )*X-1.13644895662320D-05 )*X-           &
           7.91549618884063D-05 )*X+1.03825827346828D-02 )*X-           &
           2.04389090525137D-01 )*X+1.73730726945889D+00                 
      RT4 = (((((-5.61188882415248D-08*X-2.49480733072460D-07)*X+       &
           3.428685057114D-06)*X+1.679007454539D-04)*X+                 &
           4.722855585715D-02)*X-1.39368301737828D+00 )*X+              &
           1.18463056481543D+01                                          
      WW1 = ((((((-1.14649303201279D-08*X+1.88015570196787D-07)*X-      &
           2.33305875372323D-06 )*X+2.68880044371597D-05 )*X-           &
           2.94268428977387D-04 )*X+3.06548909776613D-03 )*X-           &
           3.13844305680096D-02 )*X+3.62683783378335D-01                 
      WW2 = ((((((((-4.11720483772634D-09*X+6.54963481852134D-08)*X-    &
           7.20045285129626D-07 )*X+6.93779646721723D-06 )*X-           &
           6.05367572016373D-05 )*X+4.74241566251899D-04 )*X-           &
           3.26956188125316D-03 )*X+1.91883866626681D-02 )*X-           &
           8.98046242565811D-02 )*X+3.13706645877886D-01                 
      WW3 = ((((((((-3.41688436990215D-08*X+5.07238960340773D-07)*X-    &
           5.01675628408220D-06 )*X+4.20363420922845D-05 )*X-           &
           3.08040221166823D-04 )*X+1.94431864731239D-03 )*X-           &
           1.02477820460278D-02 )*X+4.28670143840073D-02 )*X-           &
           1.29314370962569D-01 )*X+2.22381034453369D-01                 
      WW4 = ((((((((( 4.99660550769508D-09*X-7.94585963310120D-08)*X+   &
           8.359072409485D-07)*X-7.422369210610D-06)*X+                 &
           5.763374308160D-05)*X-3.86645606718233D-04 )*X+              &
           2.18417516259781D-03 )*X-9.99791027771119D-03 )*X+           &
           3.48791097377370D-02 )*X-8.28299075413889D-02 )*X+           &
           1.01228536290376D-01                                          
      RETURN
!                                                                        
!     X= 1.0 TO 5.0                              NROOTS = 4              
  120 Y = X-3.0D+00                                                      
      RT1 = (((((((((-1.48570633747284D-15*Y-1.33273068108777D-13)*Y+   &
           4.068543696670D-12)*Y-9.163164161821D-11)*Y+                 &
           2.046819017845D-09)*Y-4.03076426299031D-08 )*Y+              &
           7.29407420660149D-07 )*Y-1.23118059980833D-05 )*Y+           &
           1.88796581246938D-04 )*Y-2.53262912046853D-03 )*Y+           &
           2.51198234505021D-02                                          
      RT2 = ((((((((( 1.35830583483312D-13*Y-2.29772605964836D-12)*Y-   &
           3.821500128045D-12)*Y+6.844424214735D-10)*Y-                 &
           1.048063352259D-08)*Y+1.50083186233363D-08 )*Y+              &
           3.48848942324454D-06 )*Y-1.08694174399193D-04 )*Y+           &
           2.08048885251999D-03 )*Y-2.91205805373793D-02 )*Y+           &
           2.72276489515713D-01                                          
      RT3 = ((((((((( 5.02799392850289D-13*Y+1.07461812944084D-11)*Y-   &
           1.482277886411D-10)*Y-2.153585661215D-09)*Y+                 &
           3.654087802817D-08)*Y+5.15929575830120D-07 )*Y-              &
           9.52388379435709D-06 )*Y-2.16552440036426D-04 )*Y+           &
           9.03551469568320D-03 )*Y-1.45505469175613D-01 )*Y+           &
           1.21449092319186D+00                                          
      RT4 = (((((((((-1.08510370291979D-12*Y+6.41492397277798D-11)*Y+   &
           7.542387436125D-10)*Y-2.213111836647D-09)*Y-                 &
           1.448228963549D-07)*Y-1.95670833237101D-06 )*Y-              &
           1.07481314670844D-05 )*Y+1.49335941252765D-04 )*Y+           &
           4.87791531990593D-02 )*Y-1.10559909038653D+00 )*Y+           &
           8.09502028611780D+00                                          
      WW1 = ((((((((((-4.65801912689961D-14*Y+7.58669507106800D-13)*Y-  &
           1.186387548048D-11)*Y+1.862334710665D-10)*Y-                 &
           2.799399389539D-09)*Y+4.148972684255D-08)*Y-                 &
           5.933568079600D-07)*Y+8.168349266115D-06)*Y-                 &
           1.08989176177409D-04 )*Y+1.41357961729531D-03 )*Y-           &
           1.87588361833659D-02 )*Y+2.89898651436026D-01                 
      WW2 = ((((((((((((-1.46345073267549D-14*Y+2.25644205432182D-13)*Y-&
           3.116258693847D-12)*Y+4.321908756610D-11)*Y-                 &
           5.673270062669D-10)*Y+7.006295962960D-09)*Y-                 &
           8.120186517000D-08)*Y+8.775294645770D-07)*Y-                 &
           8.77829235749024D-06 )*Y+8.04372147732379D-05 )*Y-           &
           6.64149238804153D-04 )*Y+4.81181506827225D-03 )*Y-           &
           2.88982669486183D-02 )*Y+1.56247249979288D-01                 
      WW3 = ((((((((((((( 9.06812118895365D-15*Y-1.40541322766087D-13)* &
           Y+1.919270015269D-12)*Y-2.605135739010D-11)*Y+               &
           3.299685839012D-10)*Y-3.86354139348735D-09 )*Y+              &
           4.16265847927498D-08 )*Y-4.09462835471470D-07 )*Y+           &
           3.64018881086111D-06 )*Y-2.88665153269386D-05 )*Y+           &
           2.00515819789028D-04 )*Y-1.18791896897934D-03 )*Y+           &
           5.75223633388589D-03 )*Y-2.09400418772687D-02 )*Y+           &
           4.85368861938873D-02                                          
      WW4 = ((((((((((((((-9.74835552342257D-16*Y+1.57857099317175D-14)*&
           Y-2.249993780112D-13)*Y+3.173422008953D-12)*Y-               &
           4.161159459680D-11)*Y+5.021343560166D-10)*Y-                 &
           5.545047534808D-09)*Y+5.554146993491D-08)*Y-                 &
           4.99048696190133D-07 )*Y+3.96650392371311D-06 )*Y-           &
           2.73816413291214D-05 )*Y+1.60106988333186D-04 )*Y-           &
           7.64560567879592D-04 )*Y+2.81330044426892D-03 )*Y-           &
           7.16227030134947D-03 )*Y+9.66077262223353D-03                 
      RETURN
!                                                                        
  140 IF (X > 10.0D+00) GO TO 160                                        
!     X=5.0 TO 10.0                              NROOTS = 4              
      Y = X-7.5D+00                                                      
      RT1 = ((((((((( 4.64217329776215D-15*Y-6.27892383644164D-15)*Y+   &
           3.462236347446D-13)*Y-2.927229355350D-11)*Y+                 &
           5.090355371676D-10)*Y-9.97272656345253D-09 )*Y+              &
           2.37835295639281D-07 )*Y-4.60301761310921D-06 )*Y+           &
           8.42824204233222D-05 )*Y-1.37983082233081D-03 )*Y+           &
           1.66630865869375D-02                                          
      RT2 = ((((((((( 2.93981127919047D-14*Y+8.47635639065744D-13)*Y-   &
           1.446314544774D-11)*Y-6.149155555753D-12)*Y+                 &
           8.484275604612D-10)*Y-6.10898827887652D-08 )*Y+              &
           2.39156093611106D-06 )*Y-5.35837089462592D-05 )*Y+           &
           1.00967602595557D-03 )*Y-1.57769317127372D-02 )*Y+           &
           1.74853819464285D-01                                          
      RT3 = (((((((((( 2.93523563363000D-14*Y-6.40041776667020D-14)*Y-  &
           2.695740446312D-12)*Y+1.027082960169D-10)*Y-                 &
           5.822038656780D-10)*Y-3.159991002539D-08)*Y+                 &
           4.327249251331D-07)*Y+4.856768455119D-06)*Y-                 &
           2.54617989427762D-04 )*Y+5.54843378106589D-03 )*Y-           &
           7.95013029486684D-02 )*Y+7.20206142703162D-01                 
      RT4 = (((((((((((-1.62212382394553D-14*Y+7.68943641360593D-13)*Y+ &
           5.764015756615D-12)*Y-1.380635298784D-10)*Y-                 &
           1.476849808675D-09)*Y+1.84347052385605D-08 )*Y+              &
           3.34382940759405D-07 )*Y-1.39428366421645D-06 )*Y-           &
           7.50249313713996D-05 )*Y-6.26495899187507D-04 )*Y+           &
           4.69716410901162D-02 )*Y-6.66871297428209D-01 )*Y+           &
           4.11207530217806D+00                                          
      WW1 = ((((((((((-1.65995045235997D-15*Y+6.91838935879598D-14)*Y-  &
           9.131223418888D-13)*Y+1.403341829454D-11)*Y-                 &
           3.672235069444D-10)*Y+6.366962546990D-09)*Y-                 &
           1.039220021671D-07)*Y+1.959098751715D-06)*Y-                 &
           3.33474893152939D-05 )*Y+5.72164211151013D-04 )*Y-           &
           1.05583210553392D-02 )*Y+2.26696066029591D-01                 
      WW2 = ((((((((((((-3.57248951192047D-16*Y+6.25708409149331D-15)*Y-&
           9.657033089714D-14)*Y+1.507864898748D-12)*Y-                 &
           2.332522256110D-11)*Y+3.428545616603D-10)*Y-                 &
           4.698730937661D-09)*Y+6.219977635130D-08)*Y-                 &
           7.83008889613661D-07 )*Y+9.08621687041567D-06 )*Y-           &
           9.86368311253873D-05 )*Y+9.69632496710088D-04 )*Y-           &
           8.14594214284187D-03 )*Y+8.50218447733457D-02                 
      WW3 = ((((((((((((( 1.64742458534277D-16*Y-2.68512265928410D-15)* &
           Y+3.788890667676D-14)*Y-5.508918529823D-13)*Y+               &
           7.555896810069D-12)*Y-9.69039768312637D-11 )*Y+              &
           1.16034263529672D-09 )*Y-1.28771698573873D-08 )*Y+           &
           1.31949431805798D-07 )*Y-1.23673915616005D-06 )*Y+           &
           1.04189803544936D-05 )*Y-7.79566003744742D-05 )*Y+           &
           5.03162624754434D-04 )*Y-2.55138844587555D-03 )*Y+           &
           1.13250730954014D-02                                          
      WW4 = ((((((((((((((-1.55714130075679D-17*Y+2.57193722698891D-16)*&
           Y-3.626606654097D-15)*Y+5.234734676175D-14)*Y-               &
           7.067105402134D-13)*Y+8.793512664890D-12)*Y-                 &
           1.006088923498D-10)*Y+1.050565098393D-09)*Y-                 &
           9.91517881772662D-09 )*Y+8.35835975882941D-08 )*Y-           &
           6.19785782240693D-07 )*Y+3.95841149373135D-06 )*Y-           &
           2.11366761402403D-05 )*Y+9.00474771229507D-05 )*Y-           &
           2.78777909813289D-04 )*Y+5.26543779837487D-04                 
      RETURN
!                                                                        
!     X=10.0 TO 15.0                             NROOTS = 4              
  160 Y = X-12.5D+00                                                     
      RT1 = ((((((((((( 4.94869622744119D-17*Y+8.03568805739160D-16)*Y- &
           5.599125915431D-15)*Y-1.378685560217D-13)*Y+                 &
           7.006511663249D-13)*Y+1.30391406991118D-11 )*Y+              &
           8.06987313467541D-11 )*Y-5.20644072732933D-09 )*Y+           &
           7.72794187755457D-08 )*Y-1.61512612564194D-06 )*Y+           &
           4.15083811185831D-05 )*Y-7.87855975560199D-04 )*Y+           &
           1.14189319050009D-02                                          
      RT2 = ((((((((((( 4.89224285522336D-16*Y+1.06390248099712D-14)*Y- &
           5.446260182933D-14)*Y-1.613630106295D-12)*Y+                 &
           3.910179118937D-12)*Y+1.90712434258806D-10 )*Y+              &
           8.78470199094761D-10 )*Y-5.97332993206797D-08 )*Y+           &
           9.25750831481589D-07 )*Y-2.02362185197088D-05 )*Y+           &
           4.92341968336776D-04 )*Y-8.68438439874703D-03 )*Y+           &
           1.15825965127958D-01                                          
      RT3 = (((((((((( 6.12419396208408D-14*Y+1.12328861406073D-13)*Y-  &
           9.051094103059D-12)*Y-4.781797525341D-11)*Y+                 &
           1.660828868694D-09)*Y+4.499058798868D-10)*Y-                 &
           2.519549641933D-07)*Y+4.977444040180D-06)*Y-                 &
           1.25858350034589D-04 )*Y+2.70279176970044D-03 )*Y-           &
           3.99327850801083D-02 )*Y+4.33467200855434D-01                 
      RT4 = ((((((((((( 4.63414725924048D-14*Y-4.72757262693062D-14)*Y- &
           1.001926833832D-11)*Y+6.074107718414D-11)*Y+                 &
           1.576976911942D-09)*Y-2.01186401974027D-08 )*Y-              &
           1.84530195217118D-07 )*Y+5.02333087806827D-06 )*Y+           &
           9.66961790843006D-06 )*Y-1.58522208889528D-03 )*Y+           &
           2.80539673938339D-02 )*Y-2.78953904330072D-01 )*Y+           &
           1.82835655238235D+00                                          
      WW4 = ((((((((((((( 2.90401781000996D-18*Y-4.63389683098251D-17)* &
           Y+6.274018198326D-16)*Y-8.936002188168D-15)*Y+               &
           1.194719074934D-13)*Y-1.45501321259466D-12 )*Y+              &
           1.64090830181013D-11 )*Y-1.71987745310181D-10 )*Y+           &
           1.63738403295718D-09 )*Y-1.39237504892842D-08 )*Y+           &
           1.06527318142151D-07 )*Y-7.27634957230524D-07 )*Y+           &
           4.12159381310339D-06 )*Y-1.74648169719173D-05 )*Y+           &
           8.50290130067818D-05                                          
      WW3 = ((((((((((((-4.19569145459480D-17*Y+5.94344180261644D-16)*Y-&
           1.148797566469D-14)*Y+1.881303962576D-13)*Y-                 &
           2.413554618391D-12)*Y+3.372127423047D-11)*Y-                 &
           4.933988617784D-10)*Y+6.116545396281D-09)*Y-                 &
           6.69965691739299D-08 )*Y+7.52380085447161D-07 )*Y-           &
           8.08708393262321D-06 )*Y+6.88603417296672D-05 )*Y-           &
           4.67067112993427D-04 )*Y+5.42313365864597D-03                 
      WW2 = ((((((((((-6.22272689880615D-15*Y+1.04126809657554D-13)*Y-  &
           6.842418230913D-13)*Y+1.576841731919D-11)*Y-                 &
           4.203948834175D-10)*Y+6.287255934781D-09)*Y-                 &
           8.307159819228D-08)*Y+1.356478091922D-06)*Y-                 &
           2.08065576105639D-05 )*Y+2.52396730332340D-04 )*Y-           &
           2.94484050194539D-03 )*Y+6.01396183129168D-02                 
      WW1 = (((-1.8784686463512D-01/X+2.2991849164985D-01)/X -          &
           4.9893752514047D-01)/X-2.1916512131607D-05)*EXP(-X) +        &
           SQRT(PIE4/X)-WW4-WW3-WW2                                      
      RETURN
!                                                                        
  180 WW1 = SQRT(PIE4/X)                                                 
      IF (X > 35.0D+00) GO TO 220                                        
      IF (X > 20.0D+00) GO TO 200                                        
!     X=15.0 TO 20.0                             NROOTS = 4              
      Y = X-17.5D+00                                                     
      RT1 = ((((((((((( 4.36701759531398D-17*Y-1.12860600219889D-16)*Y- &
           6.149849164164D-15)*Y+5.820231579541D-14)*Y+                 &
           4.396602872143D-13)*Y-1.24330365320172D-11 )*Y+              &
           6.71083474044549D-11 )*Y+2.43865205376067D-10 )*Y+           &
           1.67559587099969D-08 )*Y-9.32738632357572D-07 )*Y+           &
           2.39030487004977D-05 )*Y-4.68648206591515D-04 )*Y+           &
           8.34977776583956D-03                                          
      RT2 = ((((((((((( 4.98913142288158D-16*Y-2.60732537093612D-16)*Y- &
           7.775156445127D-14)*Y+5.766105220086D-13)*Y+                 &
           6.432696729600D-12)*Y-1.39571683725792D-10 )*Y+              &
           5.95451479522191D-10 )*Y+2.42471442836205D-09 )*Y+           &
           2.47485710143120D-07 )*Y-1.14710398652091D-05 )*Y+           &
           2.71252453754519D-04 )*Y-4.96812745851408D-03 )*Y+           &
           8.26020602026780D-02                                          
      RT3 = ((((((((((( 1.91498302509009D-15*Y+1.48840394311115D-14)*Y- &
           4.316925145767D-13)*Y+1.186495793471D-12)*Y+                 &
           4.615806713055D-11)*Y-5.54336148667141D-10 )*Y+              &
           3.48789978951367D-10 )*Y-2.79188977451042D-09 )*Y+           &
           2.09563208958551D-06 )*Y-6.76512715080324D-05 )*Y+           &
           1.32129867629062D-03 )*Y-2.05062147771513D-02 )*Y+           &
           2.88068671894324D-01                                          
      RT4 = (((((((((((-5.43697691672942D-15*Y-1.12483395714468D-13)*Y+ &
           2.826607936174D-12)*Y-1.266734493280D-11)*Y-                 &
           4.258722866437D-10)*Y+9.45486578503261D-09 )*Y-              &
           5.86635622821309D-08 )*Y-1.28835028104639D-06 )*Y+           &
           4.41413815691885D-05 )*Y-7.61738385590776D-04 )*Y+           &
           9.66090902985550D-03 )*Y-1.01410568057649D-01 )*Y+           &
           9.54714798156712D-01                                          
      WW4 = ((((((((((((-7.56882223582704D-19*Y+7.53541779268175D-18)*Y-&
           1.157318032236D-16)*Y+2.411195002314D-15)*Y-                 &
           3.601794386996D-14)*Y+4.082150659615D-13)*Y-                 &
           4.289542980767D-12)*Y+5.086829642731D-11)*Y-                 &
           6.35435561050807D-10 )*Y+6.82309323251123D-09 )*Y-           &
           5.63374555753167D-08 )*Y+3.57005361100431D-07 )*Y-           &
           2.40050045173721D-06 )*Y+4.94171300536397D-05                 
      WW3 = (((((((((((-5.54451040921657D-17*Y+2.68748367250999D-16)*Y+ &
           1.349020069254D-14)*Y-2.507452792892D-13)*Y+                 &
           1.944339743818D-12)*Y-1.29816917658823D-11 )*Y+              &
           3.49977768819641D-10 )*Y-8.67270669346398D-09 )*Y+           &
           1.31381116840118D-07 )*Y-1.36790720600822D-06 )*Y+           &
           1.19210697673160D-05 )*Y-1.42181943986587D-04 )*Y+           &
           4.12615396191829D-03                                          
      WW2 = (((((((((((-1.86506057729700D-16*Y+1.16661114435809D-15)*Y+ &
           2.563712856363D-14)*Y-4.498350984631D-13)*Y+                 &
           1.765194089338D-12)*Y+9.04483676345625D-12 )*Y+              &
           4.98930345609785D-10 )*Y-2.11964170928181D-08 )*Y+           &
           3.98295476005614D-07 )*Y-5.49390160829409D-06 )*Y+           &
           7.74065155353262D-05 )*Y-1.48201933009105D-03 )*Y+           &
           4.97836392625268D-02                                          
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -           &
           6.0156581186481D-05)*EXP(-X)+WW1-WW2-WW3-WW4                  
      RETURN
!                                                                        
!     X=20.0 TO 35.0                             NROOTS = 4              
  200 E = EXP(-X)                                                        
      RT1 = ((((((-4.45711399441838D-05*X+1.27267770241379D-03)*X -     &
           2.36954961381262D-01)*X+1.54330657903756D+01)*X -            &
           5.22799159267808D+02)*X+1.05951216669313D+04)*X + (-         &
           2.51177235556236D+06/X+8.72975373557709D+05)/X -             &
           1.29194382386499D+05)*E + R14/(X-R14)                         
      RT2 = (((((-7.85617372254488D-02*X+6.35653573484868D+00)*X -      &
           3.38296938763990D+02)*X+1.25120495802096D+04)*X -            &
           3.16847570511637D+05)*X + ((-1.02427466127427D+09/X +        &
           3.70104713293016D+08)/X-5.87119005093822D+07)/X +            &
           5.38614211391604D+06)*E + R24/(X-R24)                         
      RT3 = (((((-2.37900485051067D-01*X+1.84122184400896D+01)*X -      &
           1.00200731304146D+03)*X+3.75151841595736D+04)*X -            &
           9.50626663390130D+05)*X + ((-2.88139014651985D+09/X +        &
           1.06625915044526D+09)/X-1.72465289687396D+08)/X +            &
           1.60419390230055D+07)*E + R34/(X-R34)                         
      RT4 = ((((((-6.00691586407385D-04*X-3.64479545338439D-01)*X +     &
           1.57496131755179D+01)*X-6.54944248734901D+02)*X +            &
           1.70830039597097D+04)*X-2.90517939780207D+05)*X + (+         &
           3.49059698304732D+07/X-1.64944522586065D+07)/X +             &
           2.96817940164703D+06)*E + R44/(X-R44)                         
      IF (X <= 25.0D+00) WW4 = ((((((( 2.33766206773151D-07*X-          &
           3.81542906607063D-05)*X +3.51416601267000D-03)*X-            &
           1.66538571864728D-01)*X +4.80006136831847D+00)*X-            &
           8.73165934223603D+01)*X +9.77683627474638D+02)*X +           &
           1.66000945117640D+04/X -6.14479071209961D+03)*E + W44*WW1     
      IF (X > 25.0D+00) WW4 = (((((( 5.74245945342286D-06*X-            &
           7.58735928102351D-05)*X +2.35072857922892D-04)*X-            &
           3.78812134013125D-03)*X +3.09871652785805D-01)*X-            &
           7.11108633061306D+00)*X +5.55297573149528D+01)*E + W44*WW1    
      WW3 = (((((( 2.36392855180768D-04*X-9.16785337967013D-03)*X +     &
           4.62186525041313D-01)*X-1.96943786006540D+01)*X +            &
           4.99169195295559D+02)*X-6.21419845845090D+03)*X + ((+        &
           5.21445053212414D+07/X-1.34113464389309D+07)/X +             &
           1.13673298305631D+06)/X-2.81501182042707D+03)*E + W34*WW1     
      WW2 = (((((( 7.29841848989391D-04*X-3.53899555749875D-02)*X +     &
           2.07797425718513D+00)*X-1.00464709786287D+02)*X +            &
           3.15206108877819D+03)*X-6.27054715090012D+04)*X + (+         &
           1.54721246264919D+07/X-5.26074391316381D+06)/X +             &
           7.67135400969617D+05)*E + W24*WW1                             
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -           &
           6.0156581186481D-05)*E + WW1-WW2-WW3-WW4                      
      RETURN
!                                                                        
  220 IF (X > 53.0D+00) GO TO 240                                        
!     X=35.0 TO 53.0                             NROOTS = 4              
      E = EXP(-X)*(X*X)**2                                               
      RT4 = ((-2.19135070169653D-03*X-1.19108256987623D-01)*X -         &
           7.50238795695573D-01)*E + R44/(X-R44)                         
      RT3 = ((-9.65842534508637D-04*X-4.49822013469279D-02)*X +         &
           6.08784033347757D-01)*E + R34/(X-R34)                         
      RT2 = ((-3.62569791162153D-04*X-9.09231717268466D-03)*X +         &
           1.84336760556262D-01)*E + R24/(X-R24)                         
      RT1 = ((-4.07557525914600D-05*X-6.88846864931685D-04)*X +         &
           1.74725309199384D-02)*E + R14/(X-R14)                         
      WW4 = (( 5.76631982000990D-06*X-7.89187283804890D-05)*X +         &
           3.28297971853126D-04)*E + W44*WW1                             
      WW3 = (( 2.08294969857230D-04*X-3.77489954837361D-03)*X +         &
           2.09857151617436D-02)*E + W34*WW1                             
      WW2 = (( 6.16374517326469D-04*X-1.26711744680092D-02)*X +         &
          8.14504890732155D-02)*E + W24*WW1
      WW1 = WW1-WW2-WW3-WW4
      RETURN
!
!     X=47.0 TO INFINITY                         NROOTS = 4
  240 RT1 = R14/(X-R14)
      RT2 = R24/(X-R24)
      RT3 = R34/(X-R34)
      RT4 = R44/(X-R44)
      WW4 = W44*WW1
      WW3 = W34*WW1
      WW2 = W24*WW1
      WW1 = WW1-WW2-WW3-WW4
      RETURN
      END

! Calling by HSandT & ERISPDFGHIL: ROOT5 
      SUBROUTINE ROOT5
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROOT  / X,U(13),W(13),NROOTS
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
      DATA R15,PIE4/1.17581320211778D-01, 7.85398163397448D-01/
      DATA R25,W25/ 1.07456201243690D+00, 2.70967405960535D-01/
      DATA R35,W35/ 3.08593744371754D+00, 3.82231610015404D-02/
      DATA R45,W45/ 6.41472973366203D+00, 1.51614186862443D-03/
      DATA R55,W55/ 1.18071894899717D+01, 8.62130526143657D-06/
!
      IF (X > 15.0D+00) GO TO 180
      IF (X > 5.0D+00) GO TO 140
      IF (X > 1.0D+00) GO TO 120
      IF (X > 3.0D-07) GO TO 100
!     X IS APPROXIMATELY 0.0d0.                   NROOTS = 5
      RT1 = 2.26659266316985D-02 -2.15865967920897D-03 *X
      RT2 = 2.31271692140903D-01 -2.20258754389745D-02 *X
      RT3 = 8.57346024118836D-01 -8.16520023025515D-02 *X
      RT4 = 2.97353038120346D+00 -2.83193369647137D-01 *X
      RT5 = 1.84151859759051D+01 -1.75382723579439D+00 *X
      WW1 = 2.95524224714752D-01 -1.96867576909777D-02 *X
      WW2 = 2.69266719309995D-01 -5.61737590184721D-02 *X
      WW3 = 2.19086362515981D-01 -9.71152726793658D-02 *X
      WW4 = 1.49451349150580D-01 -1.02979262193565D-01 *X
      WW5 = 6.66713443086877D-02 -5.73782817488315D-02 *X
      RETURN
!
!     X=0.0 TO 1.0                               NROOTS = 5
  100 RT1 = ((((((-4.46679165328413D-11*X+1.21879111988031D-09)*X-      &
           2.62975022612104D-08 )*X+5.15106194905897D-07 )*X-           &
           9.27933625824749D-06 )*X+1.51794097682482D-04 )*X-           &
           2.15865967920301D-03 )*X+2.26659266316985D-02                 
      RT2 = (((((( 1.93117331714174D-10*X-4.57267589660699D-09)*X+      &
           2.48339908218932D-08 )*X+1.50716729438474D-06 )*X-           &
           6.07268757707381D-05 )*X+1.37506939145643D-03 )*X-           &
           2.20258754419939D-02 )*X+2.31271692140905D-01                 
      RT3 = ((((( 4.84989776180094D-09*X+1.31538893944284D-07)*X-       &
           2.766753852879D-06)*X-7.651163510626D-05)*X+                 &
           4.033058545972D-03)*X-8.16520022916145D-02 )*X+              &
           8.57346024118779D-01                                          
      RT4 = ((((-2.48581772214623D-07*X-4.34482635782585D-06)*X-        &
           7.46018257987630D-07 )*X+1.01210776517279D-02 )*X-           &
           2.83193369640005D-01 )*X+2.97353038120345D+00                 
      RT5 = (((((-8.92432153868554D-09*X+1.77288899268988D-08)*X+       &
           3.040754680666D-06)*X+1.058229325071D-04)*X+                 &
           4.596379534985D-02)*X-1.75382723579114D+00 )*X+              &
           1.84151859759049D+01                                          
      WW1 = ((((((-2.03822632771791D-09*X+3.89110229133810D-08)*X-      &
           5.84914787904823D-07 )*X+8.30316168666696D-06 )*X-           &
           1.13218402310546D-04 )*X+1.49128888586790D-03 )*X-           &
           1.96867576904816D-02 )*X+2.95524224714749D-01                 
      WW2 = ((((((( 8.62848118397570D-09*X-1.38975551148989D-07)*X+     &
           1.602894068228D-06)*X-1.646364300836D-05)*X+                 &
           1.538445806778D-04)*X-1.28848868034502D-03 )*X+              &
           9.38866933338584D-03 )*X-5.61737590178812D-02 )*X+           &
           2.69266719309991D-01                                          
      WW3 = ((((((((-9.41953204205665D-09*X+1.47452251067755D-07)*X-    &
           1.57456991199322D-06 )*X+1.45098401798393D-05 )*X-           &
           1.18858834181513D-04 )*X+8.53697675984210D-04 )*X-           &
           5.22877807397165D-03 )*X+2.60854524809786D-02 )*X-           &
           9.71152726809059D-02 )*X+2.19086362515979D-01                 
      WW4 = ((((((((-3.84961617022042D-08*X+5.66595396544470D-07)*X-    &
           5.52351805403748D-06 )*X+4.53160377546073D-05 )*X-           &
           3.22542784865557D-04 )*X+1.95682017370967D-03 )*X-           &
           9.77232537679229D-03 )*X+3.79455945268632D-02 )*X-           &
           1.02979262192227D-01 )*X+1.49451349150573D-01                 
      WW5 = ((((((((( 4.09594812521430D-09*X-6.47097874264417D-08)*X+   &
           6.743541482689D-07)*X-5.917993920224D-06)*X+                 &
           4.531969237381D-05)*X-2.99102856679638D-04 )*X+              &
           1.65695765202643D-03 )*X-7.40671222520653D-03 )*X+           &
           2.50889946832192D-02 )*X-5.73782817487958D-02 )*X+           &
           6.66713443086877D-02                                          
      RETURN
                                                                        
!     X=1.0 TO 5.0                               NROOTS = 5              
  120 Y = X-3.0D+00                                                      
      RT1 = ((((((((-2.58163897135138D-14*Y+8.14127461488273D-13)*Y-    &
           2.11414838976129D-11 )*Y+5.09822003260014D-10 )*Y-           &
           1.16002134438663D-08 )*Y+2.46810694414540D-07 )*Y-           &
           4.92556826124502D-06 )*Y+9.02580687971053D-05 )*Y-           &
           1.45190025120726D-03 )*Y+1.73416786387475D-02                 
      RT2 = ((((((((( 1.04525287289788D-14*Y+5.44611782010773D-14)*Y-   &
           4.831059411392D-12)*Y+1.136643908832D-10)*Y-                 &
           1.104373076913D-09)*Y-2.35346740649916D-08 )*Y+              &
           1.43772622028764D-06 )*Y-4.23405023015273D-05 )*Y+           &
           9.12034574793379D-04 )*Y-1.52479441718739D-02 )*Y+           &
           1.76055265928744D-01                                          
      RT3 = (((((((((-6.89693150857911D-14*Y+5.92064260918861D-13)*Y+   &
           1.847170956043D-11)*Y-3.390752744265D-10)*Y-                 &
           2.995532064116D-09)*Y+1.57456141058535D-07 )*Y-              &
           3.95859409711346D-07 )*Y-9.58924580919747D-05 )*Y+           &
           3.23551502557785D-03 )*Y-5.97587007636479D-02 )*Y+           &
           6.46432853383057D-01                                          
      RT4 = ((((((((-3.61293809667763D-12*Y-2.70803518291085D-11)*Y+    &
           8.83758848468769D-10 )*Y+1.59166632851267D-08 )*Y-           &
           1.32581997983422D-07 )*Y-7.60223407443995D-06 )*Y-           &
           7.41019244900952D-05 )*Y+9.81432631743423D-03 )*Y-           &
           2.23055570487771D-01 )*Y+2.21460798080643D+00                 
      RT5 = ((((((((( 7.12332088345321D-13*Y+3.16578501501894D-12)*Y-   &
           8.776668218053D-11)*Y-2.342817613343D-09)*Y-                 &
           3.496962018025D-08)*Y-3.03172870136802D-07 )*Y+              &
           1.50511293969805D-06 )*Y+1.37704919387696D-04 )*Y+           &
           4.70723869619745D-02 )*Y-1.47486623003693D+00 )*Y+           &
           1.35704792175847D+01                                          
      WW1 = ((((((((( 1.04348658616398D-13*Y-1.94147461891055D-12)*Y+   &
           3.485512360993D-11)*Y-6.277497362235D-10)*Y+                 &
           1.100758247388D-08)*Y-1.88329804969573D-07 )*Y+              &
           3.12338120839468D-06 )*Y-5.04404167403568D-05 )*Y+           &
           8.00338056610995D-04 )*Y-1.30892406559521D-02 )*Y+           &
           2.47383140241103D-01                                          
      WW2 = ((((((((((( 3.23496149760478D-14*Y-5.24314473469311D-13)*Y+ &
           7.743219385056D-12)*Y-1.146022750992D-10)*Y+                 &
           1.615238462197D-09)*Y-2.15479017572233D-08 )*Y+              &
           2.70933462557631D-07 )*Y-3.18750295288531D-06 )*Y+           &
           3.47425221210099D-05 )*Y-3.45558237388223D-04 )*Y+           &
           3.05779768191621D-03 )*Y-2.29118251223003D-02 )*Y+           &
           1.59834227924213D-01                                          
      WW3 = ((((((((((((-3.42790561802876D-14*Y+5.26475736681542D-13)*Y-&
           7.184330797139D-12)*Y+9.763932908544D-11)*Y-                 &
           1.244014559219D-09)*Y+1.472744068942D-08)*Y-                 &
           1.611749975234D-07)*Y+1.616487851917D-06)*Y-                 &
           1.46852359124154D-05 )*Y+1.18900349101069D-04 )*Y-           &
           8.37562373221756D-04 )*Y+4.93752683045845D-03 )*Y-           &
           2.25514728915673D-02 )*Y+6.95211812453929D-02                 
      WW4 = ((((((((((((( 1.04072340345039D-14*Y-1.60808044529211D-13)* &
           Y+2.183534866798D-12)*Y-2.939403008391D-11)*Y+               &
           3.679254029085D-10)*Y-4.23775673047899D-09 )*Y+              &
           4.46559231067006D-08 )*Y-4.26488836563267D-07 )*Y+           &
           3.64721335274973D-06 )*Y-2.74868382777722D-05 )*Y+           &
           1.78586118867488D-04 )*Y-9.68428981886534D-04 )*Y+           &
           4.16002324339929D-03 )*Y-1.28290192663141D-02 )*Y+           &
           2.22353727685016D-02                                          
      WW5 = ((((((((((((((-8.16770412525963D-16*Y+1.31376515047977D-14)*&
           Y-1.856950818865D-13)*Y+2.596836515749D-12)*Y-               &
           3.372639523006D-11)*Y+4.025371849467D-10)*Y-                 &
           4.389453269417D-09)*Y+4.332753856271D-08)*Y-                 &
           3.82673275931962D-07 )*Y+2.98006900751543D-06 )*Y-           &
           2.00718990300052D-05 )*Y+1.13876001386361D-04 )*Y-           &
           5.23627942443563D-04 )*Y+1.83524565118203D-03 )*Y-           &
           4.37785737450783D-03 )*Y+5.36963805223095D-03                 
      RETURN
                                                                        
  140 IF (X > 10.0D+00) GO TO 160                                        
!     X=5.0 TO 10.0                              NROOTS = 5              
      Y = X-7.5D+00                                                      
      RT1 = ((((((((-1.13825201010775D-14*Y+1.89737681670375D-13)*Y-    &
           4.81561201185876D-12 )*Y+1.56666512163407D-10 )*Y-           &
           3.73782213255083D-09 )*Y+9.15858355075147D-08 )*Y-           &
           2.13775073585629D-06 )*Y+4.56547356365536D-05 )*Y-           &
           8.68003909323740D-04 )*Y+1.22703754069176D-02                 
      RT2 = (((((((((-3.67160504428358D-15*Y+1.27876280158297D-14)*Y-   &
           1.296476623788D-12)*Y+1.477175434354D-11)*Y+                 &
           5.464102147892D-10)*Y-2.42538340602723D-08 )*Y+              &
           8.20460740637617D-07 )*Y-2.20379304598661D-05 )*Y+           &
           4.90295372978785D-04 )*Y-9.14294111576119D-03 )*Y+           &
           1.22590403403690D-01                                          
      RT3 = ((((((((( 1.39017367502123D-14*Y-6.96391385426890D-13)*Y+   &
           1.176946020731D-12)*Y+1.725627235645D-10)*Y-                 &
           3.686383856300D-09)*Y+2.87495324207095D-08 )*Y+              &
           1.71307311000282D-06 )*Y-7.94273603184629D-05 )*Y+           &
           2.00938064965897D-03 )*Y-3.63329491677178D-02 )*Y+           &
           4.34393683888443D-01                                          
      RT4 = ((((((((((-1.27815158195209D-14*Y+1.99910415869821D-14)*Y+  &
           3.753542914426D-12)*Y-2.708018219579D-11)*Y-                 &
           1.190574776587D-09)*Y+1.106696436509D-08)*Y+                 &
           3.954955671326D-07)*Y-4.398596059588D-06)*Y-                 &
           2.01087998907735D-04 )*Y+7.89092425542937D-03 )*Y-           &
           1.42056749162695D-01 )*Y+1.39964149420683D+00                 
      RT5 = ((((((((((-1.19442341030461D-13*Y-2.34074833275956D-12)*Y+  &
           6.861649627426D-12)*Y+6.082671496226D-10)*Y+                 &
           5.381160105420D-09)*Y-6.253297138700D-08)*Y-                 &
           2.135966835050D-06)*Y-2.373394341886D-05)*Y+                 &
           2.88711171412814D-06 )*Y+4.85221195290753D-02 )*Y-           &
           1.04346091985269D+00 )*Y+7.89901551676692D+00                 
      WW1 = ((((((((( 7.95526040108997D-15*Y-2.48593096128045D-13)*Y+   &
           4.761246208720D-12)*Y-9.535763686605D-11)*Y+                 &
           2.225273630974D-09)*Y-4.49796778054865D-08 )*Y+              &
           9.17812870287386D-07 )*Y-1.86764236490502D-05 )*Y+           &
           3.76807779068053D-04 )*Y-8.10456360143408D-03 )*Y+           &
           2.01097936411496D-01                                          
      WW2 = ((((((((((( 1.25678686624734D-15*Y-2.34266248891173D-14)*Y+ &
           3.973252415832D-13)*Y-6.830539401049D-12)*Y+                 &
           1.140771033372D-10)*Y-1.82546185762009D-09 )*Y+              &
           2.77209637550134D-08 )*Y-4.01726946190383D-07 )*Y+           &
           5.48227244014763D-06 )*Y-6.95676245982121D-05 )*Y+           &
           8.05193921815776D-04 )*Y-8.15528438784469D-03 )*Y+           &
           9.71769901268114D-02                                          
      WW3 = ((((((((((((-8.20929494859896D-16*Y+1.37356038393016D-14)*Y-&
           2.022863065220D-13)*Y+3.058055403795D-12)*Y-                 &
           4.387890955243D-11)*Y+5.923946274445D-10)*Y-                 &
           7.503659964159D-09)*Y+8.851599803902D-08)*Y-                 &
           9.65561998415038D-07 )*Y+9.60884622778092D-06 )*Y-           &
           8.56551787594404D-05 )*Y+6.66057194311179D-04 )*Y-           &
           4.17753183902198D-03 )*Y+2.25443826852447D-02                 
      WW4 = ((((((((((((((-1.08764612488790D-17*Y+1.85299909689937D-16)*&
           Y-2.730195628655D-15)*Y+4.127368817265D-14)*Y-               &
           5.881379088074D-13)*Y+7.805245193391D-12)*Y-                 &
           9.632707991704D-11)*Y+1.099047050624D-09)*Y-                 &
           1.15042731790748D-08 )*Y+1.09415155268932D-07 )*Y-           &
           9.33687124875935D-07 )*Y+7.02338477986218D-06 )*Y-           &
           4.53759748787756D-05 )*Y+2.41722511389146D-04 )*Y-           &
           9.75935943447037D-04 )*Y+2.57520532789644D-03                 
      WW5 = ((((((((((((((( 7.28996979748849D-19*Y-1.26518146195173D-17)&
           *Y+1.886145834486D-16)*Y-2.876728287383D-15)*Y+              &
           4.114588668138D-14)*Y-5.44436631413933D-13 )*Y+              &
           6.64976446790959D-12 )*Y-7.44560069974940D-11 )*Y+           &
           7.57553198166848D-10 )*Y-6.92956101109829D-09 )*Y+           &
           5.62222859033624D-08 )*Y-3.97500114084351D-07 )*Y+           &
           2.39039126138140D-06 )*Y-1.18023950002105D-05 )*Y+           &
           4.52254031046244D-05 )*Y-1.21113782150370D-04 )*Y+           &
           1.75013126731224D-04                                          
      RETURN
                                                                        
!     X=10.0 TO 15.0                             NROOTS = 5              
  160 Y = X-12.5D+00                                                     
      RT1 = ((((((((((-4.16387977337393D-17*Y+7.20872997373860D-16)*Y+  &
           1.395993802064D-14)*Y+3.660484641252D-14)*Y-                 &
           4.154857548139D-12)*Y+2.301379846544D-11)*Y-                 &
           1.033307012866D-09)*Y+3.997777641049D-08)*Y-                 &
           9.35118186333939D-07 )*Y+2.38589932752937D-05 )*Y-           &
           5.35185183652937D-04 )*Y+8.85218988709735D-03                 
      RT2 = ((((((((((-4.56279214732217D-16*Y+6.24941647247927D-15)*Y+  &
           1.737896339191D-13)*Y+8.964205979517D-14)*Y-                 &
           3.538906780633D-11)*Y+9.561341254948D-11)*Y-                 &
           9.772831891310D-09)*Y+4.240340194620D-07)*Y-                 &
           1.02384302866534D-05 )*Y+2.57987709704822D-04 )*Y-           &
           5.54735977651677D-03 )*Y+8.68245143991948D-02                 
      RT3 = ((((((((((-2.52879337929239D-15*Y+2.13925810087833D-14)*Y+  &
           7.884307667104D-13)*Y-9.023398159510D-13)*Y-                 &
           5.814101544957D-11)*Y-1.333480437968D-09)*Y-                 &
           2.217064940373D-08)*Y+1.643290788086D-06)*Y-                 &
           4.39602147345028D-05 )*Y+1.08648982748911D-03 )*Y-           &
           2.13014521653498D-02 )*Y+2.94150684465425D-01                 
      RT4 = ((((((((((-6.42391438038888D-15*Y+5.37848223438815D-15)*Y+  &
           8.960828117859D-13)*Y+5.214153461337D-11)*Y-                 &
           1.106601744067D-10)*Y-2.007890743962D-08)*Y+                 &
           1.543764346501D-07)*Y+4.520749076914D-06)*Y-                 &
           1.88893338587047D-04 )*Y+4.73264487389288D-03 )*Y-           &
           7.91197893350253D-02 )*Y+8.60057928514554D-01                 
      RT5 = (((((((((((-2.24366166957225D-14*Y+4.87224967526081D-14)*Y+ &
           5.587369053655D-12)*Y-3.045253104617D-12)*Y-                 &
           1.223983883080D-09)*Y-2.05603889396319D-09 )*Y+              &
           2.58604071603561D-07 )*Y+1.34240904266268D-06 )*Y-           &
           5.72877569731162D-05 )*Y-9.56275105032191D-04 )*Y+           &
           4.23367010370921D-02 )*Y-5.76800927133412D-01 )*Y+           &
           3.87328263873381D+00                                          
      WW1 = ((((((((( 8.98007931950169D-15*Y+7.25673623859497D-14)*Y+   &
           5.851494250405D-14)*Y-4.234204823846D-11)*Y+                 &
           3.911507312679D-10)*Y-9.65094802088511D-09 )*Y+              &
           3.42197444235714D-07 )*Y-7.51821178144509D-06 )*Y+           &
           1.94218051498662D-04 )*Y-5.38533819142287D-03 )*Y+           &
           1.68122596736809D-01                                          
      WW2 = ((((((((((-1.05490525395105D-15*Y+1.96855386549388D-14)*Y-  &
           5.500330153548D-13)*Y+1.003849567976D-11)*Y-                 &
           1.720997242621D-10)*Y+3.533277061402D-09)*Y-                 &
           6.389171736029D-08)*Y+1.046236652393D-06)*Y-                 &
           1.73148206795827D-05 )*Y+2.57820531617185D-04 )*Y-           &
           3.46188265338350D-03 )*Y+7.03302497508176D-02                 
      WW3 = ((((((((((( 3.60020423754545D-16*Y-6.24245825017148D-15)*Y+ &
           9.945311467434D-14)*Y-1.749051512721D-12)*Y+                 &
           2.768503957853D-11)*Y-4.08688551136506D-10 )*Y+              &
           6.04189063303610D-09 )*Y-8.23540111024147D-08 )*Y+           &
           1.01503783870262D-06 )*Y-1.20490761741576D-05 )*Y+           &
           1.26928442448148D-04 )*Y-1.05539461930597D-03 )*Y+           &
           1.15543698537013D-02                                          
      WW4 = ((((((((((((( 2.51163533058925D-18*Y-4.31723745510697D-17)* &
           Y+6.557620865832D-16)*Y-1.016528519495D-14)*Y+               &
           1.491302084832D-13)*Y-2.06638666222265D-12 )*Y+              &
           2.67958697789258D-11 )*Y-3.23322654638336D-10 )*Y+           &
           3.63722952167779D-09 )*Y-3.75484943783021D-08 )*Y+           &
           3.49164261987184D-07 )*Y-2.92658670674908D-06 )*Y+           &
           2.12937256719543D-05 )*Y-1.19434130620929D-04 )*Y+           &
           6.45524336158384D-04                                          
      WW5 = ((((((((((((((-1.29043630202811D-19*Y+2.16234952241296D-18)*&
           Y-3.107631557965D-17)*Y+4.570804313173D-16)*Y-               &
           6.301348858104D-15)*Y+8.031304476153D-14)*Y-                 &
           9.446196472547D-13)*Y+1.018245804339D-11)*Y-                 &
           9.96995451348129D-11 )*Y+8.77489010276305D-10 )*Y-           &
           6.84655877575364D-09 )*Y+4.64460857084983D-08 )*Y-           &
           2.66924538268397D-07 )*Y+1.24621276265907D-06 )*Y-           &
           4.30868944351523D-06 )*Y+9.94307982432868D-06                 
      RETURN
                                                                        
  180 IF (X > 25.0D+00) GO TO 220                                        
      IF (X > 20.0D+00) GO TO 200                                        
!     X=15.0 TO 20.0                             NROOTS = 5              
      Y = X-17.5D+00                                                     
      RT1 = (((((((((( 1.91875764545740D-16*Y+7.8357401095707D-16)*Y-   &
           3.260875931644D-14)*Y-1.186752035569D-13)*Y+                 &
           4.275180095653D-12)*Y+3.357056136731D-11)*Y-                 &
           1.123776903884D-09)*Y+1.231203269887D-08)*Y-                 &
           3.99851421361031D-07 )*Y+1.45418822817771D-05 )*Y-           &
           3.49912254976317D-04 )*Y+6.67768703938812D-03                 
      RT2 = (((((((((( 2.02778478673555D-15*Y+1.01640716785099D-14)*Y-  &
           3.385363492036D-13)*Y-1.615655871159D-12)*Y+                 &
           4.527419140333D-11)*Y+3.853670706486D-10)*Y-                 &
           1.184607130107D-08)*Y+1.347873288827D-07)*Y-                 &
           4.47788241748377D-06 )*Y+1.54942754358273D-04 )*Y-           &
           3.55524254280266D-03 )*Y+6.44912219301603D-02                 
      RT3 = (((((((((( 7.79850771456444D-15*Y+6.00464406395001D-14)*Y-  &
           1.249779730869D-12)*Y-1.020720636353D-11)*Y+                 &
           1.814709816693D-10)*Y+1.766397336977D-09)*Y-                 &
           4.603559449010D-08)*Y+5.863956443581D-07)*Y-                 &
           2.03797212506691D-05 )*Y+6.31405161185185D-04 )*Y-           &
           1.30102750145071D-02 )*Y+2.10244289044705D-01                 
      RT4 = (((((((((((-2.92397030777912D-15*Y+1.94152129078465D-14)*Y+ &
           4.859447665850D-13)*Y-3.217227223463D-12)*Y-                 &
           7.484522135512D-11)*Y+7.19101516047753D-10 )*Y+              &
           6.88409355245582D-09 )*Y-1.44374545515769D-07 )*Y+           &
           2.74941013315834D-06 )*Y-1.02790452049013D-04 )*Y+           &
           2.59924221372643D-03 )*Y-4.35712368303551D-02 )*Y+           &
           5.62170709585029D-01                                          
      RT5 = ((((((((((( 1.17976126840060D-14*Y+1.24156229350669D-13)*Y- &
           3.892741622280D-12)*Y-7.755793199043D-12)*Y+                 &
           9.492190032313D-10)*Y-4.98680128123353D-09 )*Y-              &
           1.81502268782664D-07 )*Y+2.69463269394888D-06 )*Y+           &
           2.50032154421640D-05 )*Y-1.33684303917681D-03 )*Y+           &
           2.29121951862538D-02 )*Y-2.45653725061323D-01 )*Y+           &
           1.89999883453047D+00                                          
      WW1 = (((((((((( 1.74841995087592D-15*Y-6.95671892641256D-16)*Y-  &
           3.000659497257D-13)*Y+2.021279817961D-13)*Y+                 &
           3.853596935400D-11)*Y+1.461418533652D-10)*Y-                 &
           1.014517563435D-08)*Y+1.132736008979D-07)*Y-                 &
           2.86605475073259D-06 )*Y+1.21958354908768D-04 )*Y-           &
           3.86293751153466D-03 )*Y+1.45298342081522D-01                 
      WW2 = ((((((((((-1.11199320525573D-15*Y+1.85007587796671D-15)*Y+  &
           1.220613939709D-13)*Y+1.275068098526D-12)*Y-                 &
           5.341838883262D-11)*Y+6.161037256669D-10)*Y-                 &
           1.009147879750D-08)*Y+2.907862965346D-07)*Y-                 &
           6.12300038720919D-06 )*Y+1.00104454489518D-04 )*Y-           &
           1.80677298502757D-03 )*Y+5.78009914536630D-02                 
      WW3 = ((((((((((-9.49816486853687D-16*Y+6.67922080354234D-15)*Y+  &
           2.606163540537D-15)*Y+1.983799950150D-12)*Y-                 &
           5.400548574357D-11)*Y+6.638043374114D-10)*Y-                 &
           8.799518866802D-09)*Y+1.791418482685D-07)*Y-                 &
           2.96075397351101D-06 )*Y+3.38028206156144D-05 )*Y-           &
           3.58426847857878D-04 )*Y+8.39213709428516D-03                 
      WW4 = ((((((((((( 1.33829971060180D-17*Y-3.44841877844140D-16)*Y+ &
           4.745009557656D-15)*Y-6.033814209875D-14)*Y+                 &
           1.049256040808D-12)*Y-1.70859789556117D-11 )*Y+              &
           2.15219425727959D-10 )*Y-2.52746574206884D-09 )*Y+           &
           3.27761714422960D-08 )*Y-3.90387662925193D-07 )*Y+           &
           3.46340204593870D-06 )*Y-2.43236345136782D-05 )*Y+           &
           3.54846978585226D-04                                          
      WW5 = ((((((((((((( 2.69412277020887D-20*Y-4.24837886165685D-19)* &
           Y+6.030500065438D-18)*Y-9.069722758289D-17)*Y+               &
           1.246599177672D-15)*Y-1.56872999797549D-14 )*Y+              &
           1.87305099552692D-13 )*Y-2.09498886675861D-12 )*Y+           &
           2.11630022068394D-11 )*Y-1.92566242323525D-10 )*Y+           &
           1.62012436344069D-09 )*Y-1.23621614171556D-08 )*Y+           &
           7.72165684563049D-08 )*Y-3.59858901591047D-07 )*Y+           &
           2.43682618601000D-06                                          
      RETURN
                                                                        
!     X=20.0 TO 25.0                             NROOTS = 5              
  200 Y = X-22.5D+00                                                     
      RT1 = (((((((((-1.13927848238726D-15*Y+7.39404133595713D-15)*Y+   &
           1.445982921243D-13)*Y-2.676703245252D-12)*Y+                 &
           5.823521627177D-12)*Y+2.17264723874381D-10 )*Y+              &
           3.56242145897468D-09 )*Y-3.03763737404491D-07 )*Y+           &
           9.46859114120901D-06 )*Y-2.30896753853196D-04 )*Y+           &
           5.24663913001114D-03                                          
      RT2 = (((((((((( 2.89872355524581D-16*Y-1.22296292045864D-14)*Y+  &
           6.184065097200D-14)*Y+1.649846591230D-12)*Y-                 &
           2.729713905266D-11)*Y+3.709913790650D-11)*Y+                 &
           2.216486288382D-09)*Y+4.616160236414D-08)*Y-                 &
           3.32380270861364D-06 )*Y+9.84635072633776D-05 )*Y-           &
           2.30092118015697D-03 )*Y+5.00845183695073D-02                 
      RT3 = (((((((((( 1.97068646590923D-15*Y-4.89419270626800D-14)*Y+  &
           1.136466605916D-13)*Y+7.546203883874D-12)*Y-                 &
           9.635646767455D-11)*Y-8.295965491209D-11)*Y+                 &
           7.534109114453D-09)*Y+2.699970652707D-07)*Y-                 &
           1.42982334217081D-05 )*Y+3.78290946669264D-04 )*Y-           &
           8.03133015084373D-03 )*Y+1.58689469640791D-01                 
      RT4 = (((((((((( 1.33642069941389D-14*Y-1.55850612605745D-13)*Y-  &
           7.522712577474D-13)*Y+3.209520801187D-11)*Y-                 &
           2.075594313618D-10)*Y-2.070575894402D-09)*Y+                 &
           7.323046997451D-09)*Y+1.851491550417D-06)*Y-                 &
           6.37524802411383D-05 )*Y+1.36795464918785D-03 )*Y-           &
           2.42051126993146D-02 )*Y+3.97847167557815D-01                 
      RT5 = ((((((((((-6.07053986130526D-14*Y+1.04447493138843D-12)*Y-  &
           4.286617818951D-13)*Y-2.632066100073D-10)*Y+                 &
           4.804518986559D-09)*Y-1.835675889421D-08)*Y-                 &
           1.068175391334D-06)*Y+3.292234974141D-05)*Y-                 &
           5.94805357558251D-04 )*Y+8.29382168612791D-03 )*Y-           &
           9.93122509049447D-02 )*Y+1.09857804755042D+00                 
      WW1 = (((((((((-9.10338640266542D-15*Y+1.00438927627833D-13)*Y+   &
           7.817349237071D-13)*Y-2.547619474232D-11)*Y+                 &
           1.479321506529D-10)*Y+1.52314028857627D-09 )*Y+              &
           9.20072040917242D-09 )*Y-2.19427111221848D-06 )*Y+           &
           8.65797782880311D-05 )*Y-2.82718629312875D-03 )*Y+           &
           1.28718310443295D-01                                          
      WW2 = ((((((((( 5.52380927618760D-15*Y-6.43424400204124D-14)*Y-   &
           2.358734508092D-13)*Y+8.261326648131D-12)*Y+                 &
           9.229645304956D-11)*Y-5.68108973828949D-09 )*Y+              &
           1.22477891136278D-07 )*Y-2.11919643127927D-06 )*Y+           &
           4.23605032368922D-05 )*Y-1.14423444576221D-03 )*Y+           &
           5.06607252890186D-02                                          
      WW3 = ((((((((( 3.99457454087556D-15*Y-5.11826702824182D-14)*Y-   &
           4.157593182747D-14)*Y+4.214670817758D-12)*Y+                 &
           6.705582751532D-11)*Y-3.36086411698418D-09 )*Y+              &
           6.07453633298986D-08 )*Y-7.40736211041247D-07 )*Y+           &
           8.84176371665149D-06 )*Y-1.72559275066834D-04 )*Y+           &
           7.16639814253567D-03                                          
      WW4 = (((((((((((-2.14649508112234D-18*Y-2.45525846412281D-18)*Y+ &
           6.126212599772D-16)*Y-8.526651626939D-15)*Y+                 &
           4.826636065733D-14)*Y-3.39554163649740D-13 )*Y+              &
           1.67070784862985D-11 )*Y-4.42671979311163D-10 )*Y+           &
           6.77368055908400D-09 )*Y-7.03520999708859D-08 )*Y+           &
           6.04993294708874D-07 )*Y-7.80555094280483D-06 )*Y+           &
           2.85954806605017D-04                                          
      WW5 = ((((((((((((-5.63938733073804D-21*Y+6.92182516324628D-20)*Y-&
           1.586937691507D-18)*Y+3.357639744582D-17)*Y-                 &
           4.810285046442D-16)*Y+5.386312669975D-15)*Y-                 &
           6.117895297439D-14)*Y+8.441808227634D-13)*Y-                 &
           1.18527596836592D-11 )*Y+1.36296870441445D-10 )*Y-           &
           1.17842611094141D-09 )*Y+7.80430641995926D-09 )*Y-           &
           5.97767417400540D-08 )*Y+1.65186146094969D-06                 
      RETURN
                                                                        
  220 WW1 = SQRT(PIE4/X)                                                 
      IF (X > 40.0D+00) GO TO 240                                        
!     X=25.0 TO 40.0                             NROOTS = 5              
      E = EXP(-X)                                                        
      RT1 = ((((((((-1.73363958895356D-06*X+1.19921331441483D-04)*X -   &
           1.59437614121125D-02)*X+1.13467897349442D+00)*X -            &
           4.47216460864586D+01)*X+1.06251216612604D+03)*X -            &
           1.52073917378512D+04)*X+1.20662887111273D+05)*X -            &
           4.07186366852475D+05)*E + R15/(X-R15)                         
      RT2 = ((((((((-1.60102542621710D-05*X+1.10331262112395D-03)*X -   &
           1.50043662589017D-01)*X+1.05563640866077D+01)*X -            &
           4.10468817024806D+02)*X+9.62604416506819D+03)*X -            &
           1.35888069838270D+05)*X+1.06107577038340D+06)*X -            &
           3.51190792816119D+06)*E + R25/(X-R25)                         
      RT3 = ((((((((-4.48880032128422D-05*X+2.69025112122177D-03)*X -   &
           4.01048115525954D-01)*X+2.78360021977405D+01)*X -            &
           1.04891729356965D+03)*X+2.36985942687423D+04)*X -            &
           3.19504627257548D+05)*X+2.34879693563358D+06)*X -            &
           7.16341568174085D+06)*E + R35/(X-R35)                         
      RT4 = ((((((((-6.38526371092582D-05*X-2.29263585792626D-03)*X -   &
           7.65735935499627D-02)*X+9.12692349152792D+00)*X -            &
           2.32077034386717D+02)*X+2.81839578728845D+02)*X +            &
           9.59529683876419D+04)*X-1.77638956809518D+06)*X +            &
           1.02489759645410D+07)*E + R45/(X-R45)                         
      RT5 = ((((((((-3.59049364231569D-05*X-2.25963977930044D-02)*X +   &
           1.12594870794668D+00)*X-4.56752462103909D+01)*X +            &
           1.05804526830637D+03)*X-1.16003199605875D+04)*X -            &
           4.07297627297272D+04)*X+2.22215528319857D+06)*X -            &
           1.61196455032613D+07)*E + R55/(X-R55)                         
      WW5 = (((((((((-4.61100906133970D-10*X+1.43069932644286D-07)*X -  &
           1.63960915431080D-05)*X+1.15791154612838D-03)*X -            &
           5.30573476742071D-02)*X+1.61156533367153D+00)*X -            &
           3.23248143316007D+01)*X+4.12007318109157D+02)*X -            &
           3.02260070158372D+03)*X+9.71575094154768D+03)*E + W55*WW1     
      WW4 = (((((((((-2.40799435809950D-08*X+8.12621667601546D-06)*X -  &
           9.04491430884113D-04)*X+6.37686375770059D-02)*X -            &
           2.96135703135647D+00)*X+9.15142356996330D+01)*X -            &
           1.86971865249111D+03)*X+2.42945528916947D+04)*X -            &
           1.81852473229081D+05)*X+5.96854758661427D+05)*E + W45*WW1     
      WW3 = (((((((( 1.83574464457207D-05*X-1.54837969489927D-03)*X +   &
           1.18520453711586D-01)*X-6.69649981309161D+00)*X +            &
           2.44789386487321D+02)*X-5.68832664556359D+03)*X +            &
           8.14507604229357D+04)*X-6.55181056671474D+05)*X +            &
           2.26410896607237D+06)*E + W35*WW1                             
      WW2 = (((((((( 2.77778345870650D-05*X-2.22835017655890D-03)*X +   &
           1.61077633475573D-01)*X-8.96743743396132D+00)*X +            &
           3.28062687293374D+02)*X-7.65722701219557D+03)*X +            &
           1.10255055017664D+05)*X-8.92528122219324D+05)*X +            &
           3.10638627744347D+06)*E + W25*WW1                             
      WW1 = WW1-0.01962D+00*E-WW2-WW3-WW4-WW5                            
      RETURN
                                                                        
  240 IF (X > 59.0D+00) GO TO 260                                        
!     X=40.0 TO 59.0                             NROOTS = 5              
      XXX = X**3                                                         
      E = XXX*EXP(-X)                                                    
      RT1 = (((-2.43758528330205D-02*X+2.07301567989771D+00)*X -        &
           6.45964225381113D+01)*X+7.14160088655470D+02)*E + R15/(X-R15) 
      RT2 = (((-2.28861955413636D-01*X+1.93190784733691D+01)*X -        &
           5.99774730340912D+02)*X+6.61844165304871D+03)*E + R25/(X-R25) 
      RT3 = (((-6.95053039285586D-01*X+5.76874090316016D+01)*X -        &
           1.77704143225520D+03)*X+1.95366082947811D+04)*E + R35/(X-R35) 
      RT4 = (((-1.58072809087018D+00*X+1.27050801091948D+02)*X -        &
           3.86687350914280D+03)*X+4.23024828121420D+04)*E + R45/(X-R45) 
      RT5 = (((-3.33963830405396D+00*X+2.51830424600204D+02)*X -        &
           7.57728527654961D+03)*X+8.21966816595690D+04)*E + R55/(X-R55) 
      E = XXX*E                                                          
      WW5 = (( 1.35482430510942D-08*X-3.27722199212781D-07)*X +         &
           2.41522703684296D-06)*E + W55*WW1                             
      WW4 = (( 1.23464092261605D-06*X-3.55224564275590D-05)*X +         &
           3.03274662192286D-04)*E + W45*WW1                             
      WW3 = (( 1.34547929260279D-05*X-4.19389884772726D-04)*X +         &
           3.87706687610809D-03)*E + W35*WW1                             
      WW2 = (( 2.09539509123135D-05*X-6.87646614786982D-04)*X +         &
           6.68743788585688D-03)*E + W25*WW1
      WW1 = WW1-WW2-WW3-WW4-WW5
      RETURN

!     X=59.0 TO INFINITY                         NROOTS = 5
  260 RT1 = R15/(X-R15)
      RT2 = R25/(X-R25)
      RT3 = R35/(X-R35)
      RT4 = R45/(X-R45)
      RT5 = R55/(X-R55)
      WW2 = W25*WW1
      WW3 = W35*WW1
      WW4 = W45*WW1
      WW5 = W55*WW1
      WW1 = WW1-WW2-WW3-WW4-WW5
      RETURN
      END

! Calling by HSandT & ERISPDFGHIL: ROOT6 
      SUBROUTINE ROOT6
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXAUX=55)
      DIMENSION RGRID(MXAUX),WGRID(MXAUX),P0(MXAUX),P1(MXAUX),          &
                P2(MXAUX),RTS(13),WTS(13),WRK(13),ALPHA(0:12),BETA(0:12)
      COMMON /ROOT  / XX,UF(13),WF(13),NROOTS
      COMMON /RYSPAR/ XASYMP(13),RTSASY(13,13),WTSASY(13,13),           &
                      NAUXS(13),MAPRYS(13),RTSAUX(55,8),WTSAUX(55,8)
!-----------------------------------------------------------------------
      IF(XX>=XASYMP(NROOTS)) THEN
       FACTR = 1.0d0/XX
       FACTW = SQRT(FACTR)
       DO I=1,NROOTS
         RTS(I)= FACTR * RTSASY(I,NROOTS)
         WTS(I)= FACTW * WTSASY(I,NROOTS)
       ENDDO
      ELSE
       NAUX=NAUXS(NROOTS)
       MAP=MAPRYS(NROOTS)
       DO I=1,NAUX
          T2 = RTSAUX(I,MAP)*RTSAUX(I,MAP)
          RGRID(I) = T2
          WGRID(I) = WTSAUX(I,MAP)*EXP(-XX*T2)
       ENDDO
       EPS = 1.0D-14
       CALL RYSDS(NROOTS,NAUX,RGRID,WGRID,ALPHA,BETA,IERR,P0,P1,P2)
       CALL RYSGW(NROOTS,ALPHA,BETA,EPS,RTS,WTS,IERR,WRK)
      END IF
      DO K=1,NROOTS
       DUM  = RTS(K)
       UF(K)= DUM/(1.0d0-DUM)
       WF(K)= WTS(K)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! RYSDS
      SUBROUTINE RYSDS(N,NCAP,X,W,ALPHA,BETA,IERR,P0,P1,P2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION X(NCAP),W(NCAP),ALPHA(N),BETA(N),P0(NCAP),              &
                P1(NCAP),P2(NCAP)

      TINY = 1.0D-40
      HUGE = 1.0D+40

      IERR=0
      IF(N<=0 .or. N>NCAP) THEN
        IERR=1
        RETURN
      END IF
      NM1=N-1

      SUM0=0.0D+00
      SUM1=0.0D+00
      DO 10 M=1,NCAP
        SUM0=SUM0+W(M)
        SUM1=SUM1+W(M)*X(M)
   10 CONTINUE
      ALPHA(1)=SUM1/SUM0
      BETA(1)=SUM0
      IF(N==1) RETURN

      DO 20 M=1,NCAP
        P1(M)=0.0D+00
        P2(M)=1.0D+00
   20 CONTINUE
      DO 40 K=1,NM1
        SUM1=0.0D+00
        SUM2=0.0D+00
        DO 30 M=1,NCAP

          IF(W(M)==0.0D+00) GOTO 30
          P0(M)=P1(M)
          P1(M)=P2(M)
          P2(M)=(X(M)-ALPHA(K))*P1(M)-BETA(K)*P0(M)

          IF(ABS(P2(M))>HUGE .or. ABS(SUM2)>HUGE) THEN
            IERR=K
            RETURN
          END IF
          T=W(M)*P2(M)*P2(M)
          SUM1=SUM1+T
          SUM2=SUM2+T*X(M)
   30   CONTINUE

        IF(ABS(SUM1)<TINY) THEN
          IERR=-K
          RETURN
        END IF
        ALPHA(K+1)=SUM2/SUM1
        BETA(K+1)=SUM1/SUM0
        SUM0=SUM1
   40 CONTINUE

      RETURN
      END
      
! RYSGW
      SUBROUTINE RYSGW(N,ALPHA,BETA,EPS,ROOTS,WEIGHT,IERR,WRK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION ALPHA(N),BETA(N),ROOTS(N),WEIGHT(N),WRK(N)

      IF(N<1) THEN
        IERR=-1
        RETURN
      END IF

      IERR=0
      ROOTS(1)=ALPHA(1)
      IF(BETA(1)<0.0D+00) THEN
        IERR=-2
        RETURN
      END IF
      WEIGHT(1)=BETA(1)
      IF (N==1) RETURN

      WEIGHT(1)=1.0D+00
      WRK(N)=0.0D+00
      DO 100 K=2,N
        ROOTS(K)=ALPHA(K)
        IF(BETA(K)<0.0D+00) THEN
          IERR=-2
          RETURN
        END IF
        WRK(K-1)=SQRT(BETA(K))
        WEIGHT(K)=0.0D+00
  100 CONTINUE

      DO 240 L=1,N
        J=0

  105   DO 110 M=L,N
         IF(M==N) GO TO 120
         IF(ABS(WRK(M))<=EPS*(ABS(ROOTS(M))+ABS(ROOTS(M+1))))GOTO 120
  110   CONTINUE
  120   DP=ROOTS(L)
        IF(M==L) GO TO 240
        IF(J==30) GO TO 400
        J=J+1

        DG=(ROOTS(L+1)-DP)/(2.0D+00*WRK(L))
        DR=SQRT(DG*DG+1.0D+00)
        DG=ROOTS(M)-DP+WRK(L)/(DG+SIGN(DR,DG))
        DS=1.0D+00
        DC=1.0D+00
        DP=0.0D+00
        MML=M-L

        DO 200 II=1,MML
          I=M-II
          DF=DS*WRK(I)
          DB=DC*WRK(I)
          IF(ABS(DF)<ABS(DG)) GO TO 150
          DC=DG/DF
          DR=SQRT(DC*DC+1.0D+00)
          WRK(I+1)=DF*DR
          DS=1.0D+00/DR
          DC=DC*DS
          GO TO 160
  150     DS=DF/DG
          DR=SQRT(DS*DS+1.0D+00)
          WRK(I+1)=DG*DR
          DC=1.0D+00/DR
          DS=DS*DC
  160     DG=ROOTS(I+1)-DP
          DR=(ROOTS(I)-DG)*DS+2.0D+00*DC*DB
          DP=DS*DR
          ROOTS(I+1)=DG+DP
          DG=DC*DR-DB

          DF=WEIGHT(I+1)
          WEIGHT(I+1)=DS*WEIGHT(I)+DC*DF
          WEIGHT(I)=DC*WEIGHT(I)-DS*DF
  200   CONTINUE
        ROOTS(L)=ROOTS(L)-DP
        WRK(L)=DG
        WRK(M)=0.0D+00
        GO TO 105
  240 CONTINUE

      DO 300 II=2,N
        I=II-1
        K=I
        DP=ROOTS(I)
        DO 260 J=II,N
          IF(ROOTS(J)>=DP) GO TO 260
          K=J
          DP=ROOTS(J)
  260   CONTINUE
        IF(K==I) GO TO 300
        ROOTS(K)=ROOTS(I)
        ROOTS(I)=DP
        DP=WEIGHT(I)
        WEIGHT(I)=WEIGHT(K)
        WEIGHT(K)=DP
  300 CONTINUE
      DO 310 K=1,N
        WEIGHT(K)=BETA(1)*WEIGHT(K)*WEIGHT(K)
  310 CONTINUE
      RETURN

  400 IERR=L

      RETURN
      END

! ExchangeInt                                           
      SUBROUTINE ExchangeInt(XINTS,GHONDO,NSH2,MAXG,EX,CS,CP,CD,CF,CG,  &
                             CH,CI,NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,  &
                             KMIN,KMAX,NSHELL,Cxyz,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER, DIMENSION(4,3) :: IB                                                       
      COMMON/INTDEX1/IJGT(784),KLGT(784)   
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)  
      COMMON/SHLNOS1/QQ4,IJKL
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DIMENSION XINTS(NSH2),GHONDO(MAXG)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DDIJ
      LOGICAL ISHandJSH
!-----------------------------------------------------------------------
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      NANGM =  4                                          
      IF(LMAXIMA==2) NANGM =  6                                          
      IF(LMAXIMA==3) NANGM = 10                                          
      IF(LMAXIMA==4) NANGM = 15                                          
      IF(LMAXIMA==5) NANGM = 21                                          
      IF(LMAXIMA==6) NANGM = 28                                          
      NGTH(4) = 1                                                       
      NGTH(3) = NGTH(4) * NANGM                                         
      NGTH(2) = NGTH(3) * NANGM                                         
      NGTH(1) = NGTH(2) * NANGM                                         
      DO I=1,3                                                       
       NORGSH(I) = 0                                               
       NORGSP(I) = 0                                               
      ENDDO                                                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEXCH = 1                                                         
      QQ4   = 1.0d0                                                       
      NINTEG  = 0  
!- - - - - - - - - - - - - - - - - - - - - - - -
      IJIJ = 0                                                          
      DO ISH = 1,NSHELL                                             
       DO JSH = 1,ISH                                             
        IJIJ = IJIJ+1                                               
        ALLOCATE(DDIJ(49*900))                                                      
        CALL SHELLS(1,ISH,JSH,ISH,JSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,   &
                    NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,&
                    Cxyz)                    
        CALL IJPRIM(DDIJ)                                           
        CALL SHELLS(2,ISH,JSH,ISH,JSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,   &
                    NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,&
                    Cxyz)                       
        CALL ZQOUT(GHONDO,MAXG)                                          
        IF(IJKL==1) CALL S0000(GHONDO,DDIJ)                       
        IF(IJKL>1) CALL ERISPDFGHIL(GHONDO,DDIJ)
        DEALLOCATE(DDIJ)
        VMAX = 0.0D+00                                                    
        MINI = KMIN(ISH)                                               
        MINJ = KMIN(JSH)                                               
        MAXI = KMAX(ISH)                                               
        JMAX = KMAX(JSH)                                               
        ISHandJSH=ISH==JSH                                               
        IBB = IB(1,IEXCH)                                              
        JBB = IB(2,IEXCH)                                              
        KBB = IB(3,IEXCH)                                              
        LBB = IB(4,IEXCH)                                              
        IJN = 0                                                        
        DO I=MINI,MAXI                                             
         IF(ISHandJSH) JMAX = I                                          
         DO J=MINJ,JMAX                                          
          IJN = IJN+1                                           
          NN = IJGT(IJN) + KLGT(IJN)                            
          VAL = GHONDO(NN)                                      
          IF(VAL>0.0D+00)NINTEG = NINTEG + 1                              
          IF(VAL>VMAX)VMAX=VAL                                 
         END DO
        END DO
        XINTS(IJIJ) = SQRT(VMAX)                                         
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! QOUT                                             
      SUBROUTINE QOUT(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,GHONDO,IDONTW,  &
                      KLOC,KMIN,KMAX,NSHELL)                            
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL IANDJ,KANDL,SAME
      INTEGER,DIMENSION(NSHELL) :: KLOC,KMIN,KMAX
      DIMENSION BUFP(NINTMX),IX(NINTMX),GHONDO(*)
      COMMON /ERIOUT/ ISH,JSH,KSH,LSH,LSTRI,LSTRJ,LSTRK,LSTRL           
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /RESTAR/ NREC,IST,JST,KST,LST                               
      INTEGER,DIMENSION(NINTEGtm) :: IX2                                 
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2                      
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,              &
                      MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          &
                      NIJ,IJ,KL                                    
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
      SAVE IJN,KLN                                                      
!-----------------------------------------------------------------------                                                                       
!     Pack 4-indices into 1 word. 
!     Write Label & integral on Unit 1 if DONTW = .False.
!-----------------------------------------------------------------------
      SAME  = ISH == KSH .and. JSH == LSH                           
      IANDJ = ISH == JSH                                              
      KANDL = KSH == LSH                                              
      MINI = KMIN(ISH)                                                  
      MINJ = KMIN(JSH)                                                  
      MINK = KMIN(KSH)                                                  
      MINL = KMIN(LSH)                                                  
      MAXI = KMAX(ISH)                                                  
      MAXJ = KMAX(JSH)                                                  
      MAXK = KMAX(KSH)                                                  
      MAXL = KMAX(LSH)                                                  
      LOCI = KLOC(ISH)-MINI                                             
      LOCJ = KLOC(JSH)-MINJ                                             
      LOCK = KLOC(KSH)-MINK                                             
      LOCL = KLOC(LSH)-MINL          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                               
      IJN = 0                                                           
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       I_INDEX = (I-MINI)*LSTRI + 1                                   
       IF (IANDJ) JMAX = I                                            
       DO 1 J = MINJ,JMAX                                           
        IJ_INDEX = (J-MINJ)*LSTRJ + I_INDEX                         
        IJN = IJN+1                                                 
        LMAX = MAXL                                                 
        KLN = 0                                                     
        DO K =  MINK,MAXK                                       
         IJK_INDEX = (K-MINK)*LSTRK + IJ_INDEX                    
         IF (KANDL) LMAX = K                                      
         DO L = MINL,LMAX                                     
          KLN = KLN+1                                           
          IF(SAME.and.KLN>IJN)GO TO 1                 
          IJKL_INDEX = (L-MINL)*LSTRL + IJK_INDEX               
          VAL = GHONDO( IJKL_INDEX ) 
          IF(ABS(VAL)>=CUTOFF)THEN
           I1 = LOCI+I                                           
           I2 = LOCJ+J                                           
           I3 = LOCK+K                                           
           I4 = LOCL+L                                           
           IF (I1 >= I2) GO TO 100                             
           N = I1                                                
           I1 = I2                                               
           I2 = N                                                
  100      IF (I3 >= I4) GO TO 120                             
           N = I3                                                
           I3 = I4                                               
           I4 = N                                                
  120      IF (I1-I3) 140,160,180                                
  140      N = I1                                                
           I1 = I3                                               
           I3 = N                                                
           N = I2                                                
           I2 = I4                                               
           I4 = N                                                
           GO TO 180                                             
  160      IF (I2 < I4) GO TO 140                             
  180      CONTINUE                                              
!                                                                
           IF(I1 == I2) VAL = VAL*0.5D0                        
           IF(I3 == I4) VAL = VAL*0.5D0                        
           IF(I1 == I3 .and. I2 == I4) VAL = VAL*0.5D0       
!                                                                
           NPACK = ICOUNT                                        
           IPACK = I1                                            
           JPACK = I2                                            
           KPACK = I3                                            
           LPACK = I4                                            
           LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 ) +            &
                   ISHFT( KPACK, 16 ) + LPACK                 
           IX(NPACK) = LABEL                                  
           BUFP(ICOUNT) = VAL 
           ICOUNT = ICOUNT+1                                     
           IF(ICOUNT > 0) THEN                           
            JCOUNT = ICOUNT                               
            IF(JCOUNT > NINTMX) THEN                        
             NXInteg = NINTMX
             IF(IDONTW==1)THEN
              IJBUFi = (NREC-1)*NINTMX
              do ibuf=1,NINTMX
               IX2  (IJBUFi+ibuf) = IX(ibuf)
               BUFP2(IJBUFi+ibuf) = BUFP(ibuf)
              end do
             ELSE
              WRITE(1)NXInteg,IX,BUFP
             END IF
             ICOUNT = 1                               
             NREC = NREC+1                                   
            END IF
           END IF
          END IF
         END DO
        END DO
    1  CONTINUE                                                       
      END DO
!-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END                                                               

! SHELLS                                           
      SUBROUTINE SHELLS(NELEC,ISH,JSH,KSH,LSH,FLIP,EX,CS,CP,CD,CF,CG,CH,&
                 CI,NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,&
                 Cxyz)                     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL       NORM
      COMMON/NORMAL/NORM
      LOGICAL     IANDJ,KANDL,SAME
      COMMON/MISC/IANDJ,KANDL,SAME
      COMMON /ERIOUT/ INU,JNU,KNU,LNU,NGTI,NGTJ,NGTK,NGTL                
      COMMON /INTDEX/ IJX(784),IJY(784),IJZ(784),IK(784),               &
                      KLX(784),KLY(784),KLZ(784)                         
      COMMON/INTDEX1/IJGT(784),KLGT(784)                                 
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      COMMON /ROOT  / XX,U(13),W(13),NROOTS                              
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NGTH(4)                  
      COMMON /SHLINF/  GA(30),CSA(30),CPA(30),CDA(30),                  &
                      CFA(30),CGA(30),CHA(30),CIA(30),                  &
                       GB(30),CSB(30),CPB(30),CDB(30),                  &
                      CFB(30),CGB(30),CHB(30),CIB(30),                  &
                       GC(30),CSC(30),CPC(30),CDC(30),                  &
                      CFC(30),CGC(30),CHC(30),CIC(30),                  &
                       GD(30),CSD(30),CPD(30),CDD(30),                  &
                      CFD(30),CGD(30),CHD(30),CID(30),                  &
                      AX,AY,AZ,BX,BY,BZ,RAB,CX,CY,CZ,                   &
                      DX,DY,DZ,RCD,NGA,NGB,NGC,NGD                                    
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,              &
                      MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          &
                      NIJ,IJ,KL                                          
      COMMON /SHLNOS1/QQ4,IJKL
!
      LOGICAL FLIP                                                      
      INTEGER,DIMENSION(NSHELL)::KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DIMENSION IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84),              &
                KX(84),KY(84),KZ(84),LX(84),LY(84),LZ(84)                                     
!
      DATA LX /   0,   1,   0,   0,   2,   0,   0,   1,   1,   0,       &
                  3,   0,   0,   2,   2,   1,   0,   1,   0,   1,       &
                  4,   0,   0,   3,   3,   1,   0,   1,   0,   2,       &
                  2,   0,   2,   1,   1,                                &
                  5,   0,   0,   4,   4,   1,   0,   1,   0,   3,       &
                  3,   2,   0,   2,   0,   3,   1,   1,   2,   2,       &
                  1,                                                    &
                  6,   0,   0,   5,   5,   1,   0,   1,   0,   4,       &
                  4,   2,   0,   2,   0,   4,   1,   1,   3,   3,       &
                  0,   3,   3,   2,   1,   2,   1,   2/                  
      DATA KX /   0,   7,   0,   0,  14,   0,   0,   7,   7,   0,       &
                 21,   0,   0,  14,  14,   7,   0,   7,   0,   7,       &
                 28,   0,   0,  21,  21,   7,   0,   7,   0,  14,       &
                 14,   0,  14,   7,   7,                                &
                 35,   0,   0,  28,  28,   7,   0,   7,   0,  21,       &
                 21,  14,   0,  14,   0,  21,   7,   7,  14,  14,       &
                  7,                                                    &
                 42,   0,   0,  35,  35,   7,   0,   7,   0,  28,       &
                 28,  14,   0,  14,   0,  28,   7,   7,  21,  21,       &
                  0,  21,  21,  14,   7,  14,   7,  14/                  
      DATA JX /   0,  49,   0,   0,  98,   0,   0,  49,  49,   0,       &
                147,   0,   0,  98,  98,  49,   0,  49,   0,  49,       &
                196,   0,   0, 147, 147,  49,   0,  49,   0,  98,       &
                 98,   0,  98,  49,  49,                                &
                245,   0,   0, 196, 196,  49,   0,  49,   0, 147,       &
                147,  98,   0,  98,   0, 147,  49,  49,  98,  98,       &
                 49,                                                    &
                294,   0,   0, 245, 245,  49,   0,  49,   0, 196,       &
                196,  98,   0,  98,   0, 196,  49,  49, 147, 147,       &
                  0, 147, 147,  98,  49,  98,  49,  98/                  
      DATA IX /   1, 344,   1,   1, 687,   1,   1, 344, 344,   1,       &
               1030,   1,   1, 687, 687, 344,   1, 344,   1, 344,       &
               1373,   1,   1,1030,1030, 344,   1, 344,   1, 687,       &
                687,   1, 687, 344, 344,                                &
               1716,   1,   1,1373,1373, 344,   1, 344,   1,1030,       &
               1030, 687,   1, 687,   1,1030, 344, 344, 687, 687,       &
                344,                                                    &
               2059,   1,   1,1716,1716, 344,   1, 344,   1,1373,       &
               1373, 687,   1, 687,   1,1373, 344, 344,1030,1030,       &
                  1,1030,1030, 687, 344, 687, 344, 687/                  
      DATA LY /   0,   0,   1,   0,   0,   2,   0,   1,   0,   1,       &
                  0,   3,   0,   1,   0,   2,   2,   0,   1,   1,       &
                  0,   4,   0,   1,   0,   3,   3,   0,   1,   2,       &
                  0,   2,   1,   2,   1,                                &
                  0,   5,   0,   1,   0,   4,   4,   0,   1,   2,       &
                  0,   3,   3,   0,   2,   1,   3,   1,   2,   1,       &
                  2,                                                    &
                  0,   6,   0,   1,   0,   5,   5,   0,   1,   2,       &
                  0,   4,   4,   0,   2,   1,   4,   1,   3,   0,       &
                  3,   2,   1,   3,   3,   1,   2,   2/                  
      DATA KY /   0,   0,   7,   0,   0,  14,   0,   7,   0,   7,       &
                  0,  21,   0,   7,   0,  14,  14,   0,   7,   7,       &
                  0,  28,   0,   7,   0,  21,  21,   0,   7,  14,       &
                  0,  14,   7,  14,   7,                                &
                  0,  35,   0,   7,   0,  28,  28,   0,   7,  14,       &
                  0,  21,  21,   0,  14,   7,  21,   7,  14,   7,       &
                 14,                                                    &
                  0,  42,   0,   7,   0,  35,  35,   0,   7,  14,       &
                  0,  28,  28,   0,  14,   7,  28,   7,  21,   0,       &
                 21,  14,   7,  21,  21,   7,  14,  14/                  
      DATA JY /   0,   0,  49,   0,   0,  98,   0,  49,   0,  49,       &
                  0, 147,   0,  49,   0,  98,  98,   0,  49,  49,       &
                  0, 196,   0,  49,   0, 147, 147,   0,  49,  98,       &
                  0,  98,  49,  98,  49,                                &
                  0, 245,   0,  49,   0, 196, 196,   0,  49,  98,       &
                  0, 147, 147,   0,  98,  49, 147,  49,  98,  49,       &
                 98,                                                    &
                  0, 294,   0,  49,   0, 245, 245,   0,  49,  98,       &
                  0, 196, 196,   0,  98,  49, 196,  49, 147,   0,       &
                147,  98,  49, 147, 147,  49,  98,  98/                  
      DATA IY /   1,   1, 344,   1,   1, 687,   1, 344,   1, 344,       &
                  1,1030,   1, 344,   1, 687, 687,   1, 344, 344,       &
                  1,1373,   1, 344,   1,1030,1030,   1, 344, 687,       &
                  1, 687, 344, 687, 344,                                &
                  1,1716,   1, 344,   1,1373,1373,   1, 344, 687,       &
                  1,1030,1030,   1, 687, 344,1030, 344, 687, 344,       &
                687,                                                    &
                  1,2059,   1, 344,   1,1716,1716,   1, 344, 687,       &
                  1,1373,1373,   1, 687, 344,1373, 344,1030,   1,       &
               1030, 687, 344,1030,1030, 344, 687, 687/                  
      DATA LZ /   0,   0,   0,   1,   0,   0,   2,   0,   1,   1,       &
                  0,   0,   3,   0,   1,   0,   1,   2,   2,   1,       &
                  0,   0,   4,   0,   1,   0,   1,   3,   3,   0,       &
                  2,   2,   1,   1,   2,                                &
                  0,   0,   5,   0,   1,   0,   1,   4,   4,   0,       &
                  2,   0,   2,   3,   3,   1,   1,   3,   1,   2,       &
                  2,                                                    &
                  0,   0,   6,   0,   1,   0,   1,   5,   5,   0,       &
                  2,   0,   2,   4,   4,   1,   1,   4,   0,   3,       &
                  3,   1,   2,   1,   2,   3,   3,   2/                  
      DATA KZ /   0,   0,   0,   7,   0,   0,  14,   0,   7,   7,       &
                  0,   0,  21,   0,   7,   0,   7,  14,  14,   7,       &
                  0,   0,  28,   0,   7,   0,   7,  21,  21,   0,       &
                 14,  14,   7,   7,  14,                                &
                  0,   0,  35,   0,   7,   0,   7,  28,  28,   0,       &
                 14,   0,  14,  21,  21,   7,   7,  21,   7,  14,       &
                 14,                                                    &
                  0,   0,  42,   0,   7,   0,   7,  35,  35,   0,       &
                 14,   0,  14,  28,  28,   7,   7,  28,   0,  21,       &
                 21,   7,  14,   7,  14,  21,  21,  14/                  
      DATA JZ /   0,   0,   0,  49,   0,   0,  98,   0,  49,  49,       &
                  0,   0, 147,   0,  49,   0,  49,  98,  98,  49,       &
                  0,   0, 196,   0,  49,   0,  49, 147, 147,   0,       &
                 98,  98,  49,  49,  98,                                &
                  0,   0, 245,   0,  49,   0,  49, 196, 196,   0,       &
                 98,   0,  98, 147, 147,  49,  49, 147,  49,  98,       &
                 98,                                                    &
                  0,   0, 294,   0,  49,   0,  49, 245, 245,   0,       &
                 98,   0,  98, 196, 196,  49,  49, 196,   0, 147,       &
                147,  49,  98,  49,  98, 147, 147,  98/                  
      DATA IZ /   1,   1,   1, 344,   1,   1, 687,   1, 344, 344,       &
                  1,   1,1030,   1, 344,   1, 344, 687, 687, 344,       &
                  1,   1,1373,   1, 344,   1, 344,1030,1030,   1,       &
                687, 687, 344, 344, 687,                                &
                  1,   1,1716,   1, 344,   1, 344,1373,1373,   1,       &
                687,   1, 687,1030,1030, 344, 344,1030, 344, 687,       &
                687,                                                    &
                  1,   1,2059,   1, 344,   1, 344,1716,1716,   1,       &
                687,   1, 687,1373,1373, 344, 344,1373,   1,1030,       &
               1030, 344, 687, 344, 687,1030,1030, 687/                 
!-----------------------------------------------------------------------                                                                       
!     PREPARE SHELL INFORMATION/FOR HONDO INTEGRATION 
      NORM = .TRUE.  
      IF(NELEC==2) GO TO 200                                          
!                                                                       
!     ----- PERMUTE ISH AND JSH SHELLS, FOR THEIR TYPE                  
!     THIS IS DONE FOR SPEED REASONS.  THE CODE GETS THE RIGHT ANSWER   
!     WITHOUT THE ANGULAR MOMENTUM FLIPPING, AND THEREFORE A CALLING    
!     ARGUMENT ALLOWS ONE DO EXACTLY THE integral BLOCK AS SPECIFIED,   
!     SHOULD THAT BE DESIRED.                                           
!                                                                       
      IANDJ = ISH == JSH                                              
      IF (KTYPE(ISH) < KTYPE(JSH)  .and.  FLIP) THEN                 
       INU = JSH                                                      
       JNU = ISH                                                      
       NGTI = NGTH(2)                                                 
       NGTJ = NGTH(1)                                                 
      ELSE                                                              
       INU = ISH                                                      
       JNU = JSH                                                      
       NGTI = NGTH(1)                                                 
       NGTJ = NGTH(2)                                                 
      END IF                                                            
!                                                                       
!     ----- ISHELL                                                      
!                                                                       
      I = KATOM(INU)                                                    
      AX = Cxyz(1,I)                                                       
      AY = Cxyz(2,I)                                                       
      AZ = Cxyz(3,I)                                                       
      I1 = KSTART(INU)                                                  
      I2 = I1+KNG(INU)-1                                                
      LIT = KTYPE(INU)                                                  
      MINI = KMIN(INU)                                                  
      MAXI = KMAX(INU)                                                  
      LOCI = KLOC(INU)-MINI                                             
      NGA = 0                                                           
      DO I = I1,I2                                                  
       NGA = NGA+1                                                    
       GA(NGA)  = EX(I)                                                
       CSA(NGA) = CS(I)                                               
       CPA(NGA) = CP(I)                                               
       CDA(NGA) = CD(I)                                               
       CFA(NGA) = CF(I)                                               
       CGA(NGA) = CG(I)                                               
       CHA(NGA) = CH(I)                                               
       CIA(NGA) = CI(I)                                               
      END DO                                                          
!                                                                       
!     ----- JSHELL                                                      
!                                                                       
      J = KATOM(JNU)                                                    
      BX = Cxyz(1,J)                                                       
      BY = Cxyz(2,J)                                                       
      BZ = Cxyz(3,J)                                                       
      J1 = KSTART(JNU)                                                  
      J2 = J1+KNG(JNU)-1                                                
      LJT = KTYPE(JNU)                                                  
      MINJ = KMIN(JNU)                                                  
      MAXJ = KMAX(JNU)                                                  
      LOCJ = KLOC(JNU)-MINJ                                             
      NGB = 0                                                           
      DO J = J1,J2                                                  
       NGB = NGB+1                                                    
       GB(NGB) = EX(J)                                                
       CSB(NGB) = CS(J)                                               
       CPB(NGB) = CP(J)                                               
       CDB(NGB) = CD(J)                                               
       CFB(NGB) = CF(J)                                               
       CGB(NGB) = CG(J)                                               
       CHB(NGB) = CH(J)                                               
       CIB(NGB) = CI(J)                                               
      END DO                                                          
      RAB = ((AX-BX)*(AX-BX) + (AY-BY)*(AY-BY) + (AZ-BZ)*(AZ-BZ))       
!                                                                       
!     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS                
!                                                                       
      IJ = 0                                                            
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       NX = IX(I)                                                     
       NY = IY(I)                                                     
       NZ = IZ(I)                                                     
       IF (IANDJ) JMAX = I                                            
       DO J = MINJ,JMAX                                           
        IJ = IJ+1                                                   
        IJX(IJ) = NX+JX(J)                                          
        IJY(IJ) = NY+JY(J)                                          
        IJZ(IJ) = NZ+JZ(J)                                          
        IJGT(IJ) = NGTI*(I-MINI)+NGTJ*(J-MINJ)+1                    
       END DO                                                       
      END DO                                                          
      RETURN                                                            
!     ******                                                            
!                                                                       
!        K AND L SHELL                                                  
!                                                                       
  200 CONTINUE                                                          
      KANDL = KSH == LSH                                              
      SAME = ISH == KSH .and. JSH == LSH                            
!                                                                       
!     ----- PERMUTE KSH AND LSH SHELLS, FOR THEIR TYPE                  
!                                                                       
      IF (KTYPE(KSH) < KTYPE(LSH)  .and.  FLIP) THEN                 
       KNU = LSH                                                      
       LNU = KSH                                                      
       NGTK = NGTH(4)                                                 
       NGTL = NGTH(3)                                                 
      ELSE                                                              
       KNU = KSH                                                      
       LNU = LSH                                                      
       NGTK = NGTH(3)                                                 
       NGTL = NGTH(4)                                                 
      END IF                                                            
!                                                                       
!     ----- K SHELL                                                     
!                                                                       
      K = KATOM(KNU)                                                    
      CX = Cxyz(1,K)                                                       
      CY = Cxyz(2,K)                                                       
      CZ = Cxyz(3,K)                                                       
      K1 = KSTART(KNU)                                                  
      K2 = K1+KNG(KNU)-1                                                
      LKT = KTYPE(KNU)                                                  
      MINK = KMIN(KNU)                                                  
      MAXK = KMAX(KNU)                                                  
      LOCK = KLOC(KNU)-MINK                                             
      NGC = 0                                                           
      DO K = K1,K2                                                  
       NGC = NGC+1                                                    
       GC(NGC)  = EX(K)                                                
       CSC(NGC) = CS(K)                                               
       CPC(NGC) = CP(K)                                               
       CDC(NGC) = CD(K)                                               
       CFC(NGC) = CF(K)                                               
       CGC(NGC) = CG(K)                                               
       CHC(NGC) = CH(K)                                               
       CIC(NGC) = CI(K)                                               
      END DO                                                          
!                                                                       
!     ----- LSHELL                                                      
!                                                                       
      L = KATOM(LNU)                                                    
      DX = Cxyz(1,L)                                                       
      DY = Cxyz(2,L)                                                       
      DZ = Cxyz(3,L)                                                       
      L1 = KSTART(LNU)                                                  
      L2 = L1+KNG(LNU)-1                                                
      LLT = KTYPE(LNU)                                                  
      MINL = KMIN(LNU)                                                  
      MAXL = KMAX(LNU)                                                  
      LOCL = KLOC(LNU)-MINL                                             
      NGD = 0                                                           
      DO L = L1,L2                                                  
       NGD = NGD+1                                                    
       GD(NGD) = EX(L)                                                
       CSD(NGD) = CS(L)                                               
       CPD(NGD) = CP(L)                                               
       CDD(NGD) = CD(L)                                               
       CFD(NGD) = CF(L)                                               
       CGD(NGD) = CG(L)                                               
       CHD(NGD) = CH(L)                                               
       CID(NGD) = CI(L)                                               
      END DO                                                          
      NROOTS = (LIT+LJT+LKT+LLT-2)/2                                    
      RCD = ((CX-DX)*(CX-DX) + (CY-DY)*(CY-DY) + (CZ-DZ)*(CZ-DZ))       
!                                                                       
!     ----- PREPARE INDICES FOR PAIRS OF (K,L) FUNCTIONS                
!                                                                       
      KL = 0                                                            
      LMAX = MAXL                                                       
      DO K = MINK,MAXK                                              
       NX = KX(K)                                                     
       NY = KY(K)                                                     
       NZ = KZ(K)                                                     
       IF (KANDL) LMAX = K                                            
       DO L = MINL,LMAX                                           
        KL = KL+1                                                   
        KLX(KL) = NX+LX(L)                                          
        KLY(KL) = NY+LY(L)                                          
        KLZ(KL) = NZ+LZ(L)                                          
        KLGT(KL) = NGTK*(K-MINK)+NGTL*(L-MINL)                      
       END DO                                                       
      END DO                                                          
      MAX = KL                                                          
      DO 320 I = 1,IJ                                                   
      IF (SAME) MAX = I                                                 
  320 IK(I) = MAX                                                       
      IJKL = IJ*KL                                                      
      IF (SAME) IJKL = IJ*(IJ+1)/2                                      
      RETURN                                                            
      END                                                               

! IJPRIM                                           
      SUBROUTINE IJPRIM(DDIJ)                                           
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL       NORM
      COMMON/NORMAL/NORM
      LOGICAL     IANDJ,KANDL,SAME 
      COMMON/MISC/IANDJ,KANDL,SAME
      COMMON/IJGNRL/A(900),R(900),X1(900),Y1(900),Z1(900),IJD(784)                                             
      COMMON/SHLINF/ AG(30),CSA(30),CPA(30),CDA(30),                    &
                    CFA(30),CGA(30),CHA(30),CIA(30),                    &
                     BG(30),CSB(30),CPB(30),CDB(30),                    &
                    CFB(30),CGB(30),CHB(30),CIB(30),                    &
                     CG(30),CSC(30),CPC(30),CDC(30),                    &
                    CFC(30),CGC(30),CHC(30),CIC(30),                    &
                     DG(30),CSD(30),CPD(30),CDD(30),                    &
                    CFD(30),CGD(30),CHD(30),CID(30),                    &
                    XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,                     &
                    XL,YL,ZL,RRK,NGA,NGB,NGC,NGD                                      
      COMMON/SHLNOS/LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,                &
                    MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,            &
                    NIJ,IJ,KL                                          
      COMMON/SHLT/SHLTOL,CUTOFF,ICOUNT
!
      DIMENSION DDIJ(49*900)                                           
      PARAMETER (SQRT3=1.73205080756888D0,SQRT5=2.23606797749979D0,     &                       
                 SQRT7=2.64575131106459D0,SQRT11=3.3166247903553998D0)                             
!-----------------------------------------------------------------------
      MAX = MAXJ                                                        
      N = 0                                                             
      NN = 0                                                            
      NM = -2**20                                                       
      DO 180 I = MINI,MAXI                                              
         GO TO (100,100,120,120,100,120,120,100,120,120,                &
                100,120,120,100,120,120,120,120,120,100,                &
                100,120,120,100,120,120,120,120,120,100,                &
                120,120,100,120,120,                                    &
                100,120,120,100,120,120,120,120,120,100,                &
                120,120,120,120,120,100,120,120,100,120,                &
                120,                                                    &
                100,120,120,100,120,120,120,120,120,100,                &
                120,120,120,120,120,100,120,120,100,120,                &
                120,100,120,120,120,120,120,100),I                       
  100    NM = NN                                                         
  120    NN = NM                                                         
         IF (IANDJ) MAX = I                                              
         DO 170 J = MINJ,MAX                                             
            GO TO (140,140,160,160,140,160,160,140,160,160,             &
                   140,160,160,140,160,160,160,160,160,140,             &
                   140,160,160,140,160,160,160,160,160,140,             &
                   160,160,140,160,160,                                 &
                   140,160,160,140,160,160,160,160,160,140,             &
                   160,160,160,160,160,140,160,160,140,160,             &
                   160,                                                 &
                   140,160,160,140,160,160,160,160,160,140,             &
                   160,160,160,160,160,140,160,160,140,160,             &
                   160,140,160,160,160,160,160,140),J                   
  140       NN = NN+1                                                   
  160       N = N+1                                                     
            IJD(N) = NN                                                 
  170    CONTINUE                                                       
  180 CONTINUE                                                          
!                                                                       
!     ----- I PRIMITIVE                                                 
!                                                                       
      NIJ = 0                                                           
      JBMAX = NGB                                                       
      DO 540 IA = 1,NGA                                                 
         AI = AG(IA)                                                    
         ARRI = AI*RRI                                                  
         AXI = AI*XI                                                    
         AYI = AI*YI                                                    
         AZI = AI*ZI                                                    
         CSI = CSA(IA)                                                  
         CPI = CPA(IA)                                                  
         CDI = CDA(IA)                                                  
         CFI = CFA(IA)                                                  
         CGI = CGA(IA)                                                  
         CHI = CHA(IA)                                                  
         CII = CIA(IA)                                                  
!                                                                       
!        ----- J PRIMITIVE                                              
!                                                                       
         IF (IANDJ) JBMAX = IA                                          
         DO 520 JB = 1,JBMAX                                            
            AJ = BG(JB)                                                 
            AA = AI+AJ                                                  
            AAINV = 1.0d0/AA                                              
            DUM = AJ*ARRI*AAINV                                         
            IF (DUM > SHLTOL) GO TO 520                                 
            CSJ = CSB(JB)                                               
            CPJ = CPB(JB)                                               
            CDJ = CDB(JB)                                               
            CFJ = CFB(JB)                                               
            CGJ = CGB(JB)                                               
            CHJ = CHB(JB)                                               
            CIJ = CIB(JB)                                               
            NM = 49*NIJ                                                 
            NN = NM                                                     
            NIJ = NIJ+1                                                 
            R(NIJ) = DUM                                                
            A(NIJ) = AA                                                 
            X1(NIJ) = (AXI+AJ*XJ)*AAINV                                 
            Y1(NIJ) = (AYI+AJ*YJ)*AAINV                                 
            Z1(NIJ) = (AZI+AJ*ZJ)*AAINV                                 
!                                                                       
!           ----- DENSITY FACTOR                                        
!                                                                       
            DUM1 = 0.0d0                                                 
            DUM2 = 0.0d0                                                 
            DO 420 I = MINI,MAXI                                        
               GO TO (200,220,420,420,240,420,420,260,420,420,          &
                      261,420,420,262,420,420,420,420,420,263,          &
                      264,420,420,265,420,420,420,420,420,266,          &
                      420,420,267,420,420,                              &
                      268,420,420,269,420,420,420,420,420,270,          &
                      420,420,420,420,420,271,420,420,272,420,          &
                      420,                                              &
                      273,420,420,274,420,420,420,420,420,275,          &
                      420,420,420,420,420,276,420,420,277,420,          &
                      420,278,420,420,420,420,420,279),I                
  200          DUM1 = CSI*AAINV                                         
               GO TO 280                                                
  220          DUM1 = CPI*AAINV                                         
               GO TO 280                                                
  240          DUM1 = CDI*AAINV                                         
               GO TO 280                                                
  260          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  261          DUM1 = CFI*AAINV                                         
               GO TO 280                                                
  262          IF (NORM) DUM1 = DUM1*SQRT5                              
               GO TO 280                                                
  263          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  264          DUM1 = CGI*AAINV                                         
               GO TO 280                                                
  265          IF (NORM) DUM1 = DUM1*SQRT7                              
               GO TO 280                                                
  266          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
               GO TO 280                                                
  267          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  268          DUM1 = CHI*AAINV                                         
               GO TO 280                                                
  269          IF (NORM) DUM1 = DUM1*3.0d0                              
               GO TO 280                                                
  270          IF (NORM) DUM1 = DUM1*SQRT7/SQRT3                        
               GO TO 280                                                
  271          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  272          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
               GO TO 280                                                
  273          DUM1 = CII*AAINV                                         
               GO TO 280                                                
  274          IF (NORM) DUM1 = DUM1*SQRT11                             
               GO TO 280                                                
  275          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  276          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  277          IF (NORM) DUM1 = DUM1*SQRT7/(SQRT5*SQRT3)                
               GO TO 280                                                
  278          IF (NORM) DUM1 = DUM1*SQRT5                              
               GO TO 280                                                
  279          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
!                                                                       
  280          IF (IANDJ) MAX = I                                       
               DO 400 J = MINJ,MAX                                      
                  GO TO (300,320,400,400,340,400,400,360,400,400,       &
                         361,400,400,362,400,400,400,400,400,363,       &
                         364,400,400,365,400,400,400,400,400,366,       &
                         400,400,367,400,400,                           &
                         368,400,400,369,400,400,400,400,400,370,       &
                         400,400,400,400,400,371,400,400,372,400,       &
                         400,                                           &
                         373,400,400,374,400,400,400,400,400,375,       &
                         400,400,400,400,400,376,400,400,377,400,       &
                         400,378,400,400,400,400,400,379),J             
  300             DUM2 = DUM1*CSJ                                       
                  GO TO 380                                             
  320             DUM2 = DUM1*CPJ                                       
                  GO TO 380                                             
  340             DUM2 = DUM1*CDJ                                       
                  GO TO 380                                             
  360             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  361             DUM2 = DUM1*CFJ                                       
                  GO TO 380                                             
  362             IF (NORM) DUM2 = DUM2*SQRT5                           
                  GO TO 380                                             
  363             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  364             DUM2 = DUM1*CGJ                                       
                  GO TO 380                                             
  365             IF (NORM) DUM2 = DUM2*SQRT7                           
                  GO TO 380                                             
  366             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
                  GO TO 380                                             
  367             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  368             DUM2 = DUM1*CHJ                                       
                  GO TO 380                                             
  369             IF (NORM) DUM2 = DUM2*3.0d0                           
                  GO TO 380                                             
  370             IF (NORM) DUM2 = DUM2*SQRT7/SQRT3                     
                  GO TO 380                                             
  371             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  372             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
                  GO TO 380                                             
  373             DUM2 = DUM1*CIJ                                       
                  GO TO 380                                             
  374             IF (NORM) DUM2 = DUM2*SQRT11                          
                  GO TO 380                                             
  375             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  376             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  377             IF (NORM) DUM2 = DUM2*SQRT7/(SQRT5*SQRT3)             
                  GO TO 380                                             
  378             IF (NORM) DUM2 = DUM2*SQRT5                           
                  GO TO 380                                             
  379             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
!                                                                       
  380             NN = NN+1                                             
                  DDIJ(NN) = DUM2                                       
  400          CONTINUE                                                 
  420       CONTINUE                                                    
            IF ( .NOT. IANDJ) GO TO 520                                 
            IF (IA == JB) GO TO 520                                   
            GO TO (500,440,460,455,450,445,444),LIT                     
  440       IF (MINI == 2) GO TO 500                                  
            DDIJ(NM+2) = DDIJ(NM+2)+CSI*CPJ*AAINV                       
            GO TO 480                                                   
  444       DDIJ(NM+28) = DDIJ(NM+28)+DDIJ(NM+28)                       
            DDIJ(NM+27) = DDIJ(NM+27)+DDIJ(NM+27)                       
            DDIJ(NM+26) = DDIJ(NM+26)+DDIJ(NM+26)                       
            DDIJ(NM+25) = DDIJ(NM+25)+DDIJ(NM+25)                       
            DDIJ(NM+24) = DDIJ(NM+24)+DDIJ(NM+24)                       
            DDIJ(NM+23) = DDIJ(NM+23)+DDIJ(NM+23)                       
            DDIJ(NM+22) = DDIJ(NM+22)+DDIJ(NM+22)                       
            DDIJ(NM+21) = DDIJ(NM+21)+DDIJ(NM+21)                       
            DDIJ(NM+20) = DDIJ(NM+20)+DDIJ(NM+20)                       
            DDIJ(NM+19) = DDIJ(NM+19)+DDIJ(NM+19)                       
            DDIJ(NM+18) = DDIJ(NM+18)+DDIJ(NM+18)                       
            DDIJ(NM+17) = DDIJ(NM+17)+DDIJ(NM+17)                       
            DDIJ(NM+16) = DDIJ(NM+16)+DDIJ(NM+16)                       
  445       DDIJ(NM+15) = DDIJ(NM+15)+DDIJ(NM+15)                       
            DDIJ(NM+14) = DDIJ(NM+14)+DDIJ(NM+14)                       
            DDIJ(NM+13) = DDIJ(NM+13)+DDIJ(NM+13)                       
            DDIJ(NM+12) = DDIJ(NM+12)+DDIJ(NM+12)                       
            DDIJ(NM+11) = DDIJ(NM+11)+DDIJ(NM+11)                       
  450       DDIJ(NM+10) = DDIJ(NM+10)+DDIJ(NM+10)                       
            DDIJ(NM+9) = DDIJ(NM+9)+DDIJ(NM+9)                          
            DDIJ(NM+8) = DDIJ(NM+8)+DDIJ(NM+8)                          
            DDIJ(NM+7) = DDIJ(NM+7)+DDIJ(NM+7)                          
  455       DDIJ(NM+6) = DDIJ(NM+6)+DDIJ(NM+6)                          
            DDIJ(NM+5) = DDIJ(NM+5)+DDIJ(NM+5)                          
            DDIJ(NM+4) = DDIJ(NM+4)+DDIJ(NM+4)                          
  460       DDIJ(NM+2) = DDIJ(NM+2)+DDIJ(NM+2)                          
  480       DDIJ(NM+3) = DDIJ(NM+3)+DDIJ(NM+3)                          
  500       DDIJ(NM+1) = DDIJ(NM+1)+DDIJ(NM+1)                          
  520    CONTINUE                                                       
  540 CONTINUE
!-----------------------------------------------------------------------                                                          
      RETURN                                                            
      END                                                               

! S0000                                            
      SUBROUTINE S0000(GHONDO,DDIJ)                                     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL IANDJ,KANDL,SAME
      DIMENSION GHONDO(*),DDIJ(49*900)                                 
      COMMON /IJGNRL/ A(900),R(900),X1(900),Y1(900),Z1(900),IJD(784)                                           
      COMMON /MISC  / IANDJ,KANDL,SAME                                   
      COMMON /SHLINF/  AG(30),CSA(30),CPA(30),CDA(30),                  &
                      CFA(30),CGA(30),CHA(30),CIA(30),                  &
                       BG(30),CSB(30),CPB(30),CDB(30),                  &
                      CFB(30),CGB(30),CHB(30),CIB(30),                  &
                       CG(30),CSC(30),CPC(30),CDC(30),                  &
                      CFC(30),CGC(30),CHC(30),CIC(30),                  &
                       DG(30),CSD(30),CPD(30),CDD(30),                  &
                      CFD(30),CGD(30),CHD(30),CID(30),                  &
                      XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,                   &
                      XL,YL,ZL,RRK,NGA,NGB,NGC,NGD                                    
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,              &
                      MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          &
                      NIJ,IJ,KL                                    
      COMMON /SHLNOS1/QQ4,IJKL                         
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
      PARAMETER (PI252=34.986836655250D+00, PIE4=7.85398163397448D-01)                             
!-----------------------------------------------------------------------                                                                       
!     SSSS integral for HONDO integrals          
!-----------------------------------------------------------------------                                                                       
      GGOUT = 0.0d0                                                      
      LGMAX = NGD                                                       
      DO 300 KG = 1,NGC                                                 
      BK = CG(KG)                                                       
      BRRK = BK*RRK                                                     
      BXK = BK*XK                                                       
      BYK = BK*YK                                                       
      BZK = BK*ZK                                                       
      CSK = CSC(KG)                                                     
      IF (KANDL) LGMAX = KG                                             
      DO 280 LG = 1,LGMAX                                               
      BL = DG(LG)                                                       
      BB = BK+BL                                                        
      BBINV = 1.0d0/BB                                                    
      DUM = BL*BRRK*BBINV                                               
      IF (DUM > SHLTOL) GO TO 280                                       
      BBRRK = DUM                                                       
      D2 = CSD(LG)*CSK*BBINV                                            
      IF (KANDL .and. LG /= KG) D2 = D2+D2                            
      BBX = (BXK+BL*XL)*BBINV                                           
      BBY = (BYK+BL*YL)*BBINV                                           
      BBZ = (BZK+BL*ZL)*BBINV                                           
      SUM = 0.0d0                                                        
      NN = 1                                                            
      DO 260 N = 1,NIJ                                                  
      DUM = BBRRK+R(N)                                                  
      IF (DUM > SHLTOL) GO TO 260                                       
      EXPE = EXP(-DUM)                                                  
      AA = A(N)                                                         
      AB = AA+BB                                                        
      DUM = X1(N)-BBX                                                   
      XX = DUM*DUM                                                      
      DUM = Y1(N)-BBY                                                   
      XX = DUM*DUM+XX                                                   
      DUM = Z1(N)-BBZ                                                   
      XX = DUM*DUM+XX                                                   
      X = XX*AA*BB/AB                                                   
!                                                                       
      IF (X > 5.0D+00) GO TO 160                                     
      IF (X > 1.0D+00) GO TO 120                                     
      IF (X > 3.0D-07) GO TO 100                                     
      WW1 = 1.0D+00-X/3.0D+00                                           
      GO TO 240                                                         
!                                                                       
  100 CONTINUE                                                          
      F1 = ((((((((-8.36313918003957D-08*X+1.21222603512827D-06 )*X-    &
           1.15662609053481D-05 )*X+9.25197374512647D-05 )*X-           &
           6.40994113129432D-04 )*X+3.78787044215009D-03 )*X-           &
           1.85185172458485D-02 )*X+7.14285713298222D-02 )*X-           &
           1.99999999997023D-01 )*X+3.33333333333318D-01                 
      WW1 = (X+X)*F1+EXP(-X)                                             
      GO TO 240                                                          
!                                                                        
  120 CONTINUE                                                           
      IF (X > 3.0D+00) GO TO 140                                         
      Y = X-2.0D+00                                                      
      F1 = ((((((((((-1.61702782425558D-10*Y+1.96215250865776D-09 )*Y-  &
           2.14234468198419D-08 )*Y+2.17216556336318D-07 )*Y-           &
           1.98850171329371D-06 )*Y+1.62429321438911D-05 )*Y-           &
           1.16740298039895D-04 )*Y+7.24888732052332D-04 )*Y-           &
           3.79490003707156D-03 )*Y+1.61723488664661D-02 )*Y-           &
           5.29428148329736D-02 )*Y+1.15702180856167D-01                 
      WW1 = (X+X)*F1+EXP(-X)                                             
      GO TO 240                                                          
!                                                                        
  140 CONTINUE                                                           
      Y = X-4.0D+00                                                      
      F1 = ((((((((((-2.62453564772299D-11*Y+3.24031041623823D-10 )*Y-  &
           3.614965656163D-09)*Y+3.760256799971D-08)*Y-                 &
           3.553558319675D-07)*Y+3.022556449731D-06)*Y-                 &
           2.290098979647D-05)*Y+1.526537461148D-04)*Y-                 &
           8.81947375894379D-04 )*Y+4.33207949514611D-03 )*Y-           &
           1.75257821619926D-02 )*Y+5.28406320615584D-02                 
      WW1 = (X+X)*F1+EXP(-X)                                             
      GO TO 240                                                          
!                                                                        
  160 CONTINUE                                                           
      IF (X > 15.0D+00) GO TO 200                                        
      E = EXP(-X)                                                        
      IF (X > 10.0D+00) GO TO 180                                        
      XINV = 1.0d0/X                                                      
      WW1 = (((((( 4.6897511375022D-01*XINV-6.9955602298985D-01)*XINV + &
           5.3689283271887D-01)*XINV-3.2883030418398D-01)*XINV +        &
           2.4645596956002D-01)*XINV-4.9984072848436D-01)*XINV -        &
           3.1501078774085D-06)*E + SQRT(PIE4*XINV)                      
      GO TO 240                                                          
!                                                                        
  180 CONTINUE                                                           
      XINV = 1.0d0/X                                                      
      WW1 = (((-1.8784686463512D-01*XINV+2.2991849164985D-01)*XINV      &
               -4.9893752514047D-01)*XINV-2.1916512131607D-05)*E        &
               + SQRT(PIE4*XINV)                                        
      GO TO 240                                                         
!                                                                       
  200 CONTINUE                                                          
      IF (X > 33.0D+00) GO TO 220                                    
      XINV = 1.0d0/X                                                      
      E = EXP(-X)                                                       
      WW1 = (( 1.9623264149430D-01*XINV-4.9695241464490D-01)*XINV -     &
                 6.0156581186481D-05)*E + SQRT(PIE4*XINV)                     
      GO TO 240                                                         
!                                                                       
  220 WW1 = SQRT(PIE4/X)                                                
!                                                                       
  240 CONTINUE                                                          
      SUM = SUM+DDIJ(NN)*WW1*EXPE/SQRT(AB)                
  260 NN = NN+49                                                        
      GGOUT = GGOUT+D2*SUM                                              
  280 CONTINUE                                                          
  300 CONTINUE                                                          
      GHONDO(1) = GGOUT*PI252*QQ4                                       
      RETURN                                                            
      END                                                               

! ERISPDFGHIL                                           
      SUBROUTINE ERISPDFGHIL(GHONDO,DDIJ)                                    
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      LOGICAL       NORM
      COMMON/NORMAL/NORM
      LOGICAL     IANDJ,KANDL,SAME 
      COMMON/MISC/IANDJ,KANDL,SAME
      COMMON/DENS/DKL(784),DIJ(784)                                 
      COMMON/IJGNRL/AA(900),R(900),X1(900),Y1(900),Z1(900),IJD(784)                                             
      COMMON/ROOT/XX,U(13),W(13),NROOTS                                
      COMMON/SETINT/IN(13),KN(13),NI,NJ,NK,NL,NMAX,MMAX,                &
                    BP01,B00,B10,XCP00,XC00,YCP00,YC00,                 &
                    ZCP00,ZC00,F00,                                     &
                    DXIJ,DYIJ,DZIJ,DXKL,DYKL,DZKL                        
      COMMON/SHLINF/ AG(30),CSA(30),CPA(30),CDA(30),                    &
                    CFA(30),CGA(30),CHA(30),CIA(30),                    &
                     BG(30),CSB(30),CPB(30),CDB(30),                    &
                    CFB(30),CGB(30),CHB(30),CIB(30),                    &
                     CG(30),CSC(30),CPC(30),CDC(30),                    &
                    CFC(30),CGC(30),CHC(30),CIC(30),                    &
                     DG(30),CSD(30),CPD(30),CDD(30),                    &
                    CFD(30),CGD(30),CHD(30),CID(30),                    &
                    XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,                     &
                    XL,YL,ZL,RRK,NGA,NGB,NGC,NGD                                      
      COMMON/SHLNOS/LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,                &
                    MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,            &
                    NIJ,IJ,KL                                          
      COMMON/SHLNOS1/QQ4,IJKL
      COMMON/SHLT/ SHLTOL,CUTOFF,ICOUNT
!
      LOGICAL DOBLE                          
      DIMENSION IN1(13),GHONDO(*),DDIJ(*)                                                  
      PARAMETER (SQRT3=1.73205080756888D0,SQRT5=2.23606797749979D0,     &
                 SQRT7=2.64575131106459D0,PI252=34.986836655250D0,      &
                 SQRT11=3.3166247903553998D0)               
!-----------------------------------------------------------------------
      FACTOR = PI252*QQ4                                                
      NI = LIT-1                                                        
      NJ = LJT-1                                                        
      NK = LKT-1                                                        
      NL = LLT-1                                                        
      DXIJ = XI-XJ                                                      
      DYIJ = YI-YJ                                                      
      DZIJ = ZI-ZJ                                                      
      DXKL = XK-XL                                                      
      DYKL = YK-YL                                                      
      DZKL = ZK-ZL                                                      
      NMAX = NI+NJ                                                      
      MMAX = NK+NL                                                      
      MAX = NMAX+1                                                      
      DO I = 1,MAX                                                  
       N = I-1                                                        
       IF (N <= NI) IN1(I) = 343*N+1                                
       IF (N > NI) IN1(I) = 343*NI+49*(N-NI)+1                     
      END DO
      MAX = MMAX+1                                                      
      DO K = 1,MAX                                                  
       N = K-1                                                        
       IF (N <= NK) KN(K) = 7*N                                     
       IF (N > NK) KN(K) = 7*NK+N-NK                               
      END DO
      LGMAX = NGD                                                       
      DO KG = 1,NGC                        !      K Primitive                                                 
       AK = CG(KG)                                                    
       BRRK = AK*RRK                                                  
       AKXK = AK*XK                                                   
       AKYK = AK*YK                                                   
       AKZK = AK*ZK                                                   
       CSK = CSC(KG)*FACTOR                                           
       CPK = CPC(KG)*FACTOR                                           
       CDK = CDC(KG)*FACTOR                                           
       CFK = CFC(KG)*FACTOR                                           
       CGK = CGC(KG)*FACTOR                                           
       CHK = CHC(KG)*FACTOR                                           
       CIK = CIC(KG)*FACTOR                                           
       IF (KANDL) LGMAX = KG                                          
       DO LG = 1,LGMAX                     !      L Primitive
        AL = DG(LG)                                                 
        B = AK+AL                                                   
        BINV = 1.0d0/B                                                
        BBRRK = AL*BRRK*BINV                                        
        IF(BBRRK<=SHLTOL)THEN
         CSL = CSD(LG)                                               
         CPL = CPD(LG)                                               
         CDL = CDD(LG)                                               
         CFL = CFD(LG)                                               
         CGL = CGD(LG)                                               
         CHL = CHD(LG)                                               
         CIL = CID(LG)                                               
         XB = (AKXK+AL*XL)*BINV                                      
         YB = (AKYK+AL*YL)*BINV                                      
         ZB = (AKZK+AL*ZL)*BINV                                      
         BXBK = B*(XB-XK)                                            
         BYBK = B*(YB-YK)                                            
         BZBK = B*(ZB-ZK)                                            
         BXBI = B*(XB-XI)                                            
         BYBI = B*(YB-YI)                                            
         BZBI = B*(ZB-ZI)                                            
!        DENSITY FACTOR                                        
         DOBLE = KANDL.and.KG/=LG                                   
         N = 0                                                       
         MAX = MAXL                                                  
         DUM1 = 0.0d0                                                 
         DUM2 = 0.0d0                                                 
         DO K = MINK,MAXK                                        
          GO TO (140,160,220,220,180,220,220,200,220,220,               &
                 201,220,220,202,220,220,220,220,220,203,               &
                 204,220,220,205,220,220,220,220,220,206,               &
                 220,220,207,220,220,                                   &
                 208,220,220,209,220,220,220,220,220,210,               &
                 220,220,220,220,220,211,220,220,212,220,               &
                 220,                                                   &
                 213,220,220,214,220,220,220,220,220,215,               &
                 220,220,220,220,220,216,220,220,217,220,               &
                 220,218,220,220,220,220,220,219),K                      
  140     DUM1 = CSK*BINV                                          
          GO TO 220                                                
  160     DUM1 = CPK*BINV                                          
          GO TO 220                                                
  180     DUM1 = CDK*BINV                                          
          GO TO 220                                                
  200     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  201     DUM1 = CFK*BINV                                          
          GO TO 220                                                
  202     IF (NORM) DUM1 = DUM1*SQRT5                              
          GO TO 220                                                
  203     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  204     DUM1 = CGK*BINV                                          
          GO TO 220                                                
  205     IF (NORM) DUM1 = DUM1*SQRT7                              
          GO TO 220                                                
  206     IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
          GO TO 220                                                
  207     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  208     DUM1 = CHK*BINV                                          
          GO TO 220                                                
  209     IF (NORM) DUM1 = DUM1*3.0d0                              
          GO TO 220                                                
  210     IF (NORM) DUM1 = DUM1*SQRT7/SQRT3                        
          GO TO 220                                                
  211     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  212     IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
          GO TO 220                                                
  213     DUM1 = CIK*BINV                                          
          GO TO 220                                                
  214     IF (NORM) DUM1 = DUM1*SQRT11                             
          GO TO 220                                                
  215     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  216     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  217     IF (NORM) DUM1 = DUM1*SQRT7/(SQRT5*SQRT3)                
          GO TO 220                                                
  218     IF (NORM) DUM1 = DUM1*SQRT5                              
          GO TO 220                                                
  219     IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
!                                                                  
  220     IF (KANDL) MAX = K                                       
          DO L = MINL,MAX                                      
           GO TO (240,280,340,340,300,340,340,320,340,340,              &
                  321,340,340,322,340,340,340,340,340,323,              &
                  324,340,340,325,340,340,340,340,340,326,              &
                  340,340,327,340,340,                                  &
                  328,340,340,329,340,340,340,340,340,330,              &
                  340,340,340,340,340,331,340,340,332,340,              &
                  340,                                                  &
                  333,340,340,334,340,340,340,340,340,335,              &
                  340,340,340,340,340,336,340,340,337,340,              &
                  340,338,340,340,340,340,340,339),L             
  240      DUM2 = DUM1*CSL                                       
           IF ( .NOT. DOBLE) GO TO 340                          
           IF (K > 1) GO TO 260                               
           DUM2 = DUM2+DUM2                                      
           GO TO 340                                             
  260      DUM2 = DUM2+CSK*CPL*BINV                              
           GO TO 340                                             
  280      DUM2 = DUM1*CPL                                       
           IF (DOBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  300      DUM2 = DUM1*CDL                                       
           IF (DOBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  320      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  321      DUM2 = DUM1*CFL                                       
           IF (DOBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  322      IF (NORM) DUM2 = DUM2*SQRT5                           
           GO TO 340                                             
  323      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  324      DUM2 = DUM1*CGL                                       
           IF (DOBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  325      IF (NORM) DUM2 = DUM2*SQRT7                           
           GO TO 340                                             
  326      IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
           GO TO 340                                             
  327      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  328      DUM2 = DUM1*CHL                                       
           IF (DOBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  329      IF (NORM) DUM2 = DUM2*3.0d0                           
           GO TO 340                                             
  330      IF (NORM) DUM2 = DUM2*SQRT7/SQRT3                     
           GO TO 340                                             
  331      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  332      IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
           GO TO 340                                             
  333      DUM2 = DUM1*CIL                                       
           IF (DOBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  334      IF (NORM) DUM2 = DUM2*SQRT11                          
           GO TO 340                                             
  335      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  336      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  337      IF (NORM) DUM2 = DUM2*SQRT7/(SQRT5*SQRT3)             
           GO TO 340                                             
  338      IF (NORM) DUM2 = DUM2*SQRT5                           
           GO TO 340                                             
  339      IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
!                                                                
  340      N = N+1                                               
           DKL(N) = DUM2                                         
          END DO
         END DO
!
         NN = 0                                                      
         DO N = 1,NIJ                      !         I,J Primitives                                
          DUM = BBRRK+R(N)                                         
          IF(DUM<=SHLTOL)THEN
           DO I = 1,IJ                                          
            DIJ(I) = DDIJ(IJD(I)+NN)                              
           END DO
           A = AA(N)                                                
           AB = A*B                                                 
           AANDB = A+B                                              
           EXPE = EXP(-DUM)/SQRT(AANDB)                             
           RHO = AB/AANDB                                           
           XA = X1(N)                                               
           YA = Y1(N)                                               
           ZA = Z1(N)                                               
           XX = RHO*((XA-XB)*(XA-XB)+(YA-YB)*(YA-YB)+(ZA-ZB)*(ZA-ZB))             
           AXAK = A*(XA-XK)                                         
           AYAK = A*(YA-YK)                                         
           AZAK = A*(ZA-ZK)                                         
           AXAI = A*(XA-XI)                                         
           AYAI = A*(YA-YI)                                         
           AZAI = A*(ZA-ZI)                                         
           C1X = BXBK+AXAK                                          
           C2X = A*BXBK                                             
           C3X = BXBI+AXAI                                          
           C4X = B*AXAI                                             
           C1Y = BYBK+AYAK                                          
           C2Y = A*BYBK                                             
           C3Y = BYBI+AYAI                                          
           C4Y = B*AYAI                                             
           C1Z = BZBK+AZAK                                          
           C2Z = A*BZBK                                             
           C3Z = BZBI+AZAI                                          
           C4Z = B*AZAI                                             
           IF (NROOTS <= 3) CALL RT123                            
           IF (NROOTS == 4) CALL ROOT4                            
           IF (NROOTS == 5) CALL ROOT5                            
           IF (NROOTS >= 6) CALL ROOT6                            
           MM = 0                                                   
           MAX = NMAX+1                                             
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!          ERI for each root
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           DO M = 1,NROOTS                                      
            U2 = U(M)*RHO                                         
            F00 = EXPE*W(M)                                       
            DO I = 1,MAX                                      
             IN(I) = IN1(I)+MM                                  
            END DO
            DUMINV = 1.0d0/(AB+U2*AANDB)                         
            DM2INV = 0.5D0*DUMINV                               
            BP01 = (A+U2)*DM2INV                               
            B00 = U2*DM2INV                                    
            B10 = (B+U2)*DM2INV                                
            XCP00 = (U2*C1X+C2X)*DUMINV                        
            XC00 = (U2*C3X+C4X)*DUMINV                         
            YCP00 = (U2*C1Y+C2Y)*DUMINV                        
            YC00 = (U2*C3Y+C4Y)*DUMINV                         
            ZCP00 = (U2*C1Z+C2Z)*DUMINV                        
            ZC00 = (U2*C3Z+C4Z)*DUMINV                         
            CALL XYZINT                                           
            MM = MM+2401                                          
           END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!          Form (I,J//K,L) integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           CALL FormIntegrals(GHONDO)                                       
          END IF
          NN = NN + 49
         END DO
        END IF                                                  
       END DO
      END DO
!                                                                       
      RETURN                                                            
      END                                                               

! Calling by ERISPDFGHIL XYZINT                                           
      SUBROUTINE XYZINT                                                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL N0,N1,M0,M1,FIRST1,FIRST2,FIRST3,FIRST4                    
      COMMON /SETINT/I(13),K(13),NIMAX,NJMAX,NKMAX,NLMAX,NMAX,MMAX,     &
                     BP01,B00,B10,XCP00,XC00,YCP00,YC00,ZCP00,ZC00,F00, &
                     DXIJ,DYIJ,DZIJ,DXKL,DYKL,DZKL                     
      COMMON /XYZ   / XINT(31213),YINT(31213),ZINT(31213)               
!                                                                       
      N0 = NMAX == 0                                                  
      N1 = NMAX <= 1                                                  
      M0 = MMAX == 0                                                  
      M1 = MMAX <= 1                                                  
!                                                                       
!     ----- I(0,0) -----                                                
!                                                                       
      I1 = I(1)                                                         
      XINT(I1) = 1.0d0                                                    
      YINT(I1) = 1.0d0                                                    
      ZINT(I1) = F00                                                    
      IF (N0 .and. M0) RETURN                                           
      I2 = I(2)                                                         
      K2 = K(2)                                                         
      CP10 = B00                                                        
!                                                                       
!     ----- I(1,0) -----                                                
!                                                                       
      IF (.NOT. N0) THEN                                                
        XINT(I2) = XC00                                                 
        YINT(I2) = YC00                                                 
        ZINT(I2) = ZC00*F00                                             
        IF (M0) GO TO 120                                               
      END IF                                                            
!                                                                       
!     ----- I(0,1) -----                                                
!                                                                       
      I3 = I1+K2                                                        
      XINT(I3) = XCP00                                                  
      YINT(I3) = YCP00                                                  
      ZINT(I3) = ZCP00*F00                                              
!                                                                       
!     ----- I(1,1) -----                                                
!                                                                       
      IF (.NOT. N0) THEN                                                
        I3 = I2+K2                                                      
        XINT(I3) = XCP00*XINT(I2)+CP10                                  
        YINT(I3) = YCP00*YINT(I2)+CP10                                  
        ZINT(I3) = ZCP00*ZINT(I2)+CP10*F00                              
      END IF                                                            
!                                                                       
  120 CONTINUE                                                          
      IF (.NOT. N1) THEN                                                
        C10 = 0.0d0                                                      
        I3 = I1                                                         
        I4 = I2                                                         
        DO 160 N = 2,NMAX                                               
          C10 = C10+B10                                                 
!                                                                       
!     ----- I(N,0) -----                                                
!                                                                       
          I5 = I(N+1)                                                   
          XINT(I5) = C10*XINT(I3)+XC00*XINT(I4)                         
          YINT(I5) = C10*YINT(I3)+YC00*YINT(I4)                         
          ZINT(I5) = C10*ZINT(I3)+ZC00*ZINT(I4)                         
          IF ( .NOT. M0) THEN                                           
            CP10 = CP10+B00                                             
!                                                                       
!     ----- I(N,1) -----                                                
!                                                                       
            I3 = I5+K2                                                  
            XINT(I3) = XCP00*XINT(I5)+CP10*XINT(I4)                     
            YINT(I3) = YCP00*YINT(I5)+CP10*YINT(I4)                     
            ZINT(I3) = ZCP00*ZINT(I5)+CP10*ZINT(I4)                     
          END IF                                                        
          I3 = I4                                                       
          I4 = I5                                                       
  160     CONTINUE                                                      
      END IF                                                            
      IF ( .NOT. M1) THEN                                               
        CP01 = 0.0d0                                                     
        C01 = B00                                                       
        I3 = I1                                                         
        I4 = I1+K2                                                      
        DO 220 M = 2,MMAX                                               
          CP01 = CP01+BP01                                              
!                                                                       
!     ----- I(0,M) -----                                                
!                                                                       
          I5 = I1+K(M+1)                                                
          XINT(I5) = CP01*XINT(I3)+XCP00*XINT(I4)                       
          YINT(I5) = CP01*YINT(I3)+YCP00*YINT(I4)                       
          ZINT(I5) = CP01*ZINT(I3)+ZCP00*ZINT(I4)                       
!                                                                       
!     ----- I(1,M) -----                                                
!                                                                       
          IF (.NOT. N0) THEN                                            
            C01 = C01+B00                                               
            I3 = I2+K(M+1)                                              
            XINT(I3) = XC00*XINT(I5)+C01*XINT(I4)                       
            YINT(I3) = YC00*YINT(I5)+C01*YINT(I4)                       
            ZINT(I3) = ZC00*ZINT(I5)+C01*ZINT(I4)                       
          END IF                                                        
          I3 = I4                                                       
          I4 = I5                                                       
  220   CONTINUE                                                        
      END IF                                                            
!                                                                       
!     ----- I(N,M) -----                                                
!                                                                       
      IF (.NOT. N1 .and. .NOT. M1) THEN                                 
        C01 = B00                                                       
        K3 = K2                                                         
        DO 280 M = 2,MMAX                                               
          K4 = K(M+1)                                                   
          C01 = C01+B00                                                 
          I3 = I1                                                       
          I4 = I2                                                       
          C10 = B10                                                     
          DO 260 N = 2,NMAX                                             
            I5 = I(N+1)                                                 
            XINT(I5+K4) = C10*XINT(I3+K4)+XC00*XINT(I4+K4)              &
                          +C01*XINT(I4+K3)                              
            YINT(I5+K4) = C10*YINT(I3+K4)+YC00*YINT(I4+K4)              &
                          +C01*YINT(I4+K3)                              
            ZINT(I5+K4) = C10*ZINT(I3+K4)+ZC00*ZINT(I4+K4)              &
                          +C01*ZINT(I4+K3)                              
            C10 = C10+B10                                               
            I3 = I4                                                     
            I4 = I5                                                     
  260     CONTINUE                                                      
          K3 = K4                                                       
  280   CONTINUE                                                        
      END IF                                                            
!                                                                       
!     ----- I(NI,NJ,M) -----                                            
!                                                                       
      IF (NJMAX > 0) THEN                                            
        M = 0                                                           
        I5 = I(NMAX+1)                                                  
        FIRST1 = .TRUE.                                                 
        DO 430 WHILE (FIRST1 .or. M <= MMAX)                          
          MIN = NIMAX                                                   
          KM = K(M+1)                                                   
          FIRST2 = .TRUE.                                               
          DO 360 WHILE (FIRST2 .or. MIN < NMAX)                      
            N = NMAX                                                    
            I3 = I5+KM                                                  
            FIRST3 = .TRUE.                                             
            DO 340 WHILE (FIRST3 .or. N > MIN)                       
              I4 = I(N)+KM                                              
              XINT(I3) = XINT(I3)+DXIJ*XINT(I4)                         
              YINT(I3) = YINT(I3)+DYIJ*YINT(I4)                         
              ZINT(I3) = ZINT(I3)+DZIJ*ZINT(I4)                         
              I3 = I4                                                   
              N = N-1                                                   
              FIRST3 = .FALSE.                                          
  340       END DO                                                      
            MIN = MIN+1                                                 
            FIRST2 = .FALSE.                                            
  360     END DO                                                        
          IF (NIMAX > 0) THEN                                        
            I3 = 49+KM+I1                                               
            DO 400 NJ = 1,NJMAX                                         
              I4 = I3                                                   
              DO 380 NI = 1,NIMAX                                       
                XINT(I4) = XINT(I4+294)+DXIJ*XINT(I4-49)                
                YINT(I4) = YINT(I4+294)+DYIJ*YINT(I4-49)                
                ZINT(I4) = ZINT(I4+294)+DZIJ*ZINT(I4-49)                
                I4 = I4+343                                             
  380         CONTINUE                                                  
              I3 = I3+49                                                
  400       CONTINUE                                                    
          END IF                                                        
          M = M+1                                                       
          FIRST1 = .FALSE.                                              
  430   END DO                                                          
      END IF                                                            
!                                                                       
!     ----- I(NI,NJ,NK,NL) -----                                        
!                                                                       
      IF (NLMAX > 0) THEN                                            
        I5 = K(MMAX+1)                                                  
        IA = I1                                                         
        NI = 0                                                          
        FIRST4 = .TRUE.                                                 
        DO 580 WHILE (FIRST4 .or. NI <= NIMAX)                        
          NJ = 0                                                        
          IB = IA                                                       
          FIRST1 = .TRUE.                                               
          DO 570 WHILE (FIRST1 .or. NJ <= NJMAX)                      
            MIN = NKMAX                                                 
            FIRST2 = .TRUE.                                             
            DO 530 WHILE (FIRST2 .or. MIN < MMAX)                    
              M = MMAX                                                  
              I3 = IB+I5                                                
              FIRST3 = .TRUE.                                           
              DO 520 WHILE (FIRST3 .or. M > MIN)                     
                I4 = IB+K(M)                                            
                XINT(I3) = XINT(I3)+DXKL*XINT(I4)                       
                YINT(I3) = YINT(I3)+DYKL*YINT(I4)                       
                ZINT(I3) = ZINT(I3)+DZKL*ZINT(I4)                       
                I3 = I4                                                 
                M = M-1                                                 
                FIRST3 = .FALSE.                                        
  520         END DO                                                    
              MIN = MIN+1                                               
              FIRST2 = .FALSE.                                          
  530       END DO                                                      
            IF (NKMAX > 0) THEN                                      
              I3 = IB+1                                                 
              DO 560 NL = 1,NLMAX                                       
                I4 = I3                                                 
                DO 540 NK = 1,NKMAX                                     
                  XINT(I4) = XINT(I4+6)+DXKL*XINT(I4-1)                 
                  YINT(I4) = YINT(I4+6)+DYKL*YINT(I4-1)                 
                  ZINT(I4) = ZINT(I4+6)+DZKL*ZINT(I4-1)                 
                  I4 = I4+7                                             
  540           END DO                                                  
              I3 = I3+1                                                 
  560         END DO                                                    
            END IF                                                      
            NJ = NJ+1                                                   
            IB = IB+49                                                  
            FIRST1 = .FALSE.                                            
  570     END DO                                                        
          NI = NI+1                                                     
          IA = IA+343                                                   
          FIRST4 = .FALSE.                                              
  580   END DO                                                          
      END IF                                                            
!                                                                       
      RETURN                                                            
      END                                                               

! Calling by ERISPDFGHIL FormIntegrals                                            
      SUBROUTINE FormIntegrals(GHONDO)                                          
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION GHONDO(*)                                               
      COMMON /DENS  / DKL(784),DIJ(784)                                 
      COMMON /INTDEX/ IJX(784),IJY(784),IJZ(784),IK(784),               &
                      KLX(784),KLY(784),KLZ(784)              
      COMMON/INTDEX1/IJGT(784),KLGT(784)           
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,              &
                      MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          &
                      NIJ,IJ,KL                                    
      COMMON /ROOT  / XX,U(13),W(13),NROOTS                             
      COMMON /XYZ   / XIN(31213),YIN(31213),ZIN(31213)                  
!-----------------------------------------------------------------------
      GO TO (10,20,30,40,50,60,70,80,90,100,110,120,130),NROOTS         
!     NROOTS=1                                            
   10 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*(XIN(MX)*YIN(MY)*ZIN(MZ))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=2                                            
   20 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=3                                            
   30 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                & 
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=4                                            
   40 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=5                                            
   50 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           &
                +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=6                                            
   60 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           &
                +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           &
                +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=7                                            
   70 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           &
                +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           &
                +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           &
                +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=8                                            
   80 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           &
                +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           &
                +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           &
                +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           &
                +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=9                                            
   90 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           &
                +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           &
                +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           &
                +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           &
                +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           &
                +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=10                                           
  100 CONTINUE                                                          
      DO I = 1,IJ                                                   
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                  
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           &
                +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           &
                +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           &
                +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           &
                +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           &
                +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)           &
                +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609))          
      END DO
      END DO
      RETURN                                                            
!     NROOTS=11                                           
  110 CONTINUE                                                          
      DO I = 1,IJ                                                   
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                  
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                &
                  ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           &
                +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           &
                +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           &
                +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           &
                +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           &
                +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           &
                +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           &
                +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           &
                +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)           &
                +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609)           &
                +   XIN(MX+24010)*YIN(MY+24010)*ZIN(MZ+24010))          &
                *D1*DKL(K)+GHONDO(N)                                    
      END DO
      END DO
      RETURN                                                            
!     NROOTS=12                                           
  120 CONTINUE                                                          
      DO I = 1,IJ                                                   
       D1 = DIJ(I)                                                       
       NX = IJX(I)                                                       
       NY = IJY(I)                                                       
       NZ = IJZ(I)                                                       
       N1 = IJGT(I)                                                      
       MAX = IK(I)                                                       
       DO K = 1,MAX                                                  
        MX = NX+KLX(K)                                                    
        MY = NY+KLY(K)                                                    
        MZ = NZ+KLZ(K)                                                    
        N = N1+KLGT(K)                                                    
        GHONDO(N) = GHONDO(N) + D1*DKL(K)*                              &
                    ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )         &
                  +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)         &
                  +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)         &
                  +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)         &
                  +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)         &
                  +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)         &
                  +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)         &
                  +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)         &
                  +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)         &
                  +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609)         &
                  +   XIN(MX+24010)*YIN(MY+24010)*ZIN(MZ+24010)         &
                  +   XIN(MX+26411)*YIN(MY+26411)*ZIN(MZ+26411))        &
                  *D1*DKL(K)+GHONDO(N)                                    
       END DO
      END DO
      RETURN                                                            
!     NROOTS=13                                           
  130 CONTINUE
      DO I = 1,IJ                                                   
       D1 = DIJ(I)                                                       
       NX = IJX(I)                                                       
       NY = IJY(I)                                                       
       NZ = IJZ(I)                                                       
       N1 = IJGT(I)                                                      
       MAX = IK(I)                                                       
       DO K = 1,MAX                                                  
        MX = NX+KLX(K)                                                    
        MY = NY+KLY(K)                                                    
        MZ = NZ+KLZ(K)                                                    
        N = N1+KLGT(K)                                                    
        GHONDO(N) = GHONDO(N) + D1*DKL(K)*                              &
                    ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )         &
                  +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)         &
                  +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)         &
                  +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)         &
                  +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)         &
                  +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)         &
                  +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)         &
                  +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)         &
                  +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)         &
                  +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609)         &
                  +   XIN(MX+24010)*YIN(MY+24010)*ZIN(MZ+24010)         &
                  +   XIN(MX+26411)*YIN(MY+26411)*ZIN(MZ+26411)         &
                  +   XIN(MX+28812)*YIN(MY+28812)*ZIN(MZ+28812))          
       END DO
      END DO
      RETURN
!-----------------------------------------------------------------------                                                            
      END                                                               

! ZQOUT                                            
      SUBROUTINE ZQOUT(GHONDO,MAXG)                                          
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION GHONDO(MAXG)                                               
      LOGICAL IANDJ,KANDL,SAME                                          
      COMMON /INTDEX/ IJX(784),IJY(784),IJZ(784),IK(784),               &
                      KLX(784),KLY(784),KLZ(784)              
      COMMON/INTDEX1/IJGT(784),KLGT(784)           
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /SHLNOS/LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,               &
                     MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,           &
                     NIJ,IJ,KL                                    
!-----------------------------------------------------------------------                                                                       
!     HONDO Conventional integral Output
!-----------------------------------------------------------------------                                                                       
      IJN = 0                                                           
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       IF (IANDJ) JMAX = I                                            
       DO 1 J = MINJ,JMAX                                           
          IJN = IJN+1                                                 
          N1 = IJGT(IJN)                                              
          LMAX = MAXL                                                 
          KLN = 0                                                     
        DO K =  MINK,MAXK                                       
         IF (KANDL) LMAX = K                                      
         DO L = MINL,LMAX                                     
          KLN = KLN+1                                           
          IF (SAME .and. KLN > IJN) GO TO 1                
          NN = N1+KLGT(KLN)                                     
          GHONDO(NN) = 0.0d0                                     
         END DO
        END DO
    1  CONTINUE                                                       
      END DO
!-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END                                                               

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                             ECP integrals                            ! 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! ECPINT
      SUBROUTINE ECPINT(H0,NBFT,EX,CS,CP,CD,CF,CG,NPRIMI,KSTART,KATOM,  &
                        KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                        
      COMMON/ECPDIM/NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN
      COMMON/ECP1/X01,CAX,CAY,CAZ,CA,XCA,YCA,ZCA,                       &
                  X02,BAX,BAY,BAZ,BA,XBA,YBA,ZBA,                       &
                  PHASE,DAX,DAY,DAZ,DA,XDA,YDA,ZDA,XINT,KCNTR            
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),              &
                  KLAST(100,6),LMAX(100),LPSKIP(100),                   &
                  IZCORE(100)                                          
      LOGICAL                         CANDB                            
      COMMON/ECP4/P12(3,2),R12,ACO(3),CANDB                            
      LOGICAL                                  IANDJ,NORM,NORMI,NORMJ    
      COMMON/ECPIDX/Q2,IAMIN,IAMAX,JAMIN,JAMAX,IPMIN,IPMAX,JPMIN,       &
                    JPMAX,KF1,KL1,LLMX,NPC,NPB,IANDJ,NORM,NORMI,NORMJ    
      INTEGER, DIMENSION(8192) :: IA                                     
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB      
      COMMON/MAPSHEL/MAPSHL(500,48),NT   
      
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION FPQR(25,25,25),ZLM(581)
      DIMENSION H0(NBFT),HECP(NBFT),LMF(122),LMX(582),LMY(582),LMZ(582)
      DIMENSION FP(2*11*11*11),G(28*15),COEFI(30),COEFJ(30)
      DIMENSION FQ(1),COEFQ(1)
      LOGICAL CANDA,AANDB
      DIMENSION IANG(35),MI(48)
      DATA IANG/1,3*2,6*3,10*4,15*5/
      INTEGER,ALLOCATABLE,DIMENSION(:)::JFST1,JFST2      
      INTEGER,ALLOCATABLE,DIMENSION(:,:)::LBECP1,LBECP2   
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::DCOEF1,DCOEF2,DCOEF4      
      ALLOCATE(JFST1(J1LEN+9*NCOEF1),JFST2(J2LEN+6*NCOEF2))
      ALLOCATE(LBECP1(9,NCOEF1),LBECP2(6,NCOEF2)) 
      ALLOCATE(DCOEF1(NCOEF1),DCOEF2(NCOEF2),DCOEF4(J4LEN))
!-----------------------------------------------------------------------
      FQ(1)   = 0.0d0
      COEFQ(1)= 0.0d0
      NORM = .TRUE.
      NORMI= NORM
      NORMJ= NORM
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Read ECP
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ECCODR(DCOEF1,JFST1,LBECP1,DCOEF2,JFST2,LBECP2,              &
                  FPQR,ZLM,LMF,LMX,LMY,LMZ)
      CALL DAWT
      CALL ERRT
      CALL DAWERT
      CALL ECPINI(LMF,LMX,LMY,LMZ)
      CALL ZTAB(ZLM)
      CALL FTAB(FPQR,NLIM-1)
      CALL ECCOD3(FPQR,DCOEF4,ZLM,LMF,LMX,LMY,LMZ)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL VCLR(HECP,1,NBFT)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Triangular Index Matrix
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
      DO I = 1,8192                                                 
       IA(I) = (I*I-I)/2                                               
      ENDDO      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     ISHELL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO 1 II=1,NSHELL
       DO IT=1,NT
        ID=MAPSHL(II,IT)
        IF(ID.GT.II) GO TO 1
        MI(IT)=ID
       END DO
       I1 = KSTART(II)
       I2 = I1+KNG(II)-1
       IPMIN = I1
       IPMAX = I2
       ICNTR = KATOM(II)
       IMIN = KMIN(II)
       IMAX = KMAX(II)
       LOCI = KLOC(II)-IMIN
       IAMIN = IMIN
       IAMAX = IMAX
       IIMAX = 1
       IF(IMIN.EQ.1 .AND. IMAX.EQ.4) IIMAX = 2
       DO 2 III=1,IIMAX
        IF(IIMAX.EQ.2) THEN
         IF(III.EQ.1) THEN
          IAMIN = 1
          IAMAX = 1
         ELSE
          IAMIN = 2
          IAMAX = 4
         END IF
        END IF
        NPC0= IANG(IAMAX)
        DO IG=IPMIN,IPMAX
         IF(IAMIN.LE.35) T01= CG(IG)
         IF(IAMIN.LE.20) T01= CF(IG)
         IF(IAMIN.LE.10) T01= CD(IG)
         IF(IAMIN.LE. 4) T01= CP(IG)
         IF(IAMIN.EQ. 1) T01= CS(IG)
         COEFI(IG-IPMIN+1)= T01
        END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       JSHELL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        DO 3 JJ=1,II
         Q2=1
         N2=0
         DO 5 IT=1,NT
          JD=MAPSHL(JJ,IT)
          IF(JD.GT.II) GO TO 3
          ID=MAX0(MI(IT),JD)
          JD=MIN0(MI(IT),JD)
          IF(ID.LT.II) GO TO 5
          IF(JD.LT.JJ) GO TO 5
          IF(JD.GT.JJ) GO TO 3
          N2=N2+1
    5    CONTINUE
         Q2 = NT
         Q2 = Q2/N2
         IANDJ = II.EQ.JJ
         J1 = KSTART(JJ)
         J2 = J1+KNG(JJ)-1
         JPMIN = J1
         JPMAX = J2
         JCNTR = KATOM(JJ)
         JMIN = KMIN(JJ)
         JMAX = KMAX(JJ)
         LOCJ = KLOC(JJ)-JMIN
         JAMIN = JMIN
         JAMAX = JMAX
         JJMAX = 1
         IF(JMIN.EQ.1 .AND. JMAX.EQ.4) JJMAX = 2
         DO 4 JJJ=1,JJMAX
          IF(JJMAX.EQ.2) THEN
           IF(JJJ.EQ.1) THEN
            JAMIN = 1
            JAMAX = 1
           ELSE
            IF(IANDJ .AND. IAMIN.EQ.1) GO TO 4
            JAMIN = 2
            JAMAX = 4
           END IF
          END IF
         DO JG=JPMIN,JPMAX
          IF(JAMIN.LE.35) T01= CG(JG)
          IF(JAMIN.LE.20) T01= CF(JG)
          IF(JAMIN.LE.10) T01= CD(JG)
          IF(JAMIN.LE. 4) T01= CP(JG)
          IF(JAMIN.EQ. 1) T01= CS(JG)
          COEFJ(JG-JPMIN+1)= T01
         END DO
         NPB0= IANG(JAMAX)
         IJMAX= MAX0((IAMAX-IAMIN+1)*(JAMAX-JAMIN+1),60)
         CALL VCLR(G,1,IJMAX)
         CANDB= ICNTR.EQ.JCNTR
         R12= 0.0d0
         DO M=1,3
          P12(M,1)= Cxyz(M,ICNTR)
          P12(M,2)= Cxyz(M,JCNTR)
          R12= R12+(P12(M,2)-P12(M,1))*(P12(M,2)-P12(M,1))
         END DO
         NPC= NPC0
         NPB= NPB0
         NPNP= NPC+NPB-1
         DO 6 IKCNTR=1,NAT
          KCNTR= IKCNTR
          ACO(1)= Cxyz(1,KCNTR)
          ACO(2)= Cxyz(2,KCNTR)
          ACO(3)= Cxyz(3,KCNTR)
          IF(LPSKIP(KCNTR).EQ.1)GO TO 6
          LLMX = LMAX(KCNTR)+1
          KF1 = KFRST(KCNTR,1)
          KL1 = KLAST(KCNTR,1)
         CANDA= ICNTR.EQ.KCNTR
         AANDB= KCNTR.EQ.JCNTR
         CALL ECPCBA(CANDA,AANDB,ICAB,IPOW)
         IF(ICNTR.NE.KCNTR .OR. KCNTR.NE.JCNTR)                         &
          CALL ECPPWR(IPOW,NPC0,NPB0)                                    
           IF(ICAB.EQ.1)THEN                                             
            CALL ECPAA1(NPNP,FPQR,COEFI,COEFJ,DCOEF4,G,EX,NPRIMI)                  
           ELSE IF(ICAB.EQ.2 .OR. ICAB.EQ.3) THEN                        
            CALL ECPRA2(ICAB,NPNP,FP,COEFI,COEFJ,                       &
                        DCOEF1,JFST1,LBECP1,DCOEF4,                     &
                        DCOEF2,JFST2,LBECP2,G,                          &
                        ZLM,LMF,LMX,LMY,LMZ,EX,NPRIMI)                             
           ELSE IF(ICAB.EQ.4) THEN                                       
            IC4C= 0                                                      
            CALL ECPDRA(IC4C,NPNP,FP,FQ,COEFI,COEFQ,COEFJ,DCOEF1,       &
                        JFST1,LBECP1,DCOEF2,JFST2,LBECP2,G,ZLM,LMF,     &
                        LMX,LMY,LMZ,EX,NPRIMI)
           END IF
    6     CONTINUE
          MMAX= JAMAX
          NN= 1
          DO I=IAMIN,IAMAX
           IN= IA(LOCI+I)+LOCJ
           IF(IANDJ) MMAX= I
           DO J=JAMIN,MMAX
            HECP(IN+J)= G(NN)
            NN= NN+1
           END DO
          END DO
    4    CONTINUE
    3   CONTINUE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       JSHELL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    2  CONTINUE
    1 CONTINUE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     New Core Hamiltonian
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      H0 = H0 + HECP
!-----------------------------------------------------------------------
      DEALLOCATE(LBECP1,LBECP2,JFST1,JFST2,DCOEF1,DCOEF4,DCOEF2)       
      RETURN
      END

! ECCODR
      SUBROUTINE ECCODR(DCOEF1,JFST1,LBECP1,DCOEF2,JFST2,LBECP2,        &
                        FPQR,ZLM,LMF,LMX,LMY,LMZ)                        
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION FPQR(25,25,25),ZLM(581),DCOEF1(*),DCOEF2(*)
      DIMENSION JFST1(*),LBECP1(9,*),JFST2(*),LBECP2(6,*),              &
                LMF(122),LMZ(581),LMX(581),LMY(581)
      COMMON /ECPDIM/ NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN
      CALL ECPINI(LMF,LMX,LMY,LMZ)
      CALL ZTAB(ZLM)
      CALL FTAB(FPQR,NLIM-1)
      CALL ECCOD1(DCOEF1,JFST1,LBECP1,FPQR,ZLM,LMF,LMX,LMY,LMZ)
      CALL ECCOD2(DCOEF2,JFST2,LBECP2,FPQR,ZLM,LMF,LMX,LMY,LMZ)
      RETURN
      END

! ECCOD1
      SUBROUTINE ECCOD1(DCOEF1,JFST1,LBECP1,FPQR,ZLM,LMF,LMX,LMY,LMZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION DCOEF1(*),FPQR(25,25,25),ZLM(*)
      DIMENSION JFST1(*),LBECP1(9,*),LMF(*),LMX(*),LMY(*),LMZ(*)
      COMMON /ECPDIM/ NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN
      COMMON /GBASE / NFST(8),NX(84),NY(84),NZ(84)
      PARAMETER(SQRFPI=3.5449077018110D+00, TOL=1.0D-10)
!        -----  THREE-CENTER ONE ELECTRON INTEGRALS.            -----
      DIMENSION BINCO(28),IA(128)
      DATA BINCO/           1.0D+00,                                    &
                        1.0D+00, 1.0D+00,                               &
                     1.0D+00, 2.0D+00, 1.0D+00,                         &
                  1.0D+00, 3.0D+00, 3.0D+00, 1.0D+00,                   &
               1.0D+00, 4.0D+00, 6.0D+00, 4.0D+00, 1.0D+00,             &
            1.0D+00, 5.0D+00,10.0D+00,10.0D+00, 5.0D+00,1.0D+00,        &
         1.0D+00,6.0D+00,15.0D+00,20.0D+00,15.0D+00,6.0D+00,1.0D+00/

      J= 0
      DO 110 I=1,128
       IA(I)= J
  110 J= J+I

      JNDX = 0
      JJLST= 0
! LOOP OVER POSSIBLE I SHELLS
      DO 230 NN1=1,NLIM
         NF1 = NFST(NN1)
         NL1 = NFST(NN1+1)-1
         NN2LIM= NN1
! LOOP OVER THE I SHELL ANGUALR MOMENTUM FUNCTIONS
         DO 220 N1=NF1,NL1
            N1T = IA(N1)
            MX1 = IA(NX(N1)+1)+1
            MY1 = IA(NY(N1)+1)+1
            MZ1 = IA(NZ(N1)+1)+1
! LOOP OVER THE POSSIBLE J SHELLS (NOTE J SHELL <= I SHELL)
            DO 210 NN2=1,NN2LIM
               NF2 = NFST(NN2)
               NL2 = MIN0(NFST(NN2+1)-1,N1)
! LOOP OVER J SHELL ANGULAR MOMENTUM
               DO 200 N2=NF2,NL2
                  INDX = N2+N1T
                  MX2 = IA(NX(N2)+1)+1
                  MY2 = IA(NY(N2)+1)+1
                  MZ2 = IA(NZ(N2)+1)+1
                  LLMAX= NN1+NN2-2
! LOOP OVER LA, MU, KX...
                  DO 190 LA=0,LLMAX
                     DO 180 MU=-LA,LA
                        DO 170 KX=0,NX(N1)
                           DO 160 KY=0,NY(N1)
                              DO 150 KZ=0,NZ(N1)
                                 DO 140 KXP=0,NX(N2)
                                    DO 130 KYP=0,NY(N2)
                                       DO 120 KZP=0,NZ(N2)
                              KA = KX+KY+KZ+KXP+KYP+KZP
!
! NOTE NO NONZERO INTEGRALS FOR LA > KA
! IF KA + LA IS EVEN GO AHEAD AND CALCULATE THE ANGULAR INTEGRAL
!
                              IF(MOD(LA+KA,2).NE.1 .AND. LA.LE.KA) THEN
      DC=DCO(0,0,KX+KXP,KY+KYP,KZ+KZP,LA,MU,FPQR,ZLM,LMF,LMX,LMY,LMZ)
!
! IF THE INTEGRAL IS NON-ZERO THEN STORE IT AWAY FOR FUTURE USE
!
                                 IF(ABS(DC).LT.TOL) GO TO 120
                                 JNDX = JNDX+1
                                 LBECP1(1,JNDX)= KA
                                 LBECP1(2,JNDX)= LA
                                 LBECP1(3,JNDX)= MU
                                 LBECP1(4,JNDX)= KX
                                 LBECP1(5,JNDX)= KY
                                 LBECP1(6,JNDX)= KZ
                                 LBECP1(7,JNDX)= KXP
                                 LBECP1(8,JNDX)= KYP
                                 LBECP1(9,JNDX)= KZP
!
! THE INTEGRAL IS MULTIPLIED BY THE COMBINATION FACTORS AND BY SQRT(4PI)
! SINCE THERE IS AN EXTRA 1/SQRT(4PI) IN THE INTEGRAL
!
      DCOEF1(JNDX)= BINCO(MX1+KX) *BINCO(MY1+KY) *BINCO(MZ1+KZ) *       &
                    BINCO(MX2+KXP)*BINCO(MY2+KYP)*BINCO(MZ2+KZP)*       &
                    DC*SQRFPI
                              END IF
  120                                  CONTINUE
  130                               CONTINUE
  140                            CONTINUE
  150                         CONTINUE
  160                      CONTINUE
  170                   CONTINUE
  180                CONTINUE
  190             CONTINUE
                  JFST1(INDX)  = JJLST+1
                  JFST1(INDX+1)= JNDX+1
                  JJLST= JNDX
  200          CONTINUE
  210       CONTINUE
  220    CONTINUE
  230 CONTINUE

      IF(JNDX.GT.NCOEF1) THEN
         WRITE(6,9010) JNDX,NCOEF1
         CALL ABRT
      END IF
      NCOEF1= JNDX
      RETURN
 9010 FORMAT(/'****ECCOD1 OUT OF BOUNDS, USED ',I7,' ALLOWED ',I7)
      END

! ECCOD2
      SUBROUTINE ECCOD2(DCOEF2,JFST2,LBECP2,FPQR,ZLM,LMF,LMX,LMY,LMZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION DCOEF2(*),FPQR(25,25,25),ZLM(*)
      DIMENSION JFST2(*),LBECP2(6,*),LMF(*),LMX(*),LMY(*),LMZ(*)
      COMMON /ECPDIM/ NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN
      COMMON /GBASE / NFST(8),NX(84),NY(84),NZ(84)
      PARAMETER(TOL=1.0D-10)

! BINCO -- INDEXED COMBINATIONS (B!/(A!(B-A)!)) INDEXED BY B AND A
!          AS:  (B,A): (0,0),(1,0),(1,1),(2,0),(2,1),(2,2)...
! AKA PASCAL'S TRIANGLE, ENTRIES THROUGH I FUNCTIONS (G HESSIANS)

      DIMENSION BINCO(28),IA(8)
      DATA BINCO/            1.0D+00,                                   &
                        1.0D+00, 1.0D+00,                               &
                    1.0D+00, 2.0D+00, 1.0D+00,                          &
                 1.0D+00, 3.0D+00, 3.0D+00, 1.0D+00,                    &
              1.0D+00, 4.0D+00, 6.0D+00, 4.0D+00, 1.0D+00,              &
           1.0D+00, 5.0D+00,10.0D+00,10.0D+00, 5.0D+00,1.0D+00,         &
        1.0D+00,6.0D+00,15.0D+00,20.0D+00,15.0D+00,6.0D+00,1.0D+00/

!        -----  ROUTINE FINDS FORMULA CODE FOR ONE-ELECTRON     -----
!        -----  THREE-CENTER INTEGRALS INVOLVING PROJECTION     -----
!        -----  OPERATORS.                                      -----

! THE TYPE 2 ANGULAR INTEGRAL TABLE GENERATOR

      J= 0
      DO 110 I=1,8
!        IA(I)=(I*(I-1))/2
         IA(I)= J
  110 J= J+I

      JNDX = 0
      JJLST= 0
      LLLIM= LLIM-1
      DO 200 L=0,LLLIM
         DO 190 M=L,-L,-1
            LMINDX =(L*(L+1)-M)*NTLIM
            DO 180 NN=1,NLIM
               NF = NFST(NN)
               NL = NFST(NN+1)-1
               L2MX = L+NN-1
               DO 170 N=NF,NL
                  INDX = LMINDX+N
                  MX = IA(NX(N)+1)+1
                  MY = IA(NY(N)+1)+1
                  MZ = IA(NZ(N)+1)+1
                  DO 160 LA=0,L2MX
                     DO 150 MU=-LA,LA
                        DO 140 KX=0,NX(N)
                           DO 130 KY=0,NY(N)
                              DO 120 KZ=0,NZ(N)
                                 IS = KX+KY+KZ
      DC= DCO(L,M,KX,KY,KZ,LA,MU,FPQR,ZLM,LMF,LMX,LMY,LMZ)
                                 IF(ABS(DC).LT.TOL) GO TO 120
                                 JNDX = JNDX+1
                                 LBECP2(1,JNDX)= LA
                                 LBECP2(2,JNDX)= IS
                                 LBECP2(3,JNDX)= MU
                                 LBECP2(4,JNDX)= KX
                                 LBECP2(5,JNDX)= KY
                                 LBECP2(6,JNDX)= KZ
      DCOEF2(JNDX)= BINCO(MX+KX)*BINCO(MY+KY)*BINCO(MZ+KZ)*DC
  120                         CONTINUE
  130                      CONTINUE
  140                   CONTINUE
  150                CONTINUE
  160             CONTINUE
                  JFST2(INDX)  = JJLST+1
                  JFST2(INDX+1)= JNDX+1
                  JJLST= JNDX
  170          CONTINUE
  180       CONTINUE
  190    CONTINUE
  200 CONTINUE

      IF(JNDX.GT.NCOEF2) THEN
         WRITE(6,9010) JNDX,NCOEF2
         CALL ABRT
      END IF
      NCOEF2= JNDX
      RETURN
 9010 FORMAT(/'****ECCOD2 OUT OF BOUNDS, USED ',I6,' ALLOWED ',I5)
      END

! ECCOD3
      SUBROUTINE ECCOD3(FPQR,DCOEF4,ZLM,LMF,LMX,LMY,LMZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/ECPDIM/NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN
      COMMON/GBASE/NFST(8),NX(84),NY(84),NZ(84)
      DOUBLE PRECISION FPQR(25,25,25),ZLM(*),DCOEF4(*)
      DIMENSION LMF(*),LMX(*),LMY(*),LMZ(*)
!-----------------------------------------------------------------------
      SQRFPI = 3.5449077018110D+00
      IIIDX = 0
      DO L=0,LLIM-1
       DO M=L,-L,-1
        LMINDX =(L*(L+1)-M)*NTLIM
        DO NN=1,NLIM
         NF = NFST(NN)
         NL = NFST(NN+1)-1
         DO N=NF,NL
          INDX = LMINDX+N
          IIIDX= MAX0(INDX,IIIDX)
          DCOEF4(INDX)= DCO(0,0,NX(N),NY(N),NZ(N),L,M,                  &
                            FPQR,ZLM,LMF,LMX,LMY,LMZ)*SQRFPI
         END DO
        END DO
       END DO
      END DO
      IF(IIIDX>J4LEN) THEN
       WRITE(6,*)'Stop: IIIDX > J4LEN'
       CALL ABRT
      END IF
!-----------------------------------------------------------------------
      RETURN
      END

! FTAB
      SUBROUTINE FTAB(FPQR,NMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER P,Q,R
      DOUBLE PRECISION FPQR(25,25,25)
!     FOR NMAX= 6, N4MAX= 4*NMAX+1=25, AND 3*N4MAX-2=73
      DIMENSION REC(73)

!        -----  ROUTINE SETS A TABLE OF F-FUNCTION VALUES.      -----
!     WHERE F MEANS THE ANGULAR INTEGRAL GIVEN BY:
!     INT[DW X^R Y^S Z^T = O FOR R, S, OR T ODD
!                        =(R-1)!!(S-1)!!(T-1)!!/(R+S+T+1)!!
!                      FOR R, S, AND T EVEN
!     NEEDS DIMENSION 4*(MAX REAL ANGULAR MOMENTUM) + 1
!     WHERE 1 IS ADDED SINCE WE REALLY NEED THE 0-TH ELEMENT
!     THUS FOR F GRADIENTS NEED G(4) SO 4*4+1=17
      PARAMETER (FPI=12.566370614359D+00)
!-----------------------------------------------------------------------
      N4MAX = 4*NMAX+1
      IF(N4MAX.GT.25) THEN
       WRITE(6,9010) NMAX
       CALL ABRT
      END IF

      DEN= 1.0d0+2.0d0
      DO P=3,3*N4MAX-2,2
       REC(P)= 1.0d0/DEN
       DEN= DEN+2.0d0
      END DO

!        -----  ZERO OUT THE TABLE.                             -----
      DO 120 P=1,N4MAX
        DO 120 Q=1,N4MAX
          DO 120 R=1,N4MAX
  120 FPQR(R,Q,P) = 0.0D+00
!        -----  RECURSIVELY GENERATE NON-ZERO ENTRIES.          -----
      FPQR(1,1,1) = FPI
      PM2=-1.0d0
      DO 150 P=1,N4MAX,2
         QM2=-1.0d0
         DO 140 Q=1,N4MAX,2
            RM2=-1.0d0
            DO 130 R=1,N4MAX,2
               IF(P.GT.1) THEN
                  FPQR(P,Q,R)= PM2*FPQR(P-2,Q,R)*REC(P-2+Q+R)
               ELSE IF(Q.GT.1) THEN
                  FPQR(P,Q,R)= QM2*FPQR(P,Q-2,R)*REC(P+Q-2+R)
               ELSE IF(R.GT.1) THEN
                  FPQR(P,Q,R)= RM2*FPQR(P,Q,R-2)*REC(P+Q+R-2)
               END IF
  130       RM2= RM2+2.0d0
  140    QM2= QM2+2.0d0
  150 PM2= PM2+2.0d0

      RETURN
 9010 FORMAT(' FTAB: NMAX TOO LARGE =',I3)
      END

! ZTAB
      SUBROUTINE ZTAB(ZLM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION ZLM(*)
!
!        -----  ROUTINE SETS UP THE REAL SPHERICAL HARMONICS    -----
!        -----  IN THE FORM OF LINEAR COMBINATIONS OF           -----
!        -----  CARTESIAN PRODUCTS.                             -----
!
      PARAMETER (THR=3.0D+00, FOR=4.0D+00,                              &
                 FIV=5.0D+00, SIX=6.0D+00, SEV=7.0D+00, EIT=8.0D+00,    &
                 F09=9.0D+00, TEN=10.0D+00, F11=11.0D+00, F13=13.0D+00, &
                 F15=15.0D+00, F17=17.0D+00, F19=19.0D+00)
      PARAMETER (ZP5=0.5D+00, FPI=12.566370614359D+00)
      DIMENSION FAP(0:17),FAT(0:17)

      FAP(0)= SQRT(1.0d0/FPI)
      FAP(1)= FAP(0)/ DSQRT(2.0d0)
      DO I=2,16,2
       FAP(I  )= FAP(I-2)*ZP5
       FAP(I+1)= FAP(I-1)*ZP5
      END DO
      DO 120 I=0,17
  120 FAT(I)= FAP(I)*THR

      SR3= SQRT(THR)
      SR5= SQRT(FIV)
      SR7= SQRT(SEV)
      S11= SQRT(F11)
      S13= SQRT(F13)
      S15= SQRT(F15)
      S17= SQRT(F17)
      S19= SQRT(F19)

      S3BYS5= SR3*SR5
      S3BYS7= SR3*SR7
      S5BYS7= SR5*SR7
      S5XS11= SR5*S11
      S7XS11= SR7*S11
      S7XS13= SR7*S13
      SR0119= SQRT(119.0D+00)
      SR0221= SQRT(221.0D+00)
      SR0247= SQRT(247.0D+00)
      SR0323= SQRT(323.0D+00)
      SR0385= S5BYS7*S11
      SR1001= S7XS11*S13
      SR3003= SR1001*SR3
      SR5005= SR1001*SR5
      SR1309= S7XS11*S17
      SR1365= S3BYS5*S7XS13
      SR2431= SR0221*S11
      S13585= SR0247*S5XS11
! L= 0, ML= 0
      ZLM(  1)= FAP(0)
! L= 1, ML=+1,0,-1
!     POWERS (X, Z, Y)
      ZLM(  2)= SR3*FAP(0)
      ZLM(  3)= ZLM(  2)
      ZLM(  4)= ZLM(  2)
! ---
! L= 2, ML=+2...-2
!     POWERS ([5]X^2+[6]Y^2,[7]XZ,[8]Z^2+[9],[10]YZ,[11]XY)
      ZLM(  5)= S15*FAP(2)
      ZLM(  6)=-ZLM(  5)
      ZLM(  7)= ZLM(  5)*2.0d0
      TEMP    = SR5*FAP(2)
      ZLM(  8)= TEMP*THR
      ZLM(  9)=-TEMP
      ZLM( 10)= ZLM(  7)
      ZLM( 11)= ZLM(  7)
! ---
! L= 3, ML=+3...-3
!     POWERS ([12]X^3+[13]XY^2,[14]X^2Z+[15]Y^2Z,[16]XZ^2+[17]X,
!             [18]Z^3+[19]Z,[20]YZ^2+[21]Y,[22]XYZ,[23]X^2Y+[24]Y^3)
      ZLM( 12)= S5BYS7*FAP(3)
      ZLM( 13)=-ZLM( 12)*THR
      ZLM( 14)= S3BYS7*SR5*FAP(2)
      ZLM( 15)=-ZLM( 14)
      TEMP    = S3BYS7*FAP(3)
      ZLM( 16)= TEMP*FIV
      ZLM( 17)=-TEMP
      TEMP    = SR7*FAP(2)
      ZLM( 18)= TEMP*FIV
      ZLM( 19)=-TEMP*THR
      ZLM( 20)= ZLM( 16)
      ZLM( 21)= ZLM( 17)
      ZLM( 22)= ZLM( 14)*2.0d0
      ZLM( 23)=-ZLM( 13)
      ZLM( 24)=-ZLM( 12)
! ---
! L= 4, ML=+4...-4
      ZLM( 25)= S5BYS7*FAT(6)
      ZLM( 26)=-ZLM( 25)*SIX
      ZLM( 27)= ZLM( 25)
      ZLM( 28)= S5BYS7*FAT(3)
      ZLM( 29)=-ZLM( 28)*THR
      TEMP    = SR5*FAT(4)
      ZLM( 30)= TEMP*SEV
      ZLM( 31)=-ZLM( 30)
      ZLM( 32)= TEMP
      ZLM( 33)=-TEMP
      TEMP    = SR5*FAT(3)
      ZLM( 34)= TEMP*SEV
      ZLM( 35)=-TEMP*THR
      TEMP    = FAT(6)
      ZLM( 36)= TEMP*FIV*SEV
      ZLM( 37)=-TEMP*FIV*SIX
      ZLM( 38)= TEMP*THR
      ZLM( 39)= ZLM( 34)
      ZLM( 40)= ZLM( 35)
      TEMP    = SR5*FAT(2)
      ZLM( 41)= TEMP*SEV
      ZLM( 42)=-TEMP
      ZLM( 43)=-ZLM( 29)
      ZLM( 44)=-ZLM( 28)
      ZLM( 45)= S5BYS7*FAT(2)
      ZLM( 46)=-ZLM( 45)
! ---
! L= 5, ML=+5...-5
      ZLM( 47)= S7XS11*FAT(7)
      ZLM( 48)=-ZLM( 47)*TEN
      ZLM( 49)= ZLM( 47)*FIV
      ZLM( 50)= SR0385*FAT(6)
      ZLM( 51)=-ZLM( 50)*SIX
      ZLM( 52)= ZLM( 50)
      TEMP    = SR0385*FAP(7)
      ZLM( 53)= TEMP*THR*THR
      ZLM( 54)=-TEMP*THR*F09
      ZLM( 55)= TEMP*THR
      ZLM( 56)=-TEMP
      TEMP    = SR0385*SR3*FAP(4)
      ZLM( 57)= TEMP*THR
      ZLM( 58)=-ZLM( 57)
      ZLM( 59)=-TEMP
      ZLM( 60)= TEMP
      TEMP    = S3BYS5*S11*FAP(6)
      ZLM( 61)= TEMP*21.0D+00
      ZLM( 62)=-TEMP*14.0D+00
      ZLM( 63)= TEMP
      TEMP    = S11*FAP(6)
      ZLM( 64)= TEMP*63.0D+00
      ZLM( 65)=-TEMP*70.0D+00
      ZLM( 66)= TEMP*15.0D+00
      ZLM( 67)= ZLM( 61)
      ZLM( 68)= ZLM( 62)
      ZLM( 69)= ZLM( 63)
      TEMP    = SR0385*SR3*FAP(2)
      ZLM( 70)= TEMP*THR
      ZLM( 71)=-TEMP
      ZLM( 72)=-ZLM( 54)
      ZLM( 73)=-ZLM( 55)
      ZLM( 74)=-ZLM( 53)
      ZLM( 75)=-ZLM( 56)
      ZLM( 76)= SR0385*FAT(2)
      ZLM( 77)=-ZLM( 76)
      ZLM( 78)= ZLM( 49)
      ZLM( 79)= ZLM( 48)
      ZLM( 80)= ZLM( 47)
! ---
! L= 6, ML=+6...-6
      ZLM( 81)= SR3003*FAP(9)
      ZLM( 82)=-ZLM( 81)*F15
      ZLM( 83)=-ZLM( 82)
      ZLM( 84)=-ZLM( 81)
      ZLM( 85)= SR1001*FAT(7)
      ZLM( 86)=-ZLM( 85)*TEN
      ZLM( 87)= ZLM( 85)*FIV
      TEMP    = S7XS13*FAT(8)
      ZLM( 88)= TEMP*F11
      ZLM( 89)=-TEMP*F11*SIX
      ZLM( 90)= ZLM( 88)
      ZLM( 91)=-TEMP
      ZLM( 92)= TEMP*SIX
      ZLM( 93)=-TEMP
      TEMP    = SR1365*FAP(7)
      ZLM( 94)= TEMP*F11
      ZLM( 95)=-TEMP*THR*F11
      ZLM( 96)= TEMP*THR*THR
      ZLM( 97)=-TEMP*THR
      TEMP    = SR1365*FAP(9)
      ZLM( 98)= TEMP*THR*F11
      ZLM( 99)=-ZLM( 98)
      ZLM(100)=-TEMP*THR*SIX
      ZLM(101)= TEMP*THR*SIX
      ZLM(102)= TEMP
      ZLM(103)=-TEMP
      TEMP    = S3BYS7*S13*FAP(6)
      ZLM(104)= TEMP*THR*F11
      ZLM(105)=-TEMP*THR*TEN
      ZLM(106)= TEMP*FIV
      TEMP    = S13*FAP(8)
      ZLM(107)= TEMP*231.0D+00
      ZLM(108)=-TEMP*315.0D+00
      ZLM(109)= TEMP*105.0D+00
      ZLM(110)=-TEMP*FIV
      ZLM(111)= ZLM(104)
      ZLM(112)= ZLM(105)
      ZLM(113)= ZLM(106)
      TEMP    = SR1365*FAP(7)
      ZLM(114)= TEMP*THR*F11
      ZLM(115)=-TEMP*THR*SIX
      ZLM(116)= TEMP
      ZLM(117)=-ZLM( 95)
      ZLM(118)=-ZLM( 94)
      ZLM(119)=-ZLM( 96)
      ZLM(120)=-ZLM( 97)
      TEMP    = S7XS13*FAT(4)
      ZLM(121)= TEMP*F11
      ZLM(122)=-ZLM(121)
      ZLM(123)=-TEMP
      ZLM(124)= TEMP
      ZLM(125)= ZLM( 87)
      ZLM(126)= ZLM( 86)
      ZLM(127)= ZLM( 85)
      TEMP    = SR3003*FAP(9)
      ZLM(128)= TEMP*SIX
      ZLM(129)=-TEMP*20.0D+00
      ZLM(130)= ZLM(128)
! ---
! L= 7, ML=-7
      ZLM(131)= S5XS11*S13*FAT(10)
      ZLM(132)= ZLM(131)*SEV*FIV
      ZLM(133)=-ZLM(131)*SEV*THR
      ZLM(134)=-ZLM(131)*SEV
! L= 7, ML=-6
      ZLM(135)= SR5005*FAT(9)
      ZLM(136)=-ZLM(135)*F15
      ZLM(137)=-ZLM(135)
      ZLM(138)=-ZLM(136)
! L= 7, ML=-5
      TEMP    = SR0385*FAT(10)
      ZLM(139)= TEMP*F13
      ZLM(140)=-ZLM(139)*TEN
      ZLM(141)= ZLM(139)*FIV
      ZLM(142)=-TEMP
      ZLM(143)=-ZLM(142)*TEN
      ZLM(144)= ZLM(142)*FIV
! L= 7, ML=-4
      TEMP    = SR0385*FAT(8)
      ZLM(145)= TEMP*F13
      ZLM(146)=-TEMP*F13*SIX
      ZLM(147)= ZLM(145)
      ZLM(148)=-TEMP*THR
      ZLM(149)= TEMP*THR*SIX
      ZLM(150)= ZLM(148)
! L= 7, ML=-3
      TEMP    = S5BYS7*FAT(10)
      ZLM(151)= TEMP*F11*F13
      ZLM(152)=-ZLM(151)*THR
      ZLM(153)=-TEMP*F11*SIX
      ZLM(154)=-ZLM(153)*THR
      ZLM(155)= TEMP*THR
      ZLM(156)=-TEMP*F09
! L= 7, ML=-2
      TEMP    = S5BYS7*FAT(9)
      ZLM(157)= TEMP*F11*F13
      ZLM(158)=-ZLM(157)
      ZLM(159)=-TEMP*F11*TEN
      ZLM(160)=-ZLM(159)
      ZLM(161)= TEMP*F15
      ZLM(162)=-ZLM(161)
! L= 7, ML=-1
      TEMP    = SR7*S15*FAP(10)
      ZLM(163)= TEMP*429.0D+00
      ZLM(164)=-TEMP*495.0D+00
      ZLM(165)= TEMP*135.0D+00
      ZLM(166)=-TEMP*FIV
! L= 7, ML= 0
      TEMP    = S15*FAP(8)
      ZLM(167)= TEMP*429.0D+00
      ZLM(168)=-TEMP*693.0D+00
      ZLM(169)= TEMP*315.0D+00
      ZLM(170)=-TEMP*35.0D+00
! L= 7, ML= 1
      ZLM(171)= ZLM(163)
      ZLM(172)= ZLM(164)
      ZLM(173)= ZLM(165)
      ZLM(174)= ZLM(166)
! L= 7, ML= 2
      ZLM(175)= ZLM(157)*2.0d0
      ZLM(176)= ZLM(159)*2.0d0
      ZLM(177)= ZLM(161)*2.0d0
! L= 7, ML= 3
      ZLM(178)=-ZLM(152)
      ZLM(179)=-ZLM(151)
      ZLM(180)=-ZLM(154)
      ZLM(181)=-ZLM(153)
      ZLM(182)=-ZLM(156)
      ZLM(183)=-ZLM(155)
! L= 7, ML= 4
      ZLM(184)= ZLM(145)*FOR
      ZLM(185)=-ZLM(184)
      ZLM(186)= ZLM(148)*FOR
      ZLM(187)=-ZLM(186)
! L= 7, ML= 5
      ZLM(188)= ZLM(141)
      ZLM(189)= ZLM(140)
      ZLM(190)= ZLM(139)
      ZLM(191)= ZLM(144)
      ZLM(192)= ZLM(143)
      ZLM(193)= ZLM(142)
! L= 7, ML= 6
      TEMP    = SR5005*FAT(7)
      ZLM(194)= TEMP*THR
      ZLM(195)=-TEMP*TEN
      ZLM(196)= ZLM(194)
! L= 7, ML= 7
      ZLM(197)=-ZLM(131)
      ZLM(198)=-ZLM(132)
      ZLM(199)=-ZLM(133)
      ZLM(200)=-ZLM(134)
! ---
! L= 8, ML=-8
      ZLM(201)= SR2431*SR5*FAT(14)
      ZLM(202)=-ZLM(201)*2.8D+01
      ZLM(203)= ZLM(201)*7.0D+01
      ZLM(204)= ZLM(202)
      ZLM(205)= ZLM(201)
! L= 8, ML=-7
      ZLM(206)= SR2431*SR5*FAT(10)
      ZLM(207)=-ZLM(206)*SEV*THR
      ZLM(208)= ZLM(206)*SEV*FIV
      ZLM(209)=-ZLM(206)*SEV
! L= 8, ML=-6
      TEMP    = SR2431*SR3*FAP(11)
      ZLM(210)= TEMP*F15
      ZLM(211)=-ZLM(210)*F15
      ZLM(212)=-ZLM(211)
      ZLM(213)=-ZLM(210)
      ZLM(214)=-TEMP
      ZLM(215)= ZLM(210)
      ZLM(216)=-ZLM(215)
      ZLM(217)= TEMP
! L= 8, ML=-5
      TEMP    = SR1001*S17*FAT(10)
      ZLM(218)= TEMP*FIV
      ZLM(219)=-ZLM(218)*TEN
      ZLM(220)= ZLM(218)*FIV
      ZLM(221)=-TEMP
      ZLM(222)= TEMP*TEN
      ZLM(223)= ZLM(221)*FIV
! L= 8, ML=-4
      TEMP    = SR1309*FAT(12)
      ZLM(224)= TEMP*F13*FIV
      ZLM(225)= ZLM(224)
      ZLM(226)=-ZLM(224)*SIX
      ZLM(227)=-TEMP*F13*2.0d0
      ZLM(228)= ZLM(227)
      ZLM(229)=-ZLM(227)*SIX
      ZLM(230)= TEMP
      ZLM(231)= TEMP
      ZLM(232)=-TEMP*SIX
! L= 8, ML=-3
      TEMP    = SR1309*S3BYS5*FAP(10)
      ZLM(233)= TEMP*F13*THR
      ZLM(234)=-ZLM(233)*THR
      ZLM(235)=-TEMP*F13*2.0d0
      ZLM(236)=-ZLM(235)*THR
      ZLM(237)= TEMP*THR
      ZLM(238)=-ZLM(237)*THR
! L= 8, ML=-2
      TEMP    = SR0119*SR5*FAT(11)
      ZLM(239)= TEMP*F11*F13
      ZLM(240)=-ZLM(239)
      ZLM(241)= ZLM(240)
      ZLM(242)= ZLM(239)
      ZLM(243)= TEMP*F11*THR
      ZLM(244)=-ZLM(243)
      ZLM(245)=-TEMP
      ZLM(246)= TEMP
! L= 8, ML=-1
      TEMP    = S17*FAT(10)
      ZLM(247)= TEMP*7.15D+02
      ZLM(248)=-TEMP*1.001D+03
      ZLM(249)= TEMP*3.85D+02
      ZLM(250)=-TEMP*3.5D+01
! L= 8, ML= 0
      TEMP    = S17*FAP(14)
      ZLM(251)= TEMP*6.435D+03
      ZLM(252)=-TEMP*1.2012D+04
      ZLM(253)= TEMP*6.930D+03
      ZLM(254)=-TEMP*1.260D+03
      ZLM(255)= TEMP*3.5D+01
! L= 8, ML= 1
      ZLM(256)= ZLM(247)
      ZLM(257)= ZLM(248)
      ZLM(258)= ZLM(249)
      ZLM(259)= ZLM(250)
! L= 8, ML= 2
      TEMP    = SR0119*SR5*FAT(9)
      ZLM(260)= TEMP*F11*F13
      ZLM(261)=-ZLM(260)
      ZLM(262)= TEMP*F11*THR
      ZLM(263)=-TEMP
! L= 8, ML= 3
      ZLM(264)=-ZLM(234)
      ZLM(265)=-ZLM(233)
      ZLM(266)=-ZLM(236)
      ZLM(267)=-ZLM(235)
      ZLM(268)=-ZLM(238)
      ZLM(269)=-ZLM(237)
! L= 8, ML= 4
      TEMP    = SR1309*FAT(8)
      ZLM(270)= TEMP*F13*FIV
      ZLM(271)=-ZLM(270)
      ZLM(272)=-TEMP*F13*2.0d0
      ZLM(273)=-ZLM(272)
      ZLM(274)= TEMP
      ZLM(275)=-TEMP
! L= 8, ML= 5
      TEMP    = SR1001*S17*FAT(10)
      ZLM(276)= TEMP*FIV*FIV
      ZLM(277)=-TEMP*FIV*TEN
      ZLM(278)= TEMP*FIV
      ZLM(279)=-TEMP*FIV
      ZLM(280)= TEMP*TEN
      ZLM(281)=-TEMP
! L= 8, ML= 6
      TEMP    = SR2431*SR3*FAP(9)
      ZLM(282)= TEMP*F15*THR
      ZLM(283)=-TEMP*F15*TEN
      ZLM(284)= ZLM(282)
      ZLM(285)=-TEMP*THR
      ZLM(286)= TEMP*TEN
      ZLM(287)= ZLM(285)
! L= 8, ML= 7
      ZLM(288)=-ZLM(209)
      ZLM(289)=-ZLM(208)
      ZLM(290)=-ZLM(207)
      ZLM(291)=-ZLM(206)
! L= 8, ML= 8
      ZLM(292)= ZLM(201)*EIT
      ZLM(293)=-ZLM(292)*SEV
      ZLM(294)=-ZLM(293)
      ZLM(295)=-ZLM(292)
! ---
! L= 9, ML=-9
      ZLM(296)= S13585*S17*FAP(15)
      ZLM(297)=-ZLM(296)*3.6D+01
      ZLM(298)= ZLM(296)*1.26D+02
      ZLM(299)=-ZLM(296)*8.4D+01
      ZLM(300)= ZLM(296)*9.0D+00
! L= 9, ML=-8
      ZLM(301)= S13585*S17*FAT(14)
      ZLM(302)=-ZLM(301)*SEV*FOR
      ZLM(303)= ZLM(301)*SEV*TEN
      ZLM(304)= ZLM(302)
      ZLM(305)= ZLM(301)
! L= 9, ML=-7
      TEMP    = S13585*FAT(15)
      ZLM(306)= TEMP*F17
      ZLM(307)=-ZLM(306)*SEV*THR
      ZLM(308)= ZLM(306)*SEV*FIV
      ZLM(309)=-ZLM(306)*SEV
      ZLM(310)=-TEMP
      ZLM(311)= TEMP*SEV*THR
      ZLM(312)=-TEMP*SEV*FIV
      ZLM(313)= TEMP*SEV
! L= 9, ML=-6
      TEMP    = SR0247*S11*S15*FAP(11)
      ZLM(314)= TEMP*F17
      ZLM(315)=-ZLM(314)*F15
      ZLM(316)=-ZLM(315)
      ZLM(317)=-ZLM(314)
      ZLM(318)=-TEMP*THR
      ZLM(319)=-ZLM(318)*F15
      ZLM(320)=-ZLM(319)
      ZLM(321)=-ZLM(318)
! L= 9, ML=-5
      TEMP    = SR0247*S11*FAT(13)
      ZLM(322)= TEMP*FIV*F17
      ZLM(323)=-ZLM(322)*TEN
      ZLM(324)= ZLM(322)*FIV
      ZLM(325)=-TEMP*FIV*SIX
      ZLM(326)=-ZLM(325)*TEN
      ZLM(327)= ZLM(325)*FIV
      ZLM(328)= TEMP
      ZLM(329)=-TEMP*TEN
      ZLM(330)= TEMP*FIV
! L= 9, ML=-4
      TEMP    = SR5005*S19*FAT(12)
      ZLM(331)= TEMP*F17
      ZLM(332)= ZLM(331)
      ZLM(333)=-ZLM(331)*SIX
      ZLM(334)=-TEMP*TEN
      ZLM(335)= ZLM(334)
      ZLM(336)=-ZLM(334)*SIX
      ZLM(337)= TEMP
      ZLM(338)= TEMP
      ZLM(339)=-TEMP*SIX
! L= 9, ML=-3
      TEMP    = S3BYS5*S7XS11*S19*FAP(13)
      ZLM(340)= TEMP*2.21D+02
      ZLM(341)=-ZLM(340)*THR
      ZLM(342)=-TEMP*F13*THR*FIV
      ZLM(343)=-ZLM(342)*THR
      ZLM(344)= TEMP*F13*THR
      ZLM(345)=-ZLM(344)*THR
      ZLM(346)=-TEMP
      ZLM(347)= TEMP*THR
! L= 9, ML=-2
      TEMP    = S5XS11*S19*FAT(11)
      ZLM(348)= TEMP*2.21D+02
      ZLM(349)=-ZLM(348)
      ZLM(350)=-TEMP*SEV*F13*THR
      ZLM(351)=-ZLM(350)
      ZLM(352)= TEMP*SEV*F13
      ZLM(353)=-ZLM(352)
      ZLM(354)=-TEMP*SEV
      ZLM(355)=-ZLM(354)
! L= 9, ML=-1
      TEMP    = SR5*S19*FAT(14)
      ZLM(356)= TEMP*2.431D+03
      ZLM(357)=-TEMP*4.004D+03
      ZLM(358)= TEMP*2.002D+03
      ZLM(359)=-TEMP*3.08D+02
      ZLM(360)= TEMP*SEV
! L= 9, ML= 0
      TEMP    = S19*FAP(14)
      ZLM(361)= TEMP*1.2155D+04
      ZLM(362)=-TEMP*2.5740D+04
      ZLM(363)= TEMP*1.8018D+04
      ZLM(364)=-TEMP*4.620D+03
      ZLM(365)= TEMP*3.15D+02
! L= 9, ML= 1
      ZLM(366)= ZLM(356)
      ZLM(367)= ZLM(357)
      ZLM(368)= ZLM(358)
      ZLM(369)= ZLM(359)
      ZLM(370)= ZLM(360)
! L= 9, ML= 2
      TEMP    = S5XS11*S19*FAT(9)
      ZLM(371)= TEMP*2.21D+02
      ZLM(372)=-TEMP*2.73D+02
      ZLM(373)= TEMP*9.1D+01
      ZLM(374)=-TEMP*SEV
! L= 9, ML= 3
      ZLM(375)=-ZLM(341)
      ZLM(376)=-ZLM(340)
      ZLM(377)=-ZLM(343)
      ZLM(378)=-ZLM(342)
      ZLM(379)=-ZLM(345)
      ZLM(380)=-ZLM(344)
      ZLM(381)=-ZLM(347)
      ZLM(382)=-ZLM(346)
! L= 9, ML= 4
      TEMP    = SR5005*S19*FAT(8)
      ZLM(383)= TEMP*F17
      ZLM(384)=-ZLM(383)
      ZLM(385)=-TEMP*TEN
      ZLM(386)=-ZLM(385)
      ZLM(387)= TEMP
      ZLM(388)=-ZLM(387)
! L= 9, ML= 5
      ZLM(389)= ZLM(324)
      ZLM(390)= ZLM(323)
      ZLM(391)= ZLM(322)
      ZLM(392)= ZLM(327)
      ZLM(393)= ZLM(326)
      ZLM(394)= ZLM(325)
      ZLM(395)= ZLM(330)
      ZLM(396)= ZLM(329)
      ZLM(397)= ZLM(328)
! L= 9, ML= 6
      TEMP    = SR0247*S3BYS5*S11*FAP(9)
      ZLM(398)= TEMP*F17*THR
      ZLM(399)=-TEMP*F17*TEN
      ZLM(400)= ZLM(398)
      ZLM(401)=-TEMP*THR*THR
      ZLM(402)= TEMP*THR*TEN
      ZLM(403)= ZLM(401)
! L= 9, ML= 7
      ZLM(404)=-ZLM(309)
      ZLM(405)=-ZLM(308)
      ZLM(406)=-ZLM(307)
      ZLM(407)=-ZLM(306)
      ZLM(408)=-ZLM(313)
      ZLM(409)=-ZLM(312)
      ZLM(410)=-ZLM(311)
      ZLM(411)=-ZLM(310)
! L= 9, ML= 8
      ZLM(412)= ZLM(301)*EIT
      ZLM(413)=-ZLM(412)*SEV
      ZLM(414)=-ZLM(413)
      ZLM(415)=-ZLM(412)
! L= 9, ML= 9
      ZLM(416)= ZLM(300)
      ZLM(417)= ZLM(299)
      ZLM(418)= ZLM(298)
      ZLM(419)= ZLM(297)
      ZLM(420)= ZLM(296)
! ---
! L=10, ML=-10
      ZLM(421)= SR0323*SR3003*FAP(17)
      ZLM(422)=-ZLM(421)*4.5D+01
      ZLM(423)= ZLM(421)*2.10D+02
      ZLM(424)=-ZLM(423)
      ZLM(425)=-ZLM(422)
      ZLM(426)=-ZLM(421)
! L=10, ML=-9
      ZLM(427)= SR0323*SR3003*SR5*FAP(15)
      ZLM(428)=-ZLM(427)*3.6D+01
      ZLM(429)= ZLM(427)*1.26D+02
      ZLM(430)=-ZLM(427)*8.4D+01
      ZLM(431)= ZLM(427)*9.0D+00
! L=10, ML=-8
      TEMP    = SR5005*S17*SR3*FAP(16)
      ZLM(432)= TEMP*F19
      ZLM(433)=-ZLM(432)*SEV*FOR
      ZLM(434)= ZLM(432)*SEV*TEN
      ZLM(435)= ZLM(433)
      ZLM(436)= ZLM(432)
      ZLM(437)=-TEMP
      ZLM(438)=-ZLM(437)*SEV*FOR
      ZLM(439)= ZLM(437)*SEV*TEN
      ZLM(440)= ZLM(438)
      ZLM(441)= ZLM(437)
! L=10, ML=-7
      TEMP    = SR5005*S17*FAT(15)
      ZLM(442)= TEMP*F19
      ZLM(443)=-ZLM(442)*SEV*THR
      ZLM(444)= ZLM(442)*SEV*FIV
      ZLM(445)=-ZLM(442)*SEV
      ZLM(446)=-TEMP*THR
      ZLM(447)=-ZLM(446)*SEV*THR
      ZLM(448)= ZLM(446)*SEV*FIV
      ZLM(449)=-ZLM(446)*SEV
! L=10, ML=-6
      TEMP    = SR5005*FAT(17)
      ZLM(450)= TEMP*3.23D+02
      ZLM(451)=-ZLM(450)*F15
      ZLM(452)=-ZLM(451)
      ZLM(453)=-ZLM(450)
      ZLM(454)=-TEMP*1.02D+02
      ZLM(455)=-ZLM(454)*F15
      ZLM(456)=-ZLM(455)
      ZLM(457)=-ZLM(454)
      ZLM(458)= TEMP*THR
      ZLM(459)=-ZLM(458)*F15
      ZLM(460)=-ZLM(459)
      ZLM(461)=-ZLM(458)
! L=10, ML=-5
      TEMP    = SR1001*FAT(13)
      ZLM(462)= TEMP*3.23D+02
      ZLM(463)=-ZLM(462)*TEN
      ZLM(464)= ZLM(462)*FIV
      ZLM(465)=-TEMP*1.70D+02
      ZLM(466)=-ZLM(465)*TEN
      ZLM(467)= ZLM(465)*FIV
      ZLM(468)= TEMP*F15
      ZLM(469)=-ZLM(468)*TEN
      ZLM(470)= ZLM(468)*FIV
! L=10, ML=-4
      TEMP    = SR5005*FAT(14)
      ZLM(471)= TEMP*3.23D+02
      ZLM(472)= ZLM(471)
      ZLM(473)=-ZLM(471)*SIX
      ZLM(474)=-TEMP*2.55D+02
      ZLM(475)= ZLM(474)
      ZLM(476)=-ZLM(474)*SIX
      ZLM(477)= TEMP*4.5D+01
      ZLM(478)= ZLM(477)
      ZLM(479)=-ZLM(477)*SIX
      ZLM(480)=-TEMP
      ZLM(481)= ZLM(480)
      ZLM(482)=-ZLM(480)*SIX
! L=10, ML=-3
      TEMP    = SR5005*FAT(13)
      ZLM(483)= TEMP*3.23D+02
      ZLM(484)=-ZLM(483)*THR
      ZLM(485)=-TEMP*3.57D+02
      ZLM(486)=-ZLM(485)*THR
      ZLM(487)= TEMP*1.05D+02
      ZLM(488)=-ZLM(487)*THR
      ZLM(489)=-TEMP*SEV
      ZLM(490)=-ZLM(489)*THR
! L=10, ML=-2
      TEMP    = SR0385*FAT(16)
      ZLM(491)= TEMP*4.199D+03
      ZLM(492)=-ZLM(491)
      ZLM(493)=-TEMP*6.188D+03
      ZLM(494)=-ZLM(493)
      ZLM(495)= TEMP*2.730D+03
      ZLM(496)=-ZLM(495)
      ZLM(497)=-TEMP*3.64D+02
      ZLM(498)=-ZLM(497)
      ZLM(499)= TEMP*SEV
      ZLM(500)=-ZLM(499)
! L=10, ML=-1
      TEMP    = SR0385*SR3*FAP(14)
      ZLM(501)= TEMP*4.199D+03
      ZLM(502)=-TEMP*7.956D+03
      ZLM(503)= TEMP*4.914D+03
      ZLM(504)=-TEMP*1.092D+03
      ZLM(505)= TEMP*6.3D+01
! L=10, ML= 0
      TEMP    = S3BYS7*FAP(16)
      ZLM(506)= TEMP*4.6189D+04
      ZLM(507)=-TEMP*1.09395D+05
      ZLM(508)= TEMP*9.0090D+04
      ZLM(509)=-TEMP*3.0030D+04
      ZLM(510)= TEMP*3.465D+03
      ZLM(511)=-TEMP*6.3D+01
! L=10, ML= 1
      ZLM(512)= ZLM(501)
      ZLM(513)= ZLM(502)
      ZLM(514)= ZLM(503)
      ZLM(515)= ZLM(504)
      ZLM(516)= ZLM(505)
! L=10, ML= 2
      ZLM(517)= ZLM(491)*2.0d0
      ZLM(518)= ZLM(493)*2.0d0
      ZLM(519)= ZLM(495)*2.0d0
      ZLM(520)= ZLM(497)*2.0d0
      ZLM(521)= ZLM(499)*2.0d0
! L=10, ML= 3
      ZLM(522)=-ZLM(484)
      ZLM(523)=-ZLM(483)
      ZLM(524)=-ZLM(486)
      ZLM(525)=-ZLM(485)
      ZLM(526)=-ZLM(488)
      ZLM(527)=-ZLM(487)
      ZLM(528)=-ZLM(490)
      ZLM(529)=-ZLM(489)
! L=10, ML= 4
      ZLM(530)= ZLM(471)*FOR
      ZLM(531)=-ZLM(530)
      ZLM(532)= ZLM(474)*FOR
      ZLM(533)=-ZLM(532)
      ZLM(534)= ZLM(477)*FOR
      ZLM(535)=-ZLM(534)
      ZLM(536)= ZLM(480)*FOR
      ZLM(537)=-ZLM(536)
! L=10, ML= 5
      ZLM(538)= ZLM(462)
      ZLM(539)= ZLM(463)
      ZLM(540)= ZLM(464)
      ZLM(541)= ZLM(465)
      ZLM(542)= ZLM(466)
      ZLM(543)= ZLM(467)
      ZLM(544)= ZLM(468)
      ZLM(545)= ZLM(469)
      ZLM(546)= ZLM(470)
! L=10, ML= 6
      ZLM(547)= ZLM(450)*SIX
      ZLM(548)=-ZLM(450)*2.0D+01
      ZLM(549)= ZLM(547)
      ZLM(550)= ZLM(454)*SIX
      ZLM(551)=-ZLM(454)*2.0D+01
      ZLM(552)= ZLM(550)
      ZLM(553)= ZLM(458)*SIX
      ZLM(554)=-ZLM(458)*2.0D+01
      ZLM(555)= ZLM(553)
! L=10, ML= 7
      ZLM(556)=-ZLM(445)
      ZLM(557)=-ZLM(444)
      ZLM(558)=-ZLM(443)
      ZLM(559)=-ZLM(442)
      ZLM(560)=-ZLM(449)
      ZLM(561)=-ZLM(448)
      ZLM(562)=-ZLM(447)
      ZLM(563)=-ZLM(446)
! L=10, ML= 8
      ZLM(564)= ZLM(432)*EIT
      ZLM(565)=-ZLM(432)*5.6D+01
      ZLM(566)=-ZLM(565)
      ZLM(567)=-ZLM(564)
      ZLM(568)= ZLM(437)*EIT
      ZLM(569)=-ZLM(437)*5.6D+01
      ZLM(570)=-ZLM(569)
      ZLM(571)=-ZLM(568)
! L=10, ML= 9
      ZLM(572)= ZLM(431)
      ZLM(573)= ZLM(430)
      ZLM(574)= ZLM(429)
      ZLM(575)= ZLM(428)
      ZLM(576)= ZLM(427)
! L=10, ML= 10
      ZLM(577)= ZLM(421)*TEN
      ZLM(578)=-ZLM(421)*1.20D+02
      ZLM(579)= ZLM(421)*2.52D+02
      ZLM(580)= ZLM(578)
      ZLM(581)= ZLM(577)
!
      RETURN
      END

! ECPINI
      SUBROUTINE ECPINI(LMF,LMX,LMY,LMZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION LMF(122),LMX(581),LMY(581),LMZ(581)
      COMMON /GBASE / NFST(8),NX(84),NY(84),NZ(84)

! LMF (FIRST) POINT TO THE FIRST PARTS OF THE
! SPHERICAL HARMONIC COEF TABLE (ZLM) AND TO THE CORRESPONDING POWERS
! OF X, Y, AND Z STORED IN LMX, LMY, LMZ (GOOD THROUGH L=10)

      DIMENSION ILMF(122),ILMX(581),ILMY(581),ILMZ(581)
      DIMENSION INFST(8),INX(84),INY(84),INZ(84)
      DATA ILMF/1, 2,3,4, 5,7,8,10,11, 12,14,16,18,20,22,23,            &
      25,28,30,34,36,39,41,43,45, 47,50,53,57,61,64,67,70,72,76,78,     &
      81,85,88,94,98,104,107,111,114,117,121,125,128,                   &
      131,135,139,145,151,157,163,167,171,175,178,184,188,194,197,      &
      201,206,210,218,224,233,239,247,251,256,260,264,270,276,282,      &
      288,292, 296,301,306,314,322,331,340,348,356,361,366,371,375,383, &
      389,398,404,412,416, 421,427,432,442,450,462,471,483,491,501,506, &
      512,517,522,530,538,547,556,564,572,577, 582/                      
      DATA ILMX/0, 1,0,0, 2,0,1,0,0,0,1, 3,1,2,0,1,1,0,0,0,0,1,2,0,     &
      4,2,0,3,1,2,0,0,2,1,1,0,0,0,0,0,1,1,2,0,3,1, 5,3,1,0,2,4,3,1,1,3, &
      2,0,2,0,1,1,1,0,0,0,0,0,0,1,1,2,2,0,0,3,1,4,2,0, 6,4,2,0,5,3,1,4, &
      2,0,4,2,0,3,1,1,3,2,0,2,0,2,0,1,1,1,0,0,0,0,0,0,0,1,1,1,2,0,2,0,3,&
      1,3,1,4,2,0,5,3,1, 7,3,5,1,6,4,0,2,5,3,1,5,3,1,4,2,0,4,2,0,3,1,3, &
      1,3,1,2,0,2,0,2,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,2,0,2,0,2,0,3,1,3,&
      1,4,2,0,4,2,0,5,3,1,0,4,2,6, 8,6,4,2,0,7,5,3,1,6,4,2,0,6,4,2,0,5, &
      3,1,5,3,1,4,0,2,4,0,2,4,0,2,3,1,3,1,3,1,2,0,2,0,2,0,2,0,1,1,1,1,0,&
      0,0,0,0,0,0,0,0,1,1,1,1,2,0,2,0,2,0,3,1,3,1,3,1,4,2,0,4,2,0,5,3,1,&
      5,3,1,6,4,2,0,7,5,3,1, 9,7,5,3,1,8,6,4,2,0,7,5,3,1,7,5,3,1,6,4,2, &
      0,6,4,2,0,5,3,1,5,3,1,5,3,1,4,0,2,4,0,2,4,0,2,3,1,3,1,3,1,3,1,2,0,&
      2,0,2,0,2,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,0,2,0,2,0,2,0,&
      3,1,3,1,3,1,4,2,0,4,2,0,4,2,0,5,3,1,5,3,1,6,4,2,0,6,4,2,0,7,5,3,1,&
      8,6,4,2,0, 10,8,6,4,2,0,9,7,5,3,1,8,6,4,2,0,8,6,4,2,0,7,5,3,1,7,5,&
      3,1,6,4,2,0,6,4,2,0,6,4,2,0,5,3,1,5,3,1,5,3,1,4,0,2,4,0,2,4,0,2,4,&
      0,2,3,1,3,1,3,1,3,1,2,0,2,0,2,0,2,0,2,0,1,1,1,1,1,0,0,0,0,0,0,0,  &
      0,0,0,0,1,1,1,1,1,2,0,2,0,2,0,2,0,3,1,3,1,3,1,3,1,0,2,4,0,2,4,0,2,&
      4,5,3,1,5,3,1,5,3,1,6,4,2,0,6,4,2,0,7,5,3,1,7,5,3,1,8,6,4,2,0,9,7,&
      5,3,1/                                                             
      DATA ILMY/0, 0,0,1, 0,2,0,0,0,1,1, 0,2,0,2,0,0,0,0,1,1,1,1,3,     &
      0,2,4,0,2,0,2,2,0,0,0,0,0,0,1,1,1,1,1,3,1,3, 0,2,4,4,2,0,0,2,2,0, &
      0,2,0,2,0,0,0,0,0,0,1,1,1,1,1,1,1,3,3,1,3,1,3,5, 0,2,4,6,0,2,4,0, &
      2,4,0,2,4,0,2,2,0,0,2,0,2,0,2,0,0,0,0,0,0,0,1,1,1,1,1,1,1,3,1,3,1,&
      3,1,3,1,3,5,1,3,5, 0,4,2,6,0,2,6,4,0,2,4,0,2,4,0,2,4,0,2,4,0,2,0, &
      2,0,2,0,2,0,2,0,2,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,1,3,1,3,1,3,1,&
      3,1,3,5,1,3,5,1,3,5,7,3,5,1, 0,2,4,6,8,0,2,4,6,0,2,4,6,0,2,4,6,0, &
      2,4,0,2,4,0,4,2,0,4,2,0,4,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,0,0,&
      0,0,0,0,1,1,1,1,1,1,1,1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,5,1,3,5,1,3,5,&
      1,3,5,1,3,5,7,1,3,5,7, 0,2,4,6,8,0,2,4,6,8,0,2,4,6,0,2,4,6,0,2,4, &
      6,0,2,4,6,0,2,4,0,2,4,0,2,4,0,4,2,0,4,2,0,4,2,0,2,0,2,0,2,0,2,0,2,&
      0,2,0,2,0,2,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,3,1,3,1,3,1,3,&
      1,3,1,3,1,3,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,1,3,5,7,1,3,5,7,1,3,5,7,&
      1,3,5,7,9, 0,2,4,6,8,10,0,2,4,6,8,0,2,4,6,8,0,2,4,6,8,0,2,4,6,0,2,&
      4,6,0,2,4,6,0,2,4,6,0,2,4,6,0,2,4,0,2,4,0,2,4,0,4,2,0,4,2,0,4,2,0,&
      4,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,1,  &
      1,1,1,1,1,1,1,1,1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,5,3,1,5,3,1,5,3,&
      1,1,3,5,1,3,5,1,3,5,1,3,5,7,1,3,5,7,1,3,5,7,1,3,5,7,1,3,5,7,9,1,3,&
      5,7,9/                                                             
      DATA ILMZ/0, 0,1,0, 0,0,1,2,0,1,0, 0,0,1,1,2,0,3,1,2,0,1,0,0,     &
      0,0,0,1,1,2,2,0,0,3,1,4,2,0,3,1,2,0,1,1,0,0, 0,0,0,1,1,1,2,2,0,0, &
      3,3,1,1,4,2,0,5,3,1,4,2,0,3,1,2,0,2,0,1,1,0,0,0, 0,0,0,0,1,1,1,2, &
      2,2,0,0,0,3,3,1,1,4,4,2,2,0,0,5,3,1,6,4,2,0,5,3,1,4,2,0,3,3,1,1,2,&
      2,0,0,1,1,1,0,0,0, 0,0,0,0,1,1,1,1,2,2,2,0,0,0,3,3,3,1,1,1,4,4,2, &
      2,0,0,5,5,3,3,1,1,6,4,2,0,7,5,3,1,6,4,2,0,5,3,1,4,4,2,2,0,0,3,3,1,&
      1,2,2,2,0,0,0,1,1,1,0,0,0,0, 0,0,0,0,0,1,1,1,1,2,2,2,2,0,0,0,0,3, &
      3,3,1,1,1,4,4,4,2,2,2,0,0,0,5,5,3,3,1,1,6,6,4,4,2,2,0,0,7,5,3,1,8,&
      6,4,2,0,7,5,3,1,6,4,2,0,5,5,3,3,1,1,4,4,2,2,0,0,3,3,3,1,1,1,2,2,2,&
      0,0,0,1,1,1,1,0,0,0,0, 0,0,0,0,0,1,1,1,1,1,2,2,2,2,0,0,0,0,3,3,3, &
      3,1,1,1,1,4,4,4,2,2,2,0,0,0,5,5,5,3,3,3,1,1,1,6,6,4,4,2,2,0,0,7,7,&
      5,5,3,3,1,1,8,6,4,2,0,9,7,5,3,1,8,6,4,2,0,7,5,3,1,6,6,4,4,2,2,0,0,&
      5,5,3,3,1,1,4,4,4,2,2,2,0,0,0,3,3,3,1,1,1,2,2,2,2,0,0,0,0,1,1,1,1,&
      0,0,0,0,0, 0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,0,0,0,0,0,3,3,3,3,1,1, &
      1,1,4,4,4,4,2,2,2,2,0,0,0,0,5,5,5,3,3,3,1,1,1,6,6,6,4,4,4,2,2,2,0,&
      0,0,7,7,5,5,3,3,1,1,8,8,6,6,4,4,2,2,0,0,9,7,5,3,1,10,8,6,4,2,0,9, &
      7,5,3,1,8,6,4,2,0,7,7,5,5,3,3,1,1,6,6,4,4,2,2,0,0,5,5,5,3,3,3,1,1,&
      1,4,4,4,2,2,2,0,0,0,3,3,3,3,1,1,1,1,2,2,2,2,0,0,0,0,1,1,1,1,1,0,0,&
      0,0,0/                                                             
      DATA INFST/1,2,5,11,21,36,57,85/                                   
      DATA INX/0,1,0,0,2,0,0,1,1,0,3,0,0,2,2,1,0,1,0,1,4,0,0,3,3,1,0,   &
      1,0,2,2,0,2,1,1, 5,0,0,4,4,1,0,1,0,3,3,2,0,2,0,3,1,1,2,2,1,       &
      6,0,0,5,5,1,0,1,0,4,4,2,0,2,0,4,1,1,3,3,0,3,3,2,1,2,1,2/,         &
           INY/0,0,1,0,0,2,0,1,0,1,0,3,0,1,0,2,2,0,1,1,0,4,0,1,0,3,3,   &
      0,1,2,0,2,1,2,1, 0,5,0,1,0,4,4,0,1,2,0,3,3,0,2,1,3,1,2,1,2,       &
      0,6,0,1,0,5,5,0,1,2,0,4,4,0,2,1,4,1,3,0,3,2,1,3,3,1,2,2/,         &
           INZ/0,0,0,1,0,0,2,0,1,1,0,0,3,0,1,0,1,2,2,1,0,0,4,0,1,0,1,   &
      3,3,0,2,2,1,1,2, 0,0,5,0,1,0,1,4,4,0,2,0,2,3,3,1,1,3,1,2,2,       &
      0,0,6,0,1,0,1,5,5,0,2,0,2,4,4,1,1,4,0,3,3,1,2,1,2,3,3,2/

      DO 110 I = 1,122
         LMF(I)= ILMF(I)
  110 CONTINUE
      DO 120 J = 1,581
         LMX(J)= ILMX(J)
         LMY(J)= ILMY(J)
         LMZ(J)= ILMZ(J)
  120 CONTINUE
      DO 130 K = 1,8
         NFST(K)= INFST(K)
  130 CONTINUE
      DO 140 L = 1,84
         NX(L) = INX(L)
         NY(L) = INY(L)
         NZ(L) = INZ(L)
  140 CONTINUE
      RETURN
      END

! DAWERT
      SUBROUTINE DAWERT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
!        -----  ROUTINE ALLOCATES Parameters SPECIFYING THE     -----
!        -----  PIECEWISE CHEBYCHEV POLYNOMIAL FIT TO THE       -----
!        -----  DAWSON-ERROR FUNCTION.                          -----
!
      COMMON /DERFCM/ C(246),IFRST(40),ILAST(40),H
!
      H = 0.25D+00
! ... 0.00 < X <= 0.25  INTERVAL NO. 1, ABS.ERROR = 3.0831115438446D-
      IFRST( 1)= 1
      ILAST( 1)= 8
      C( 1)=-0.2227673357873D-15
      C( 2)=-0.3603041588494D-08
      C( 3)= 0.5641900599881D+00
      C( 4)=-0.1855716761667D-04
      C( 5)=-0.3758028089842D+00
      C( 6)=-0.2937263239086D-02
      C( 7)= 0.1586735773807D+00
      C( 8)=-0.3712362707925D-01
! ... 0.25 < X <= 0.50  INTERVAL NO. 2, ABS.ERROR = 1.6200374375330D-
      IFRST( 2)= 9
      ILAST( 2)=16
      C( 9)= 0.1654923320373D-05
      C(10)=-0.4283673776908D-04
      C(11)= 0.5646780085194D+00
      C(12)=-0.3216632920741D-02
      C(13)=-0.3626661648377D+00
      C(14)=-0.3697874666458D-01
      C(15)= 0.2103001701512D+00
      C(16)=-0.7233313577516D-01
! ... 0.50 < X <= 0.75  INTERVAL NO. 3, ABS.ERROR = 2.6527224861184D-
      IFRST( 3)=17
      ILAST( 3)=24
      C(17)=-0.4909038422764D-03
      C(18)= 0.6169678713757D-02
      C(19)= 0.5309521767077D+00
      C(20)= 0.9902446632012D-01
      C(21)=-0.5497719612405D+00
      C(22)= 0.1699289458172D+00
      C(23)= 0.8215358267937D-01
      C(24)=-0.3800879631724D-01
! ... 0.75 < X <= 1.00  INTERVAL NO. 4, ABS.ERROR = 2.1188384380366D-
      IFRST( 4)=25
      ILAST( 4)=32
      C(25)=-0.8860184581188D-02
      C(26)= 0.8182679610811D-01
      C(27)= 0.2361899484096D+00
      C(28)= 0.7408443731368D+00
      C(29)=-0.1393552470603D+01
      C(30)= 0.8398504617092D+00
      C(31)=-0.2153157176716D+00
      C(32)= 0.1898293835776D-01
! ... 1.00 < X <= 1.25  INTERVAL NO. 5, ABS.ERROR = 1.0054179711005D-
      IFRST( 5)=33
      ILAST( 5)=40
      C(33)=-0.2622864777452D-01
      C(34)= 0.2070481292278D+00
      C(35)=-0.1517729522946D+00
      C(36)= 0.1410375745664D+01
      C(37)=-0.2088589931697D+01
      C(38)= 0.1273821623264D+01
      C(39)=-0.3662054027830D+00
      C(40)= 0.4151758125850D-01
! ... 1.25 < X <= 1.50  INTERVAL NO. 6, ABS.ERROR = 1.2743583965857D-
      IFRST( 6)=41
      ILAST( 6)=48
      C(41)= 0.7652753217902D-01
      C(42)=-0.3496979906426D+00
      C(43)= 0.1142731303255D+01
      C(44)=-0.2641065409391D+00
      C(45)=-0.7870989692331D+00
      C(46)= 0.6659477061060D+00
      C(47)=-0.2082257760423D+00
      C(48)= 0.2389272621700D-01
! ... 1.50 < X <= 1.75  INTERVAL NO. 7, ABS.ERROR = 3.2651215065016D-
      IFRST( 7)=49
      ILAST( 7)=55
      C(49)= 0.4634935721533D+00
      C(50)=-0.2162775089324D+01
      C(51)= 0.4787745789535D+01
      C(52)=-0.4340108008393D+01
      C(53)= 0.1951017416635D+01
      C(54)=-0.4390388356211D+00
      C(55)= 0.3981846570969D-01
! ... 1.75 < X <= 2.00  INTERVAL NO. 8, ABS.ERROR = 8.9706020389713D-
      IFRST( 8)=56
      ILAST( 8)=63
      C(56)= 0.9892135872598D+00
      C(57)=-0.4311631180681D+01
      C(58)= 0.8556855041877D+01
      C(59)=-0.8017503990110D+01
      C(60)= 0.4106390132111D+01
      C(61)=-0.1197913275632D+01
      C(62)= 0.1884269501482D+00
      C(63)=-0.1248598098755D-01
! ... 2.00 < X <= 2.25  INTERVAL NO. 9, ABS.ERROR = 3.1388225352202D-
      IFRST( 9)=64
      ILAST( 9)=71
      C(64)= 0.4508582229747D+00
      C(65)=-0.2475021032343D+01
      C(66)= 0.5870952943693D+01
      C(67)=-0.5834804573043D+01
      C(68)= 0.3041872702481D+01
      C(69)=-0.8863349469112D+00
      C(70)= 0.1377496059452D+00
      C(71)=-0.8952617645264D-02
! ... 2.25 < X <= 2.50  INTERVAL NO.10, ABS.ERROR = 3.5207392556913D-
      IFRST(10)=72
      ILAST(10)=78
      C(72)=-0.2479150925527D+01
      C(73)= 0.6465442349154D+01
      C(74)=-0.5832144628726D+01
      C(75)= 0.2684557558935D+01
      C(76)=-0.6830155078836D+00
      C(77)= 0.9186854104822D-01
      C(78)=-0.5120121563474D-02
! ... 2.50 < X <= 2.75  INTERVAL NO.11, ABS.ERROR = 1.5842438472191D-
      IFRST(11)=79
      ILAST(11)=85
      C(79)=-0.2550246682056D+01
      C(80)= 0.6663085650406D+01
      C(81)=-0.6057008239737D+01
      C(82)= 0.2819123791215D+01
      C(83)=-0.7278168845029D+00
      C(84)= 0.9975271609922D-01
      C(85)=-0.5693960934877D-02
! ... 2.75 < X <= 3.00  INTERVAL NO.12, ABS.ERROR = 2.1390000881638D-
      IFRST(12)=86
      ILAST(12)=92
      C(86)=-0.1437322524459D+01
      C(87)= 0.4244945032011D+01
      C(88)=-0.3866819653025D+01
      C(89)= 0.1760657886042D+01
      C(90)=-0.4399493394691D+00
      C(91)= 0.5797869518089D-01
      C(92)=-0.3166941925883D-02
! ... 3.00 < X <= 3.25  INTERVAL NO.13, ABS.ERROR = 1.2176926134089D-
      IFRST(13)=93
      ILAST(13)=99
      C(93)= 0.4326982515539D-01
      C(94)= 0.1278541925538D+01
      C(95)=-0.1389457146276D+01
      C(96)= 0.6567745067205D+00
      C(97)=-0.1631568799154D+00
      C(98)= 0.2094831465123D-01
      C(99)=-0.1101922864715D-02
! ... 3.25 < X <= 3.50  INTERVAL NO.14, ABS.ERROR = 4.2543746303636D-
      IFRST(14)=100
      ILAST(14)=106
      C(100)= 0.1115286202567D+01
      C(101)=-0.7098356509943D+00
      C(102)= 0.1477452918517D+00
      C(103)= 0.2274875774917D-01
      C(104)=-0.1601072077271D-01
      C(105)= 0.2728999281923D-02
      C(106)=-0.1616695274909D-03
! ... 3.50 < X <= 3.75  INTERVAL NO.15, ABS.ERROR = 2.3193003073629D-
      IFRST(15)=107
      ILAST(15)=112
      C(107)= 0.1346851272697D+01
      C(108)=-0.1125834241251D+01
      C(109)= 0.4583884751028D+00
      C(110)=-0.1007033665315D+00
      C(111)= 0.1153266357142D-01
      C(112)=-0.5427038297057D-03
! ... 3.75 < X <= 4.00  INTERVAL NO.16, ABS.ERROR = 2.6108004647085D-
      IFRST(16)=113
      ILAST(16)=118
      C(113)= 0.1220883963156D+01
      C(114)=-0.9581085557663D+00
      C(115)= 0.3690371210149D+00
      C(116)=-0.7689811239270D-01
      C(117)= 0.8360797545174D-02
      C(118)=-0.3736140672117D-03
! ... 4.00 < X <= 4.25  INTERVAL NO.17, ABS.ERROR = 1.7570833676928D-
      IFRST(17)=119
      ILAST(17)=124
      C(119)= 0.1079863694049D+01
      C(120)=-0.7816343308043D+00
      C(121)= 0.2806819253411D+00
      C(122)=-0.5477512389825D-01
      C(123)= 0.5590565502644D-02
      C(124)=-0.2348302397877D-03
! ... 4.25 < X <= 4.50  INTERVAL NO.18, ABS.ERROR = 1.0521805648978D-
      IFRST(18)=125
      ILAST(18)=130
      C(125)= 0.9600857053756D+00
      C(126)=-0.6404875010594D+00
      C(127)= 0.2141383549717D+00
      C(128)=-0.3908625281056D-01
      C(129)= 0.3740753346938D-02
      C(130)=-0.1475725788623D-03
! ... 4.50 < X <= 4.75  INTERVAL NO.19, ABS.ERROR = 6.2718719107124D-
      IFRST(19)=131
      ILAST(19)=136
      C(131)= 0.8652746664820D+00
      C(132)=-0.5349723088368D+00
      C(133)= 0.1671594028443D+00
      C(134)=-0.2862620440719D-01
      C(135)= 0.2576075398247D-02
      C(136)=-0.9569143876433D-04
! ... 4.75 < X <= 5.00  INTERVAL NO.20, ABS.ERROR = 3.9639402871217D-
      IFRST(20)=137
      ILAST(20)=142
      C(137)= 0.7900679556534D+00
      C(138)=-0.4556957919175D+00
      C(139)= 0.1337277737706D+00
      C(140)=-0.2157594052042D-01
      C(141)= 0.1832563601783D-02
      C(142)=-0.6432286463678D-04
! ... 5.00 < X <= 5.25  INTERVAL NO.21, ABS.ERROR = 2.4784618801732D-
      IFRST(21)=143
      ILAST(21)=148
      C(143)= 0.7290302365904D+00
      C(144)=-0.3945841937680D+00
      C(145)= 0.1092502418252D+00
      C(146)=-0.1667318620030D-01
      C(147)= 0.1341496314853D-02
      C(148)=-0.4464581143111D-04
! ... 5.25 < X <= 5.50  INTERVAL NO.22, ABS.ERROR = 1.6431300764452D-
      IFRST(22)=149
      ILAST(22)=154
      C(149)= 0.6781821897825D+00
      C(150)=-0.3461064436915D+00
      C(151)= 0.9076079662805D-01
      C(152)=-0.1314681150288D-01
      C(153)= 0.1005173704471D-02
      C(154)=-0.3181374631822D-04
! ... 5.50 < X <= 5.75  INTERVAL NO.23, ABS.ERROR = 1.1222134332911D-
      IFRST(23)=155
      ILAST(23)=160
      C(155)= 0.6349563489690D+00
      C(156)=-0.3067739392218D+00
      C(157)= 0.7644326048783D-01
      C(158)=-0.1054063730153D-01
      C(159)= 0.7679506117711D-03
      C(160)=-0.2317563630640D-04
! ... 5.75 < X <= 6.00  INTERVAL NO.24, ABS.ERROR = 7.8559381222476D-
      IFRST(24)=161
      ILAST(24)=166
      C(161)= 0.5976075476333D+00
      C(162)=-0.2742701592908D+00
      C(163)= 0.6512719379650D-01
      C(164)=-0.8570613370193D-02
      C(165)= 0.5964515294181D-03
      C(166)=-0.1720313448459D-04
! ... 6.00 < X <= 6.25  INTERVAL NO.25, ABS.ERROR = 4.6252335295094D-
      IFRST(25)=167
      ILAST(25)=171
      C(167)= 0.4530821605957D+00
      C(168)=-0.1556937202255D+00
      C(169)= 0.2621052097467D-01
      C(170)=-0.2184050212463D-02
      C(171)= 0.7237572572194D-04
! ... 6.25 < X <= 6.50  INTERVAL NO.26, ABS.ERROR = 3.5389913222161D-
      IFRST(26)=172
      ILAST(26)=176
      C(172)= 0.4314398767018D+00
      C(173)=-0.1418342842259D+00
      C(174)= 0.2288200151943D-01
      C(175)=-0.1828741476402D-02
      C(176)= 0.5815166332468D-04
! ... 6.50 < X <= 6.75  INTERVAL NO.27, ABS.ERROR = 2.7426949600340D-
      IFRST(27)=177
      ILAST(27)=181
      C(177)= 0.4119346702408D+00
      C(178)=-0.1298244601295D+00
      C(179)= 0.2010878728234D-01
      C(180)=-0.1544113849832D-02
      C(181)= 0.4719618664240D-04
! ... 6.75 < X <= 7.00  INTERVAL NO.28, ABS.ERROR = 2.1502799540940D-
      IFRST(28)=182
      ILAST(28)=186
      C(182)= 0.3942461802274D+00
      C(183)=-0.1193370928285D+00
      C(184)= 0.1777693657917D-01
      C(185)=-0.1313662248549D-02
      C(186)= 0.3865502003464D-04
! ... 7.00 < X <= 7.25  INTERVAL NO.29, ABS.ERROR = 1.7034818000639D-
      IFRST(29)=187
      ILAST(29)=191
      C(187)= 0.3781177456714D+00
      C(188)=-0.1101165554215D+00
      C(189)= 0.1580007215659D-01
      C(190)=-0.1125279834923D-02
      C(191)= 0.3192276744812D-04
! ... 7.25 < X <= 7.50  INTERVAL NO.30, ABS.ERROR = 1.3624212868990D-
      IFRST(30)=192
      ILAST(30)=196
      C(192)= 0.3633408065001D+00
      C(193)=-0.1019602554247D+00
      C(194)= 0.1411174419289D-01
      C(195)=-0.9699476170226D-03
      C(196)= 0.2656330616446D-04
! ... 7.50 < X <= 7.75  INTERVAL NO.31, ABS.ERROR = 1.0990319765369D-
      IFRST(31)=197
      ILAST(31)=201
      C(197)= 0.3497439218126D+00
      C(198)=-0.9470569276499D-01
      C(199)= 0.1266017939918D-01
      C(200)=-0.8408550675085D-03
      C(201)= 0.2225784919574D-04
! ... 7.75 < X <= 8.00  INTERVAL NO.32, ABS.ERROR = 8.9381835266522D-
      IFRST(32)=202
      ILAST(32)=206
      C(202)= 0.3371845853069D+00
      C(203)=-0.8822105128463D-01
      C(204)= 0.1140456233287D-01
      C(205)=-0.7327946570967D-03
      C(206)= 0.1877023896668D-04
! ... 8.00 < X <= 8.25  INTERVAL NO.33, ABS.ERROR = 7.3210326689832D-
      IFRST(33)=207
      ILAST(33)=211
      C(207)= 0.3255431584494D+00
      C(208)=-0.8239832407718D-01
      C(209)= 0.1031237441518D-01
      C(210)=-0.6417393667562D-03
      C(211)= 0.1592339503986D-04
! ... 8.25 < X <= 8.50  INTERVAL NO.34, ABS.ERROR = 6.0371707633067D-
      IFRST(34)=212
      ILAST(34)=216
      C(212)= 0.3147180811939D+00
      C(213)=-0.7714810368023D-01
      C(214)= 0.9357439877093D-02
      C(215)=-0.5645414814808D-03
      C(216)= 0.1358301324217D-04
! ... 8.50 < X <= 8.75  INTERVAL NO.35, ABS.ERROR = 5.0113246885530D-
      IFRST(35)=217
      ILAST(35)=221
      C(217)= 0.3046231027165D+00
      C(218)=-0.7239608540250D-01
      C(219)= 0.8518560948886D-02
      C(220)=-0.4987218951555D-03
      C(221)= 0.1164632612927D-04
! ... 8.75 < X <= 9.00  INTERVAL NO.36, ABS.ERROR = 4.1842085352073D-
      IFRST(36)=222
      ILAST(36)=226
      C(222)= 0.2951839772317D+00
      C(223)=-0.6807982796391D-01
      C(224)= 0.7778392737741D-02
      C(225)=-0.4423078514719D-03
      C(226)= 0.1003385659715D-04
! ... 9.00 < X <= 9.25  INTERVAL NO.37, ABS.ERROR = 3.5125236053091D-
      IFRST(37)=227
      ILAST(37)=231
      C(227)= 0.2863364933588D+00
      C(228)=-0.6414655846973D-01
      C(229)= 0.7122648855400D-02
      C(230)=-0.3937177713169D-03
      C(231)= 0.8683627129358D-05
! ... 9.25 < X <= 9.50  INTERVAL NO.38, ABS.ERROR = 2.9645175203541D-
      IFRST(38)=232
      ILAST(38)=236
      C(232)= 0.2780246155388D+00
      C(233)=-0.6055132372497D-01
      C(234)= 0.6539470823348D-02
      C(235)=-0.3516734769846D-03
      C(236)= 0.7546893357357D-05
! ... 9.50 < X <= 9.75  INTERVAL NO.39, ABS.ERROR = 2.5142110615661D-
      IFRST(39)=237
      ILAST(39)=241
      C(237)= 0.2701996594546D+00
      C(238)=-0.5725581832360D-01
      C(239)= 0.6018987049956D-02
      C(240)=-0.3151372568482D-03
      C(241)= 0.6585092705791D-05
! ... 9.75 < X <= 10.0  INTERVAL NO.40, ABS.ERROR = 2.1422863483167D-
      IFRST(40)=242
      ILAST(40)=246
      C(242)= 0.2628187673463D+00
      C(243)=-0.5422707501601D-01
      C(244)= 0.5552907092188D-02
      C(245)=-0.2832594125266D-03
      C(246)= 0.5767453330918D-05
      RETURN
      END

! DAWT
      SUBROUTINE DAWT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
!        -----  ROUTINE ALLOCATES Parameters SPECIFYING         -----
!        -----  THE PIECEWISE CHEBYSHEV POLONOMIAL FIT TO       -----
!        -----  THE DAWSON FUNCTION.                            -----
!
      COMMON /DAWFCM/ C(249),IFRST(40),ILAST(40),H
!
      H = 0.25D+00
! ... 0.00 < X <= 0.25  INTERVAL NO. 1, ABS.ERROR = 1.6571632954765D-
      IFRST( 1)= 1
      ILAST( 1)= 8
      C( 1)=-0.1587492209085D-15
      C( 2)= 0.1000000001679D+01
      C( 3)=-0.2200140634227D-06
      C( 4)=-0.6666582802511D+00
      C( 5)=-0.1406923341036D-03
      C( 6)= 0.2678610335986D+00
      C( 7)=-0.5192471402032D-02
      C( 8)=-0.6640836596489D-01
! ... 0.25 < X <= 0.50  INTERVAL NO. 2, ABS.ERROR = 3.1585400961376D-
      IFRST( 2)= 9
      ILAST( 2)=16
      C( 9)=-0.1012320887742D-04
      C(10)= 0.1000229551438D+01
      C(11)=-0.2249318275452D-02
      C(12)=-0.6542497725108D+00
      C(13)=-0.4207802992979D-01
      C(14)= 0.3555122257011D+00
      C(15)=-0.1112488455006D+00
      C(16)=-0.8490860462189D-02
! ... 0.50 < X <= 0.75  INTERVAL NO. 3, ABS.ERROR = 1.5242918038894D-
      IFRST( 3)=17
      ILAST( 3)=24
      C(17)=-0.4921356497286D-03
      C(18)= 0.1006613917835D+01
      C(19)=-0.3889997394948D-01
      C(20)=-0.5358795704274D+00
      C(21)=-0.2746372044452D+00
      C(22)= 0.6337005279825D+00
      C(23)=-0.2989429214171D+00
      C(24)= 0.4661336966923D-01
! ... 0.75 < X <= 1.00  INTERVAL NO. 4, ABS.ERROR = 9.9014130228170D-
      IFRST( 4)=25
      ILAST( 4)=32
      C(25)= 0.2895369459824D-03
      C(26)= 0.1001188430399D+01
      C(27)=-0.2450339520101D-01
      C(28)=-0.5518735978257D+00
      C(29)=-0.2745338921003D+00
      C(30)= 0.6506738753191D+00
      C(31)=-0.3141764870712D+00
      C(32)= 0.5101503644671D-01
! ... 1.00 < X <= 1.25  INTERVAL NO. 5, ABS.ERROR = 1.8118839761883D-
      IFRST( 5)=33
      ILAST( 5)=40
      C(33)= 0.4002056337725D-01
      C(34)= 0.7312836053563D+00
      C(35)= 0.7635870948288D+00
      C(36)=-0.1834201228325D+01
      C(37)= 0.9813999234300D+00
      C(38)=-0.8984573983721D-01
      C(39)=-0.7076886296272D-01
      C(40)= 0.1660415104457D-01
! ... 1.25 < X <= 1.50  INTERVAL NO. 6, ABS.ERROR = 8.9031004790741D-
      IFRST( 6)=41
      ILAST( 6)=48
      C(41)= 0.1852097215132D+00
      C(42)=-0.7878409599634D-01
      C(43)= 0.2705240106371D+01
      C(44)=-0.4425988758096D+01
      C(45)= 0.3062214704197D+01
      C(46)=-0.1094631867084D+01
      C(47)= 0.1994346954993D+00
      C(48)=-0.1461141450065D-01
! ... 1.50 < X <= 1.75  INTERVAL NO. 7, ABS.ERROR = 2.2932766796657D-
      IFRST( 7)=49
      ILAST( 7)=56
      C(49)= 0.2566795947043D+00
      C(50)=-0.4340789653964D+00
      C(51)= 0.3460647185102D+01
      C(52)=-0.5316677310217D+01
      C(53)= 0.3691359889577D+01
      C(54)=-0.1360915547303D+01
      C(55)= 0.2619748477425D+00
      C(56)=-0.2090002809252D-01
! ... 1.75 < X <= 2.00  INTERVAL NO. 8, ABS.ERROR = 5.7358562344234D-
      IFRST( 8)=57
      ILAST( 8)=64
      C(57)=-0.2953293234440D+00
      C(58)= 0.1741536362797D+01
      C(59)=-0.2179107446162D+00
      C(60)=-0.1857700863729D+01
      C(61)= 0.1737803495672D+01
      C(62)=-0.6982079451638D+00
      C(63)= 0.1369430933680D+00
      C(64)=-0.1077900614057D-01
! ... 2.00 < X <= 2.25  INTERVAL NO. 9, ABS.ERROR = 7.9634077110313D-
      IFRST( 9)=65
      ILAST( 9)=71
      C(65)=-0.1683235354314D+01
      C(66)= 0.6579307910802D+01
      C(67)=-0.7452680221211D+01
      C(68)= 0.4159630869064D+01
      C(69)=-0.1268324481886D+01
      C(70)= 0.2038507675752D+00
      C(71)=-0.1359998434782D-01
! ... 2.25 < X <= 2.50  INTERVAL NO.10, ABS.ERROR = 4.9522164147220D-
      IFRST(10)=72
      ILAST(10)=78
      C(72)=-0.1172884307439D+01
      C(73)= 0.5243170888632D+01
      C(74)=-0.5994671204809D+01
      C(75)= 0.3310821796507D+01
      C(76)=-0.9902715162510D+00
      C(77)= 0.1552556976676D+00
      C(78)=-0.1006003345052D-01
! ... 2.50 < X <= 2.75  INTERVAL NO.11, ABS.ERROR = 4.0683012514364D-
      IFRST(11)=79
      ILAST(11)=85
      C(79)= 0.2453071419396D+00
      C(80)= 0.1843675794804D+01
      C(81)=-0.2597381166786D+01
      C(82)= 0.1499064046402D+01
      C(83)=-0.4464691670097D+00
      C(84)= 0.6815297792976D-01
      C(85)=-0.4243532816569D-02
! ... 2.75 < X <= 3.00  INTERVAL NO.12, ABS.ERROR = 1.7797319173951D-
      IFRST(12)=86
      ILAST(12)=92
      C(86)= 0.1711553394682D+01
      C(87)=-0.1366851519128D+01
      C(88)= 0.3331226440003D+00
      C(89)= 0.7176989090082D-01
      C(90)=-0.5525697253082D-01
      C(91)= 0.1093749119900D-01
      C(92)=-0.7553007453680D-03
! ... 3.00 < X <= 3.25  INTERVAL NO.13, ABS.ERROR = 3.6681768733615D-
      IFRST(13)=93
      ILAST(13)=99
      C(93)= 0.2517095374277D+01
      C(94)=-0.2990903746754D+01
      C(95)= 0.1697891140418D+01
      C(96)=-0.5401196813139D+00
      C(97)= 0.9911334144514D-01
      C(98)=-0.9840574037905D-02
      C(99)= 0.4103935013215D-03
! ... 3.25 < X <= 3.50  INTERVAL NO.14, ABS.ERROR = 1.1128875598843D-
      IFRST(14)=100
      ILAST(14)=106
      C(100)= 0.2590851813134D+01
      C(101)=-0.3134054423500D+01
      C(102)= 0.1813437074513D+01
      C(103)=-0.5897752524597D+00
      C(104)= 0.1110979078173D+00
      C(105)=-0.1138103745567D-01
      C(106)= 0.4927876094977D-03
! ... 3.50 < X <= 3.75  INTERVAL NO.15, ABS.ERROR = 1.4752643551219D-
      IFRST(15)=107
      ILAST(15)=113
      C(107)= 0.2263419843285D+01
      C(108)=-0.2574296380066D+01
      C(109)= 0.1414605080120D+01
      C(110)=-0.4381747671623D+00
      C(111)= 0.7867466333846D-01
      C(112)=-0.7681612002974D-02
      C(113)= 0.3168638795614D-03
! ... 3.75 < X <= 4.00  INTERVAL NO.16, ABS.ERROR = 9.2281737806843D-
      IFRST(16)=114
      ILAST(16)=120
      C(114)= 0.1858711024930D+01
      C(115)=-0.1925962656395D+01
      C(116)= 0.9817358192129D+00
      C(117)=-0.2839951967696D+00
      C(118)= 0.4777651946157D-01
      C(119)=-0.4378302333256D-02
      C(120)= 0.1696776598692D-03
! ... 4.00 < X <= 4.25  INTERVAL NO.17, ABS.ERROR = 2.0758506025231D-
      IFRST(17)=121
      ILAST(17)=126
      C(121)= 0.1097210930469D+01
      C(122)=-0.8018697789038D+00
      C(123)= 0.2901340972873D+00
      C(124)=-0.5698500686831D-01
      C(125)= 0.5849148664856D-02
      C(126)=-0.2469443250448D-03
! ... 4.25 < X <= 4.50  INTERVAL NO.18, ABS.ERROR = 1.1124878795954D-
      IFRST(18)=127
      ILAST(18)=132
      C(127)= 0.9640388573940D+00
      C(128)=-0.6448585002328D+00
      C(129)= 0.2160731515099D+00
      C(130)=-0.3951479965599D-01
      C(131)= 0.3788248790079D-02
      C(132)=-0.1496796030551D-03
! ... 4.50 < X <= 4.75  INTERVAL NO.19, ABS.ERROR = 6.3691274476696D-
      IFRST(19)=133
      ILAST(19)=138
      C(133)= 0.8660393462895D+00
      C(134)=-0.5357754986697D+00
      C(135)= 0.1674970705868D+00
      C(136)=-0.2869722599326D-01
      C(137)= 0.2583548621624D-02
      C(138)=-0.9600615594536D-04
! ... 4.75 < X <= 5.00  INTERVAL NO.20, ABS.ERROR = 3.8777869804107D-
      IFRST(20)=139
      ILAST(20)=144
      C(139)= 0.7902176622367D+00
      C(140)=-0.4558460385033D+00
      C(141)= 0.1337881166153D+00
      C(142)=-0.2158806335901D-01
      C(143)= 0.1833781835739D-02
      C(144)=-0.6437185220420D-04
! ... 5.00 < X <= 5.25  INTERVAL NO.21, ABS.ERROR = 2.4793500585929D-
      IFRST(21)=145
      ILAST(21)=150
      C(145)= 0.7290485015677D+00
      C(146)=-0.3946016171968D+00
      C(147)= 0.1092568925649D+00
      C(148)=-0.1667445598850D-01
      C(149)= 0.1341617573053D-02
      C(150)=-0.4465044476092D-04
! ... 5.25 < X <= 5.50  INTERVAL NO.22, ABS.ERROR = 1.6431300764452D-
      IFRST(22)=151
      ILAST(22)=156
      C(151)= 0.6781842728186D+00
      C(152)=-0.3461083410440D+00
      C(153)= 0.9076148811696D-01
      C(154)=-0.1314693754430D-01
      C(155)= 0.1005185194663D-02
      C(156)=-0.3181416541338D-04
! ... 5.50 < X <= 5.75  INTERVAL NO.23, ABS.ERROR = 1.1226575225010D-
      IFRST(23)=157
      ILAST(23)=162
      C(157)= 0.6349565075405D+00
      C(158)=-0.3067740750644D+00
      C(159)= 0.7644330701296D-01
      C(160)=-0.1054064526443D-01
      C(161)= 0.7679512928007D-03
      C(162)=-0.2317565958947D-04
! ... 5.75 < X <= 6.00  INTERVAL NO.24, ABS.ERROR = 7.8470563380506D-
      IFRST(24)=163
      ILAST(24)=168
      C(163)= 0.5976070486768D+00
      C(164)=-0.2742697363056D+00
      C(165)= 0.6512705037617D-01
      C(166)=-0.8570589057672D-02
      C(167)= 0.5964494688669D-03
      C(168)=-0.1720306463540D-04
! ... 6.00 < X <= 6.25  INTERVAL NO.25, ABS.ERROR = 5.6132876125048D-
      IFRST(25)=169
      ILAST(25)=174
      C(169)= 0.5649180454987D+00
      C(170)=-0.2470090261752D+00
      C(171)= 0.5603266263223D-01
      C(172)=-0.7053466938578D-02
      C(173)= 0.4698947566794D-03
      C(174)=-0.1297991257161D-04
! ... 6.25 < X <= 6.50  INTERVAL NO.26, ABS.ERROR = 3.5389913222161D-
      IFRST(26)=175
      ILAST(26)=179
      C(175)= 0.4314398767018D+00
      C(176)=-0.1418342842259D+00
      C(177)= 0.2288200151943D-01
      C(178)=-0.1828741476402D-02
      C(179)= 0.5815166332468D-04
! ... 6.50 < X <= 6.75  INTERVAL NO.27, ABS.ERROR = 2.7426949600340D-
      IFRST(27)=180
      ILAST(27)=184
      C(180)= 0.4119346702408D+00
      C(181)=-0.1298244601295D+00
      C(182)= 0.2010878728234D-01
      C(183)=-0.1544113849832D-02
      C(184)= 0.4719618664240D-04
! ... 6.75 < X <= 7.00  INTERVAL NO.28, ABS.ERROR = 2.1502799540940D-
      IFRST(28)=185
      ILAST(28)=189
      C(185)= 0.3942461802274D+00
      C(186)=-0.1193370928285D+00
      C(187)= 0.1777693657917D-01
      C(188)=-0.1313662248549D-02
      C(189)= 0.3865502003464D-04
! ... 7.00 < X <= 7.25  INTERVAL NO.29, ABS.ERROR = 1.7034818000639D-
      IFRST(29)=190
      ILAST(29)=194
      C(190)= 0.3781177456714D+00
      C(191)=-0.1101165554215D+00
      C(192)= 0.1580007215659D-01
      C(193)=-0.1125279834923D-02
      C(194)= 0.3192276744812D-04
! ... 7.25 < X <= 7.50  INTERVAL NO.30, ABS.ERROR = 1.3624212868990D-
      IFRST(30)=195
      ILAST(30)=199
      C(195)= 0.3633408065001D+00
      C(196)=-0.1019602554247D+00
      C(197)= 0.1411174419289D-01
      C(198)=-0.9699476170226D-03
      C(199)= 0.2656330616446D-04
! ... 7.50 < X <= 7.75  INTERVAL NO.31, ABS.ERROR = 1.0990319765369D-
      IFRST(31)=200
      ILAST(31)=204
      C(200)= 0.3497439218126D+00
      C(201)=-0.9470569276499D-01
      C(202)= 0.1266017939918D-01
      C(203)=-0.8408550675085D-03
      C(204)= 0.2225784919574D-04
! ... 7.75 < X <= 8.00  INTERVAL NO.32, ABS.ERROR = 8.9381835266522D-
      IFRST(32)=205
      ILAST(32)=209
      C(205)= 0.3371845853069D+00
      C(206)=-0.8822105128463D-01
      C(207)= 0.1140456233287D-01
      C(208)=-0.7327946570967D-03
      C(209)= 0.1877023896668D-04
! ... 8.00 < X <= 8.25  INTERVAL NO.33, ABS.ERROR = 7.3210326689832D-
      IFRST(33)=210
      ILAST(33)=214
      C(210)= 0.3255431584494D+00
      C(211)=-0.8239832407718D-01
      C(212)= 0.1031237441518D-01
      C(213)=-0.6417393667562D-03
      C(214)= 0.1592339503986D-04
! ... 8.25 < X <= 8.50  INTERVAL NO.34, ABS.ERROR = 6.0371707633067D-
      IFRST(34)=215
      ILAST(34)=219
      C(215)= 0.3147180811939D+00
      C(216)=-0.7714810368023D-01
      C(217)= 0.9357439877093D-02
      C(218)=-0.5645414814808D-03
      C(219)= 0.1358301324217D-04
! ... 8.50 < X <= 8.75  INTERVAL NO.35, ABS.ERROR = 5.0113246885530D-
      IFRST(35)=220
      ILAST(35)=224
      C(220)= 0.3046231027165D+00
      C(221)=-0.7239608540250D-01
      C(222)= 0.8518560948886D-02
      C(223)=-0.4987218951555D-03
      C(224)= 0.1164632612927D-04
! ... 8.75 < X <= 9.00  INTERVAL NO.36, ABS.ERROR = 4.1842085352073D-
      IFRST(36)=225
      ILAST(36)=229
      C(225)= 0.2951839772317D+00
      C(226)=-0.6807982796391D-01
      C(227)= 0.7778392737741D-02
      C(228)=-0.4423078514719D-03
      C(229)= 0.1003385659715D-04
! ... 9.00 < X <= 9.25  INTERVAL NO.37, ABS.ERROR = 3.5125236053091D-
      IFRST(37)=230
      ILAST(37)=234
      C(230)= 0.2863364933588D+00
      C(231)=-0.6414655846973D-01
      C(232)= 0.7122648855400D-02
      C(233)=-0.3937177713169D-03
      C(234)= 0.8683627129358D-05
! ... 9.25 < X <= 9.50  INTERVAL NO.38, ABS.ERROR = 2.9645175203541D-
      IFRST(38)=235
      ILAST(38)=239
      C(235)= 0.2780246155388D+00
      C(236)=-0.6055132372497D-01
      C(237)= 0.6539470823348D-02
      C(238)=-0.3516734769846D-03
      C(239)= 0.7546893357357D-05
! ... 9.50 < X <= 9.75  INTERVAL NO.39, ABS.ERROR = 2.5142110615661D-
      IFRST(39)=240
      ILAST(39)=244
      C(240)= 0.2701996594546D+00
      C(241)=-0.5725581832360D-01
      C(242)= 0.6018987049956D-02
      C(243)=-0.3151372568482D-03
      C(244)= 0.6585092705791D-05
! ... 9.75 < X <= 10.0  INTERVAL NO.40, ABS.ERROR = 2.1422863483167D-
      IFRST(40)=245
      ILAST(40)=249
      C(245)= 0.2628187673463D+00
      C(246)=-0.5422707501601D-01
      C(247)= 0.5552907092188D-02
      C(248)=-0.2832594125266D-03
      C(249)= 0.5767453330918D-05
      RETURN
      END

! DCO
      DOUBLE PRECISION FUNCTION DCO(L,M,KX,KY,KZ,LP,MP,                 &
                                    FPQR,ZLM,LMF,LMX,LMY,LMZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION FPQR(25,25,25),ZLM(*)
      DIMENSION LMF(*),LMX(*),LMY(*),LMZ(*)
!
!        -----  ROUTINE EVALUATES ANGULAR MOMENTUM COUPLING     -----
!        -----  COEFFICIENTS.                                   -----
!
! FOR A GIVEN SET OF L AND M, THIS ROUTINE CALCULATES THE TYPE 1
! (L,M=0) OR THE TYPE 2 ANGULAR INTEGRALS. (IE THE SECOND LINE OF
! EQ 28 OR 29 IN MD'S PAPER) YOU STILL MUST DO THE SUMS.
!
      ID = L*(L+1)-M+1
      IMN= LMF(ID)
      IMX= LMF(ID+1)-1
      JD = LP*(LP+1)-MP+1
      JMN= LMF(JD)
      JMX= LMF(JD+1)-1
      SUMI= 0.0D+00
      DO 120 I=IMN,IMX
         IX = LMX(I)+KX+1
         IY = LMY(I)+KY+1
         IZ = LMZ(I)+KZ+1
         SUMJ= 0.0D+00
         DO 110 J=JMN,JMX
            JX = IX+LMX(J)
            JY = IY+LMY(J)
            JZ = IZ+LMZ(J)
  110    SUMJ= SUMJ+ZLM(J)*FPQR(JX,JY,JZ)
  120 SUMI= SUMI+ZLM(I)*SUMJ
      DCO = SUMI
      RETURN
      END

! ERRT
      SUBROUTINE ERRT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ERRFCM/ C(142),IFRST(20),ILAST(20),H
!
!        -----  ROUTINE ALLOCATES Parameters FOR THE POLYNOMIAL -----
!        -----  FIT TO THE ERROR FUNCTION.                      -----
!
      H = 0.25D+00
! ... 0.00 < X <= 0.25  INTERVAL NO. 1, ABS.ERROR = 5.1496584774213D-
      IFRST( 1)= 1
      ILAST( 1)= 8
      C( 1)= 0.9976905682968D-15
      C( 2)= 0.1128379167616D+01
      C( 3)=-0.6825080083050D-07
      C( 4)=-0.3761237879247D+00
      C( 5)=-0.4362679036164D-04
      C( 6)= 0.1132081528735D+00
      C( 7)=-0.1608829014003D-02
      C( 8)=-0.2383745887450D-01
! ... 0.25 < X <= 0.50  INTERVAL NO. 2, ABS.ERROR = 1.0329515021112D-
      IFRST( 2)= 9
      ILAST( 2)=16
      C( 9)=-0.3265133599788D-05
      C(10)= 0.1128453123654D+01
      C(11)=-0.7236769295451D-03
      C(12)=-0.3721384745633D+00
      C(13)=-0.1348362056472D-01
      C(14)= 0.1412226404729D+00
      C(15)=-0.3539596498013D-01
      C(16)=-0.5454029355730D-02
! ... 0.50 < X <= 0.75  INTERVAL NO. 3, ABS.ERROR = 6.1888272284705D-
      IFRST( 3)=17
      ILAST( 3)=24
      C(17)=-0.1801988094647D-03
      C(18)= 0.1130782166249D+01
      C(19)=-0.1400474656066D-01
      C(20)=-0.3295493300819D+00
      C(21)=-0.9653664285517D-01
      C(22)= 0.2398163462058D+00
      C(23)=-0.1014115256923D+00
      C(24)= 0.1378314835685D-01
! ... 0.75 < X <= 1.00  INTERVAL NO. 4, ABS.ERROR = 1.6626700016786D-
      IFRST( 4)=25
      ILAST( 4)=32
      C(25)=-0.4457991000617D-03
      C(26)= 0.1133670008174D+01
      C(27)=-0.2725712863074D-01
      C(28)=-0.2961333291272D+00
      C(29)=-0.1466850258377D+00
      C(30)= 0.2847021965842D+00
      C(31)=-0.1236317583493D+00
      C(32)= 0.1848162923540D-01
! ... 1.00 < X <= 1.25  INTERVAL NO. 5, ABS.ERROR = 5.4747317790316D-
      IFRST( 5)=33
      ILAST( 5)=40
      C(33)= 0.1036667435991D-01
      C(34)= 0.1060681450430D+01
      C(35)= 0.1844323965440D+00
      C(36)=-0.6381386282176D+00
      C(37)= 0.1857801550899D+00
      C(38)= 0.9020967608584D-01
      C(39)=-0.6022465654782D-01
      C(40)= 0.9593725204468D-02
! ... 1.25 < X <= 1.50  INTERVAL NO. 6, ABS.ERROR = 2.1689317009077D-
      IFRST( 6)=41
      ILAST( 6)=47
      C(41)= 0.5096577645657D-01
      C(42)= 0.8301050352144D+00
      C(43)= 0.7461454169558D+00
      C(44)=-0.1399088183681D+01
      C(45)= 0.8049290742492D+00
      C(46)=-0.2123844940215D+00
      C(47)= 0.2202851573626D-01
! ... 1.50 < X <= 1.75  INTERVAL NO. 7, ABS.ERROR = 5.4356519285648D-
      IFRST( 7)=48
      ILAST( 7)=55
      C(48)= 0.1356983343156D+00
      C(49)= 0.4248183601853D+00
      C(50)= 0.1578617255285D+01
      C(51)=-0.2350907279473D+01
      C(52)= 0.1459137006763D+01
      C(53)=-0.4826721286933D+00
      C(54)= 0.8417719176837D-01
      C(55)=-0.6134748458862D-02
! ... 1.75 < X <= 2.00  INTERVAL NO. 8, ABS.ERROR = 1.3677947663382D-
      IFRST( 8)=56
      ILAST( 8)=63
      C(56)= 0.5650617287234D-01
      C(57)= 0.7303727164846D+00
      C(58)= 0.1073427393133D+01
      C(59)=-0.1886956498357D+01
      C(60)= 0.1203543744299D+01
      C(61)=-0.3982083398317D+00
      C(62)= 0.6867500288146D-01
      C(63)=-0.4915782383510D-02
! ... 2.00 < X <= 2.25  INTERVAL NO. 9, ABS.ERROR = 2.7604585284280D-
      IFRST( 9)=64
      ILAST( 9)=70
      C(64)=-0.7044612080369D+00
      C(65)= 0.3313423632378D+01
      C(66)=-0.2688303271381D+01
      C(67)= 0.1159938873721D+01
      C(68)=-0.2789363703341D+00
      C(69)= 0.3510668004553D-01
      C(70)=-0.1778023938338D-02
! ... 2.25 < X <= 2.50  INTERVAL NO.10, ABS.ERROR = 1.8687273950491D-
      IFRST(10)=71
      ILAST(10)=77
      C(71)=-0.8530571392369D+00
      C(72)= 0.3718753089373D+01
      C(73)=-0.3149110592528D+01
      C(74)= 0.1439416506820D+01
      C(75)=-0.3743063133443D+00
      C(76)= 0.5246810708195D-01
      C(77)=-0.3095234433810D-02
! ... 2.50 < X <= 2.75  INTERVAL NO.11, ABS.ERROR = 9.7095664841618D-
      IFRST(11)=78
      ILAST(11)=84
      C(78)=-0.6325006110506D+00
      C(79)= 0.3195352274705D+01
      C(80)=-0.2631359977752D+01
      C(81)= 0.1166146516443D+01
      C(82)=-0.2931400812425D+00
      C(83)= 0.3960487060249D-01
      C(84)=-0.2245448529720D-02
! ... 2.75 < X <= 3.00  INTERVAL NO.12, ABS.ERROR = 7.6525452641363D-
      IFRST(12)=85
      ILAST(12)=91
      C(85)=-0.1578663656307D+00
      C(86)= 0.2160403160352D+01
      C(87)=-0.1690605397678D+01
      C(88)= 0.7098560625163D+00
      C(89)=-0.1685917225356D+00
      C(90)= 0.2146466169506D-01
      C(91)=-0.1144051551819D-02
! ... 3.00 < X <= 3.25  INTERVAL NO.13, ABS.ERROR = 3.9079850466806D-
      IFRST(13)=92
      ILAST(13)=98
      C(92)= 0.3337223693570D+00
      C(93)= 0.1174814163831D+01
      C(94)=-0.8669311383990D+00
      C(95)= 0.3425820853154D+00
      C(96)=-0.7643589524863D-01
      C(97)= 0.9127119866510D-02
      C(98)=-0.4555632670720D-03
! ... 3.25 < X <= 3.50  INTERVAL NO.14, ABS.ERROR = 1.5241141682054D-
      IFRST(14)= 99
      ILAST(14)=105
      C( 99)= 0.6858505344288D+00
      C(100)= 0.5221032227938D+00
      C(101)=-0.3626430750192D+00
      C(102)= 0.1347162453894D+00
      C(103)=-0.2822370117065D-01
      C(104)= 0.3161233228942D-02
      C(105)=-0.1478642225266D-03
! ... 3.50 < X <= 3.75  INTERVAL NO.15, ABS.ERROR = 9.5496943686157D-
      IFRST(15)=106
      ILAST(15)=111
      C(106)= 0.9680982760858D+00
      C(107)= 0.4187846825891D-01
      C(108)=-0.2202918541743D-01
      C(109)= 0.5803572496370D-02
      C(110)=-0.7656564703211D-03
      C(111)= 0.4046317189932D-04
! ... 3.75 < X <= 4.00  INTERVAL NO.16, ABS.ERROR = 2.2239987629291D-
      IFRST(16)=112
      ILAST(16)=117
      C(112)= 0.9910262142894D+00
      C(113)= 0.1110389476297D-01
      C(114)=-0.5503022341054D-02
      C(115)= 0.1365301693295D-02
      C(116)=-0.1695606159046D-03
      C(117)= 0.8432380855083D-05
! ... 4.00 < X <= 4.25  INTERVAL NO.17, ABS.ERROR = 4.4764192352886D-
      IFRST(17)=118
      ILAST(17)=123
      C(118)= 0.9978511542662D+00
      C(119)= 0.2512562013763D-02
      C(120)=-0.1176282812867D-02
      C(121)= 0.2755980203801D-03
      C(122)=-0.3231375012547D-04
      C(123)= 0.1516751945019D-05
! ... 4.25 < X <= 4.50  INTERVAL NO.18, ABS.ERROR = 9.9475983006414D-
      IFRST(18)=124
      ILAST(18)=129
      C(124)= 0.9995577955752D+00
      C(125)= 0.4898449770963D-03
      C(126)=-0.2172069044718D-03
      C(127)= 0.4819046007469D-04
      C(128)=-0.5349400453269D-05
      C(129)= 0.2376735210419D-06
! ... 4.50 < X <= 4.75  INTERVAL NO.19, ABS.ERROR = 6.0396132539609D-
      IFRST(19)=130
      ILAST(19)=135
      C(130)= 0.9999195780401D+00
      C(131)= 0.8461205943888D-04
      C(132)=-0.3562696920198D-04
      C(133)= 0.7504334644182D-05
      C(134)=-0.7907161489129D-06
      C(135)= 0.3334134817123D-07
! ... 4.75 < X <= 5.00  INTERVAL NO.20, ABS.ERROR = 7.4429351570870D-
      IFRST(20)=136
      ILAST(20)=142
      C(136)= 0.8965357422439D+00
      C(137)= 0.1272754720567D+00
      C(138)=-0.6523024655166D-01
      C(139)= 0.1782843628219D-01
      C(140)=-0.2740698420287D-02
      C(141)= 0.2246825024486D-03
      C(142)=-0.7674098014832D-05
      RETURN
      END

! DAWERF
      DOUBLE PRECISION FUNCTION DAWERF(Y)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /DERFCM/ C(246),IFRST(40),ILAST(40),H
!     EVALUATES THE HYBRID DAWSON-ERROR FUNCTION
      PARAMETER (ZP5=0.5D0, TEN=10.0D0)
      X= ABS(Y)
      IF(X>=TEN) GO TO 115

      XN = X/H
      NX = INT(XN)+1
      I1 = IFRST(NX)
      IL = ILAST(NX)
      T= C(IL)
      DO 110 K=IL-1,I1,-1
  110 T= C(K)+T*X
      DAWERF= T
      RETURN
  115 CONTINUE
      X2I = 1.0d0/(X*X)
      IL = 8
      TXT=(IL +ZP5)*X2I
      SUM= TXT
      DO 120 K=IL,1,-1
         TXT= TXT-X2I
  120 SUM= TXT*(1.0d0+SUM)
      DAWERF= X*TXT*(1.0d0+SUM)
      RETURN
      END
      
! DAWF
      DOUBLE PRECISION FUNCTION DAWF(Y)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /DAWFCM/ C(249),IFRST(40),ILAST(40),H
!     EVALUATES THE DAWSON FUNCTION -----
      PARAMETER (ZP5=0.5D0, TEN=10.0D0)
!
      X= Y
      S= 1.0d0
      IF(X>=0.0d0) GO TO 105
      X=-Y
      S=-1.0d0
  105 IF(X>=TEN) GO TO 115
      XN = X/H
      NX = INT(XN)+1
      I1 = IFRST(NX)
      IL = ILAST(NX)
      T= C(IL)
      DO 110 K=IL-1,I1,-1
  110 T= C(K)+T*X
      DAWF  = T*S
      RETURN
!
  115 CONTINUE
      X2I = 1.0d0/(X*X)
      IL = 8
      TXT=(IL +ZP5)*X2I
      SUM= TXT
      DO 120 K=IL,1,-1
         TXT= TXT-X2I
  120 SUM= TXT*(1.0d0+SUM)
      DAWF = Y*TXT*(1.0d0+SUM)
      RETURN
      END
      
! ECPAA1
      SUBROUTINE ECPAA1(NPNP,FPQR,COEFI,COEFJ,DCOEF4,G,EX,NPRIMI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION DCOEF4(*),FPQR(25,25,25)
      DIMENSION COEFI(*),COEFJ(*),G(*)
      COMMON /ECP1  / X01,CAX,CAY,CAZ,CA,XCA,YCA,ZCA,                   &
                      X02,BAX,BAY,BAZ,BA,XBA,YBA,ZBA,                   &
                      PHASE,DAX,DAY,DAZ,DA,XDA,YDA,ZDA,XINT,KCNTR        
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(100,6),          &
                      KLAST(100,6),LMAX(100),LPSKIP(100),               &
                      IZCORE(100)
      COMMON /ECPDIM/ NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN
      LOGICAL IANDJ,NORM,NORMI,NORMJ
      COMMON /ECPIDX/ Q2,IAMIN,IAMAX,JAMIN,JAMAX,IPMIN,IPMAX,JPMIN,     &
                      JPMAX,KF1,KL1,LLMX,NPC,NPB,IANDJ,NORM,NORMI,NORMJ                                                                        
      COMMON /GBASE / NFST(8),NX(84),NY(84),NZ(84)                       
      DIMENSION EX(NPRIMI)
      PARAMETER (SR3=1.73205080756888D+00, SR5=2.23606797749979D+00)     
      PARAMETER (SR7=2.64575131106459D+00)                               
      PARAMETER (S35=SR3*SR5, S57=SR5*SR7, S53=S57/SR3)                                                                        
      DIMENSION ECPFAC(35)                                               
      DATA ECPFAC/7*1.0d0,3*SR3,3*1.0d0,6*SR5,S35,3*1.0d0,6*SR7,        &
                  3*S53,3*S57/
!
      NBC = NPNP-1
      IF(MOD(NBC,2)==1) RETURN
      FPSUM = 0.0d0
      DO 120 IG=IPMIN,IPMAX
         X01= EX(IG)
         DO 120 JG=JPMIN,JPMAX
            X02= EX(JG)
            X12= X01+X02
            DUM= COEFI(IG-IPMIN+1)*COEFJ(JG-JPMIN+1)
            FPTEMP= 0.0d0
            DO 110 K=KF1,KL1
  110       FPTEMP= FPTEMP+FA(NBC+NLP(K),X12+ZLP(K))*CLP(K)
  120 FPSUM = FPSUM+FPTEMP*DUM
      FPSQ2 = FPSUM*Q2
      MMAX= JAMAX
      NN= 1
      DO 140 I=IAMIN,IAMAX
         DUMI= FPSQ2
         IF(NORMI) DUMI= DUMI*ECPFAC(I)
         IF(IANDJ) MMAX= I
         DO 140 J=JAMIN,MMAX
            DUMJ= DUMI
            IF(NORMJ) DUMJ= DUMJ*ECPFAC(J)
            MX= NX(I)+NX(J)+1
            MY= NY(I)+NY(J)+1
            MZ= NZ(I)+NZ(J)+1
            G(NN)= G(NN)+DUMJ*FPQR(MX,MY,MZ)
  140 NN= NN+1

      IF(LLMX<2) RETURN
      DO 300 LL=2,LLMX
         L = LL-2
         NLM1=(L*(L+1))
         KF = KFRST(KCNTR,LL)
         KL = KLAST(KCNTR,LL)
         FPSUM = 0.0d0
         DO 220 IG=IPMIN,IPMAX
            X01= EX(IG)
            DO 220 JG=JPMIN,JPMAX
               X02= EX(JG)
               X12= X01+X02
               DUM= COEFI(IG-IPMIN+1)*COEFJ(JG-JPMIN+1)
               FPTEMP= 0.0d0
               DO 210 K=KF,KL
  210          FPTEMP= FPTEMP+FA(NBC+NLP(K),X12+ZLP(K))*CLP(K)
  220    FPSUM = FPSUM+FPTEMP*DUM
         FPSQ2 = FPSUM*Q2
         MMAX= JAMAX
         NN= 1
         DO 240 I=IAMIN,IAMAX
            DUMI= FPSQ2
            IF(NORMI) DUMI= DUMI*ECPFAC(I)
            IF(IANDJ) MMAX= I
            DO 240 J=JAMIN,MMAX
               DUMJ= DUMI
               IF(NORMJ) DUMJ= DUMJ*ECPFAC(J)
               SUM= 0.0d0
               DO 230 M=-L,L
                  NLM=(NLM1-M)*NTLIM
  230          SUM= SUM+DCOEF4(NLM+I)*DCOEF4(NLM+J)
               G(NN)= G(NN)+DUMJ*SUM
  240    NN= NN+1

  300 CONTINUE
      RETURN
      END

! ECPRA2
      SUBROUTINE ECPRA2(ICAB,NPNP,FP,COEFI,COEFJ,DCOEF1,JFST1,LBECP1,   &
          DCOEF4,DCOEF2,JFST2,LBECP2,G,ZLM,LMF,LMX,LMY,LMZ,EX,NPRIMI)                             
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DOUBLE PRECISION DCOEF1(*),DCOEF2(*),DCOEF4(*),ZLM(*)
      DIMENSION FP(*),COEFI(*),COEFJ(*),JFST1(*),LBECP1(9,*),           &
                JFST2(*),LBECP2(6,*),G(*)                      
      DIMENSION LMF(*),LMX(*),LMY(*),LMZ(*)                       
      COMMON /ECP1  / X01,CAX,CAY,CAZ,CA,XCA,YCA,ZCA,                   &
                      X02,BAX,BAY,BAZ,BA,XBA,YBA,ZBA,                   &
                      PHASE,DAX,DAY,DAZ,DA,XDA,YDA,ZDA,XINT,KCNTR        
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(100,6),          &
                      KLAST(100,6),LMAX(100),LPSKIP(100),               &
                      IZCORE(100)                                        
      COMMON /ECP3  / ACX(7),ACY(7),ACZ(7),ABX(7),ABY(7),ABZ(7)          
      COMMON /ECPDIM/ NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN    
      LOGICAL IANDJ,NORM,NORMI,NORMJ                                     
      COMMON /ECPIDX/ Q2,IAMIN,IAMAX,JAMIN,JAMAX,IPMIN,IPMAX,JPMIN,     &
                      JPMAX,KF1,KL1,LLMX,NPC,NPB,IANDJ,NORM,NORMI,NORMJ  
      COMMON /FICMN / ALF,XI,XP0,XP1                                     
      COMMON /GBASE / NFST(8),NX(84),NY(84),NZ(84)
      
      DIMENSION EX(NPRIMI)               
      PARAMETER (SR3=1.73205080756888D+00, SR5=2.23606797749979D+00)     
      PARAMETER (SR7=2.64575131106459D+00)                               
      PARAMETER (S35=SR3*SR5, S57=SR5*SR7, S53=S57/SR3)                  
      PARAMETER (TOL=1.0D-10, FPI=12.566370614359D+00)                   
      DIMENSION ECPFAC(35),FIP(78),ZFNLM(121),CKL(11,11)                 
      DATA ECPFAC/7*1.0d0,3*SR3,3*1.0d0,6*SR5,S35,3*1.0d0,6*SR7,        &
                  3*S53,3*S57/
!     
      NPNPMX=(NPNP*(NPNP+1))/2
      CALL VCLR(FP,1,NPNPMX)

      DO 140 IG=IPMIN,IPMAX
         X01= EX(IG)
         DO 130 JG=JPMIN,JPMAX
            X02= EX(JG)
            X12= X01+X02
            DUM= COEFI(IG-IPMIN+1)*COEFJ(JG-JPMIN+1)
            IF(ICAB==2) THEN
               ALFA= X02*BA
               ALFX= ALFA*BA
            ELSE IF(ICAB==3) THEN
               ALFA= X01*CA
               ALFX= ALFA*CA
            END IF
            ALFI= 1.0d0/(ALFA+ALFA)
            XP0 = EXP(-ALFX)
            DO 120 K=KF1,KL1
               XI = 1.0d0/SQRT(X12+ZLP(K))
               ALF= ALFA*XI
               XP1= EXP(-ALFX+ALF*ALF)
               NLPK= NLP(K)
               CLPK= CLP(K)*DUM
               CALL FIECP(FIP,ALFI,NLPK,NPNP-1)
               DO 110 N=1,NPNPMX
  110          FP(N)= FP(N)+FIP(N)*CLPK
  120       CONTINUE
  130    CONTINUE
  140 CONTINUE
      CALL ZFN(ZFNLM,NPNP-1,ZLM,LMF,LMX,LMY,LMZ)
      FPIQ2 = FPI*Q2
      MMAX= JAMAX
      NN= 1
      DO 240 I=IAMIN,IAMAX
         DUMI= FPIQ2
         IF(NORMI) DUMI= DUMI*ECPFAC(I)
         IF(IANDJ) MMAX= I
         DO 240 J=JAMIN,MMAX
            DUMJ= DUMI
            IF(NORMJ) DUMJ= DUMJ*ECPFAC(J)
            IF(I>=J) THEN
               INDX= J+(I*(I-1))/2
            ELSE
               INDX= I+(J*(J-1))/2
            END IF
            JF = JFST1(INDX)
            JL = JFST1(INDX+1)-1
            DO 210 L=1,NPNP
               DO 210 K=L,NPNP
  210       CKL(K,L)= 0.0d0
            NXYZ = NX(I)+NY(I)+NZ(I)+NX(J)+NY(J)+NZ(J)
            K= I
            M= 3
            IF(ICAB==2) THEN
               K= I+J-K
               M= 3+6-M
            END IF
            IF(I>=J) M= 3+6-M
            DO 220 JJ=JF,JL
               KA = LBECP1(1,JJ)+1
               LA = LBECP1(2,JJ)+1
               MU = LBECP1(3,JJ)
               KX = LBECP1(M+1,JJ)+NX(K)
               KY = LBECP1(M+2,JJ)+NY(K)
               KZ = LBECP1(M+3,JJ)+NZ(K)
               IF((KX+KY+KZ)/=NXYZ) GO TO 220
               IX = LBECP1(4,JJ)+LBECP1(7,JJ)
               IY = LBECP1(5,JJ)+LBECP1(8,JJ)
               IZ = LBECP1(6,JJ)+LBECP1(9,JJ)
               LU = LA*(LA-1)-MU+1
               IF(ICAB==2) THEN
                  DT= ABX(KX+1-IX)*ABY(KY+1-IY)*ABZ(KZ+1-IZ)*ZFNLM(LU)
               ELSE
                  DT= ACX(KX+1-IX)*ACY(KY+1-IY)*ACZ(KZ+1-IZ)*ZFNLM(LU)
               END IF
               CKL(KA,LA)= CKL(KA,LA)+DCOEF1(JJ)*DT
  220       CONTINUE
            SUM= 0.0d0
            N= 1
            DO 230 K=1,NPNP
               DO 230 L=1,K
                  IF(ABS(CKL(K,L))>TOL) SUM= SUM+FP(N)*CKL(K,L)
  230       N= N+1
            G(NN)= G(NN)+DUMJ*SUM
  240 NN= NN+1
      IF(LLMX<2) RETURN
      DO 500 LL=2,LLMX
         CALL VCLR(FP,1,NPNPMX)
         KF = KFRST(KCNTR,LL)
         KL = KLAST(KCNTR,LL)
         DO 340 IG=IPMIN,IPMAX
            X01= EX(IG)
            DO 330 JG=JPMIN,JPMAX
               X02= EX(JG)
               X12= X01+X02
               DUM= COEFI(IG-IPMIN+1)*COEFJ(JG-JPMIN+1)
               IF(ICAB==2) THEN
                  GAMA= X02*BA
                  GAMX= GAMA*BA
               ELSE IF(ICAB==3) THEN
                  GAMA= X01*CA
                  GAMX= GAMA*CA
               END IF
               GAMI= 1.0d0/(GAMA+GAMA)
               XP0 = EXP(-GAMX)
               DO 320 K=KF,KL
                  XI = 1.0d0/SQRT(X12+ZLP(K))
                  ALF= GAMA*XI
                  XP1= EXP(-GAMX+ALF*ALF)
                  NLPK = NLP(K)
                  CLPK = CLP(K)*DUM
                  CALL FIECP(FIP,GAMI,NLPK,NPNP-1)
                  DO 310 N=1,NPNPMX
  310             FP(N)= FP(N)+FIP(N)*CLPK
  320          CONTINUE
  330       CONTINUE
  340    CONTINUE
         L2PL=(LL-2)*(LL-1)
         CALL ZFN(ZFNLM,NPNP-1,ZLM,LMF,LMX,LMY,LMZ)
         FPIQ2 = FPI*Q2
         MMAX= JAMAX
         NN= 1
         DO 440 I=IAMIN,IAMAX
            DUMI= FPIQ2
            IF(NORMI) DUMI= DUMI*ECPFAC(I)
            IF(IANDJ) MMAX= I
            DO 440 J=JAMIN,MMAX
               DUMJ= DUMI
               IF(NORMJ) DUMJ= DUMJ*ECPFAC(J)
               DO 400 L=1,NPNP
                  DO 400 K=L,NPNP
  400          CKL(K,L)= 0.0d0
               MX = NX(I)+NX(J)+1
               MY = NY(I)+NY(J)+1
               MZ = NZ(I)+NZ(J)+1
               IF(ICAB==2) THEN
                  K= I
               ELSE
                  K= J
               END IF
               KT = NX(K)+NY(K)+NZ(K)+1
               L= LL-2
               DO 420 M=L,-L,-1
                  NLM=(L2PL-M)*NTLIM
                  CT = DCOEF4(NLM+K)
                  IF(ABS(CT)<TOL) GO TO 420
                  NLM= NLM+I+J
                  JF = JFST2(NLM-K)
                  JL = JFST2(NLM-K+1)-1
                  DO 410 JJ=JF,JL
                     LA = LBECP2(1,JJ)+1
                     KA = LBECP2(2,JJ)+KT
                     MU = LBECP2(3,JJ)
                     KX = LBECP2(4,JJ)+NX(K)
                     KY = LBECP2(5,JJ)+NY(K)
                     KZ = LBECP2(6,JJ)+NZ(K)
                     LU = LA*(LA-1)-MU+1
                     IF(ICAB==2) THEN
                        DT=CT*ABX(MX-KX)*ABY(MY-KY)*ABZ(MZ-KZ)*ZFNLM(LU)
                     ELSE
                        DT=CT*ACX(MX-KX)*ACY(MY-KY)*ACZ(MZ-KZ)*ZFNLM(LU)
                     END IF
                     CKL(KA,LA)= CKL(KA,LA)+DCOEF2(JJ)*DT
  410             CONTINUE
  420          CONTINUE
               SUM= 0.0d0
               N= 1
               DO 430 K=1,NPNP
                  DO 430 L=1,K
               IF(ABS(CKL(K,L))>TOL) SUM= SUM+FP(N)*CKL(K,L)
  430          N= N+1
               G(NN)= G(NN)+DUMJ*SUM
  440    NN= NN+1
  500 CONTINUE
!
      RETURN
      END

! ECPDRA
      SUBROUTINE ECPDRA(IC4C,NPNP,FP,FQ,COEFI,COEFQ,COEFJ,DCOEF1,JFST1, &
            LBECP1,DCOEF2,JFST2,LBECP2,G,ZLM,LMF,LMX,LMY,LMZ,EX,NPRIMI)                             
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DOUBLE PRECISION DCOEF1(*),DCOEF2(*),ZLM(*)
      DIMENSION FP(*),FQ(*),COEFI(*),COEFQ(*),COEFJ(*),JFST1(*),        &
                LBECP1(9,*),JFST2(*),LBECP2(6,*),G(*)                      
      DIMENSION LMF(*),LMX(*),LMY(*),LMZ(*)                       
      COMMON /ECP1  / X01,CAX,CAY,CAZ,CA,XCA,YCA,ZCA,                   &
                      X02,BAX,BAY,BAZ,BA,XBA,YBA,ZBA,                   &
                      PHASE,DAX,DAY,DAZ,DA,XDA,YDA,ZDA,XINT,KCNTR        
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFRST(100,6),          &
                      KLAST(100,6),LMAX(100),LPSKIP(100),               &
                      IZCORE(100)                                        
      COMMON /ECP3  / ACX(7),ACY(7),ACZ(7),ABX(7),ABY(7),ABZ(7)          
      LOGICAL CANDB                                                      
      COMMON /ECP4  / P12(3,2),R12,ACO(3),CANDB                          
      COMMON /ECPDIM/ NCOEF1,NCOEF2,J1LEN,J2LEN,LLIM,NLIM,NTLIM,J4LEN    
      LOGICAL IANDJ,NORM,NORMI,NORMJ                                     
      COMMON /ECPIDX/ Q2,IAMIN,IAMAX,JAMIN,JAMAX,IPMIN,IPMAX,JPMIN,     &
                      JPMAX,KF1,KL1,LLMX,NPC,NPB,IANDJ,NORM,NORMI,NORMJ  
      COMMON /ZFNCM / X,Y,Z                                              
      COMMON /FICMN / ALF,XI,XP0,XP1                                     
      COMMON /FJCMN / ALEF,BEIT,XXI,XPLS,XMNS,XP                         
      COMMON /FJNEW / XKA,XKB,GAM1,GAM2,A1,A2,C                          
      COMMON /GBASE / NFST(8),NX(84),NY(84),NZ(84)                       
      
      DIMENSION EX(NPRIMI)
      DIMENSION FIP(78),ZFNLM(121),CKLU(23,12,12)                        
      DIMENSION CKLC(11,11),CKLB(11,11),CPQ(11,11,11)                    
      DIMENSION FJPQ(11,11,11),ZFNLMC(121),ZFNLMB(121)                   
      SAVE FJPQ,ZFNLMC,ZFNLMB                                            
      PARAMETER (ABLIM=1.0D-01)                                          
      PARAMETER (SR3=1.73205080756888D+00, SR5=2.23606797749979D+00)     
      PARAMETER (SR7=2.64575131106459D+00)                               
      PARAMETER (S35=SR3*SR5, S57=SR5*SR7, S53=S57/SR3)                  
      PARAMETER (TOL=1.0D-10, FPI=12.566370614359D+00)                   
      PARAMETER (TM6=1.0D-06, ONDS4P=0.28209479177388D+00)               
      DIMENSION ECPFAC(35)                                               
      DATA ECPFAC/7*1.0d0,3*SR3,3*1.0d0,6*SR5,S35,3*1.0d0,6*SR7,        &
                  3*S53,3*S57/
!
      IF(IC4C>0) GO TO 200
      NPNPMX=(NPNP*(NPNP+1)*(2*NPNP+1))/6
      CALL VCLR(FP,1,NPNPMX)
      IF(IC4C<0)CALL VCLR(FQ,1,NPNPMX)
      DO 160 IG=IPMIN,IPMAX
         X01= EX(IG)
         DO 160 JG=JPMIN,JPMAX
            X02= EX(JG)
            X12= X01+X02
            DUM= COEFI(IG-IPMIN+1)*COEFJ(JG-JPMIN+1)
            IF(IC4C<0)DUQ= COEFQ(IG-IPMIN+1)*COEFJ(JG-JPMIN+1)
            X21= 1.0d0/X12
            Y01= X01*X21
            Y02= 1.0d0-Y01
            Y12= Y01*X02
            DAX= P12(1,1)+(P12(1,2)-P12(1,1))*Y02-ACO(1)
            DAY= P12(2,1)+(P12(2,2)-P12(2,1))*Y02-ACO(2)
            DAZ= P12(3,1)+(P12(3,2)-P12(3,1))*Y02-ACO(3)
            DA = SQRT(DAX*DAX+DAY*DAY+DAZ*DAZ)
            IF(.NOT.CANDB) THEN
               DUM= DUM*EXP(-R12*Y12)
               IF(IC4C<0)DUQ= DUQ*EXP(-R12*Y12)
            END IF
            IF(DA>=TM6) THEN
               ALFA= X12*DA
               ALFX= ALFA*DA
               ALFI= 1.0d0/(ALFA+ALFA)
               X  = DAX/DA
               Y  = DAY/DA
               Z  = DAZ/DA
               CALL ZFN(ZFNLM,NPNP-1,ZLM,LMF,LMX,LMY,LMZ)
               XP0 = EXP(-ALFX)
               DO 130 K=KF1,KL1
                  XI  = 1.0d0/SQRT(X12+ZLP(K))
                  ALF = ALFA*XI
                  XP1 = EXP(-ALFX+ALF*ALF)
                  NLPK= NLP(K)
                  CLPK= CLP(K)*DUM
                  IF(IC4C<0)CLPQ= CLP(K)*DUQ
                  CALL FIECP(FIP,ALFI,NLPK,NPNP-1)
                  N= 1
                  NN= 1
                  DO 120 KK=1,NPNP
                     DO 120 L=1,KK
                        FIPTEM= FIP(NN)*CLPK
                        IF(IC4C<0)FIPTEQ= FIP(NN)*CLPQ
                        KKLL= L*(L-1)+1+L
                        DO 110 MU=1,2*L-1
                           FP(N)= FP(N)+FIPTEM*ZFNLM(KKLL-MU)
                           IF(IC4C<0)FQ(N)= FQ(N)+FIPTEQ*ZFNLM(KKLL-MU)
  110                   N= N+1
  120             NN= NN+1
  130          CONTINUE
            ELSE
               DO 150 K=KF1,KL1
                  ZETA= X12+ZLP(K)
                  NLPK= NLP(K)
                  CLPK= CLP(K)*ONDS4P*DUM
                  IF(IC4C<0)CLPQ= CLP(K)*ONDS4P*DUQ
                  DO 140 N=1,NPNP
                     NK=(N*(N-1)*(2*N-1))/6+1
                     FATEMP= FA(N+NLPK-1,ZETA)
                     FP(NK)= FP(NK)+FATEMP*CLPK
                     IF(IC4C<0)FQ(NK)= FQ(NK)+FATEMP*CLPQ
  140             CONTINUE
  150          CONTINUE
            END IF
  160 CONTINUE
  200 CONTINUE
!
      FPIQ2 = FPI*Q2
      MMAX= JAMAX
      NN= 1
      DO 240 I=IAMIN,IAMAX
         DUMI= FPIQ2
         IF(NORMI) DUMI= DUMI*ECPFAC(I)
         IF(IANDJ) MMAX= I
         DO 240 J=JAMIN,MMAX
            DUMJ= DUMI
            IF(NORMJ) DUMJ= DUMJ*ECPFAC(J)
            IF(I>=J) THEN
               INDX= J+(I*(I-1))/2
            ELSE
               INDX= I+(J*(J-1))/2
            END IF
            JF = JFST1(INDX)
            JL = JFST1(INDX+1)-1
            NXC= NX(I)+1
            NYC= NY(I)+1
            NZC= NZ(I)+1
            NXB= NX(J)+1
            NYB= NY(J)+1
            NZB= NZ(J)+1
            DO 210 K=1,NPNP+1
               DO 210 L=1,K
                  DO 210 MU=1,2*L-1
  210       CKLU(MU,L,K)= 0.0d0

            DO 220 K=JF,JL
               KA = LBECP1(1,K)+1
               LA = LBECP1(2,K)+1
               MU = LBECP1(3,K)
               IF(I>=J) THEN
                  KX = LBECP1(4,K)
                  KY = LBECP1(5,K)
                  KZ = LBECP1(6,K)
                  KXP= LBECP1(7,K)
                  KYP= LBECP1(8,K)
                  KZP= LBECP1(9,K)
               ELSE
                  KXP= LBECP1(4,K)
                  KYP= LBECP1(5,K)
                  KZP= LBECP1(6,K)
                  KX = LBECP1(7,K)
                  KY = LBECP1(8,K)
                  KZ = LBECP1(9,K)
               END IF
      CKLU(LA+MU,LA,KA) = CKLU(LA+MU,LA,KA) + DCOEF1(K)                 &
                        * ACX(NXC-KX) *ACY(NYC-KY) *ACZ(NZC-KZ)         &
                        * ABX(NXB-KXP)*ABY(NYB-KYP)*ABZ(NZB-KZP)
  220       CONTINUE
            SUM= 0.0d0
            N= 1
            DO 230 K=1,NPNP
               DO 230 L=1,K
                  DO 230 MU=1,2*L-1
                     CKLTEM= CKLU(MU,L,K)
                     IF(IC4C<=0) THEN
                        IF(ABS(CKLTEM)>TOL) SUM= SUM+FP(N)*CKLTEM
                     ELSE
                        IF(ABS(CKLTEM)>TOL) SUM= SUM+FQ(N)*CKLTEM
                     END IF
  230       N= N+1
            G(NN)= G(NN)+DUMJ*SUM
  240 NN= NN+1
      IF(LLMX<2) RETURN
      FPISQ2= FPI*FPIQ2
      DO 500 LL=2,LLMX
         L= LL-2
         NP1  = MAX0(NPC,NPB)
         NP1PL= NP1+L
         NPCPL= NPC+L
         NPBPL= NPB+L
         NMAX =(NPNP-1)*NPCPL*(NPBPL/2+1)+6
         LTMAX= MAX0(NPNP,NP1PL)
         LEMX = MAX0(L,LTMAX/2)
         KF = KFRST(KCNTR,LL)
         KL = KLAST(KCNTR,LL)
         CALL VCLR(FP,1,NMAX)
         DO 340 IG=IPMIN,IPMAX
            X01= EX(IG)
            ALFA= X01*CA
            ALFX= ALFA*CA
            ALFI= 1.0d0/(ALFA+ALFA)
            DO 340 JG=JPMIN,JPMAX
               X02= EX(JG)
               X12= X01+X02
               BETA= X02*BA
               BETX= BETA*BA
               BETI= 1.0d0/(BETA+BETA)
               ALBE= ALFX+BETX
               XP = EXP(-ALBE)
               DUM= COEFI(IG-IPMIN+1)*COEFJ(JG-JPMIN+1)
               DO 330 K=KF,KL
                  XXI= 1.0d0/SQRT(X12+ZLP(K))
                  ALEF= ALFA*XXI
                  BEIT= BETA*XXI
                  IF(ALEF*BEIT>ABLIM) THEN
                     XKA= ALFA+ALFA
                     XKB= BETA+BETA
                     A1 = ALEF+BEIT
                     A2 = ALEF-BEIT
                     C  = X12+ZLP(K)
                     XPLS= EXP(-ALBE+(ALEF+BEIT)**2)
                     XMNS= EXP(-ALBE+(ALEF-BEIT)**2)
                     GAM1= XPLS*0.25D+00
                     GAM2= XMNS*0.25D+00
                  ELSE
                     XPLS= EXP(-ALBE+ALEF*ALEF)
                     XMNS= EXP(-ALBE+BEIT*BEIT)
                  END IF
                  NLPK = NLP(K)
                  CLPK = CLP(K)*DUM
                  CALL FJECP(FJPQ,ALFI,BETI,NLPK,NPNP,LTMAX,LEMX)
                  DO 310 IN=1,LEMX+1
  310             FP(IN)= FP(IN)+FJPQ(IN,IN,1)*CLPK
                  IF(NPNP<2) GO TO 330
                  NBEG= 1
                  N= 6+1
                  DO 320 IN=2,NPNP
                     NBEG= 1-NBEG
                     LBEG= NBEG
                     DO 320 IP=1,NPCPL
                        LBEG= 1-LBEG
                        DO 320 IQ=1+LBEG,NPBPL,2
                  FP(N)= FP(N)+FJPQ(IQ,IP,IN)*CLPK
  320             N= N+1
  330          CONTINUE
  340    CONTINUE
!
         L= LL-2
         L1MAX= MAX0(1,L+1)
         L2PL=(LL-1)*(LL-2)
         X = XCA
         Y = YCA
         Z = ZCA
         CALL ZFN(ZFNLMC,NPCPL-1,ZLM,LMF,LMX,LMY,LMZ)
         X = XBA
         Y = YBA
         Z = ZBA
         CALL ZFN(ZFNLMB,NPBPL-1,ZLM,LMF,LMX,LMY,LMZ)
!        FPISQ2= FPI*FPI*Q2
         MMAX= JAMAX
         NN= 1
         DO 440 I=IAMIN,IAMAX
            DUMI = FPISQ2
            IF(NORMI) DUMI= DUMI*ECPFAC(I)
            IF(IANDJ) MMAX= I
            DO 440 J=JAMIN,MMAX
               DUMJ= DUMI
               IF(NORMJ) DUMJ= DUMJ*ECPFAC(J)
               NXC = NX(I)+1
               NYC = NY(I)+1
               NZC = NZ(I)+1
               NXB = NX(J)+1
               NYB = NY(J)+1
               NZB = NZ(J)+1
               DO 410 M=1,2*NP1-1
                  DO 410 N=1,NPCPL
                     DO 410 K=1,NPBPL
  410          CPQ(K,N,M)= 0.0d0
               NLM=(L2PL-L)*NTLIM
               DO 420 M=L,-L,-1
                  DO 412 N=1,NP1
                     DO 412 K=1,NP1PL
                        CKLC(K,N)= 0.0d0
                        CKLB(K,N)= 0.0d0
  412             CONTINUE
                  JF = JFST2(NLM+I)
                  JL = JFST2(NLM+I+1)-1
                  DO 414 JJ=JF,JL
                     LA = LBECP2(1,JJ)+1
                     KA = LBECP2(2,JJ)+1
                     MU = LBECP2(3,JJ)
                     KX = LBECP2(4,JJ)
                     KY = LBECP2(5,JJ)
                     KZ = LBECP2(6,JJ)
                     LU = LA*(LA-1)-MU+1
                     CKLC(LA,KA)= CKLC(LA,KA)+DCOEF2(JJ)*ZFNLMC(LU)*    &
                                  ACX(NXC-KX)*ACY(NYC-KY)*ACZ(NZC-KZ)
  414             CONTINUE
                  JF = JFST2(NLM+J)
                  JL = JFST2(NLM+J+1)-1
                  DO 416 JJ=JF,JL
                     LA = LBECP2(1,JJ)+1
                     KA = LBECP2(2,JJ)+1
                     MU = LBECP2(3,JJ)
                     KX = LBECP2(4,JJ)
                     KY = LBECP2(5,JJ)
                     KZ = LBECP2(6,JJ)
                     LU = LA*(LA-1)-MU+1
                     CKLB(LA,KA)= CKLB(LA,KA)+DCOEF2(JJ)*ZFNLMB(LU)*    &
                                  ABX(NXB-KX)*ABY(NYB-KY)*ABZ(NZB-KZ)
  416             CONTINUE
                  DO 418 K=1,NP1
                     DO 418 N=1,NPCPL
                        CT= CKLC(N,K)
                        DO 418 K2=K,K+NP1-1
                           DO 418 N2=1,NPBPL
  418             CPQ(N2,N,K2)= CPQ(N2,N,K2)+CT*CKLB(N2,K2+1-K)
  420          NLM= NLM+NTLIM
               SUM= 0.0d0
               DO 422 N=1,L1MAX
  422          SUM= SUM+FP(N)*CPQ(N,N,1)
               IF(NPNP<2) GO TO 425
               JBEG= 1
               N= 6+1
               DO 424 KK=2,NPNP
                  JBEG= 1-JBEG
                  LBEG= JBEG
                  DO 424 JJ=1,NPCPL
                     LBEG= 1-LBEG
                     DO 424 M=LBEG+1,NPBPL,2
               IF(ABS(CPQ(M,JJ,KK))>TOL) SUM= SUM+FP(N)*CPQ(M,JJ,KK)
  424          N= N+1
  425          CONTINUE
               G(NN)= G(NN)+DUMJ*SUM
  440    NN= NN+1
  500 CONTINUE
!
      RETURN
      END

! ECPPWR
      SUBROUTINE ECPPWR(ISWTCH,NI,NJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ECP1  / X01,CAX,CAY,CAZ,CA,XCA,YCA,ZCA,                   &
                      X02,BAX,BAY,BAZ,BA,XBA,YBA,ZBA,                   &
                      PHASE,DAX,DAY,DAZ,DA,XDA,YDA,ZDA,XINT,KCNTR
      COMMON /ECP3  / ACX(7),ACY(7),ACZ(7),ABX(7),ABY(7),ABZ(7)
      ACX(1)= 1.0d0
      ACY(1)= 1.0d0
      ACZ(1)= 1.0d0
      IF(ISWTCH<1) THEN
         IF(NI>1) THEN
            ACX(2)=-CAX
            ACY(2)=-CAY
            ACZ(2)=-CAZ
            IF(NI>2) THEN
               DO 110 II=3,NI
                  ACX(II)=-CAX*ACX(II-1)
                  ACY(II)=-CAY*ACY(II-1)
                  ACZ(II)=-CAZ*ACZ(II-1)
  110          CONTINUE
            END IF
         END IF
      END IF
      ABX(1)= 1.0d0
      ABY(1)= 1.0d0
      ABZ(1)= 1.0d0
      IF(ISWTCH>(-1)) THEN
         IF(NJ>1) THEN
            ABX(2)=-BAX
            ABY(2)=-BAY
            ABZ(2)=-BAZ
            IF(NJ>2) THEN
               DO 120 II=3,NJ
                  ABX(II)=-BAX*ABX(II-1)
                  ABY(II)=-BAY*ABY(II-1)
                  ABZ(II)=-BAZ*ABZ(II-1)
  120          CONTINUE
            END IF
         END IF
      END IF
      RETURN
      END

! ERRF
      DOUBLE PRECISION FUNCTION ERRF(Y)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ERRFCM/ C(142),IFRST(20),ILAST(20),H
!
      X= Y
      S= 1.0d0
      IF(X>=0.0d0) GO TO 105
      X=-Y
      S=-1.0d0
  105 IF(X>=4.86D+00) GO TO 115
      XN = X/H
      NX = INT(XN)+1
      I1 = IFRST(NX)
      IL = ILAST(NX)
      T= C(IL)
      DO 110 K=IL-1,I1,-1
  110 T= C(K)+T*X
      ERRF  = T*S
      GO TO 999
  115 ERRF  = S
  999 CONTINUE
      RETURN
      END

! FA
      DOUBLE PRECISION FUNCTION FA(N,ZETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION GAMMO(9),GAMME(9)
      DATA GAMMO/0.5D+00,0.5D+00,1.0D+00,3.0D+00,12.0D+00,60.0D+00,     &
                 360.0D+00,2520.0D+00,20160.0D+00/                       
      DATA GAMME/0.5D+00,0.25D+00,0.375D+00,0.9375D+00,3.28125D+00,     &
                 14.765625D+00,81.2109375D+00,527.87109375D+00,         &
                 3959.033203125D+00/
      DATA SQRPI/1.772453850905D+00/

      K= N/2
      IF(MOD(N,2)/=0) THEN
         T= GAMMO(K+1)
      ELSE
         T= GAMME(K+1)*SQRPI*SQRT(ZETA)
      END IF
      FA= T/ZETA**(K+1)
      RETURN
      END

! FIECP
      SUBROUTINE FIECP(FIP,ALFI,NLP,NPNP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION FIP(*)
      COMMON /FICMN / ALF,XI,XP0,XP1
      DIMENSION FIT(19,2)
      PARAMETER (ZP5=0.5D+00)
      NEFF=NLP+NPNP
      IF(MOD(NEFF,2)/=0) THEN
         NEMX= NEFF+1
         NOMX= NEFF
      ELSE
         NEMX= NEFF
         NOMX= NEFF+1
      END IF
      IF(NEFF==0) NOMX=-1
      YI= XI*ZP5
      A1= XI*ALF
      A2= XI*YI
      IF(NEMX<0) GO TO 115
      FIT(1,1)= FSI0(0)*YI
      IF(NEMX==0) GO TO 115
      FIT(2,2)= FSI1(1)*YI*YI
      IF(NEMX==1) GO TO 115
      T1= A2
      DO 110 N=2,NEMX,2
         T2= T1-A2
         FIT(N+1,1)= A1*FIT(N  ,2)+T1*FIT(N-1,1)
         FIT(N+2,2)= A1*FIT(N+1,1)+T2*FIT(N  ,2)
  110 T1= T1+A2+A2
  115 CONTINUE
      IF(NOMX<0) GO TO 125
      FIT(1,2)= FSI1(0)*YI
      IF(NOMX==0) GO TO 125
      FIT(2,1)= FSI0(1)*YI*YI
      IF(NOMX==1) GO TO 125
      T1= A2+A2
      DO 120 N=2,NOMX,2
         T2= T1-A2-A2-A2
         FIT(N+1,2)= A1*FIT(N  ,1)+T2*FIT(N-1,2)
         FIT(N+2,1)= A1*FIT(N+1,2)+T1*FIT(N  ,1)
  120 T1= T1+A2+A2
  125 CONTINUE
      LMAX= 1
      NK=0
      NM1K=0
      DO 150 N=1,NPNP+1
!        NK=(N*(N-1))/2
         DO 130 L=1,LMAX
  130    FIP(NK+L)= FIT(N+NLP,L)
         LMAX= 2
         IF(N<=2) GO TO 145
!        NM1K=((N-1)*(N-2))/2
         T01 = ALFI+ALFI+ALFI
         DO 140 L=3,N
            FIP(NK+L)= FIP(NK-2+L)-T01*FIP(NM1K-1+L)
  140    T01 = T01 +ALFI+ALFI
  145    NM1K=NK
  150 NK=NK+N
      RETURN
      END
      
! FJFORM
      SUBROUTINE FJFORM(RHO,SGA,SGB,TAU,NMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION RHO(15),SGA(15),SGB(15),TAU(15)
      COMMON /FJCMN / ALEF,BET,XI,XPLS,XMNS,XP
      COMMON /FJNEW / XKA,XKB,GAM1,GAM2,A1,A2,C
      PARAMETER (ZP5=0.5D+00)
      DIMENSION FACTI(13),B1(15),B2(15),C1(15),C2(15)
      DATA FACTI/1.0D+00,4.0D+00,1.8D+01,9.6D+01,6.0D+02,4.32D+03,      &
                 3.528D+04,3.2256D+05,3.26592D+06,3.6288D+07,           &
                 4.390848D+08,5.7480192D+09,8.09512704D+10/
      DATA SQPI/1.772453850905D+00/
!
      SQPIDC= SQPI*XI
      B1(1) = SQPIDC*GAM1
      C1(1) = SQPIDC*GAM1*ERRF(A1)
      B2(1) = SQPIDC*GAM2
      C2(1) = SQPIDC*GAM2*ERRF(A2)
      TWSQPI= SQPI+SQPI
      B1(2) = TWSQPI*GAM1*DAWERF(A1)
      C1(2) = TWSQPI*GAM1*DAWF(A1)
      B2(2) = TWSQPI*GAM2*DAWERF(A2)
      C2(2) = TWSQPI*GAM2*DAWF(A2)
      TWC= C+C
      XKAPKB= XKA+XKB
      XKAMKB= XKA-XKB
      XPP= XP
      XPM= XP
      FAP= 0.0d0
      DEN= 1.0d0
      DO 110 I=3,NMAX
         XPP= XPP*XKAPKB
         XPM= XPM*XKAMKB
!        FAP=(1+((-1)**I))*0.25D+00
!        FAM=(1-((-1)**I))*0.25D+00
         FAM= ZP5-FAP
         T01= FAP/FACTI(I-2)
         T02= FAM/FACTI(I-2)
         T03= 1.0d0/DEN
         B1(I)= XPP*T01-(TWC*B1(I-2)-XKAPKB*C1(I-1))*T03
         C1(I)= XPP*T02-(TWC*C1(I-2)-XKAPKB*B1(I-1))*T03
         B2(I)= XPM*T01-(TWC*B2(I-2)-XKAMKB*C2(I-1))*T03
         C2(I)= XPM*T02-(TWC*C2(I-2)-XKAMKB*B2(I-1))*T03
      FAP= FAM
  110 DEN= DEN+1.0d0
      DO 120 I=1,NMAX
         RHO(I)= B1(I)-B2(I)
         SGA(I)= C1(I)+C2(I)
         SGB(I)= C1(I)-C2(I)
         TAU(I)= B1(I)+B2(I)
  120 CONTINUE
      RETURN
      END
      
! FJECP
      SUBROUTINE FJECP(FJPQ,ALFI,BETI,NLP,NPNP,LMAX,LEMX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION FJPQ(11,11,11)
      COMMON /FJCMN / ALEF,BET,XI,XPLS,XMNS,XP
      COMMON /FJNEW / XKA,XKB,GAM1,GAM2,A1,A2,C
      DIMENSION RHO(15),SGA(15),SGB(15),TAU(15),FJT(19,2,2)
      PARAMETER (ZP5=0.5D+00, ABLIM=1.0D-01)
      PARAMETER (ZP1=0.1D+00, FIV=5.0D+00, SIX=6.0D+00, TEN=10.0D+00)
!
      JEFF= NLP+NPNP-1
      NEMX= JEFF
      NOMX= JEFF
      IF(JEFF==0) NOMX=-1
      LOMX= LEMX
      IF(ALEF*BET>ABLIM) THEN
         XKAKB = XKA*XKB
         ONEDAB= 1.0d0/XKAKB
         ONDAB2= ONEDAB*ONEDAB
!        IF(2*LEMX+3>15) THEN
         IF(LEMX>6) THEN
            WRITE(6,*) 'LEMX TOO BIG, LEMX= ',LEMX
            CALL ABRT
         END IF
         DO 110 II=1,15
            RHO(II)= 0.0d0
            SGA(II)= 0.0d0
            SGB(II)= 0.0d0
            TAU(II)= 0.0d0
  110    CONTINUE
         CALL FJFORM(RHO,SGA,SGB,TAU,2*LEMX+3)
         FJT(1,1,1)= RHO(3)*ONEDAB
         FJT(2,1,1)= RHO(2)*ONEDAB
         FJT(1,2,1)=(SGB(3)-RHO(4)*ONEDAB*XKB)*ONEDAB
         FJT(2,2,1)=(SGB(2)-RHO(3)*ONEDAB*XKB)*ONEDAB
         FJT(1,1,2)=(SGA(3)-RHO(4)*ONEDAB*XKA)*ONEDAB
         FJT(2,1,2)=(SGA(2)-RHO(3)*ONEDAB*XKA)*ONEDAB
         FJT(1,2,2)=(RHO(5)-XKA*SGB(4)-XKB*SGA(4)+XKAKB*TAU(3))*ONDAB2
         FJT(2,2,2)=(RHO(4)-XKA*SGB(3)-XKB*SGA(3)+XKAKB*TAU(2))*ONDAB2
      ELSE
         CALL SITABL(LEMX,LOMX)
         FJT(1,1,1)= FJPS(0,0,0)
         FJT(2,1,1)= FJPS(1,0,0)
         FJT(1,2,1)= FJPS(0,1,0)
         FJT(2,2,1)= FJPS(1,1,0)
         FJT(1,1,2)= FJPS(0,0,1)
         FJT(2,1,2)= FJPS(1,0,1)
         FJT(1,2,2)= FJPS(0,1,1)
         FJT(2,2,2)= FJPS(1,1,1)
      END IF
      XA= XI*ALEF
      XB= XI*BET
      XX= XI*XI*ZP5
      IF(NEMX<0) GO TO 125
      IF(NEMX==0) GO TO 125
      IF(NEMX==1) GO TO 125
      T2= 0.0d0
      DO 120 N=2,NEMX,2
         T1= T2+XX
         T3= T2-XX-XX-XX
         FJT(N+1,1,1)= XA*FJT(N  ,2,1)+XB*FJT(N  ,1,2)+T1*FJT(N-1,1,1)
         FJT(N+1,2,2)= XA*FJT(N  ,1,2)+XB*FJT(N  ,2,1)+T3*FJT(N-1,2,2)
         FJT(N+2,2,1)= XA*FJT(N+1,1,1)+XB*FJT(N+1,2,2)+T2*FJT(N  ,2,1)
         FJT(N+2,1,2)= XA*FJT(N+1,2,2)+XB*FJT(N+1,1,1)+T2*FJT(N  ,1,2)
  120 T2= T2+XX+XX
  125 CONTINUE
      IF(NOMX<0) GO TO 135
      IF(NOMX==0) GO TO 135
      IF(NOMX==1) GO TO 135
      T2=-XX
      DO 130 N=2,NOMX,2
         T1= T2-XX
         T3= T2+XX+XX+XX
         FJT(N+1,2,1)= XA*FJT(N  ,1,1)+XB*FJT(N  ,2,2)+T2*FJT(N-1,2,1)
         FJT(N+1,1,2)= XA*FJT(N  ,2,2)+XB*FJT(N  ,1,1)+T2*FJT(N-1,1,2)
         FJT(N+2,1,1)= XA*FJT(N+1,2,1)+XB*FJT(N+1,1,2)+T3*FJT(N  ,1,1)
         FJT(N+2,2,2)= XA*FJT(N+1,1,2)+XB*FJT(N+1,2,1)+T1*FJT(N  ,2,2)
  130 T2= T2+XX+XX
  135 CONTINUE
      IF(2<=LEMX .and. LEMX<=6) THEN
         IF(ALEF*BET>ABLIM) THEN
            IF(NLP>2) THEN
               WRITE(6,*) 'NLP TOO BIG!, ',NLP,' LEMX = ',LEMX
               CALL ABRT
            END IF
         END IF
      ELSEIF(LEMX>6) THEN
         WRITE(6,*) 'ERROR LEMX = ',LEMX,' IS TOO LARGE IN FJECP'
         CALL ABRT
      END IF
      N= NLP
      DO 150 IP= 1,LEMX+1
         IF(IP<3) THEN
            FJPQ(IP,IP,1)= FJT(N+1,IP,IP)
            GO TO 150
         ELSEIF(ALEF*BET<=ABLIM) THEN
            FJPQ(IP,IP,1)= FJPS(N,IP-1,IP-1)
            GO TO 150
         END IF
         IF(IP==3) THEN
            XKA2 = XKA*XKA
            XKB2 = XKB*XKB
            XKAKB2= XKAKB*XKAKB
            DU4= ONDAB2
            QA2= 3.0D+00*XKA2
            QB2= 3.0D+00*XKB2
            T02= QA2+QB2
            T00= 9.0D+00
      DU0 = T00*RHO( 7-N)+T02*RHO( 5-N)+XKAKB2*RHO( 3-N)
      DU1 = T00*SGA( 6-N)+QA2*SGA( 4-N)
      DU2 = T00*SGB( 6-N)+QB2*SGB( 4-N)
      DU3 = T00*TAU( 5-N)
         ELSEIF(IP==4) THEN
            QA2= 1.5D+01*XKA2
            QB2= 1.5D+01*XKB2
            T02= QA2+QB2
            XRE= SIX*XKAKB2
            T00= 2.25D+02
      DU0 = T00*RHO( 9-N)+(T02*RHO( 7-N)+RHO( 5-N)*XRE)*SIX
      DU1 = T00*SGA( 8-N)+(T02+FIV* QA2)*SGA( 6-N)+SGA( 4-N)*XRE
      DU2 = T00*SGB( 8-N)+(T02+FIV* QB2)*SGB( 6-N)+SGB( 4-N)*XRE
      DU3 = T00*TAU( 7-N)+ T02*TAU( 5-N)+TAU( 3-N)*XKAKB2
         ELSEIF(IP==5) THEN
            XKA4 = XKA2*XKA2
            XKB4 = XKB2*XKB2
            QA2= 4.5D+01*XKA2
            QB2= 4.5D+01*XKB2
            T02= QA2+QB2
            T03= 1.05D+03*(XKA2+XKB2)
            QA4= 1.05D+02*XKA4
            QB4= 1.05D+02*XKB4
            T04= QA4+QB4
            XRE= TEN*XKAKB2
            T00= 1.1025D+04
      DU0 = T00*RHO(11-N)+1.05D+02*T02*RHO( 9-N)+T04*RHO( 7-N)+         &
           (2.025D+03*RHO( 7-N)+T02*RHO( 5-N)+RHO( 3-N)*XKAKB2)*XKAKB2   
      DU1 = T00*SGA(10-N)+(T03+3.675D+03*XKA2)*SGA( 8-N)+               &
            QA4*SGA( 6-N)+(4.5D+01*SGA( 6-N)+XKA2*SGA( 4-N))*XRE         
      DU2 = T00*SGB(10-N)+(T03+3.675D+03*XKB2)*SGB( 8-N)+               &
            QB4*SGB( 6-N)+(4.5D+01*SGB( 6-N)+XKB2*SGB( 4-N))*XRE
      DU3 = T00*TAU( 9-N)+T03*TAU( 7-N)+TEN*TAU( 5-N)*XRE
         ELSEIF(IP==6) THEN
            QA2= 4.2D+02*XKA2
            QB2= 4.2D+02*XKB2
            T02= QA2+QB2
            T03= 9.9225D+04*(XKA2+XKB2)
            QA4= 9.45D+02*XKA4
            QB4= 9.45D+02*XKB4
            T04= QA4+QB4
            XRE= 1.5D+01*XKAKB2
            T00= 8.93025D+05
      DU0 = T00*RHO(13-N)+4.0D+00*T03*RHO(11-N)+1.5D+01*T04*RHO( 9-N)+  &
           (1.176D+04*RHO( 9-N)+T02*RHO( 7-N)+RHO( 5-N)*XRE)*XRE         
      DU1 = T00*SGA(12-N)+(T03+7.0875D+02*QA2)*SGA(10-N)+               &
            (T04+1.4D+01*QA4)*SGA( 8-N)+                                &
           (4.41D+04*SGA( 8-N)+(T02+2.75D+00*QA2)*SGA( 6-N)+            &
            SGA( 4-N)*XRE)*XKAKB2                                        
      DU2 = T00*SGB(12-N)+(T03+7.0875D+02*QB2)*SGB(10-N)+               &
            (T04+1.4D+01*QB4)*SGB( 8-N)+                                &
            (4.41D+04*SGB( 8-N)+(T02+2.75D+00*QB2)*SGB( 6-N)+           &
            SGB( 4-N)*XRE)*XKAKB2                                        
      DU3 = T00*TAU(11-N)+T03*TAU( 9-N)+T04*TAU( 7-N)+                  &
           (1.1025D+04*TAU( 7-N)+2.5D-01*T02*TAU( 5-N)+                 &
            TAU( 3-N)*XKAKB2)*XKAKB2
         ELSEIF(IP==7) THEN
            XKA6 = XKA4*XKA2
            XKB6 = XKB4*XKB2
            QA2= 3.5D+00*XKA2
            QB2= 3.5D+00*XKB2
            T02= QA2+QB2
            T03= 6.496875D+01*T02
            QA4= 3.5D+00*XKA4
            QB4= 3.5D+00*XKB4
            T04= 3.75D-01*(QA4+QB4)
            T05= 7.7D+00*T04
            QA6= 4.8125D-02*XKA6
            QB6= 4.8125D-02*XKB6
            T06= QA6+QB6
            XRE= ZP1*XKAKB2/SIX
            T00= 5.00259375D+02
      DU0 = T00*RHO(15-N)+T03*RHO(13-N)+T05*RHO(11-N)+T06*RHO( 9-N)+    &
            (6.2015625D+03*RHO(11-N)+                                   &
            7.875D+01*T02*RHO( 9-N)+T04*RHO( 7-N)+                      &
            (7.35D+02*RHO( 7-N)+T02*RHO( 5-N)+RHO( 3-N)*XRE)*XRE)*XRE    
      DU1 = T00*SGA(14-N)+(T03-1.66753125D+02*XKB2)*SGA(12-N)+          &
            (T05-2.59875D+00*QB4)*SGA(10-N)+QA6*SGA( 8-N)+              &
           (1.65375D+04*SGA(10-N)+2.1D+02*(T02-6.25D-01*QB2)*SGA( 8-N)+ &
            QA4*SGA( 6-N)+(7.35D+02*SGA( 6-N)+QA2*SGA( 4-N))*XRE        &
           )*XRE*ZP1                                                     
      DU2 = T00*SGB(14-N)+(T03-1.66753125D+02*XKA2)*SGB(12-N)+          &
            (T05-2.59875D+00*QA4)*SGB(10-N)+QB6*SGB( 8-N)+              &
           (1.65375D+04*SGB(10-N)+2.1D+02*(T02-6.25D-01*QA2)*SGB( 8-N)+ &
            QB4*SGB( 6-N)+(7.35D+02*SGB( 6-N)+QB2*SGB( 4-N))*XRE        &
           )*XRE*ZP1                                                     
      DU3 = T00*TAU(13-N)+1.7325D+01*T02*TAU(11-N)+ZP1*T05*TAU( 9-N)+   &
           (2.1D+02*TAU( 9-N)+T02*TAU( 7-N)+3.5D+00*TAU( 5-N)*XRE       &
           )*XRE*2.1D+00
      DU4 = DU4*2.16D+05
         END IF
         DU4= DU4*ONEDAB
         FJPQ(IP,IP,1)=(DU0-DU1*XKB-DU2*XKA+DU3*XKAKB)*DU4
  150 CONTINUE
      IF(NPNP<=1) GO TO 999
      DO 220 IK=2,NPNP
         DO 160 IP=1,2
            DO 160 IQ=1,2
  160    FJPQ(IQ,IP,IK)= FJT(NLP+IK,IP,IQ)
         IF(LMAX<=2) GO TO 220
         T01= ALFI+ALFI+ALFI
         DO 170 IP=3,LMAX
            FJPQ( 1,IP,IK)= FJPQ( 1,IP-2,IK)-T01*FJPQ( 1,IP-1,IK-1)
            FJPQ( 2,IP,IK)= FJPQ( 2,IP-2,IK)-T01*FJPQ( 2,IP-1,IK-1)
  170    T01= T01 +ALFI+ALFI
         T02= BETI+BETI+BETI
         DO 180 IQ=3,LMAX
            FJPQ(IQ, 1,IK)= FJPQ(IQ-2, 1,IK)-T02*FJPQ(IQ-1, 1,IK-1)
            FJPQ(IQ, 2,IK)= FJPQ(IQ-2, 2,IK)-T02*FJPQ(IQ-1, 2,IK-1)
  180    T02= T02 +BETI+BETI

         T01= ALFI+ALFI+ALFI
         DO 210 IP=3,LMAX
            T02= BETI+BETI+BETI
            IF(IP==3) GO TO 195
            DO 190 IQ=3,IP-1
               FJPQ(IQ,IP,IK)= FJPQ(IQ,IP-2,IK)-T01*FJPQ(IQ,IP-1,IK-1)
  190       T02= T02 +BETI+BETI
  195       CONTINUE
            DO 200 IQ=IP,LMAX
               FJPQ(IQ,IP,IK)= FJPQ(IQ-2,IP,IK)-T02*FJPQ(IQ-1,IP,IK-1)
  200       T02= T02 +BETI+BETI
  210    T01= T01 +ALFI+ALFI
  220 CONTINUE

  999 CONTINUE
      RETURN
      END
      
! FJPS
      DOUBLE PRECISION FUNCTION FJPS(N,LALF,LBET)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FJCMN / ALF,BET,XI,XPLS,XMNS,XP
      COMMON /FSICMN/ SI(30,7)
      PARAMETER(LIMAB=10)
      DIMENSION DFCTRL(7)
      DATA DFCTRL/1.0D+00,3.0D+00,15.0D+00,105.0D+00,945.0D+00,         &
                  1.0395D+04,1.35135D+05/
      IF((ALF-BET)>0.0D+00) THEN
         L0= LBET+1
         X = BET
      ELSE
         L0= LALF+1
         X = ALF
      END IF
      T = X**(L0-1)/DFCTRL(L0)
      X = X*X
      L1= LALF+LBET+2-L0
      L2= L0+N
      L3= L0+L0-1
      SUM = T*SI(L2,L1)
      DO 110 K=1,LIMAB
         T= T*X/(2*K*(K+K+L3))
  110 SUM = SUM+T*SI(K+K+L2,L1)
      FJPS= SUM*(0.5D+00*XI)**(N+1)
      RETURN
      END

! FSI
      DOUBLE PRECISION FUNCTION FSI(N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FICMN / ALFA,XI,XP0,XP1
      SAVE DAWFS,ERRFS
      PARAMETER (ZP5=0.5D0, OP5=1.5D0)
      PARAMETER (TP5=2.5D0, THR=3.0D0, FIV=5.0D0)
      PARAMETER (SIX=6.0D0, SP5=7.5D0, FIF=15.0D0, ALIM=0.317D0)
      DATA SQPI/1.772453850905D0/
      DATA ERRFS/0.0D0/
!     -------------
      ENTRY FSI0(N)
!     -------------
      IF(ALFA>ALIM) GO TO 010
      FSI0= FSIPS(N,0)
      GO TO 030
  010 NP1 = N+1
      IF(NP1==2) GO TO 020
      DAWFS=DAWF(ALFA)
      FSI0= SQPI*XP1*DAWFS/ALFA
      GO TO 030
  020 FSI0= ERRFS/ALFA
  030 FSI = FSI0
      RETURN
!     -------------
      ENTRY FSI1(N)
!     -------------
      IF(ALFA>ALIM) GO TO 100
      FSI1= FSIPS(N,1)
      GO TO 140
  100 NP1 = N+1
      ALF2= ALFA*ALFA
      TLF2= ALF2+ALF2
      IF(NP1-2) 110,120,130
  110 ERRFS=SQPI*XP1*ERRF(ALFA)
      FSI1=(ZP5*ERRFS-XP0*ALFA)/ALF2
      GO TO 140
  120 FSI1= SQPI*XP1*(ALFA-DAWFS)/ALF2
      GO TO 140
  130 FSI1=(2.0d0*XP0*ALFA+(TLF2-1.0d0)*ERRFS)/ALF2
  140 FSI = FSI1
      RETURN
!     -------------
      ENTRY FSI2(N)
!     -------------
      IF(ALFA>ALIM) GO TO 200
      FSI2= FSIPS(N,2)
      GO TO 250
  200 NP1 = N+1
      ALF2= ALFA*ALFA
      ALF3= ALFA*ALF2
      TLF2= ALF2+ALF2
      GO TO(210,220,230,240),NP1
  210 FSI2= ZP5*SQPI*XP1*(OP5*ALFA-(ALF2+OP5)*DAWFS)/ALF3
      GO TO 250
  220 FSI2=(THR*XP0*ALFA+(ALF2-OP5)*ERRFS)/ALF3
      GO TO 250
  230 FSI2= SQPI*XP1*(ALFA*(TLF2-THR)+THR*DAWFS)/ALF3
      GO TO 250
  240 FSI2=(2.0d0*XP0*ALFA*(TLF2-THR)+(TLF2*(TLF2-2.0)+THR)*ERRFS)/ALF3
  250 FSI = FSI2
      RETURN
!     -------------
      ENTRY FSI3(N)
!     -------------
      IF(ALFA>ALIM) GO TO 300
      FSI3= FSIPS(N,3)
      GO TO 360
  300 NP1 = N+1
      ALF2= ALFA*ALFA
      ALF3= ALFA*ALF2
      ALF4= ALFA*ALF3
      TLF2= ALF2+ALF2
      GO TO(310,320,330,340,350),NP1
  310 FSI3=(2.0d0*XP0*ALFA*(TLF2+SP5)/SIX+ZP5*(ALF2-TP5)*ERRFS)/ALF4
      GO TO 360
  320 FSI3= ZP5*SQPI*XP1*(ALFA*(TLF2-SP5)+OP5*(TLF2+FIV)*DAWFS)/ALF4
      GO TO 360
  330 FSI3=(2.0d0*XP0*ALFA*(ALF2-SP5)+(TLF2*(ALF2-THR)+SP5)*ERRFS)/ALF4
      GO TO 360
  340 FSI3= SQPI*XP1*(ALFA*(TLF2*(TLF2-FIV)+FIF)-FIF*DAWFS)/ALF4
      GO TO 360
  350 FSI3=(2.0d0*XP0*ALFA*(TLF2*(TLF2-1.0d0-THR)+FIF)+                 &
            (TLF2*(TLF2*(TLF2-THR)+SIX+THR)-FIF)*ERRFS)/ALF4
  360 FSI = FSI3
      RETURN
      END
      
! FSIPS
      DOUBLE PRECISION FUNCTION FSIPS(N,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FICMN / ALFA,XI,XP0,XP1
      PARAMETER (LIMA=10)
      DIMENSION FCTRL(10),DFCTRL(10)
      DATA  FCTRL/1.0d0,1.0d0,2.0D+00,6.0D+00,24.0D+00,120.0D+00,       &
                  720.0D+00,5040.0D+00,40320.0D+00,362880.0D+00/         
      DATA DFCTRL/1.0d0,1.0d0,3.0D+00,15.0D+00,105.0D+00,945.0D+00,     &
                  10395.0D+00,135135.0D+00,2027025.0D+00,34459425.0D+00/
      DATA SQPI/1.772453850905D+00/
!
      NL= N+L
      LAMBDA=NL/2
      IF(MOD(NL,2)/=0) THEN
         T  =  FCTRL(LAMBDA+1)/DFCTRL(L+2)
         FAC= 2.0d0**NL
      ELSE
         T  = DFCTRL(LAMBDA+1)/DFCTRL(L+2)
         FAC=(2.0d0**LAMBDA)*SQPI
      ENDIF
      L2= L+L+1
      X = ALFA*ALFA
      SUM= T
      DO 110 K=1,LIMA
         T =(T*X*(K+K+NL-1))/(K*(K+K+L2))
  110 SUM= SUM+T
      FSIPS = FAC*XP0*(ALFA**L)*SUM
      RETURN
      END

! RECUR
      SUBROUTINE RECUR(NMIN,NMAX,LMAX,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FSICMN/ SI(30,7)
!
      TWX= X+X
      T01=(NMIN-2.0d0)*2.0d0
      IF(LMAX<2) THEN
         DO 110 N=NMIN,NMAX,2
            T02= T01+2.0d0
            SI(N+1,1)= T02*SI(N-1,1)+TWX*SI(N  ,2)
            SI(N+2,2)= T01*SI(N  ,2)+TWX*SI(N+1,1)
  110    T01= T02+2.0d0
      ELSE IF(LMAX==3) THEN
         DO 120 N=NMIN,NMAX,2
            T02= T01+2.0d0
            SI(N+1,1)= T02*SI(N-1,1)+TWX*SI(N  ,2)
            SI(N+2,2)= T01*SI(N  ,2)+TWX*SI(N+1,1)
            SI(N+3,3)= T01*SI(N+1,3)+TWX*SI(N+2,2)
  120    T01= T02+2.0d0
      ELSE
         DO 130 N=NMIN,NMAX,2
            T02= T01+2.0d0
            SI(N+1,1)= T02*SI(N-1,1)+TWX*SI(N  ,2)
            SI(N+2,2)= T01*SI(N  ,2)+TWX*SI(N+1,1)
            SI(N+3,3)= T01*SI(N+1,3)+TWX*SI(N+2,2)
            SI(N+4,4)= T01*SI(N+2,4)+TWX*SI(N+3,3)
            SI(N+5,5)= T01*SI(N+3,5)+TWX*SI(N+4,4)
            SI(N+6,6)= T01*SI(N+4,6)+TWX*SI(N+5,5)
            SI(N+7,7)= T01*SI(N+5,7)+TWX*SI(N+6,6)
  130    T01= T02+2.0d0
      END IF
      RETURN
      END
      
! SITABL
      SUBROUTINE SITABL(LEMAX,LOMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /FICMN / ALFI,XI,XP0,XP1
      COMMON /FJCMN / ALFJ,BETJ,XJ,XPLS,XMNS,XP
      COMMON /FSICMN/ SI(30,7)
!
      IF((ALFJ-BETJ)<=0.0D+00) THEN
         ALFI= BETJ
         XP1 = XMNS
      ELSE
         ALFI= ALFJ
         XP1 = XPLS
      END IF
      X   = ALFI
      XI  = XJ
      XP0 = XP
      SI(1,1)= FSI0(0)
      SI(2,2)= FSI1(1)
      IF(LEMAX<=1) GO TO 110
      SI(3,3)= FSI2(2)
      IF(LEMAX==2) GO TO 110
      SI(4,4)= FSI3(3)
      IF(LEMAX==3) GO TO 110
      SI(5,5)= FSIPS(4,4)
      IF(LEMAX==4) GO TO 110
      SI(6,6)= FSIPS(5,5)
      IF(LEMAX==5) GO TO 110
      SI(7,7)= FSIPS(6,6)
  110 CONTINUE
      CALL RECUR(2,22,LEMAX,X)
      SI(1,2)= FSI1(0)
      SI(2,1)= FSI0(1)
      SI(3,2)= FSI1(2)
      IF(LOMAX<=1) GO TO 120
      SI(4,3)= FSI2(3)
      IF(LOMAX==2) GO TO 120
      SI(5,4)= FSI3(4)
      IF(LOMAX==3) GO TO 120
      SI(6,5)= FSIPS(4,5)
      IF(LOMAX==4) GO TO 120
      SI(7,6)= FSIPS(5,6)
      IF(LOMAX==5) GO TO 120
      SI(8,7)= FSIPS(6,7)
  120 CONTINUE
      CALL RECUR(3,21,LOMAX,X)
      RETURN
      END
      
! ZFN
      SUBROUTINE ZFN(ZFNLM,LMAX,ZLM,LMF,LMX,LMY,LMZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION ZLM(*)
      DIMENSION ZFNLM(121),LMF(*),LMX(*),LMY(*),LMZ(*)
      COMMON /ZFNCM / X,Y,Z
!
      IF(LMAX<=10) THEN
         DO 130 L=0,LMAX
            ID= L*(L+1)+L+1
            DO 120 M=-L,L
               IMN= LMF(ID)
               IMX= LMF(ID+1)-1
               SUM= 0.0d0
               DO 110 I=IMN,IMX
                  DUMMY = ZLM(I)
                  IF(LMX(I)>0) DUMMY= DUMMY*(X**LMX(I))
                  IF(LMY(I)>0) DUMMY= DUMMY*(Y**LMY(I))
                  IF(LMZ(I)>0) DUMMY= DUMMY*(Z**LMZ(I))
  110          SUM= SUM+DUMMY
               ZFNLM(ID)= SUM
  120       ID= ID-1
  130    CONTINUE
      ELSE
         WRITE(6,9010) LMAX
         CALL ABRT
      END IF
      RETURN
 9010 FORMAT(' ERROR: ZFN MAX LAMDA=10, YOU REQUESTED LAMDA = ',I3)
      END

! ECPCBA
      SUBROUTINE ECPCBA(CANDA,AANDB,ICAB,IPOW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL CANDA,AANDB
      COMMON /ECP1  / X01,CAX,CAY,CAZ,CA,XCA,YCA,ZCA,                   &
                      X02,BAX,BAY,BAZ,BA,XBA,YBA,ZBA,                   &
                      PHASE,DAX,DAY,DAZ,DA,XDA,YDA,ZDA,XINT,KCNTR
      LOGICAL CANDB
      COMMON /ECP4  / P12(3,2),R12,ACO(3),CANDB
      COMMON /ZFNCM / X,Y,Z

      IF(CANDA) THEN
         IF(AANDB) THEN
            ICAB = 1
         ELSE
            CAX= 0.0d0
            CAY= 0.0d0
            CAZ= 0.0d0
            CA = 0.0d0
            BAX= P12(1,2)-ACO(1)
            BAY= P12(2,2)-ACO(2)
            BAZ= P12(3,2)-ACO(3)
            BA = SQRT(BAX*BAX+BAY*BAY+BAZ*BAZ)
            X  = BAX/BA
            Y  = BAY/BA
            Z  = BAZ/BA
            ICAB= 2
            IPOW= 1
         END IF
      ELSE
         IF(AANDB) THEN
            CAX= P12(1,1)-ACO(1)
            CAY= P12(2,1)-ACO(2)
            CAZ= P12(3,1)-ACO(3)
            CA = SQRT(CAX*CAX+CAY*CAY+CAZ*CAZ)
            X  = CAX/CA
            Y  = CAY/CA
            Z  = CAZ/CA
            BAX= 0.0d0
            BAY= 0.0d0
            BAZ= 0.0d0
            BA = 0.0d0
            ICAB= 3
            IPOW=-1
         ELSE
            CAX= P12(1,1)-ACO(1)
            CAY= P12(2,1)-ACO(2)
            CAZ= P12(3,1)-ACO(3)
            CA = SQRT(CAX*CAX+CAY*CAY+CAZ*CAZ)
            XCA= CAX/CA
            YCA= CAY/CA
            ZCA= CAZ/CA
            BAX= P12(1,2)-ACO(1)
            BAY= P12(2,2)-ACO(2)
            BAZ= P12(3,2)-ACO(3)
            BA = SQRT(BAX*BAX+BAY*BAY+BAZ*BAZ)
            XBA= BAX/BA
            YBA= BAY/BA
            ZBA= BAZ/BA
            ICAB= 4
            IPOW= 0
         END IF
      END IF
      RETURN
      END

!----------------------------------------------------------------------!
!                                                                      !
!       2020 Use Libreta open source library for ERI calculation       !                                                                      !                                                                      !
!  implemented by Juan Felipe Huan Lew Yee and Jorge Martin del Campo  ! 
!                                                                      !
!----------------------------------------------------------------------!
      
! HSandTlib                                           
      SUBROUTINE HSandTlib(H,S,TKIN,NBFT,KATOM,KLOC,KMIN,KMAX,NSHELL,   &
                           ZAN,C)        
      USE ISO_C_BINDING
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S,TKIN
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      LOGICAL     LINEAR
      COMMON/ZMAT/LINEAR      
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB 
      LOGICAL IIANDJJ
      INTEGER,DIMENSION(NSHELL) :: KATOM,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: C
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: Z,SBLK,TBLK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: VBLK,ZBLK
      ALLOCATE(Z(NBFT))
      ALLOCATE(SBLK(784),TBLK(784),VBLK(784),ZBLK(784))
!-----------------------------------------------------------------------
!                      H, S & TKIN integrals
!-----------------------------------------------------------------------
      ZBLK = 0.0D+00
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     I SHELL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO III = 1,NSHELL
       I = KATOM(III)
       MINI = KMIN(III)
       MAXI = KMAX(III)
       LOCI = KLOC(III)-MINI
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      J SHELL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO JJ = 1,III
        J = KATOM(JJ)
        MINJ = KMIN(JJ)
        MAXJ = KMAX(JJ)
        LOCJ = KLOC(JJ)-MINJ
        IIANDJJ = III == JJ
!       Call to libreta
!lib        CALL sval(BASLIB,III,JJ,SBLK)
!lib        CALL tval(BASLIB,III,JJ,TBLK)
!lib        CALL vval(BASLIB,III,JJ,NAT,C(1,1:NAT),C(2,1:NAT),C(3,1:NAT),   &
!lib                  ZAN(1:NAT),VBLK)
!
        JMAX = MAXJ
        NN = 0
        DO I = MINI,MAXI
         LI = LOCI+I
         IN = (LI*(LI-1))/2
         IF (IIANDJJ) JMAX = I
         DO J = MINJ,JMAX
          LJ = LOCJ+J
          JN = LJ+IN
          NN = NN+1
          H(JN) =  TBLK(NN) + VBLK(NN)
          S(JN) =  SBLK(NN)
          TKIN(JN) =  TBLK(NN)
          IF(LINEAR) Z(JN) = ZBLK(NN)
         END DO
        END DO
       END DO
      END DO
!-----------------------------------------------------------------------
      DEALLOCATE(Z,SBLK,TBLK,VBLK,ZBLK)
      RETURN
      END

! PRCALClib                                           
      SUBROUTINE PRCALClib(XVAL,WINT,NVAL,L2,KATOM,KLOC,KMIN,KMAX,NSHELL)               
      USE ISO_C_BINDING              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      LOGICAL IIANDJJ
      INTEGER,DIMENSION(NSHELL) :: KATOM,KLOC,KMIN,KMAX
      DIMENSION XVAL(NVAL*L2),WINT(*)                                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO II=1,NSHELL
       I    = KATOM(II)
       MINI = KMIN(II)
       MAXI = KMAX(II)
       LOCI = KLOC(II) - MINI
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO JJ=1,II
        J    = KATOM(JJ)
        MINJ = KMIN(JJ)
        MAXJ = KMAX(JJ)
        LOCJ = KLOC(JJ) - MINJ
        IIandJJ = II==JJ
        IJ = 0
        JMAX = MAXJ
        DO I=MINI,MAXI
         IF (IIandJJ) JMAX = I
         DO J=MINJ,JMAX
          IJ = IJ+1
         END DO
        END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!          Integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!lib        CALL DIPVAL(BASLIB,II,JJ,WINT)
        JMAX = MAXJ
        DO K=1,NVAL
         NL2 = (K-1)*L2
         NN  = (K-1)*IJ
         DO I=MINI,MAXI
          LI = LOCI + I
          IN = LI*(LI-1)/2 + NL2
          IF (IIandJJ) JMAX = I
          DO J=MINJ,JMAX
           LJ = LOCJ + J
           JN = LJ + IN
           NN = NN+1
           XVAL(JN) = WINT(NN)
          END DO
         END DO
        END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

! ExchangeIntlib                                           
      SUBROUTINE ExchangeIntlib(XINTS,GLIBRETA,NSH2,MAXG,               &
                                KTYPE,KMIN,KMAX,NSHELL)   
      USE ISO_C_BINDING              
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      INTEGER,DIMENSION(NSHELL) :: KTYPE,KMIN,KMAX
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)  
      COMMON/SHLNOS1/QQ4,IJKL                                                                              
      DIMENSION XINTS(NSH2),GLIBRETA(MAXG)
      LOGICAL ISHandJSH
      INTEGER::ORII,ORIJ
!-----------------------------------------------------------------------
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      NANGM =  4                                          
      IF(LMAXIMA==2) NANGM =  6                                          
      IF(LMAXIMA==3) NANGM = 10                                          
      IF(LMAXIMA==4) NANGM = 15                                          
      IF(LMAXIMA==5) NANGM = 21                                          
      IF(LMAXIMA==6) NANGM = 28                                          
      NGTH(4) = 1                                                       
      NGTH(3) = NGTH(4) * NANGM                                         
      NGTH(2) = NGTH(3) * NANGM                                         
      NGTH(1) = NGTH(2) * NANGM                                         
      DO I=1,3                                                       
       NORGSH(I) = 0                                               
       NORGSP(I) = 0                                               
      ENDDO                                                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEXCH = 1                                                         
      QQ4   = 1.0d0                                                       
      NINTEG  = 0  
!- - - - - - - - - - - - - - - - - - - - - - - -
      IJIJ = 0
      DO ISH = 1,NSHELL
       DO JSH = 1,ISH
        IJIJ = IJIJ+1
        VMAX = 0.0D+00
        MINI = KMIN(ISH)
        MINJ = KMIN(JSH)
        MAXI = KMAX(ISH)
        JMAX = KMAX(JSH)
        ISHandJSH=ISH==JSH
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ORII = KMAX(ISH) - KMIN(ISH) + 1
        ORIJ = KMAX(JSH) - KMIN(JSH) + 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        JMAX = ORIJ
        DO I=1,ORII
         IF(ISHandJSH) JMAX = I
          DO J=1,JMAX
!lib          CALL erisval(BASLIB,ISH,JSH,ISH,JSH,GLIBRETA)
          IJKL_INDEX = (I-1)*ORIJ*ORII*ORIJ                             &
                     + (J-1)*ORII*ORIJ+(I-1)*ORIJ + (J-1)+1
          VAL = GLIBRETA(IJKL_INDEX)
          IF(VAL>0.0D+00)NINTEG = NINTEG + 1
          IF(VAL>VMAX)VMAX=VAL
         END DO
        END DO
        XINTS(IJIJ) = SQRT(VMAX)
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

! QOUTlib
      SUBROUTINE QOUTlib(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,GLIBRETA,    &
                         IDONTW,ISH,JSH,KSH,LSH,KLOC,KMIN,KMAX,NSHELL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL IANDJ,KANDL,SAME
      COMMON/MISC/IANDJ,KANDL,SAME
      COMMON /RESTAR/NREC,IST,JST,KST,LST
      COMMON/SHLT/SHLTOL,CUTOFF,ICOUNT
      COMMON/SHLNOS/LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,MINI,MINJ,MINK, &
                    MINL,MAXI,MAXJ,MAXK,MAXL,NIJ,IJ,KL
      INTEGER :: ORII,ORIJ,ORIK,ORIL,ISH,JSH,KSH,LSH
      INTEGER,DIMENSION(NSHELL) :: KLOC,KMIN,KMAX
      INTEGER,DIMENSION(NINTEGtm) :: IX2                                 
      DIMENSION BUFP(NINTMX),IX(NINTMX),GLIBRETA(*)
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2                      
      SAVE IJN,KLN
!-----------------------------------------------------------------------
!     Pack 4-indices into 1 word.
!     Write Label & integral on Unit 1 if DONTW = .False.
!-----------------------------------------------------------------------
      SAME  = ISH == KSH .and. JSH == LSH
      IANDJ = ISH == JSH
      KANDL = KSH == LSH
      MINI = KMIN(ISH)
      MINJ = KMIN(JSH)
      MINK = KMIN(KSH)
      MINL = KMIN(LSH)
      MAXI = KMAX(ISH)
      MAXJ = KMAX(JSH)
      MAXK = KMAX(KSH)
      MAXL = KMAX(LSH)
      LOCI = KLOC(ISH)-MINI
      LOCJ = KLOC(JSH)-MINJ
      LOCK = KLOC(KSH)-MINK
      LOCL = KLOC(LSH)-MINL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ORII = MAXI - MINI + 1
      ORIJ = MAXJ - MINJ + 1
      ORIK = MAXK - MINK + 1
      ORIL = MAXL - MINL + 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IJN = 0
      JMAX = ORIJ
      DO I = 1,ORII
       I_INDEX = (I-1)*ORIJ*ORIK*ORIL
       IF (IANDJ) JMAX = I
       DO 1 J = 1,JMAX
        IJ_INDEX = (J-1)*ORIK*ORIL + I_INDEX
        IJN = IJN+1
        LMAX = ORIL
        KLN = 0
        DO K = 1,ORIK
         IJK_INDEX = (K-1)*ORIL + IJ_INDEX
         IF (KANDL) LMAX = K
         DO L = 1,LMAX
          KLN = KLN+1
          IF(SAME.and.KLN>IJN)GO TO 1
          IJKL_INDEX = (L-1) + IJK_INDEX + 1
          VAL = GLIBRETA( IJKL_INDEX )
          IF(ABS(VAL)>=CUTOFF)THEN
           I1 = LOCI+I+MINI-1
           I2 = LOCJ+J+MINJ-1
           I3 = LOCK+K+MINK-1
           I4 = LOCL+L+MINL-1

           IF (I1 >= I2) GO TO 100
           N = I1
           I1 = I2
           I2 = N
  100      IF (I3 >= I4) GO TO 120
           N = I3
           I3 = I4
           I4 = N
  120      IF (I1-I3) 140,160,180
  140      N = I1
           I1 = I3
           I3 = N
           N = I2
           I2 = I4
           I4 = N
           GO TO 180
  160      IF (I2 < I4) GO TO 140
  180      CONTINUE
!
           IF(I1 == I2) VAL = VAL*0.5D0
           IF(I3 == I4) VAL = VAL*0.5D0
           IF(I1 == I3 .and. I2 == I4) VAL = VAL*0.5D0
!
           NPACK = ICOUNT
           IPACK = I1
           JPACK = I2
           KPACK = I3
           LPACK = I4
           LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 ) +            &
                   ISHFT( KPACK, 16 ) + LPACK
           IX(NPACK) = LABEL
           BUFP(ICOUNT) = VAL
           ICOUNT = ICOUNT+1
           IF(ICOUNT > 0) THEN
            JCOUNT = ICOUNT
            IF(JCOUNT > NINTMX) THEN
             NXInteg = NINTMX
             IF(IDONTW==1)THEN
              IJBUFi = (NREC-1)*NINTMX
              do ibuf=1,NINTMX
               IX2  (IJBUFi+ibuf) = IX(ibuf)
               BUFP2(IJBUFi+ibuf) = BUFP(ibuf)
              end do
             ELSE
              WRITE(1)NXInteg,IX,BUFP
             END IF
             ICOUNT = 1
             NREC = NREC+1
            END IF
           END IF
          END IF
         END DO
        END DO
    1  CONTINUE
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

! UPDCOOSHELL
      SUBROUTINE UPDCOOSHELL(NSHELL,KATOM,Cxyz,NAT)     
      USE ISO_C_BINDING
      INTEGER :: NSHELL,NAT 
      INTEGER,DIMENSION(NSHELL) :: KATOM
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz 
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
      TYPE(C_PTR),DIMENSION(500)::BASLIB,AUXLIB
      COMMON/LIBRETA/BASLIB
      COMMON/LIBRETAaux/AUXLIB
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)      
      INTEGER :: I,IATOM
!-----------------------------------------------------------------------      
!     Update coordinates of shells
!-----------------------------------------------------------------------
      if(IERITYP==1 .or. IERITYP==3)then      ! ERITYP = FULL or MIX
       DO I=1,NSHELL
        IATOM = KATOM(I)
!lib        CALL updatebasis(BASLIB,I,Cxyz(1:3,IATOM))
       END DO
      end if 
      if(IERITYP==2 .or. IERITYP==3)then      ! ERITYP = RI or MIX
       DO I=1,NSHELLaux
        IATOM = KATOMaux(I)
!lib        CALL updatebasis(AUXLIB,I,Cxyz(1:3,IATOM))
       END DO      
      end if       
!-----------------------------------------------------------------------      
      RETURN
      END
            
!----------------------------------------------------------------------!
!                                                                      !
!       2020  RI Approximation for ERIs implemented by                 !
!             Juan Felipe Huan Lew Yee and Jorge Martin del Campo      ! 
!             ( J. Chem. Phys. ..., ......, 2021 )                     !
!                                                                      !
!----------------------------------------------------------------------!

! AUXGEN
      SUBROUTINE AUXGEN(NAT,NPRIMI,ITYP,IMIN,IMAX,NSHELLaux,NUMaux,     &
                        IGEN,ISTAR,EX,ZAN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                         
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
      COMMON/EXCaux/EXaux(2000),Caux(2000)
!
      INTEGER::IGEN,N
      INTEGER,DIMENSION(NAT) :: IMIN,IMAX
      INTEGER,DIMENSION(NPRIMI) :: ITYP
      INTEGER,DIMENSION(NAT) :: LMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX
      DOUBLE PRECISION,DIMENSION(NAT) :: EXMAX,EXMIN,ZAN
      DOUBLE PRECISION :: COEFICIENT

      DO IAT=1,NAT
       MINI = IMIN(IAT)
       MAXI = IMAX(IAT)
       LMAX(IAT) = MAXVAL(ITYP(MINI:MAXI)) - 1
       EXMAX(IAT) = MAXVAL(EX(MINI:MAXI))
       EXMIN(IAT) = MINVAL(EX(MINI:MAXI))
      END DO

      NUMaux = 0
      NSHELLaux = 0
      DO IAT=1,NAT

        lbmax = LMAX(IAT)
        zbmax = EXMAX(IAT)
        zbmin = EXMIN(IAT)

        r = 6.0 - IGEN

        nblock = 2
        if(ISTAR==1) nblock = nblock + 1

!       H and He
        if (ZAN(IAT).LE.2) then
          r = r - 0.5*IGEN + 2.0
          nblock = nblock - 1
        end if

!       How many z?
        N = int(log(zbmax/zbmin)/log(r) + 0.5)

        zmin = zbmin
        zmax= zmin*r**(N-1)
        zmax= 2.0*zmax

        TMPEXP = zmax*r

        do iblock=1,nblock
          if (iblock==1) then
            nauxis = max(1,N/nblock + mod(N,nblock))
          else
            nauxis = max(1,N/nblock)
          end if
          do ifa=1,nauxis
            TMPEXP = TMPEXP/r
            if (ifa==1) TMPEXP = TMPEXP*(r+0.5*IGEN)/r
            do L=0,2*(iblock-1)
              NSHELLaux = NSHELLaux + 1
              KLOCaux(NSHELLaux) = NUMaux+1
              NUMaux = NUMaux + (L+1)*(L+2)/2
              KTYPEaux(NSHELLaux) = L+1
              KATOMaux(NSHELLaux) = IAT
              EXaux(NSHELLaux) = TMPEXP
              CALL NORMALIZE_AUXILIAR(TMPEXP,COEFICIENT,L)
              Caux(NSHELLaux) = COEFICIENT
            END DO
            if (ifa==1) TMPEXP = TMPEXP*r/(r+0.5*IGEN)
          END DO
       END DO
      END DO
      RETURN
      END
      
! NORMALIZE_AUXILIAR
      SUBROUTINE NORMALIZE_AUXILIAR(EX,COEFICIENT,L)
      IMPLICIT NONE
      INTEGER :: L
      DOUBLE PRECISION :: EX,COEFICIENT
      DOUBLE PRECISION,PARAMETER :: PT2953=29.53125D0
      DOUBLE PRECISION,PARAMETER :: PT1624=162.421875D0
      DOUBLE PRECISION,PARAMETER :: PT75=0.75D0
      DOUBLE PRECISION,PARAMETER :: PT187=1.875D0
      DOUBLE PRECISION,PARAMETER :: PT6562=6.5625D0
      DOUBLE PRECISION :: PI,PI32,EE,FACS,FACP,FACD,FACF,FACG,FACH,FACI
      PI = 2.0d0*DASIN(1.0d0)
      PI32 = PI*SQRT(PI)                                              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
!      Normalize Primitive Basis Functions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
      EE = EX+EX
      FACS = PI32/(EE*SQRT(EE))
      FACP = 0.5D0*FACS/EE
      FACD = PT75  *FACS/(EE*EE)
      FACF = PT187 *FACS/(EE**3)
      FACG = PT6562*FACS/(EE**4)
      FACH = PT2953*FACS/(EE**5)
      FACI = PT1624*FACS/(EE**6)
      IF(L==0) COEFICIENT = 1/SQRT(FACS)
      IF(L==1) COEFICIENT = 1/SQRT(FACP)
      IF(L==2) COEFICIENT = 1/SQRT(FACD)
      IF(L==3) COEFICIENT = 1/SQRT(FACF)
      IF(L==4) COEFICIENT = 1/SQRT(FACG)
      IF(L==5) COEFICIENT = 1/SQRT(FACH)
      IF(L==6) COEFICIENT = 1/SQRT(FACI)
!-----------------------------------------------------------------------
      END

! AUXGENlib
      SUBROUTINE AUXGENlib(NAT,NPRIMI,ITYP,IMIN,IMAX,NSHELLaux,         &
                           NUMaux,EX,ZAN,Cxyz)
      USE ISO_C_BINDING
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                         
!
      INTEGER :: NPRIMI,NSHELLaux,NUMaux            
      INTEGER,DIMENSION(NPRIMI) :: ITYP      
      INTEGER,DIMENSION(NAT) :: IMIN,IMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX      
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz      
!
      TYPE(C_PTR),DIMENSION(500)::AUXLIB
      COMMON/LIBRETAaux/AUXLIB
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
!      
      INTEGER,DIMENSION(NAT)::LMAX
      DOUBLE PRECISION,DIMENSION(NAT)::EXMAX,EXMIN
      INTEGER::IAT,N,MINI,MAXI,lbmax,nblock,iblock,nauxis,ifa,L
!-----------------------------------------------------------------------
!     AUXGEN generates the GEN-An* auxiliary basis   
!-----------------------------------------------------------------------
      do IAT=1,NAT
       MINI = IMIN(IAT)
       MAXI = IMAX(IAT)
       LMAX(IAT)  = MAXVAL(ITYP(MINI:MAXI)) - 1
       EXMAX(IAT) = MAXVAL(EX(MINI:MAXI))
       EXMIN(IAT) = MINVAL(EX(MINI:MAXI))
      end do
!
      NUMaux = 0
      NSHELLaux = 0
      do IAT=1,NAT
       lbmax = LMAX(IAT)
       zbmax = EXMAX(IAT)
       zbmin = EXMIN(IAT)
       r = 6.0 - IGEN
       nblock = 2
       if(ISTAR==1) nblock = nblock + 1
!      H and He
       if (ZAN(IAT)<=2) then
         r = r - 0.5*IGEN + 2.0
         nblock = nblock - 1
       end if
!      How many z?
       N = int(log(zbmax/zbmin)/log(r) + 0.5)
       zmin = zbmin
       zmax= zmin*r**(N-1)
       zmax= 2.0*zmax
       TMPEXP = zmax*r
       do iblock=1,nblock
        if (iblock==1) then
          nauxis = max(1,N/nblock + mod(N,nblock))
        else
          nauxis = max(1,N/nblock)
        end if
        do ifa=1,nauxis
         TMPEXP = TMPEXP/r
         if (ifa==1) TMPEXP = TMPEXP*(r+0.5*IGEN)/r
         do L=0,2*(iblock-1)
          NSHELLaux = NSHELLaux + 1
          KLOCaux(NSHELLaux) = NUMaux+1
          NUMaux = NUMaux + (L+1)*(L+2)/2
          KTYPEaux(NSHELLaux) = L+1
          KATOMaux(NSHELLaux) = IAT
!lib          CALL CREATEBASISaux(AUXLIB(NSHELLaux),TMPEXP,1.0,             &
!lib                              Cxyz(1:3,IAT),L,1)
         end do
         if (ifa==1) TMPEXP = TMPEXP*r/(r+0.5*IGEN)
        end do
       end do
      end do
!-----------------------------------------------------------------------      
      RETURN
      END

! JandKaux                
      SUBROUTINE JandKaux(BUFP2,NINTEGtm,IDONTW,IPRINTOPT,NBF,          &
                          EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,KATOM,  &
                          KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/USELIBRETA/ILIBRETA
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      INTEGER :: IPRINTOPT
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: Gaux
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
!-----------------------------------------------------------------------
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
!-----------------------------------------------------------------------
!     Driver for 2e integrals (Libreta)
!-----------------------------------------------------------------------
      call cpu_time(timestarttwoE)
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      MAXG = 4**4
      IF(LMAXIMA==2)MAXG =  6**4
      IF(LMAXIMA==3)MAXG = 10**4
      IF(LMAXIMA==4)MAXG = 15**4
      IF(LMAXIMA==5)MAXG = 21**4
      IF(LMAXIMA==6)MAXG = 28**4
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Debut
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL Debut(IDONTW,IPRINTOPT,KATOM,NSHELL,Cxyz)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     2e integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL BASCHK(LAUXMAXIMA,KTYPEaux,NSHELLaux)
      MAXORI = (LMAXIMA+1)*(LMAXIMA+2)/2
      MAXORIAUX = (LAUXMAXIMA+1)*(LAUXMAXIMA+2)/2
      MAXG = MAX(MAXORI*MAXORI*MAXORIAUX,MAXORIAUX*MAXORIAUX)
!
      ALLOCATE(Gaux(MAXG))
      IF(.NOT.SMCD) THEN      
       if(ILIBRETA==0)then
        CALL AuxERI(NINTEGtm,BUFP2,Gaux,MAXG,NBF,IPRINTOPT,             &
                    EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,KATOM,        &
                    KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz,NAT)
       else if(ILIBRETA==1)then
        CALL AuxERIlib(NINTEGtm,BUFP2,Gaux,MAXG,MAXORI,NBF,             &
                       KTYPE,KLOC,NSHELL,IPRINTOPT)
       end if
      ELSE IF(SMCD) THEN
       CALL AuxERIModChol(NINTEGtm,BUFP2,Gaux,MAXG,NBF,IPRINTOPT,       &
                          EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,KATOM,  &
                          KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz,NAT)             
      END IF
      DEALLOCATE(Gaux)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      call cpu_time(timefinishtwoE)
      DeltaTtwoE = timefinishtwoE - timestarttwoE
      IF(IPRINTOPT==1)                                                  &
       WRITE(6,'(1X,A22,F10.2)')'Time to do integrals =',DeltaTtwoE
!-----------------------------------------------------------------------
      RETURN
      END
      
! AuxERI                                            
      SUBROUTINE AuxERI(NINTEGtm,BUFP2,GHONDO,MAXG,NBF,IPRINTOPT,       &
                        EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,KATOM,    &
                        KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,Cxyz,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)     
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)     
      COMMON/RESTAR/NREC,IST,JST,KST,LST 
      COMMON/SHLNOS1/QQ4,IJKL
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)
!
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      INTEGER :: IPRINTOPT
      DIMENSION GHONDO(MAXG)
      DOUBLE PRECISION,DIMENSION(NBFaux,NBFaux)::GMAT
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX
!-----------------------------------------------------------------------
      ALLOCATE(AUX(49*900))
      BUFP2(:) = 0.0D0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Evaluate G = (P|Q) and G^{-1/2}
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL METRICmat(GMAT,GHONDO,MAXG,Cxyz,NAT)
      CALL PDPT_msqrt(GMAT,NBFaux,IPRINTOPT) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     2e- Integrals (S,P,D,F,G & L Shells)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      CALL BASCHK(LMAXIMAaux,KTYPEaux,NSHELLaux)
      NANGM =  4                                          
      IF(LMAXIMA==2) NANGM =  6                                         
      IF(LMAXIMA==3) NANGM = 10                                         
      IF(LMAXIMA==4) NANGM = 15                                         
      IF(LMAXIMA==5) NANGM = 21                                         
      IF(LMAXIMA==6) NANGM = 28                                         
      NANGMaux =  4                                         
      IF(LMAXIMAaux==2) NANGMaux =  6                                   
      IF(LMAXIMAaux==3) NANGMaux = 10                                  
      IF(LMAXIMAaux==4) NANGMaux = 15                                   
      IF(LMAXIMAaux==5) NANGMaux = 21                                   
      IF(LMAXIMAaux==6) NANGMaux = 28                                   
      NGTH(4) = 1                                                       
      NGTH(3) = NGTH(4) * 1                                      
      NGTH(2) = NGTH(3) * NANGMaux                                      
      NGTH(1) = NGTH(2) * NANGM                                         
!
      NORGSH = 0                                               
      NORGSP = 0    
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO II = IST,NSHELL                            
       J0 = JST                                                       
       DO JJ = J0,II                                               
        JST = 1                                                        
        K0 = KST                                                        
        DO KK = K0,NSHELLaux                     
         KST = 1                                                        
!- - - - - - - - - - - - - - - - - - - - - - - -
!        (II,JJ//KK)                                        
!- - - - - - - - - - - - - - - - - - - - - - - -                            
         IEXCH = 1                                                     
         ISH = II                                                      
         JSH = JJ                                                      
         KSH = KK                                                      
         QQ4 = 1                                                       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!         Compute 2e- Integrals (mn|k)                  
!         Select integral code for ERI calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         LQSUM = KTYPE(ISH) + KTYPE(JSH) + KTYPEaux(KSH) - 3     
         CALL SHELLS3C(1,ISH,JSH,KSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,    &
                       NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,    &
                       NSHELL,Cxyz,NAT)                       
         CALL IJPRIM(AUX)                                          
         CALL SHELLS3C(2,ISH,JSH,KSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,    &
                       NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,    &
                       NSHELL,Cxyz,NAT)                       
         NORGH = NORGSH(IEXCH)                                        
         CALL ZQOUT(GHONDO,MAXG)                                
         IF(LQSUM==0) THEN                                             
          CALL S0000(GHONDO(1+NORGH),AUX)                        
         ELSE                                                         
         CALL ERISPDFGHIL(GHONDO(1+NORGH),AUX)                       
         END IF                                                       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!         Contract to B tensor
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
         CALL QOUT3C(BUFP2,GHONDO,MAXG,GMAT,NBF,NBFaux,                 &
                     KLOC,KMIN,KMAX,NSHELL)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
        END DO
       END DO
      END DO
      DEALLOCATE(AUX)                                                 
!-----------------------------------------------------------------------
      RETURN                                                            
      END     

! AuxERIlib
      SUBROUTINE AuxERIlib(NINTEGtm,BUFP2,GLIBRETA,MAXG,MAXORI,NBF,     &
                           KTYPE,KLOC,NSHELL,IPRINTOPT)
      USE ISO_C_BINDING
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER :: ORII,ORIJ,ORIK      
      COMMON/ORI/ORII,ORIJ,ORIK            
      COMMON/RESTAR/NREC,IST,JST,KST,LST                 
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)      
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)      
!      
      TYPE(C_PTR),DIMENSION(500)::BASLIB,AUXLIB
      COMMON/LIBRETA/BASLIB
      COMMON/LIBRETAaux/AUXLIB
!      
      INTEGER,DIMENSION(NSHELL) :: KTYPE,KLOC      
      DOUBLE PRECISION :: GLIBRETA(MAXG),BUFP2(NINTEGtm)
      DOUBLE PRECISION :: GMAT(NBFaux,NBFaux)
      DOUBLE PRECISION :: ERIS3C(MAXORI*MAXORI*NBFaux)
!-----------------------------------------------------------------------
!lib      CALL metric_mat(NBFaux,GMAT,NSHELLaux,AUXLIB)
      CALL PDPT_msqrt(GMAT,NBFaux,IPRINTOPT)
!
      DO II = IST,NSHELL                            ! II Shell
       J0 = JST                                     ! JJ Shell
       DO JJ = J0,II
        JST = 1
        K0 = KST
        LI = KTYPE(II)
        LJ = KTYPE(JJ)
        ORII = LI*(LI+1)/2
        ORIJ = LJ*(LJ+1)/2
        ERIS3C(1:ORII*ORIJ*NBFaux) = 0.0d0
        DO KK = K0,NSHELLaux                        ! KK Shell
         KST = 1
!- - - - - - - - - - - - - - - - - - - - - - - -
!         (II,JJ//P)
!- - - - - - - - - - - - - - - - - - - - - - - -
          ISH = II
          JSH = JJ
          KSH = KK
          QQ4 = 1
          !IF(SKIPA .and. NPSYM) QQ4 = QQ4+1
          !IF(SKIPB .and. NPSYM) QQ4 = QQ4+1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!         Compute 2e- Integrals
!         Select integral code for ERI calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          LK = KTYPEaux(KSH)
          ORIK = LK*(LK+1)/2

!lib          CALL erisval3(BASLIB,AUXLIB,ISH,JSH,KSH,GLIBRETA)

          LOCK = KLOCaux(KSH)
          N = 0
          DO I=1,ORII
           DO J=1,ORIJ
            DO L=1,NBFaux
             N = N + 1
             DO K=1,ORIK
              ERIS3C(N) = ERIS3C(N) +                                   &
              GLIBRETA((I-1)*ORIJ*ORIK+(J-1)*ORIK+K)*GMAT(LOCK+K-1,L)
             END DO
            END DO
           END DO
          END DO
!- - - - - - - - - - - - - - - - - - - - - - - -
        END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Write Label & Integral on File 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL QOUTaux(BUFP2,ERIS3C,NBF,NBFaux,ISH,JSH,KLOC,NSHELL)
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

! AuxERIModChol
      SUBROUTINE AuxERIModChol(NINTEGtm,BUFP2,GHONDO,MAXG,NBF,IPRINTOPT,&
                               EX,CS,CP,CD,CF,CG,CH,CI,NPRIMI,KSTART,   &
                               KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL,   &
                               Cxyz,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
      COMMON/RESTAR/NREC,IST,JST,KST,LST
      COMMON/SHLNOS1/QQ4,IJKL
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)
!
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      INTEGER :: IPRINTOPT
      DIMENSION GHONDO(MAXG)
      DOUBLE PRECISION,DIMENSION(NBFaux,NBFaux)::GMAT,L,D,P
      DOUBLE PRECISION,DIMENSION(NBF*(NBF+1)/2,NBFaux) :: BUFP2
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX

      DOUBLE PRECISION,DIMENSION(NBFaux)::E,DIAG
      INTEGER,DIMENSION(NBFaux)::IPIV
      INTEGER::INFO
      DOUBLE PRECISION,DIMENSION(NBFAUX)::X
      DOUBLE PRECISION,DIMENSION(2*NBFAUX)::WORK
      DOUBLE PRECISION::INI,FIN
!-----------------------------------------------------------------------
      ALLOCATE(AUX(49*900))
!-----------------------------------------------------------------------
!     Evaluate G = (P|Q), G = PLDL^TP^T, ModChol and get P, L, D^1/2
!-----------------------------------------------------------------------
      CALL METRICmat(GMAT,GHONDO,MAXG,Cxyz,NAT)
      CALL LDLT(GMAT,IPIV,E,NBFaux)
      CALL MODCHOL( NBFaux, GMAT, IPIV, E, 1D-10,IPRINTOPT)
      CALL GET_PLD12(GMAT,IPIV,E,NBFaux,P,L,D)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     2e- Integrals (S,P,D,F,G & L Shells)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      CALL BASCHK(LMAXIMAaux,KTYPEaux,NSHELLaux)
      NANGM =  4
      IF(LMAXIMA==2) NANGM =  6
      IF(LMAXIMA==3) NANGM = 10
      IF(LMAXIMA==4) NANGM = 15
      IF(LMAXIMA==5) NANGM = 21
      IF(LMAXIMA==6) NANGM = 28
      NANGMaux =  4
      IF(LMAXIMAaux==2) NANGMaux =  6
      IF(LMAXIMAaux==3) NANGMaux = 10
      IF(LMAXIMAaux==4) NANGMaux = 15
      IF(LMAXIMAaux==5) NANGMaux = 21
      IF(LMAXIMAaux==6) NANGMaux = 28
      NGTH(4) = 1
      NGTH(3) = NGTH(4) * 1
      NGTH(2) = NGTH(3) * NANGMaux
      NGTH(1) = NGTH(2) * NANGM
!
      NORGSH = 0
      NORGSP = 0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO II = IST,NSHELL
       J0 = JST
       DO JJ = J0,II
        JST = 1
        K0 = KST
        DO KK = K0,NSHELLaux
         KST = 1
!- - - - - - - - - - - - - - - - - - - - - - - -
!        (II,JJ//KK)
!- - - - - - - - - - - - - - - - - - - - - - - -
         IEXCH = 1
         ISH = II
         JSH = JJ
         KSH = KK
         QQ4 = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!         Compute 2e- Integrals (mn|k)
!         Select integral code for ERI calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         LQSUM = KTYPE(ISH) + KTYPE(JSH) + KTYPEaux(KSH) - 3
         CALL SHELLS3C(1,ISH,JSH,KSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,    &
                       NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,    &
                       NSHELL,Cxyz,NAT)
         CALL IJPRIM(AUX)
         CALL SHELLS3C(2,ISH,JSH,KSH,.TRUE.,EX,CS,CP,CD,CF,CG,CH,CI,    &
                       NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,    &
                       NSHELL,Cxyz,NAT)
         NORGH = NORGSH(IEXCH)
         CALL ZQOUT(GHONDO,MAXG)
         IF(LQSUM==0) THEN
          CALL S0000(GHONDO(1+NORGH),AUX)
         ELSE
         CALL ERISPDFGHIL(GHONDO(1+NORGH),AUX)
         END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!         Store 3 center ERIs (mn|k)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
         CALL QOUT3CModChol(BUFP2,GHONDO,MAXG,GMAT,NBF,NBFaux,          &
                     KLOC,KMIN,KMAX,NSHELL)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - -
        END DO
       END DO
      END DO
      DEALLOCATE(AUX)
!-----------------------------------------------------------------------
!     Build b tensor, solve linear equation system LD^1/2 b = P^T(k|mn)
!-----------------------------------------------------------------------
      BUFP2 = MATMUL(BUFP2,P)
      DO N=1,NBF
        DO M=1,N
          MN = M + N*(N-1)/2
          CALL DTRTRS('L','N','U',NBFaux,1,L,NBFaux,BUFP2(MN,1:NBFaux), &
                      NBFaux,INFO)
          CALL SOLVE_BLOCK_SYSTEM(NBFaux,GMAT,BUFP2(MN,1:NBFaux),E)
        END DO
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

! LDLT
      SUBROUTINE LDLT(G,ipiv,e,n)
      integer :: n,i,j
      real(8) :: G(n,n)
      integer :: ipiv(n)
      real(8) :: e(n)
      real(8) :: work(3*n-1)
      integer :: lwork
      integer :: info
      logical :: spd, change, blk, equivalent
!-----------------------------------------------------------------------
      lwork = 3*n-1
      ipiv(:) = 0
      call dsytrf_rk('L',n,G,n,e,ipiv,work,lwork,info)
!-----------------------------------------------------------------------
      END

! MODCHOL
      SUBROUTINE MODCHOL ( n, a, ipiv, diag, delta, iprintopt )
      implicit none
      integer    n
      integer ipiv(n)
      real(8) a(n,n), diag(n), delta
!
      real(8) t(2,2), eig(2), work(20), zero
      parameter (zero = 0.0d0)
      integer k, lwork, info, nchanged, iprintopt
!-----------------------------------------------------------------------
      lwork = 10
      k = 1
      nchanged = 0
      
      do while ( k.le.n )
      
!     Check 1x1 block
        if ( k.eq.n .or. diag(k).eq. zero ) then
          if ( a(k,k).le.delta) then
             if(iprintopt.eq.1) write(6,*) "Changing 1",k,a(k,k)
             nchanged = nchanged + 1
             a(k,k) = delta
          end if
          a(k,k) = sqrt(a(k,k))
          k = k + 1
        else

!     Check 2x2 block

          t(1,1) = a(k,k)
          t(2,1) = diag(k)
          t(1,2) = t(2,1)
          t(2,2) = a(k+1,k+1)

          call dsyev ( 'v', 'l', 2, t, 2, eig, work, lwork, info )

          if (eig(1).le.delta) then
            if(iprintopt.eq.1) write(6,*) "Changing 2",k,eig(1)
            nchanged = nchanged + 1
            eig(1) = delta
          end if
          eig(1) = sqrt(eig(1))
          if (eig(2).le.delta) then
            if(iprintopt.eq.1) write(6,*) "Changing 2",k+1,eig(2)
            nchanged = nchanged + 1
            eig(2) = delta
          end if
          eig(2) = sqrt(eig(2))
!
          a(k,k)     = t(1,1)*t(1,1)*eig(1) + t(1,2)*t(1,2)*eig(2)
          a(k+1,k+1) = t(2,1)*t(2,1)*eig(1) + t(2,2)*t(2,2)*eig(2)
          diag(k)    = t(1,1)*t(2,1)*eig(1) + t(1,2)*t(2,2)*eig(2)

!   Check off-diagonal element; if zero reset 2x2 pivot to 2(1x1) pivots

          if ( diag(k).eq.zero ) then
             ipiv(k)   = - ipiv(k)
             ipiv(k+1) = - ipiv(k+1)
          end if
!
          k = k + 2

        end if
      end do
!-----------------------------------------------------------------------
      END

! GET_PLD12
      SUBROUTINE GET_PLD12(G,ipiv,e,n,P,L,D)
      integer :: n,i,j
      real(8) :: G(n,n)
      integer :: ipiv(n)
      real(8) :: e(n)
      logical :: equivalent
      real(8) :: L(n,n), D(n,n), vec(n)
      real(8) :: P(n,n)
!-----------------------------------------------------------------------
      P(:,:) = 0.0
      do i=1,n
        P(i,i) = 1.0
      end do
      L(:,:) = 0.0
      D(:,:) = 0.0

      do i=1,n
        do j=1,i-1
          L(i,j) = G(i,j)
        end do
        L(i,i) = 1.0
        D(i,i) = G(i,i)
        if(i.LT.n) then
          D(i+1,i) = e(i)
          D(i,i+1) = e(i)
        end if
      end do

      do i=n,1,-1
        if(abs(ipiv(i)).NE.i) then
          vec(:) = P(i,:)
          P(i,:) =P(abs(ipiv(i)),:)
          P(abs(ipiv(i)),:) = vec(:)
        end if
      end do
!-----------------------------------------------------------------------
      END SUBROUTINE

! SOLVE_BLOCK_SYSTEM 
      SUBROUTINE SOLVE_BLOCK_SYSTEM( n, a, y , diag )
      implicit none
      integer n
      real(8) a(n,n), diag(n), y(n), x(n)
!
      real(8) t(2,2), zero
      parameter (zero = 0.0d0)
      integer k
!-----------------------------------------------------------------------
      k = 1

      do while ( k.le.n )

!     Check 1x1 block
        if ( k.eq.n .or. diag(k).eq. zero ) then
          x(k) = y(k)/a(k,k)
          k = k + 1
        else

!     Check 2x2 block

          t(1,1) = a(k,k)
          t(2,1) = diag(k)
          t(1,2) = t(2,1)
          t(2,2) = a(k+1,k+1)

          if(abs(t(1,1)*t(2,2)-t(1,2)*t(2,1)).le.zero)    &
                  WRITE(6,*) "Warning: no solution available"

          x(k)=(y(k)*t(2,2)-t(1,2)*y(k+1))/(t(1,1)*t(2,2)-t(1,2)*t(2,1))
        x(k+1)=(t(1,1)*y(k+1)-y(k)*t(2,1))/(t(1,1)*t(2,2)-t(1,2)*t(2,1))

          k = k + 2

        end if
      end do

      y = x
!-----------------------------------------------------------------------
      END

! METRICmat                                            
      SUBROUTINE METRICmat(GMAT,GHONDO,MAXG,Cxyz,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)
      COMMON/RESTAR/NREC,IST,JST,KST,LST   
      COMMON/SHLNOS1/QQ4,IJKL
!
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(MAXG) :: GHONDO
      DOUBLE PRECISION,DIMENSION(NBFaux,NBFaux) :: GMAT
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX
!-----------------------------------------------------------------------
!     2e- Integrals (S,P,D,F,G & L Shells)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(AUX(49*900))        

      CALL BASCHK(LMAXIMAaux,KTYPEaux,NSHELLaux)
      NANGMAUX =  4                                          
      IF(LMAXIMAAUX==2) NANGMAUX =  6                                   
      IF(LMAXIMAAUX==3) NANGMAUX = 10                                  
      IF(LMAXIMAAUX==4) NANGMAUX = 15                                   
      IF(LMAXIMAAUX==5) NANGMAUX = 21                                   
      IF(LMAXIMAAUX==6) NANGMAUX = 28                                   
      NGTH(4) = 1                                                       
      NGTH(3) = NGTH(4) * 1                                     
      NGTH(2) = NGTH(3) * NANGMAUX                                      
      NGTH(1) = NGTH(2) * 1                                      
      DO I=1,3                                                       
       NORGSH(I) = 0                                               
       NORGSP(I) = 0                                               
      ENDDO                                                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO II = IST,NSHELLaux                        ! II Shell
       K0 = KST                                                        
       DO KK = K0,II                               ! KK Shell     
        KST = 1                                                       
!- - - - - - - - - - - - - - - - - - - - - - - -
!       (II//KK)                                        
!- - - - - - - - - - - - - - - - - - - - - - - -                            
        IEXCH = 1                                                    
        ISH = II                                                      
        KSH = KK                                                     
        QQ4 = 1                                                       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!       Compute 2e- Integrals                      
!       Select integral code for ERI calculation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        LQSUM = KTYPEaux(ISH) + KTYPEaux(KSH) - 2    
        CALL SHELLS2C(1,ISH,KSH,Cxyz,NAT)                           
        CALL SHELLS2C(2,ISH,KSH,Cxyz,NAT)                           
        CALL IJPRIM(AUX) 
        NORGH = NORGSH(IEXCH)                                         
        CALL ZQOUT(GHONDO,MAXG)                 
        IF(LQSUM==0) THEN 
         CALL S0000(GHONDO(1+NORGH),AUX)                        
        ELSE                                                          
         CALL ERISPDFGHIL(GHONDO(1+NORGH),AUX)                       
        END IF  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Transfer integrals to G matrix
!- - - - - - - - - - - - - - - - - - - - - - -
        CALL QOUT2C(GMAT,NBFaux,GHONDO,MAXG)
!- - - - - - - - - - - - - - - - - - - - - - -
       END DO
      END DO
      DEALLOCATE(AUX) 
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! SHELLS2C                                           
      SUBROUTINE SHELLS2C(NELEC,ISH,KSH,Cxyz,NAT)                   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL       NORM
      COMMON/NORMAL/NORM
      LOGICAL     IANDJ,KANDL,SAME
      COMMON/MISC/IANDJ,KANDL,SAME
      COMMON/ERIOUT/INU,JNU,KNU,LNU,NGTI,NGTJ,NGTK,NGTL                
      COMMON/INTDEX/IJX(784),IJY(784),IJZ(784),IK(784),                 &
                     KLX(784),KLY(784),KLZ(784)                         
      COMMON/INTDEX1/IJGT(784),KLGT(784)
      COMMON/ROOT/XX,U(13),W(13),NROOTS
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)
      COMMON/SHLINF/ GA(30),CSA(30),CPA(30),CDA(30),                    &
                    CFA(30),CGA(30),CHA(30),CIA(30),                    &
                     GB(30),CSB(30),CPB(30),CDB(30),                    &
                    CFB(30),CGB(30),CHB(30),CIB(30),                    &
                     GC(30),CSC(30),CPC(30),CDC(30),                    &
                    CFC(30),CGC(30),CHC(30),CIC(30),                    &
                     GD(30),CSD(30),CPD(30),CDD(30),                    &
                    CFD(30),CGD(30),CHD(30),CID(30),                    &
                    AX,AY,AZ,BX,BY,BZ,RAB,CX,CY,CZ,                     &
                    DX,DY,DZ,RCD,NGA,NGB,NGC,NGD                                      
      COMMON/SHLNOS/LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,                &
                    MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,            &
                    NIJ,IJ,KL                                          
      COMMON/SHLNOS1/QQ4,IJKL                                           
!      
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
      COMMON/EXCaux/EXaux(2000),Caux(2000)
!
      DIMENSION IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84),              &
                KX(84),KY(84),KZ(84),LX(84),LY(84),LZ(84)
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      INTEGER,DIMENSION(8) :: MINF,MAXF                                  
      DATA MINF / 1, 2,  5, 11, 21, 36, 57, 1/                           
      DATA MAXF / 1, 4, 10, 20, 35, 56, 84, 4/                           
      DATA LX /   0,   1,   0,   0,   2,   0,   0,   1,   1,   0,       &
                  3,   0,   0,   2,   2,   1,   0,   1,   0,   1,       &
                  4,   0,   0,   3,   3,   1,   0,   1,   0,   2,       &
                  2,   0,   2,   1,   1,                                &
                  5,   0,   0,   4,   4,   1,   0,   1,   0,   3,       &
                  3,   2,   0,   2,   0,   3,   1,   1,   2,   2,       &
                  1,                                                    &
                  6,   0,   0,   5,   5,   1,   0,   1,   0,   4,       &
                  4,   2,   0,   2,   0,   4,   1,   1,   3,   3,       &
                  0,   3,   3,   2,   1,   2,   1,   2/                  
      DATA KX /   0,   7,   0,   0,  14,   0,   0,   7,   7,   0,       &
                 21,   0,   0,  14,  14,   7,   0,   7,   0,   7,       &
                 28,   0,   0,  21,  21,   7,   0,   7,   0,  14,       &
                 14,   0,  14,   7,   7,                                &
                 35,   0,   0,  28,  28,   7,   0,   7,   0,  21,       &
                 21,  14,   0,  14,   0,  21,   7,   7,  14,  14,       &
                  7,                                                    &
                 42,   0,   0,  35,  35,   7,   0,   7,   0,  28,       &
                 28,  14,   0,  14,   0,  28,   7,   7,  21,  21,       &
                  0,  21,  21,  14,   7,  14,   7,  14/                  
      DATA JX /   0,  49,   0,   0,  98,   0,   0,  49,  49,   0,       &
                147,   0,   0,  98,  98,  49,   0,  49,   0,  49,       &
                196,   0,   0, 147, 147,  49,   0,  49,   0,  98,       &
                 98,   0,  98,  49,  49,                                &
                245,   0,   0, 196, 196,  49,   0,  49,   0, 147,       &
                147,  98,   0,  98,   0, 147,  49,  49,  98,  98,       &
                 49,                                                    &
                294,   0,   0, 245, 245,  49,   0,  49,   0, 196,       &
                196,  98,   0,  98,   0, 196,  49,  49, 147, 147,       &
                  0, 147, 147,  98,  49,  98,  49,  98/                  
      DATA IX /   1, 344,   1,   1, 687,   1,   1, 344, 344,   1,       &
               1030,   1,   1, 687, 687, 344,   1, 344,   1, 344,       &
               1373,   1,   1,1030,1030, 344,   1, 344,   1, 687,       &
                687,   1, 687, 344, 344,                                &
               1716,   1,   1,1373,1373, 344,   1, 344,   1,1030,       &
               1030, 687,   1, 687,   1,1030, 344, 344, 687, 687,       &
                344,                                                    &
               2059,   1,   1,1716,1716, 344,   1, 344,   1,1373,       &
               1373, 687,   1, 687,   1,1373, 344, 344,1030,1030,       &
                  1,1030,1030, 687, 344, 687, 344, 687/                  
      DATA LY /   0,   0,   1,   0,   0,   2,   0,   1,   0,   1,       &
                  0,   3,   0,   1,   0,   2,   2,   0,   1,   1,       &
                  0,   4,   0,   1,   0,   3,   3,   0,   1,   2,       &
                  0,   2,   1,   2,   1,                                &
                  0,   5,   0,   1,   0,   4,   4,   0,   1,   2,       &
                  0,   3,   3,   0,   2,   1,   3,   1,   2,   1,       &
                  2,                                                    &
                  0,   6,   0,   1,   0,   5,   5,   0,   1,   2,       &
                  0,   4,   4,   0,   2,   1,   4,   1,   3,   0,       &
                  3,   2,   1,   3,   3,   1,   2,   2/                  
      DATA KY /   0,   0,   7,   0,   0,  14,   0,   7,   0,   7,       &
                  0,  21,   0,   7,   0,  14,  14,   0,   7,   7,       &
                  0,  28,   0,   7,   0,  21,  21,   0,   7,  14,       &
                  0,  14,   7,  14,   7,                                &
                  0,  35,   0,   7,   0,  28,  28,   0,   7,  14,       &
                  0,  21,  21,   0,  14,   7,  21,   7,  14,   7,       &
                 14,                                                    &
                  0,  42,   0,   7,   0,  35,  35,   0,   7,  14,       &
                  0,  28,  28,   0,  14,   7,  28,   7,  21,   0,       &
                 21,  14,   7,  21,  21,   7,  14,  14/                  
      DATA JY /   0,   0,  49,   0,   0,  98,   0,  49,   0,  49,       &
                  0, 147,   0,  49,   0,  98,  98,   0,  49,  49,       &
                  0, 196,   0,  49,   0, 147, 147,   0,  49,  98,       &
                  0,  98,  49,  98,  49,                                &
                  0, 245,   0,  49,   0, 196, 196,   0,  49,  98,       &
                  0, 147, 147,   0,  98,  49, 147,  49,  98,  49,       &
                 98,                                                    &
                  0, 294,   0,  49,   0, 245, 245,   0,  49,  98,       &
                  0, 196, 196,   0,  98,  49, 196,  49, 147,   0,       &
                147,  98,  49, 147, 147,  49,  98,  98/                  
      DATA IY /   1,   1, 344,   1,   1, 687,   1, 344,   1, 344,       &
                  1,1030,   1, 344,   1, 687, 687,   1, 344, 344,       &
                  1,1373,   1, 344,   1,1030,1030,   1, 344, 687,       &
                  1, 687, 344, 687, 344,                                &
                  1,1716,   1, 344,   1,1373,1373,   1, 344, 687,       &
                  1,1030,1030,   1, 687, 344,1030, 344, 687, 344,       &
                687,                                                    &
                  1,2059,   1, 344,   1,1716,1716,   1, 344, 687,       &
                  1,1373,1373,   1, 687, 344,1373, 344,1030,   1,       &
               1030, 687, 344,1030,1030, 344, 687, 687/                 
      DATA LZ /   0,   0,   0,   1,   0,   0,   2,   0,   1,   1,       &
                  0,   0,   3,   0,   1,   0,   1,   2,   2,   1,       &
                  0,   0,   4,   0,   1,   0,   1,   3,   3,   0,       &
                  2,   2,   1,   1,   2,                                &
                  0,   0,   5,   0,   1,   0,   1,   4,   4,   0,       &
                  2,   0,   2,   3,   3,   1,   1,   3,   1,   2,       &
                  2,                                                    &
                  0,   0,   6,   0,   1,   0,   1,   5,   5,   0,       &
                  2,   0,   2,   4,   4,   1,   1,   4,   0,   3,       &
                  3,   1,   2,   1,   2,   3,   3,   2/                 
      DATA KZ /   0,   0,   0,   7,   0,   0,  14,   0,   7,   7,       &
                  0,   0,  21,   0,   7,   0,   7,  14,  14,   7,       &
                  0,   0,  28,   0,   7,   0,   7,  21,  21,   0,       &
                 14,  14,   7,   7,  14,                                &
                  0,   0,  35,   0,   7,   0,   7,  28,  28,   0,       &
                 14,   0,  14,  21,  21,   7,   7,  21,   7,  14,       &
                 14,                                                    &
                  0,   0,  42,   0,   7,   0,   7,  35,  35,   0,       &
                 14,   0,  14,  28,  28,   7,   7,  28,   0,  21,       &
                 21,   7,  14,   7,  14,  21,  21,  14/                 
      DATA JZ /   0,   0,   0,  49,   0,   0,  98,   0,  49,  49,       &
                  0,   0, 147,   0,  49,   0,  49,  98,  98,  49,       &
                  0,   0, 196,   0,  49,   0,  49, 147, 147,   0,       &
                 98,  98,  49,  49,  98,                                &
                  0,   0, 245,   0,  49,   0,  49, 196, 196,   0,       &
                 98,   0,  98, 147, 147,  49,  49, 147,  49,  98,       &
                 98,                                                    &
                  0,   0, 294,   0,  49,   0,  49, 245, 245,   0,       &
                 98,   0,  98, 196, 196,  49,  49, 196,   0, 147,       &
                147,  49,  98,  49,  98, 147, 147,  98/                 
      DATA IZ /   1,   1,   1, 344,   1,   1, 687,   1, 344, 344,       &
                  1,   1,1030,   1, 344,   1, 344, 687, 687, 344,       &
                  1,   1,1373,   1, 344,   1, 344,1030,1030,   1,       &
                687, 687, 344, 344, 687,                                &
                  1,   1,1716,   1, 344,   1, 344,1373,1373,   1,       &
                687,   1, 687,1030,1030, 344, 344,1030, 344, 687,       &
                687,                                                    &
                  1,   1,2059,   1, 344,   1, 344,1716,1716,   1,       &
                687,   1, 687,1373,1373, 344, 344,1373,   1,1030,       &
               1030, 344, 687, 344, 687,1030,1030, 687/                 
!-----------------------------------------------------------------------                                                                       
!     PREPARE SHELL INFORMATION/FOR HONDO INTEGRATION        
      NORM = .FALSE.  
      
      IF(NELEC==2) GO TO 200                                          
                                                                       
      IANDJ = .FALSE.                                         
      INU = ISH                                                      
      JNU = 1                                                      
      NGTI = NGTH(1)                                                 
      NGTJ = NGTH(2)                                                 
!                                                                       
!     ----- ISHELL                                                      
!                                                                       
      I = KATOMaux(INU)                                                 
      AX = Cxyz(1,I)                                                       
      AY = Cxyz(2,I)                                                       
      AZ = Cxyz(3,I)                                                       
      I1 = INU                                               
      I2 = INU                                           
      LIT = KTYPEaux(INU)                                              
      MINI = MINF(LIT)                                                  
      MAXI = MAXF(LIT)                                                  
      LOCI = KLOCaux(INU)-MINI                                          
      NGA = 0                                                           
      DO I = I1,I2                                                  
       NGA = NGA+1    
       GA(NGA) = EXaux(I)                                             
       CSA(NGA) = Caux(I)                                            
       CPA(NGA) = Caux(I)                                           
       CDA(NGA) = Caux(I)                                           
       CFA(NGA) = Caux(I)                                            
       CGA(NGA) = Caux(I)                                           
       CHA(NGA) = Caux(I)                                           
       CIA(NGA) = Caux(I)                                           
      END DO
!                                                                       
!     ----- JSHELL (Unity Shell)                                                     
!                                                                       
      J = 1                                                   
      BX = 0                                                  
      BY = 0                                                       
      BZ = 0                                                  
      J1 = 1                                              
      J2 = 1                                             
      LJT = 1                                                  
      MINJ = 1                                               
      MAXJ = 1                                               
      LOCJ = 1                                          
      NGB = 0                                                           
      DO J = J1,J2                                                  
       NGB = NGB+1                                                    
       GB(NGB) = 0                                               
       CSB(NGB) = 1                                           
       CPB(NGB) = 1                                          
       CDB(NGB) = 1                                           
       CFB(NGB) = 1                                           
       CGB(NGB) = 1                                         
       CHB(NGB) = 1                                         
       CIB(NGB) = 1                                           
      END DO                                                          
      RAB = ((AX-BX)*(AX-BX) + (AY-BY)*(AY-BY) + (AZ-BZ)*(AZ-BZ))       
!                                                                       
!     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS                
!                                                                       
      IJ = 0                                                            
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       NX = IX(I)                                                     
       NY = IY(I)                                                     
       NZ = IZ(I)                                                     
       IF (IANDJ) JMAX = I                                            
       DO J = MINJ,JMAX                                           
        IJ = IJ+1                                                   
        IJX(IJ) = NX+JX(J)                                          
        IJY(IJ) = NY+JY(J)                                          
        IJZ(IJ) = NZ+JZ(J)                                          
        IJGT(IJ) = NGTI*(I-MINI)+NGTJ*(J-MINJ)+1                    
       END DO                                                       
      END DO                                                          
      RETURN                                                            
!     ******                                                            
!                                                                       
!        K AND L SHELL                                                  
!                                                                       
  200 CONTINUE                                                          
      KANDL = .FALSE.                                        
      SAME = ISH == KSH                           
!                                                                       
!     ----- PERMUTE KSH AND LSH SHELLS, FOR THEIR TYPE                  
!                                                                       
      KNU = KSH                                                      
      LNU = 1                                                      
      NGTK = NGTH(3)                                                 
      NGTL = NGTH(4)                                                 
!                                                                       
!     ----- K SHELL                                                     
!                                                                       
      K = KATOMaux(KNU)                                                 
      CX = Cxyz(1,K)                                                       
      CY = Cxyz(2,K)                                                       
      CZ = Cxyz(3,K)                                                       
      K1 = KNU                                           
      K2 = KNU                                             
      LKT = KTYPEaux(KNU) 
      MINK = MINF(LKT)                                                  
      MAXK = MAXF(LKT)                                                  
      LOCK = KLOCaux(KNU)-MINK                                          
      NGC = 0                                                           
      DO K = K1,K2                                                  
       NGC = NGC+1                                                    
       GC(NGC) = EXaux(K)                                             
       CSC(NGC) = Caux(K)                                          
       CPC(NGC) = Caux(K)                                       
       CDC(NGC) = Caux(K)                                       
       CFC(NGC) = Caux(K)                                     
       CGC(NGC) = Caux(K)                                         
       CHC(NGC) = Caux(K)                                          
       CIC(NGC) = Caux(K)                                          
      END DO                                                          
!                                                                       
!     ----- LSHELL (Unity Shell)                                                      
!                                                                       
      L = 1                                          
      DX = 0                                                    
      DY = 0                                                  
      DZ = 0                                                      
      L1 = 1                                                 
      L2 = 1                                          
      LLT = 1                                        
      MINL = 1                                            
      MAXL = 1                                            
      LOCL = 1                                       
      NGD = 0                                                           
      DO L = L1,L2                                                  
       NGD = NGD+1                                                    
       GD(NGD) = 0                                           
       CSD(NGD) = 1                                          
       CPD(NGD) = 1                                          
       CDD(NGD) = 1                                           
       CFD(NGD) = 1                                          
       CGD(NGD) = 1                                          
       CHD(NGD) = 1                                          
       CID(NGD) = 1                                           
      END DO                                                          
      NROOTS = (LIT+LJT+LKT+LLT-2)/2                                    
      RCD = ((CX-DX)*(CX-DX) + (CY-DY)*(CY-DY) + (CZ-DZ)*(CZ-DZ))       
!                                                                       
!     ----- PREPARE INDICES FOR PAIRS OF (K,L) FUNCTIONS                
!                                                                       
      KL = 0                                                            
      LMAX = MAXL                                                       
      DO K = MINK,MAXK                                              
       NX = KX(K)                                                     
       NY = KY(K)                                                     
       NZ = KZ(K)                                                     
       IF (KANDL) LMAX = K                                            
       DO L = MINL,LMAX                                           
        KL = KL+1                                                   
        KLX(KL) = NX+LX(L)                                          
        KLY(KL) = NY+LY(L)                                          
        KLZ(KL) = NZ+LZ(L)                                          
        KLGT(KL) = NGTK*(K-MINK)+NGTL*(L-MINL)                      
       END DO                                                       
      END DO                                                      
      MAX = KL                                                          
      DO 320 I = 1,IJ                                                   
      IF (SAME) MAX = I                                                 
  320 IK(I) = MAX                                                       
      IJKL = IJ*KL        
      IF (SAME) IJKL = IJ*(IJ+1)/2 
!-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

! SHELLS3C                                           
      SUBROUTINE SHELLS3C(NELEC,ISH,JSH,KSH,FLIP,EX,CS,CP,CD,CF,CG,CH,  &
                          CI,NPRIMI,KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,   &
                          KMAX,NSHELL,Cxyz,NAT)                   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL       NORM
      COMMON/NORMAL/NORM
      LOGICAL     IANDJ,KANDL,SAME
      COMMON/MISC/IANDJ,KANDL,SAME
      COMMON/ERIOUT/INU,JNU,KNU,LNU,NGTI,NGTJ,NGTK,NGTL                
      COMMON/INTDEX/IJX(784),IJY(784),IJZ(784),IK(784),                 &
                    KLX(784),KLY(784),KLZ(784)                           
      COMMON/INTDEX1/IJGT(784),KLGT(784)                                 
      COMMON/ROOT/XX,U(13),W(13),NROOTS                                 
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)                    
      COMMON/SHLINF/ GA(30),CSA(30),CPA(30),CDA(30),                    &
                    CFA(30),CGA(30),CHA(30),CIA(30),                    &
                     GB(30),CSB(30),CPB(30),CDB(30),                    &
                    CFB(30),CGB(30),CHB(30),CIB(30),                    &
                     GC(30),CSC(30),CPC(30),CDC(30),                    &
                    CFC(30),CGC(30),CHC(30),CIC(30),                    &
                     GD(30),CSD(30),CPD(30),CDD(30),                    &
                    CFD(30),CGD(30),CHD(30),CID(30),                    &
                    AX,AY,AZ,BX,BY,BZ,RAB,CX,CY,CZ,                     &
                    DX,DY,DZ,RCD,NGA,NGB,NGC,NGD                                      
      COMMON/SHLNOS/LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,                &
                    MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,            &
                    NIJ,IJ,KL                                          
      COMMON/SHLNOS1/QQ4,IJKL
!      
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
      COMMON/EXCaux/EXaux(2000),Caux(2000)
!
      LOGICAL FLIP
      INTEGER,DIMENSION(NSHELL)::KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DIMENSION IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84),              &
                KX(84),KY(84),KZ(84),LX(84),LY(84),LZ(84)
      INTEGER,DIMENSION(8) :: MINF,MAXF                                  
      DATA MINF / 1, 2,  5, 11, 21, 36, 57, 1/                           
      DATA MAXF / 1, 4, 10, 20, 35, 56, 84, 4/                           
      DATA LX /   0,   1,   0,   0,   2,   0,   0,   1,   1,   0,       &
                  3,   0,   0,   2,   2,   1,   0,   1,   0,   1,       &
                  4,   0,   0,   3,   3,   1,   0,   1,   0,   2,       &
                  2,   0,   2,   1,   1,                                &
                  5,   0,   0,   4,   4,   1,   0,   1,   0,   3,       &
                  3,   2,   0,   2,   0,   3,   1,   1,   2,   2,       &
                  1,                                                    &
                  6,   0,   0,   5,   5,   1,   0,   1,   0,   4,       &
                  4,   2,   0,   2,   0,   4,   1,   1,   3,   3,       &
                  0,   3,   3,   2,   1,   2,   1,   2/                  
      DATA KX /   0,   7,   0,   0,  14,   0,   0,   7,   7,   0,       &
                 21,   0,   0,  14,  14,   7,   0,   7,   0,   7,       &
                 28,   0,   0,  21,  21,   7,   0,   7,   0,  14,       &
                 14,   0,  14,   7,   7,                                &
                 35,   0,   0,  28,  28,   7,   0,   7,   0,  21,       &
                 21,  14,   0,  14,   0,  21,   7,   7,  14,  14,       &
                  7,                                                    &
                 42,   0,   0,  35,  35,   7,   0,   7,   0,  28,       &
                 28,  14,   0,  14,   0,  28,   7,   7,  21,  21,       &
                  0,  21,  21,  14,   7,  14,   7,  14/                  
      DATA JX /   0,  49,   0,   0,  98,   0,   0,  49,  49,   0,       &
                147,   0,   0,  98,  98,  49,   0,  49,   0,  49,       &
                196,   0,   0, 147, 147,  49,   0,  49,   0,  98,       &
                 98,   0,  98,  49,  49,                                &
                245,   0,   0, 196, 196,  49,   0,  49,   0, 147,       &
                147,  98,   0,  98,   0, 147,  49,  49,  98,  98,       &
                 49,                                                    &
                294,   0,   0, 245, 245,  49,   0,  49,   0, 196,       &
                196,  98,   0,  98,   0, 196,  49,  49, 147, 147,       &
                  0, 147, 147,  98,  49,  98,  49,  98/                  
      DATA IX /   1, 344,   1,   1, 687,   1,   1, 344, 344,   1,       &
               1030,   1,   1, 687, 687, 344,   1, 344,   1, 344,       &
               1373,   1,   1,1030,1030, 344,   1, 344,   1, 687,       &
                687,   1, 687, 344, 344,                                &
               1716,   1,   1,1373,1373, 344,   1, 344,   1,1030,       &
               1030, 687,   1, 687,   1,1030, 344, 344, 687, 687,       &
                344,                                                    &
               2059,   1,   1,1716,1716, 344,   1, 344,   1,1373,       &
               1373, 687,   1, 687,   1,1373, 344, 344,1030,1030,       &
                  1,1030,1030, 687, 344, 687, 344, 687/                  
      DATA LY /   0,   0,   1,   0,   0,   2,   0,   1,   0,   1,       &
                  0,   3,   0,   1,   0,   2,   2,   0,   1,   1,       &
                  0,   4,   0,   1,   0,   3,   3,   0,   1,   2,       &
                  0,   2,   1,   2,   1,                                &
                  0,   5,   0,   1,   0,   4,   4,   0,   1,   2,       &
                  0,   3,   3,   0,   2,   1,   3,   1,   2,   1,       &
                  2,                                                    &
                  0,   6,   0,   1,   0,   5,   5,   0,   1,   2,       &
                  0,   4,   4,   0,   2,   1,   4,   1,   3,   0,       &
                  3,   2,   1,   3,   3,   1,   2,   2/                  
      DATA KY /   0,   0,   7,   0,   0,  14,   0,   7,   0,   7,       &
                  0,  21,   0,   7,   0,  14,  14,   0,   7,   7,       &
                  0,  28,   0,   7,   0,  21,  21,   0,   7,  14,       &
                  0,  14,   7,  14,   7,                                &
                  0,  35,   0,   7,   0,  28,  28,   0,   7,  14,       &
                  0,  21,  21,   0,  14,   7,  21,   7,  14,   7,       &
                 14,                                                    &
                  0,  42,   0,   7,   0,  35,  35,   0,   7,  14,       &
                  0,  28,  28,   0,  14,   7,  28,   7,  21,   0,       &
                 21,  14,   7,  21,  21,   7,  14,  14/                  
      DATA JY /   0,   0,  49,   0,   0,  98,   0,  49,   0,  49,       &
                  0, 147,   0,  49,   0,  98,  98,   0,  49,  49,       &
                  0, 196,   0,  49,   0, 147, 147,   0,  49,  98,       &
                  0,  98,  49,  98,  49,                                &
                  0, 245,   0,  49,   0, 196, 196,   0,  49,  98,       &
                  0, 147, 147,   0,  98,  49, 147,  49,  98,  49,       &
                 98,                                                    &
                  0, 294,   0,  49,   0, 245, 245,   0,  49,  98,       &
                  0, 196, 196,   0,  98,  49, 196,  49, 147,   0,       &
                147,  98,  49, 147, 147,  49,  98,  98/                  
      DATA IY /   1,   1, 344,   1,   1, 687,   1, 344,   1, 344,       &
                  1,1030,   1, 344,   1, 687, 687,   1, 344, 344,       &
                  1,1373,   1, 344,   1,1030,1030,   1, 344, 687,       &
                  1, 687, 344, 687, 344,                                &
                  1,1716,   1, 344,   1,1373,1373,   1, 344, 687,       &
                  1,1030,1030,   1, 687, 344,1030, 344, 687, 344,       &
                687,                                                    &
                  1,2059,   1, 344,   1,1716,1716,   1, 344, 687,       &
                  1,1373,1373,   1, 687, 344,1373, 344,1030,   1,       &
               1030, 687, 344,1030,1030, 344, 687, 687/                  
      DATA LZ /   0,   0,   0,   1,   0,   0,   2,   0,   1,   1,       &
                  0,   0,   3,   0,   1,   0,   1,   2,   2,   1,       &
                  0,   0,   4,   0,   1,   0,   1,   3,   3,   0,       &
                  2,   2,   1,   1,   2,                                &
                  0,   0,   5,   0,   1,   0,   1,   4,   4,   0,       &
                  2,   0,   2,   3,   3,   1,   1,   3,   1,   2,       &
                  2,                                                    &
                  0,   0,   6,   0,   1,   0,   1,   5,   5,   0,       &
                  2,   0,   2,   4,   4,   1,   1,   4,   0,   3,       &
                  3,   1,   2,   1,   2,   3,   3,   2/                  
      DATA KZ /   0,   0,   0,   7,   0,   0,  14,   0,   7,   7,       &
                  0,   0,  21,   0,   7,   0,   7,  14,  14,   7,       &
                  0,   0,  28,   0,   7,   0,   7,  21,  21,   0,       &
                 14,  14,   7,   7,  14,                                &
                  0,   0,  35,   0,   7,   0,   7,  28,  28,   0,       &
                 14,   0,  14,  21,  21,   7,   7,  21,   7,  14,       &
                 14,                                                    &
                  0,   0,  42,   0,   7,   0,   7,  35,  35,   0,       &
                 14,   0,  14,  28,  28,   7,   7,  28,   0,  21,       &
                 21,   7,  14,   7,  14,  21,  21,  14/                  
      DATA JZ /   0,   0,   0,  49,   0,   0,  98,   0,  49,  49,       &
                  0,   0, 147,   0,  49,   0,  49,  98,  98,  49,       &
                  0,   0, 196,   0,  49,   0,  49, 147, 147,   0,       &
                 98,  98,  49,  49,  98,                                &
                  0,   0, 245,   0,  49,   0,  49, 196, 196,   0,       &
                 98,   0,  98, 147, 147,  49,  49, 147,  49,  98,       &
                 98,                                                    &
                  0,   0, 294,   0,  49,   0,  49, 245, 245,   0,       &
                 98,   0,  98, 196, 196,  49,  49, 196,   0, 147,       &
                147,  49,  98,  49,  98, 147, 147,  98/                  
      DATA IZ /   1,   1,   1, 344,   1,   1, 687,   1, 344, 344,       &
                  1,   1,1030,   1, 344,   1, 344, 687, 687, 344,       &
                  1,   1,1373,   1, 344,   1, 344,1030,1030,   1,       &
                687, 687, 344, 344, 687,                                &
                  1,   1,1716,   1, 344,   1, 344,1373,1373,   1,       &
                687,   1, 687,1030,1030, 344, 344,1030, 344, 687,       &
                687,                                                    &
                  1,   1,2059,   1, 344,   1, 344,1716,1716,   1,       &
                687,   1, 687,1373,1373, 344, 344,1373,   1,1030,       &
               1030, 344, 687, 344, 687,1030,1030, 687/                 
!-----------------------------------------------------------------------                                                                       
!     PREPARE SHELL INFORMATION/FOR HONDO INTEGRATION                   
      IF(NELEC==2) GO TO 200      
      NORM = .TRUE.  
!                                                                       
!     ----- PERMUTE ISH AND JSH SHELLS, FOR THEIR TYPE                  
!     THIS IS DONE FOR SPEED REASONS.  THE CODE GETS THE RIGHT ANSWER   
!     WITHOUT THE ANGULAR MOMENTUM FLIPPING, AND THEREFORE A CALLING    
!     ARGUMENT ALLOWS ONE DO EXACTLY THE integral BLOCK AS SPECIFIED,   
!     SHOULD THAT BE DESIRED.                                           
!                                                                       
      IANDJ = ISH == JSH                                              
      IF (KTYPE(ISH) < KTYPE(JSH)  .and.  FLIP) THEN                 
       INU = JSH                                                      
       JNU = ISH                                                      
       NGTI = NGTH(2)                                                 
       NGTJ = NGTH(1)                                                 
      ELSE                                                              
       INU = ISH                                                      
       JNU = JSH                                                      
       NGTI = NGTH(1)                                                 
       NGTJ = NGTH(2)                                                 
      END IF                                                            
!                                                                       
!     ----- ISHELL                                                      
!                                                                       
      I = KATOM(INU)                                                    
      AX = Cxyz(1,I)                                                       
      AY = Cxyz(2,I)                                                       
      AZ = Cxyz(3,I)                                                       
      I1 = KSTART(INU)                                                  
      I2 = I1+KNG(INU)-1                                                
      LIT = KTYPE(INU)                                                  
      MINI = KMIN(INU)                                                  
      MAXI = KMAX(INU)                                                  
      LOCI = KLOC(INU)-MINI                                             
      NGA = 0                                                           
      DO I = I1,I2                                                  
       NGA = NGA+1                                                    
       GA(NGA) = EX(I)                                                
       CSA(NGA) = CS(I)                                               
       CPA(NGA) = CP(I)                                               
       CDA(NGA) = CD(I)                                               
       CFA(NGA) = CF(I)                                               
       CGA(NGA) = CG(I)                                               
       CHA(NGA) = CH(I)                                               
       CIA(NGA) = CI(I)                                               
      END DO                                                          
!                                                                       
!     ----- JSHELL                                                      
!                                                                       
      J = KATOM(JNU)                                                    
      BX = Cxyz(1,J)                                                       
      BY = Cxyz(2,J)                                                       
      BZ = Cxyz(3,J)                                                       
      J1 = KSTART(JNU)                                                  
      J2 = J1+KNG(JNU)-1                                                
      LJT = KTYPE(JNU)                                                  
      MINJ = KMIN(JNU)                                                  
      MAXJ = KMAX(JNU)                                                  
      LOCJ = KLOC(JNU)-MINJ                                             
      NGB = 0                                                           
      DO J = J1,J2                                                  
       NGB = NGB+1                                                    
       GB(NGB) = EX(J)                                                
       CSB(NGB) = CS(J)                                               
       CPB(NGB) = CP(J)                                               
       CDB(NGB) = CD(J)                                               
       CFB(NGB) = CF(J)                                               
       CGB(NGB) = CG(J)                                               
       CHB(NGB) = CH(J)                                               
       CIB(NGB) = CI(J)                                               
      END DO                                                          
      RAB = ((AX-BX)*(AX-BX) + (AY-BY)*(AY-BY) + (AZ-BZ)*(AZ-BZ))       
!                                                                       
!     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS                
!                                                                       
      IJ = 0                                                            
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       NX = IX(I)                                                     
       NY = IY(I)                                                     
       NZ = IZ(I)                                                     
       IF (IANDJ) JMAX = I                                            
       DO J = MINJ,JMAX                                           
        IJ = IJ+1                                                   
        IJX(IJ) = NX+JX(J)                                          
        IJY(IJ) = NY+JY(J)                                          
        IJZ(IJ) = NZ+JZ(J)                                          
        IJGT(IJ) = NGTI*(I-MINI)+NGTJ*(J-MINJ)+1                    
       END DO                                                   
      END DO                                                         
      RETURN                                                            
!     ******                                                            
!                                                                       
!        K AND L SHELL                                                  
!                                                                       
  200 CONTINUE    
      NORM  = .FALSE.      
      KANDL = .FALSE.                                 
      SAME  = .FALSE.          

      KNU = KSH                                                      
      LNU = 1                                                      
      NGTK = NGTH(3)                                                 
      NGTL = NGTH(4)                                                 
!                                                                       
!     ----- K SHELL                                                     
!                                                                       
      K = KATOMaux(KNU)                                                 
      CX = Cxyz(1,K)                                                       
      CY = Cxyz(2,K)                                                       
      CZ = Cxyz(3,K)                                                       
      K1 = KNU                                                 
      K2 = KNU                                               
      LKT = KTYPEaux(KNU)                                               
      MINK = MINF(LKT)                                                  
      MAXK = MAXF(LKT)                                                  
      LOCK = KLOCaux(KNU)-MINK                                          
      NGC = 0                                                           
      DO K = K1,K2                                                  
       NGC = NGC+1                                                    
       GC(NGC) = EXaux(K)                                             
       CSC(NGC) = Caux(K)                                            
       CPC(NGC) = Caux(K)                                         
       CDC(NGC) = Caux(K)                                             
       CFC(NGC) = Caux(K)                                             
       CGC(NGC) = Caux(K)                                             
       CHC(NGC) = Caux(K)                                             
       CIC(NGC) = Caux(K)                                             
      END DO                                                          
!                                                                       
!     ----- LSHELL (Unity Shell)                                                     
!                                                                       
      L = 1                                                    
      DX = 0                                                       
      DY = 0                                                       
      DZ = 0                                                       
      L1 = 1                                                
      L2 = 1                                                
      LLT = 1                                                  
      MINL = 1                                                  
      MAXL = 1                                                  
      LOCL = 1                                             
      NGD = 0                                                           
      DO L = L1,L2                                                  
       NGD = NGD+1                                                    
       GD(NGD) = 0                                                
       CSD(NGD) = 1                                             
       CPD(NGD) = 1                                              
       CDD(NGD) = 1                                               
       CFD(NGD) = 1                                               
       CGD(NGD) = 1                                               
       CHD(NGD) = 1                                               
       CID(NGD) = 1                                               
      END DO                                                          
      NROOTS = (LIT+LJT+LKT+LLT-2)/2                                    
      RCD = ((CX-DX)*(CX-DX) + (CY-DY)*(CY-DY) + (CZ-DZ)*(CZ-DZ))       
!                                                                       
!     ----- PREPARE INDICES FOR PAIRS OF (K,L) FUNCTIONS                
!                                                                       
      KL = 0                                                            
      LMAX = MAXL                                                       
      DO K = MINK,MAXK                                              
       NX = KX(K)                                                     
       NY = KY(K)                                                     
       NZ = KZ(K)                                                     
       IF (KANDL) LMAX = K                                            
       DO L = MINL,LMAX                                           
        KL = KL+1                                                   
        KLX(KL) = NX+LX(L)                                          
        KLY(KL) = NY+LY(L)                                          
        KLZ(KL) = NZ+LZ(L)                                          
        KLGT(KL) = NGTK*(K-MINK)+NGTL*(L-MINL)                      
       END DO                                                       
      END DO                                                          
      MAX = KL                                                          
      DO 320 I = 1,IJ                                                   
      IF (SAME) MAX = I                                                 
  320 IK(I) = MAX                                                       
      IJKL = IJ*KL                                                      
      IF (SAME) IJKL = IJ*(IJ+1)/2

      RETURN                                                            
      END       

! PDPT_msqrt
      SUBROUTINE PDPT_msqrt(GMAT,N,IPRINTOPT)
      INTEGER :: N,I,J
      DOUBLE PRECISION :: GMAT(N,N),TOL,VEC(N,N),EIG(N),W(N),AUX(N,N)
!
      TOL = 1.0d-10
      AUX = GMAT
      CALL DIAG(N,AUX,VEC,EIG,W)
!
      AUX = 0.0d0
      DO I=1,N
       IF (EIG(I)<=TOL) THEN
        IF(IPRINTOPT==1) write(6,*) "Truncating",I,EIG(I)
        EIG(I) = 0.0d0
        DO J=1,N
         VEC(J,I) = 0.0d0
        END DO
       ELSE
        AUX(I,I) = 1.0/DSQRT(EIG(I))
       END IF
      END DO

      GMAT = MATMUL(MATMUL(VEC,AUX),TRANSPOSE(VEC))

      END

! QOUT2C                                             
      SUBROUTINE QOUT2C(GMAT,NBFaux,GHONDO,MAXG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL IANDJ,KANDL,SAME
      COMMON/MISC  /IANDJ,KANDL,SAME                                  
      COMMON/ERIOUT/ISH,JSH,KSH,LSH,LSTRI,LSTRJ,LSTRK,LSTRL           
      COMMON/SHLNOS/LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,                &
                    MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,            &
                    NIJ,IJ,KL                                          
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
!
      DOUBLE PRECISION,DIMENSION(NBFaux,NBFaux) :: GMAT
      DOUBLE PRECISION,DIMENSION(MAXG) :: GHONDO
      INTEGER,DIMENSION(8) :: MINF,MAXF
      DATA MINF / 1, 2,  5, 11, 21, 36, 57, 1/                 
      DATA MAXF / 1, 4, 10, 20, 35, 56, 84, 4/                 
!-----------------------------------------------------------------------                                                                       
!     Get Auxiliary Basis Info. 
!-----------------------------------------------------------------------
      SAME  = ISH == KSH                            
      MINI = MINF(KTYPEaux(ISH))                                        
      MINK = MINF(KTYPEaux(KSH))                                        
      MAXI = MAXF(KTYPEaux(ISH))                                        
      MAXK = MAXF(KTYPEaux(KSH))                                        
      LOCI = KLOCaux(ISH)-MINI                                         
      LOCK = KLOCaux(KSH)-MINK                                          
!-----------------------------------------------------------------------                                                                       
!     Store (k|l) ERIs in G matrix 
!-----------------------------------------------------------------------
      DO 1 I = MINI,MAXI                                              
        I_INDEX = (I-MINI)*LSTRI + 1                                   
        DO K =  MINK,MAXK                                       
          IK_INDEX = (K-MINK)*LSTRK + I_INDEX                    
          IF(SAME.and.K>I)GO TO 1                 
          VAL = GHONDO( IK_INDEX )
          I1 = LOCI+I                                           
          I3 = LOCK+K                                           
          GMAT(I1,I3) = VAL
          GMAT(I3,I1) = VAL
        END DO
    1 CONTINUE                                                       
!-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END                                                               

! QOUT3C                                     
      SUBROUTINE QOUT3C(BUFP2,GHONDO,MAXG,GMAT,NBF,NBFaux,              &
                        KLOC,KMIN,KMAX,NSHELL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL IANDJ,KANDL,SAME
      COMMON/MISC/IANDJ,KANDL,SAME                                  
      COMMON/ERIOUT/ISH,JSH,KSH,LSH,LSTRI,LSTRJ,LSTRK,LSTRL           
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
!
      INTEGER,DIMENSION(NSHELL) :: KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NBF*(NBF+1)/2,NBFaux) :: BUFP2
      DOUBLE PRECISION,DIMENSION(NBFaux,NBFaux)::GMAT
      DOUBLE PRECISION,DIMENSION(MAXG)::GHONDO
      INTEGER,DIMENSION(8) :: MINF,MAXF
      DATA MINF / 1, 2,  5, 11, 21, 36, 57, 1/                 
      DATA MAXF / 1, 4, 10, 20, 35, 56, 84, 4/      
      INTEGER :: T
!-----------------------------------------------------------------------                                                                       
!     Get Basis and Auxiliary Basis Info. 
!-----------------------------------------------------------------------
      IANDJ = ISH == JSH                                              
      MINI = KMIN(ISH)                                                  
      MINJ = KMIN(JSH)                                                  
      MINK = MINF(KTYPEaux(KSH))                                        
      MAXI = KMAX(ISH)                                                  
      MAXJ = KMAX(JSH)                                                  
      MAXK = MAXF(KTYPEaux(KSH))                                        
      LOCI = KLOC(ISH)-MINI                                             
      LOCJ = KLOC(JSH)-MINJ                                             
      LOCK = KLOCaux(KSH)-MINK                                          
!-----------------------------------------------------------------------                                                                       
!     Build B tensor (Only Upper Triangular)
!      b_mn^l = sum_k (mn|k) G^{-1/2}_{kl}
!-----------------------------------------------------------------------
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       I_INDEX = (I-MINI)*LSTRI + 1                                   
       IF (IANDJ) JMAX = I                                            
       DO J = MINJ,JMAX                                           
        IJ_INDEX = (J-MINJ)*LSTRJ + I_INDEX                         
        DO K = MINK,MAXK                                       
          IJK_INDEX = (K-MINK)*LSTRK + IJ_INDEX                    
          VAL = GHONDO( IJK_INDEX ) 
          M = LOCI+I                                           
          N = LOCJ+J                                           
          KK = LOCK+K                                           
          IF (M <= N) GO TO 100                             
          T = M                                                
          M = N                                               
          N = T                                                
  100     MN = M + N*(N-1)/2
          DO L=1,NBFaux
           BUFP2(MN,L) = BUFP2(MN,L) + VAL*GMAT(KK,L)
          END DO
        END DO
       END DO                                                       
      END DO
!-----------------------------------------------------------------------                                                                       
      RETURN 
      END                                                               

! QOUT3CModChol
      SUBROUTINE QOUT3CModChol(BUFP2,GHONDO,MAXG,GMAT,NBF,NBFaux,       &
                               KLOC,KMIN,KMAX,NSHELL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL IANDJ,KANDL,SAME
      COMMON/MISC/IANDJ,KANDL,SAME
      COMMON/ERIOUT/ISH,JSH,KSH,LSH,LSTRI,LSTRJ,LSTRK,LSTRL
      COMMON/NSHELaux/KATOMaux(500),KTYPEaux(500),KLOCaux(500)
!
      INTEGER,DIMENSION(NSHELL) :: KLOC,KMIN,KMAX
      DOUBLE PRECISION,DIMENSION(NBF*(NBF+1)/2,NBFaux) :: BUFP2
      DOUBLE PRECISION,DIMENSION(NBFaux,NBFaux)::GMAT
      DOUBLE PRECISION,DIMENSION(MAXG)::GHONDO
      INTEGER,DIMENSION(8) :: MINF,MAXF
      DATA MINF / 1, 2,  5, 11, 21, 36, 57, 1/
      DATA MAXF / 1, 4, 10, 20, 35, 56, 84, 4/
!-----------------------------------------------------------------------                                                                       
!     Get Basis and Auxiliary Basis Info. 
!-----------------------------------------------------------------------
      IANDJ = ISH == JSH
      MINI = KMIN(ISH)
      MINJ = KMIN(JSH)
      MINK = MINF(KTYPEaux(KSH))
      MAXI = KMAX(ISH)
      MAXJ = KMAX(JSH)
      MAXK = MAXF(KTYPEaux(KSH))
      LOCI = KLOC(ISH)-MINI
      LOCJ = KLOC(JSH)-MINJ
      LOCK = KLOCaux(KSH)-MINK
!-----------------------------------------------------------------------                                                                       
!     Store (mn|P) (Only Upper Triangular)
!-----------------------------------------------------------------------
      JMAX = MAXJ
      DO I = MINI,MAXI
       I_INDEX = (I-MINI)*LSTRI + 1
       IF (IANDJ) JMAX = I
       DO 1 J = MINJ,JMAX
        IJ_INDEX = (J-MINJ)*LSTRJ + I_INDEX
        DO K =  MINK,MAXK
          IJK_INDEX = (K-MINK)*LSTRK + IJ_INDEX
          VAL = GHONDO( IJK_INDEX )
          M = LOCI+I
          N = LOCJ+J
          KK = LOCK+K
          IF (M <= N) GO TO 100
          T = M
          M = N
          N = T
  100     MN = M + N*(N-1)/2
          BUFP2(MN,KK) = VAL
  180     CONTINUE
        END DO
    1  CONTINUE
      END DO
!-----------------------------------------------------------------------                                                                       
      RETURN
      END

! QOUTaux
      SUBROUTINE QOUTaux(BUFP2,GLIBRETA,NBF,NBFaux,ISH,JSH,KLOC,NSHELL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER,DIMENSION(NSHELL) :: KLOC
      DIMENSION GLIBRETA(*)
      DOUBLE PRECISION,DIMENSION(NBF*(NBF+1)/2,NBFaux) :: BUFP2
      INTEGER :: ORII,ORIJ,ORIK
      COMMON/ORI/ORII,ORIJ,ORIK
      INTEGER :: ISH,JSH
      LOGICAL IANDJ
!-----------------------------------------------------------------------
!     Pack 4-indices into 1 word.
!     Write Label & integral on Unit 1 if DONTW = .False.
!-----------------------------------------------------------------------
      IANDJ = ISH == JSH
      LOCI = KLOC(ISH)
      LOCJ = KLOC(JSH)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IJN = 0
      JMAX = ORIJ
      DO I = 1,ORII
       I_INDEX = (I-1)*ORIJ*NBFaux
       IF (IANDJ) JMAX = I
       DO J = 1,JMAX
        IJ_INDEX = (J-1)*NBFaux + I_INDEX
        IJN = IJN+1
        KLN = 0
        DO K = 1,NBFaux
         IJK_INDEX = (K-1) + IJ_INDEX + 1
         VAL = GLIBRETA( IJK_INDEX )
         I1 = LOCI+I-1
         I2 = LOCJ+J-1
         I3 = K
         IF (I1 <= I2) GO TO 100
         N = I1
         I1 = I2
         I2 = N
  100    CONTINUE
         MN = I1 + I2*(I2-1)/2
         BUFP2(MN,K) = VAL
        END DO
       END DO
      END DO
!-----------------------------------------------------------------------
      RETURN
      END

!----------------------------------------------------------------------!
!                                                                      !
!                    Electrostatic Moment Integrals                    !     
!                                                                      !
!----------------------------------------------------------------------!

! INTMOM                                           
      SUBROUTINE INTMOM(LIT1,LJT1,IJ,IJX,IJY,IJZ,DIJ,WINT,AA,AX,AY,AZ)    
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/ELPROP/IEMOM      
      COMMON/PRPINT/XINT0,XINT1,XINT2,XINT3,YINT0,YINT1,YINT2,YINT3,    &
                    ZINT0,ZINT1,ZINT2,ZINT3
      COMMON/HERMIT/H1(55),W1(55)
      COMMON/XYZORB/TXYZ,X00,Y00,Z00,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ      
      DIMENSION DIJ(*),WINT(*),IJX(*),IJY(*),IJZ(*)                     
      DIMENSION XIN(49,4),YIN(49,4),ZIN(49,4)                           
!-----------------------------------------------------------------------
!                    Electrostatic Moment Integrals 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TXYZ  = 1.0d0/SQRT(AA)                                                 
      X00 = AX                                                           
      Y00 = AY                                                           
      Z00 = AZ                                                           
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IN = -7                                                           
      DO I=1,LIT1                                                   
       IN = IN+7                                                         
       NI = I                                                            
       DO J=1,LJT1                                                   
        JN = IN+J                                                         
        NJ = J                                                            
        CALL EMOMINT(H1,W1)                                                       
        XIN(JN,1) = XINT0*TXYZ                                               
        YIN(JN,1) = YINT0*TXYZ                                               
        ZIN(JN,1) = ZINT0*TXYZ                                               
        XIN(JN,2) = XINT1*TXYZ                                               
        YIN(JN,2) = YINT1*TXYZ                                               
        ZIN(JN,2) = ZINT1*TXYZ                                               
        IF(IEMOM>=2) THEN                                                  
         XIN(JN,3) = XINT2*TXYZ                                            
         YIN(JN,3) = YINT2*TXYZ                                            
         ZIN(JN,3) = ZINT2*TXYZ                                            
        END IF                                                            
        IF(IEMOM>=3) THEN                                                  
         XIN(JN,4) = XINT3*TXYZ                                            
         YIN(JN,4) = YINT3*TXYZ                                            
         ZIN(JN,4) = ZINT3*TXYZ                                            
        END IF                                                            
       END DO
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,IJ                                                     
       NIX = IJX(I)                                                       
       NIY = IJY(I)                                                       
       NIZ = IJZ(I)                                                       
       DENS = DIJ(I)                                                      
       XIN0 = XIN(NIX,1)                                                  
       YIN0 = YIN(NIY,1)                                                  
       ZIN0 = ZIN(NIZ,1)                                                  
       XIN1 = XIN(NIX,2)                                                   
       YIN1 = YIN(NIY,2)                                                
       ZIN1 = ZIN(NIZ,2)                                                
       INDEX = I                                                       
       WINT(INDEX) = WINT(INDEX) + XIN1 * YIN0 * ZIN0 * DENS              
       INDEX = INDEX + IJ                                                
       WINT(INDEX) = WINT(INDEX) + XIN0 * YIN1 * ZIN0 * DENS             
       INDEX = INDEX + IJ                                                
       WINT(INDEX) = WINT(INDEX) + XIN0 * YIN0 * ZIN1 * DENS             
       IF(IEMOM>=2) THEN                                                  
        XIN2 = XIN(NIX,3)                                        
        YIN2 = YIN(NIY,3)                                                
        ZIN2 = ZIN(NIZ,3)                                                
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN2 * YIN0 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN2 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN0 * ZIN2 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN1 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN0 * ZIN1 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN1 * ZIN1 * DENS           
       END IF                                                            
       IF(IEMOM>=3) THEN                                                  
        XIN3 = XIN(NIX,4)                                                
        YIN3 = YIN(NIY,4)                                                
        ZIN3 = ZIN(NIZ,4)                                                
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN3 * YIN0 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN3 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN0 * ZIN3 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN2 * YIN1 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN2 * YIN0 * ZIN1 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN2 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN2 * ZIN1 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN0 * ZIN2 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN1 * ZIN2 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN1 * ZIN1 * DENS           
       END IF                                                            
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN                                                            
      END                                                               

! EMOMINT                                           
      SUBROUTINE EMOMINT(H,WW)                                                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/ELPROP/IEMOM      
      COMMON/PRPINT/XINT0,XINT1,XINT2,XINT3,YINT0,YINT1,YINT2,YINT3,    &
                    ZINT0,ZINT1,ZINT2,ZINT3                              
      COMMON/XYZORB/TXYZ,X00,Y00,Z00,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ             
      COMMON/CMCoord/Xcm,Ycm,Zcm                           
      DIMENSION H(36),WW(36),MINARRAY(8),MAXARRAY(8)                               
      DATA MINARRAY /1,2,4, 7,11,16,22,29/                                   
      DATA MAXARRAY /1,3,6,10,15,21,28,36/
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
!     Gauss-Hermite Quadrature
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XINT0 = 0.0D+00                                                      
      YINT0 = 0.0D+00                                                      
      ZINT0 = 0.0D+00                                                      
      XINT1 = 0.0D+00                                                      
      YINT1 = 0.0D+00                                                      
      ZINT1 = 0.0D+00                                                      
      XINT2 = 0.0D+00                                                      
      YINT2 = 0.0D+00                                                      
      ZINT2 = 0.0D+00                                                      
      XINT3 = 0.0D+00                                                      
      YINT3 = 0.0D+00                                                      
      ZINT3 = 0.0D+00                                                      
      NPTS = (NI + NJ + IEMOM - 2)/2 + 1                                   
      IMIN = MINARRAY(NPTS)                                                  
      IMAX = MAXARRAY(NPTS)                                                  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I = IMIN,IMAX                                              
       DUM = WW(I)                                                     
       PX = DUM                                                       
       PY = DUM                                                       
       PZ = DUM
       DUM = H(I)*TXYZ                                                   
       PTX = DUM + X00                                                 
       PTY = DUM + Y00                                                 
       PTZ = DUM + Z00                                                 
       AX = PTX - XI                                                  
       AY = PTY - YI                                                  
       AZ = PTZ - ZI                                                  
       BX = PTX - XJ                                                  
       BY = PTY - YJ                                                  
       BZ = PTZ - ZJ                                                  
       CX = PTX - Xcm                                                  
       CY = PTY - Ycm                                                  
       CZ = PTZ - Zcm                                                  
!                                                                     
       GO TO (101,102,103,104,105,106,107), NI                        
  107  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  106  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  105  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  104  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  103  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  102  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  101  CONTINUE                                                       
!                                                                       
       GO TO (201,202,203,204,205,206,207), NJ                        
  207  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  206  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  205  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  204  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  203  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  202  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  201  CONTINUE                                                       
!                                                                     
       IEMOM1 = IEMOM + 1
       GO TO (301,302,303,304),IEMOM1                                    
  304  XINT3 = XINT3 + PX*CX*CX*CX                                    
       YINT3 = YINT3 + PY*CY*CY*CY                                    
       ZINT3 = ZINT3 + PZ*CZ*CZ*CZ                                    
  303  XINT2 = XINT2 + PX*CX*CX                                       
       YINT2 = YINT2 + PY*CY*CY                                       
       ZINT2 = ZINT2 + PZ*CZ*CZ                                       
  302  XINT1 = XINT1 + PX*CX                                          
       YINT1 = YINT1 + PY*CY                                          
       ZINT1 = ZINT1 + PZ*CZ                                          
  301  XINT0 = XINT0 + PX                                             
       YINT0 = YINT0 + PY                                             
       ZINT0 = ZINT0 + PZ                                             
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN                                                            
      END                                                               

!======================================================================!
!                                                                      !
!                    N O F     S U B R O U T I N E S                   !
!                                                                      !
!======================================================================!
      
! RunNOF
      SUBROUTINE RunNOF(NATOMSn,NBFn,NBFTn,NSHELLn,NPRIMIn,ZAN,Cxyz,    &
                        IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,INTYP,    &
                        KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP,CD,CF,   &
                        CG,CH,CI,AHCORE,OVERLAP,CHF,EiHF,DIPN,QUADN,    &
                        OCTUN,NVAL,DQOInt,NINTMXn,NREC,IX2,BUFP2,       &
                        BUFP2aux,NINTEGt,NINTEGAUXtm,IDONTW,GRADS,      &
                        IRUNTYP,DIPS,XINTS,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL CONVGDELAG,RESTART,ERIACTIVATED,HFID,HighSpin,RHF
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/CONVERGENCE/DUMEL,PCONV,CONVGDELAG
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPNOF_RHF/IRHFTYP,NCONVRHF,CONVRHFDM,MAXITRHF,RHF
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_HFID/HFID,NTHRESHEID,THRESHEID,MAXITID,KOOPMANS
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
      COMMON/ELPROP/IEMOM
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),              &
                  KLAST(100,6),LMAX(100),LPSKIP(100),IZCORE(100)
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(NATOMSn):: ZAN
      DOUBLE PRECISION,DIMENSION(3,NATOMSn):: Cxyz
      INTEGER,DIMENSION(NATOMSn):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELLn):: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELLn):: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMIn):: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMIn):: C1,C2,EX1
      DOUBLE PRECISION,DIMENSION(NPRIMIn):: CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBFn):: EiHF
      DOUBLE PRECISION,DIMENSION(NBFn,NBFn):: AHCORE,OVERLAP,CHF
      DOUBLE PRECISION,DIMENSION(3):: DIPN
      DOUBLE PRECISION,DIMENSION(6):: QUADN
      DOUBLE PRECISION,DIMENSION(10):: OCTUN
      DOUBLE PRECISION,DIMENSION(NVAL*NBFTn):: DQOInt
      INTEGER,DIMENSION(NINTEGt) :: IX2
      INTEGER:: IPRINTOPT
      DOUBLE PRECISION,DIMENSION(NINTEGt) :: BUFP2
      DOUBLE PRECISION,DIMENSION(NINTEGAUXtm) :: BUFP2aux      
      DOUBLE PRECISION,DIMENSION(3*NATOMSn) :: GRADS
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2) :: XINTS
      DOUBLE PRECISION,DIMENSION(3):: DIPS
!
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: COEF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: XIJKL,XIJKaux,USER
      CHARACTER*4,ALLOCATABLE,DIMENSION(:)::ATMNAME
      INTEGER,ALLOCATABLE,DIMENSION(:)::LIMLOW,LIMSUP,IJKL
      LOGICAL CONVG
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: GAMMA,FMIUG0
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::   ELAGN,RON
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: ELAG,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AQUADxx,AQUADyy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AQUADzz,AQUADxy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AQUADxz,AQUADyz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTxxx,AOCTyyy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTzzz,AOCTxxz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTxyy,AOCTyyz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTxzz,AOCTxxy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTyzz,AOCTxyz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: XATOM,YATOM,ZATOM
!-----------------------------------------------------------------------
      ALLOCATE(XATOM(NATOMS),YATOM(NATOMS),ZATOM(NATOMS))
      XATOM(1:NATOMS) = Cxyz(1,1:NATOMS)
      YATOM(1:NATOMS) = Cxyz(2,1:NATOMS)
      ZATOM(1:NATOMS) = Cxyz(3,1:NATOMS)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(COEF(NBF,NBF))
      COEF = CHF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate Nuclear Energy (EN)
!     ZAN: Nuclear charge array (1,NATOMS)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL NUCLEARm(NATOMS,ZAN,Cxyz,EN)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IAN(1) = IAN(1)   ! Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Name of Atoms
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ATMNAME(NATOMS))
      CALL ATOMNAMES(NATOMS,ZAN,IZCORE,ATMNAME,Cxyz,NPRINT,0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Atomic Basis Set
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       IMIN: Index of minimal primitive for atom
!       IMAX: Index of maximal primitive for atom
!     KSTART: Tells the location of the first exponent and the first
!             contraction coefficient contained in a particular shell
!      KATOM: Tells which atom the shell is centered on
!      KTYPE: is 1,2,3,4,5,6,7 for S,P,D,F,G,H,I. For L shell is 2
!       KLOC: Gives the location of the shell in the total AO basis 
!      INTYP: Index for the type of the shell
!        KNG: Number of Gaussians in the shell
!       KMIN: Starting index of the shell
!       KMAX: Ending index of the shell
!        ISH: Shell for the primitive
!       ITYP: Index for the type of the primitive
!         EX: Gaussian exponents
!         C1: S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.
!         C2: Extra L CONTRACTION COEFFICIENTS.
!      CS-CI: S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IPRINTATOMBASIS=0
      IF(NPRINT==1.and.IPRINTATOMBASIS==1.and.IPRINTOPT==1)             &
      CALL ATOMBASIS(NATOMS,ATMNAME,IMIN,IMAX,NPRIMI,ITYP,ISH,EX1,C1,C2)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Create the basis function symbol table
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(LIMLOW(NATOMS),LIMSUP(NATOMS))
      CALL SYMBOLTABLE(KATOM,ATMNAME,INTYP,KLOC,LIMLOW,LIMSUP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NINTMX:  Number of 2e-integrals (ERIs) per record (15000)
!     NINTCHK: Integral of NINTMX in each core
!     NPROCS:  Number of cores
!     NCHUNKS: Number of chunks
!     NINTCR:  Space needed to allocate 2e- integrals in Slaves
!     NSTORE:  Space needed to allocate 2e- integrals in Master
!              NIJKL if serial, NINTCR if parallel
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NINTMX = NINTMXn
      NIJKL  = NINTEGt
      NIJKaux  = NINTEGAUXtm
      CALL DISTRIBUTION(IPRINTOPT)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Read two-electron Repulsion Integrals in AO basis (ERI)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(IJKL(NSTORE),XIJKL(NSTORE),XIJKaux(NSTOREaux))
      IF(IERITYP==1) THEN
       CALL READERIs(IJKL,XIJKL,IX2,BUFP2,NINTEGt,IDONTW,NREC)
      ELSE IF(IERITYP==2 .or. IERITYP==3) THEN
       CALL READERIsAUX(XIJKaux,BUFP2aux,NINTEGAUXtm)
      END IF   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Allocate User array
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(USER(NUSER))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Pass atomic dipole, quadrupole and octupole matrices to USER array
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IEMOM>=1)THEN
       ALLOCATE(ADIPx(NSQ),ADIPy(NSQ),ADIPz(NSQ))
       CALL CPYTSQ(DQOInt(1       ),ADIPx,NBF)
       CALL CPYTSQ(DQOInt(1+  NBFT),ADIPy,NBF)
       CALL CPYTSQ(DQOInt(1+2*NBFT),ADIPz,NBF)
       CALL PASSDIPUSER(DIPN,ADIPx,ADIPy,ADIPz,USER)
       DEALLOCATE(ADIPx,ADIPy,ADIPz)
      END IF
!
      IF(IEMOM>=2)THEN
       ALLOCATE(AQUADxx(NSQ),AQUADyy(NSQ),AQUADzz(NSQ),                 &
                AQUADxy(NSQ),AQUADxz(NSQ),AQUADyz(NSQ))
       CALL CPYTSQ(DQOInt(1+3*NBFT),AQUADxx,NBF)
       CALL CPYTSQ(DQOInt(1+4*NBFT),AQUADyy,NBF)
       CALL CPYTSQ(DQOInt(1+5*NBFT),AQUADzz,NBF)
       CALL CPYTSQ(DQOInt(1+6*NBFT),AQUADxy,NBF)
       CALL CPYTSQ(DQOInt(1+7*NBFT),AQUADxz,NBF)
       CALL CPYTSQ(DQOInt(1+8*NBFT),AQUADyz,NBF)
       CALL PASSQUADUSER(QUADN,AQUADxx,AQUADyy,AQUADzz,                 &
                         AQUADxy,AQUADxz,AQUADyz,USER)
       DEALLOCATE(AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,AQUADyz)
      END IF
!
      IF(IEMOM==3)THEN
       ALLOCATE(AOCTxxx(NSQ),AOCTyyy(NSQ),AOCTzzz(NSQ),AOCTxxy(NSQ),    &
                AOCTxxz(NSQ),AOCTxyy(NSQ),AOCTyyz(NSQ),AOCTxzz(NSQ),    &
                AOCTyzz(NSQ),AOCTxyz(NSQ))
       CALL CPYTSQ(DQOInt(1+ 9*NBFT),AOCTxxx,NBF)
       CALL CPYTSQ(DQOInt(1+10*NBFT),AOCTyyy,NBF)
       CALL CPYTSQ(DQOInt(1+11*NBFT),AOCTzzz,NBF)
       CALL CPYTSQ(DQOInt(1+12*NBFT),AOCTxxy,NBF)
       CALL CPYTSQ(DQOInt(1+13*NBFT),AOCTxxz,NBF)
       CALL CPYTSQ(DQOInt(1+14*NBFT),AOCTxyy,NBF)
       CALL CPYTSQ(DQOInt(1+15*NBFT),AOCTyyz,NBF)
       CALL CPYTSQ(DQOInt(1+16*NBFT),AOCTxzz,NBF)
       CALL CPYTSQ(DQOInt(1+17*NBFT),AOCTyzz,NBF)
       CALL CPYTSQ(DQOInt(1+18*NBFT),AOCTxyz,NBF)
       CALL PASSOCTUSER(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,  &
                        AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,USER)
       DEALLOCATE(AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxz,AOCTxyy)
       DEALLOCATE(AOCTyyz,AOCTxzz,AOCTxxy,AOCTyzz,AOCTxyz)
      END IF
!***********************************************************************
!     FIRSTCALL: Initialize variables    COEF,      GAMMA,     FMIUG0
!                         according to INPUTC, INPUTGAMMA, INPUTFMUIG
!***********************************************************************
      ALLOCATE(GAMMA(NBF5),FMIUG0(NBF))
      CALL INITr(COEF,OVERLAP,GAMMA,FMIUG0,IPRINTOPT)
!=======================================================================      
!     Restricted Hartree-Fock (RHF)                                    
!     Use the Iterative Diagonalization Method to generate the HF MOs  
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(HFID)THEN
       if(INPUTC==1)CHF = COEF
       CALL HFIDr(AHCORE,IJKL,XIJKL,XIJKaux,CHF,EiHF,USER,IPRINTOPT)
       if(INPUTC==0)COEF = CHF
       if(INPUTFMIUG==0)FMIUG0 = EiHF
      ELSE
       if(INPUTC==0.and.IPRINTOPT==1)then
        if(IRHFTYP==0)then
         WRITE(6,'(/A32)')' Input for Coefficients is HCORE'
        else
         WRITE(6,'(/A30)')' Input for Coefficients is RHF'
        end if
       end if
      ENDIF
!=======================================================================      
!     INITIALIZE LOCAL VARIABLES                                       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IT=0
      ILOOP=0
      ITTOTAL=0
      IFIRSTCALL=0
      CONVG=.FALSE.
!=======================================================================
!               OPTIMIZATION WITH RESPECT TO THE OCCUPATIONS           
!=======================================================================
      ALLOCATE(ELAG(NBF,NBF),ELAGN(NBF),COEFN(NBF,NBF),RON(NBF))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Note: CONVGDELAG is the fundamental criterion in the optimization, 
!           so it must be FALSE before minimizing respect to GAMMAs and 
!           being able to call the CG subroutine. Its value is 
!           determined in the orbital optimization subroutine.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CONVGDELAG=.FALSE.
      IF(IRUNTYP/=3) EELEC_MIN = 1.0d20 ! GLOBAL FIRST CALL
      CALL OCCOPTr(IFIRSTCALL,CONVG,ATMNAME,ZAN,OVERLAP,LIMLOW,LIMSUP,  &
                   COEF,GAMMA,FMIUG0,AHCORE,IJKL,XIJKL,XIJKaux,ELAG,    &
                   USER,IZCORE,XATOM,YATOM,ZATOM,KSTART,KNG,KMIN,KMAX,  &
                   KATOM,KTYPE,KLOC,IMIN,IMAX,ISH,ITYP,EX1,C1,C2,CS,    &
                   CP,CD,CF,CG,CH,CI,ELAGN,COEFN,RON,IT,ITTOTAL,DIPS,   &
                   IPRINTOPT,IRUNTYP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     END SINGLE-POINT CALCULATION (ICOEF=0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==0)THEN
       if(IERITYP==3 .and. MIXSTATE==1)then  ! MIX: Change to FULL ERIs
        CALL READERIs(IJKL,XIJKL,IX2,BUFP2,NINTEGt,IDONTW,NREC)
        MIXSTATE = 2
       end if
       CALL PT2GRAD(ELAG,COEF,AHCORE,IJKL,XIJKL,USER,IRUNTYP,GRADS,     &
                    ATMNAME,KATOM,KTYPE,KLOC,KMIN,KMAX,KSTART,KNG,XATOM,&
                    YATOM,ZATOM,ZAN,EX1,CS,CP,CD,CF,CG,XINTS,IPRINTOPT)
       IF(IERITYP==3 .and. MIXSTATE==2) MIXSTATE = 1              ! MIX
       IF(IPRINTOPT==1)WRITE(6,2)IT
       GOTO 10
      ENDIF
!======================================================================!
!     SINGLE-POINT CALCULATION: FULL OPTIMIZATION FOR A GIVEN GEOMETRY !
!     Optimization with respect to the Occupations and Orbitals (COEF) !
!     using the iterative diagonalization method                       !
!======================================================================!
      IFIRSTCALL=1
      ITLIM=1
      DO WHILE(IT<=MAXIT)
       IT=IT+1
!      Orbital Optimization
       IF(ICOEF==1.or.ICOEF==2)THEN
        CALL ORBOPTr(IT,ITLIM,AHCORE,IJKL,XIJKL,XIJKaux,USER(N7),COEF,  &
                     USER(N1),USER(N2),USER(N3),ELAG,FMIUG0,USER(N11),  &
                     USER(N12),USER(N13),USER(N14),ILOOP,IPRINTOPT)
!      Core-Fragment Orbital Optimization
       ELSEIF(ICOEF==3)THEN
        IF(MSpin>0)STOP          ! To be implemented        
        CALL ORBOPTFrc(IT,ITLIM,AHCORE,IJKL,XIJKL,USER(N7),COEF,        &
                       USER(N1),USER(N2),USER(N3),ELAG,FMIUG0,          &
                       USER(N11),USER(N12),USER(N13),USER(N14),         &
                       ILOOP,IRUNTYP)
       ENDIF
!      MIX: Change to FULL ERIs if RI is converged
       IF(IERITYP==3 .and. MIXSTATE==1 .and. CONVGDELAG) THEN
        IF(IPRINTOPT==1)WRITE(6,*) "Change to FULL ERIs"
        CONVGDELAG = .FALSE.
        CALL READERIs(IJKL,XIJKL,IX2,BUFP2,NINTEGt,IDONTW,NREC)
        MIXSTATE = 2
       END IF
       
!      Occupation Optimization
       ITTOTAL=ITTOTAL+ILOOP
       CALL OCCOPTr(IFIRSTCALL,CONVG,ATMNAME,ZAN,OVERLAP,LIMLOW,LIMSUP, &
                    COEF,GAMMA,FMIUG0,AHCORE,IJKL,XIJKL,XIJKaux,ELAG,   &
                    USER,IZCORE,XATOM,YATOM,ZATOM,KSTART,KNG,KMIN,KMAX, &
                    KATOM,KTYPE,KLOC,IMIN,IMAX,ISH,ITYP,EX1,C1,C2,CS,   &
                    CP,CD,CF,CG,CH,CI,ELAGN,COEFN,RON,IT,ITTOTAL,DIPS,  &
                    IPRINTOPT,IRUNTYP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      END SINGLE-POINT CALCULATION (CONVG=TRUE)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(CONVG)THEN
        CALL PT2GRAD(ELAG,COEF,AHCORE,IJKL,XIJKL,USER,IRUNTYP,GRADS,    &
                    ATMNAME,KATOM,KTYPE,KLOC,KMIN,KMAX,KSTART,KNG,XATOM,&
                    YATOM,ZATOM,ZAN,EX1,CS,CP,CD,CF,CG,XINTS,IPRINTOPT)
!       MIX: Return to RI ERIs if FULL is converged                    
        IF(IERITYP==3 .and. MIXSTATE==2 .and. CONVGDELAG)MIXSTATE = 1
!                    
        IF(IPRINTOPT==0)GOTO 10
        WRITE(6,4)
        WRITE(6,5)IT,ITTOTAL
        GOTO 10
       ENDIF
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     EXCESSIVE NUMBER OF ITERATIONS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IT>MAXIT)THEN
       WRITE(6,3)
       WRITE(6,5)IT,ITTOTAL
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     STOP PROGRAM, DEALLOCATE MEMORY, GIVES ELAPSED TIME if IT > MAXIT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   10 CONTINUE 
      DEALLOCATE(COEF,ATMNAME,LIMLOW,LIMSUP,XATOM,YATOM,ZATOM)
      DEALLOCATE(GAMMA,FMIUG0,ELAG,ELAGN,RON,USER,COEFN)
      DEALLOCATE(IJKL,XIJKL,XIJKaux)
!-----------------------------------------------------------------------
!   1 FORMAT(/,'  ELAPSED REAL TIME :',F10.2,'  (SECONDS)')
    2 FORMAT(//2X,'**************************************************', &
              /2X,'*                                                *', &
              /2x,'*       SINGLE-POINT DoNOF CALCULATION           *', &
              /2X,'*                                                *', &
              /2X,'*            No.ITER =',I6,'                     *', &
              /2X,'*         (Occupation Optimization)              *', &
              /2X,'*                                                *', &
              /2x,'*  FINAL RESULTS   FINAL RESULTS  FINAL RESULTS  *', &
              /2X,'*                                                *', &
              /2X,'**************************************************')
    3 FORMAT(/,10X,30(1H-),/,10X,'EXCESSIVE NUMBER OF ITERATIONS',      &
             /,10X,30(1H-))
    4 FORMAT(//2X,'**************************************************', &
              /2X,'*                                                *', &
              /2x,'*       SINGLE-POINT DoNOF CALCULATION           *', &
              /2X,'*                                                *', &
              /2X,'*             FULL OPTIMIZATION                  *', &
              /2X,'*                                                *', &
              /2x,'*  FINAL RESULTS   FINAL RESULTS  FINAL RESULTS  *', &
              /2X,'*                                                *', &
              /2X,'**************************************************')
    5 FORMAT(/2X,'**************************************************',  &
             /2X,'*         No. EXTERNAL ITER =',I6,'              *',  &
             /2X,'*         No. of TOTAL ITER =',I6,'              *',  &
             /2X,'**************************************************')
!-----------------------------------------------------------------------
      RETURN
      END

! PT2GRAD
      SUBROUTINE PT2GRAD(ELAG,COEF,AHCORE,IJKL,XIJKL,USER,IRUNTYP,      &
                         GRADS,ATMNAME,KATOM,KTYPE,KLOC,KMIN,KMAX,      &
                         KSTART,KNG,XATOM,YATOM,ZATOM,ZAN,EX1,CS,CP,    &
                         CD,CF,CG,XINTS,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL OIMP2,SC2MCPT,HighSpin
      LOGICAL MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_OIMP2/OIMP2
      COMMON/INPNOF_MBPT/MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/INPNOF_SC2MCPT/SC2MCPT
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: ELAG,COEF,AHCORE
      INTEGER,DIMENSION(NSTORE) :: IJKL  
      DOUBLE PRECISION,DIMENSION(NSTORE):: XIJKL
      DOUBLE PRECISION,DIMENSION(NUSER) :: USER 
      DOUBLE PRECISION,DIMENSION(3*NATOMS) :: GRADS      
      CHARACTER*4 ATMNAME(NATOMS)
      INTEGER,DIMENSION(NSHELL):: KATOM,KTYPE,KLOC,KMIN,KMAX,KSTART,KNG
      DOUBLE PRECISION,DIMENSION(NATOMS) :: XATOM,YATOM,ZATOM,ZAN 
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2) :: XINTS 
!-----------------------------------------------------------------------      
!     Orbital-Invariant MP2 Perturbative Corrections
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(OIMP2.or.MBPT)THEN
#ifdef MPI
       WRITE(6,1)
       CALL ABRT       
!      avoiding warnings    
       AHCORE(1,1) = AHCORE(1,1)
       IJKL(1) = IJKL(1)
       XIJKL(1) = XIJKL(1)
#else
       if(IERITYP==1 .or. IERITYP==3)then
        CALL ORBINVMP2(ELAG,COEF,USER(N1),USER(N2),USER(N3),AHCORE,IJKL,&
                       XIJKL,USER(N12),USER(N13),USER(N14))
       else if(IERITYP==2)then
        WRITE(6,5)
        CALL ABRT  
       end if       
#endif                                             
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     SC2-MCPT (Hartree-Fock Partition)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SC2MCPT)THEN
       if(NSOC==0)then
#ifdef MPI
        WRITE(6,2)
        CALL ABRT       
!       avoiding warnings    
        AHCORE(1,1) = AHCORE(1,1)
        IJKL(1) = IJKL(1)
        XIJKL(1) = XIJKL(1)
#else
        if(IERITYP==1 .or. IERITYP==3)then
         CALL SC2MCPThf(USER(N1),COEF,AHCORE,IJKL,XIJKL,USER(N10))
        else if(IERITYP==2)then
         WRITE(6,6)
         CALL ABRT  
        end if
#endif 
       else
        WRITE(6,3)      
        CALL ABRT        
       end if
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Analytical Gradient Calculation for PNOF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IRUNTYP>1)THEN
       IF(.not.HighSpin)THEN
        CALL PNOFGRAD(COEF,USER(N7),USER(N1),ELAG,GRADS,ATMNAME,KATOM, &
                      KTYPE,KLOC,KMIN,KMAX,KSTART,KNG,XATOM,YATOM,     &
                      ZATOM,ZAN,EX1,CS,CP,CD,CF,CG,USER(N2),USER(N3),  &
                      XINTS,IPRINTOPT) 
       ELSE
        WRITE(6,4)
        CALL ABRT       
       END IF
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   
#ifdef MPI
    1 FORMAT(/1X,'Sorry: OIMP2 is not implemented with MPI.',           &
            //1X,'Use serial code for perturbative calculations.',/)           
    2 FORMAT(/1X,'Sorry: SC2MCPT is not implemented with MPI.',         &
            //1X,'Use serial code for perturbative calculations.',/)  
#else
    5 FORMAT(/1X,'Sorry: OIMP2 is not implemented with ERITYP=RI.',     &
            //1X,'Use ERITYP=FULL for perturbative calculations.',/)
    6 FORMAT(/1X,'Sorry: SC2MCPT is not implemented with ERITYP=RI.',   &
            //1X,'Use ERITYP=FULL for perturbative calculations.',/) 
#endif
    3 FORMAT(/1X,'Sorry: NSOC>0, SC2MCPT is not implemented for',       &
              1X,'Spin-uncompensated systems',/) 
    4 FORMAT(/1X,'Sorry: GRADIENT is not implemented for High Spin',/)
!-----------------------------------------------------------------------
      RETURN
      END

!----------------------------------------------------------------------!
!                                                                      !
!                    Nuclear related Subroutines                       !
!                                                                      !
!   NUCLEARm: Calculate the nuclear energy                             !
!   DQONuclear: Nuclear Dipole, Quadrupole, Octupole Elec. Moments     !
!   ATOMNAMES: Write atom name-coordinates                             !
!                                                                      !
!----------------------------------------------------------------------!

! NUCLEARm
      SUBROUTINE NUCLEARm(NATOMS,ZNUC,Cxyz,Enuc)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NATOMS) :: ZNUC
      DOUBLE PRECISION,DIMENSION(3,NATOMS) :: Cxyz
!-----------------------------------------------------------------------
      Enuc = 0.0
      DO I=1,NATOMS-1
       DO J=I+1,NATOMS
        DISTNUC = (Cxyz(1,I)-Cxyz(1,J))**2                              &
                + (Cxyz(2,I)-Cxyz(2,J))**2 + (Cxyz(3,I)-Cxyz(3,J))**2
        Enuc = Enuc + ZNUC(I)*ZNUC(J)/SQRT(DISTNUC)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! DQONuclear
      SUBROUTINE DQONuclear(DIPN,QUADN,OCTUN,Cxyz,ZAN,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/CMCoord/Xcm,Ycm,Zcm
      DOUBLE PRECISION,DIMENSION(3) :: DIPN
      DOUBLE PRECISION,DIMENSION(6) :: QUADN
      DOUBLE PRECISION,DIMENSION(10):: OCTUN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
!-----------------------------------------------------------------------
      DIPN  = 0.0d0                                                     
      QUADN = 0.0d0                                                       
      OCTUN = 0.0d0
      DO I=1,NAT
       XN = Cxyz(1,I) - Xcm
       YN = Cxyz(2,I) - Ycm
       ZN = Cxyz(3,I) - Zcm
       DIPN(1)   = DIPN(1)   + ZAN(I)*XN                                        
       DIPN(2)   = DIPN(2)   + ZAN(I)*YN                                        
       DIPN(3)   = DIPN(3)   + ZAN(I)*ZN                                        
       QUADN(1)  = QUADN(1)  + ZAN(I)*XN*XN                               
       QUADN(2)  = QUADN(2)  + ZAN(I)*YN*YN                               
       QUADN(3)  = QUADN(3)  + ZAN(I)*ZN*ZN                               
       QUADN(4)  = QUADN(4)  + ZAN(I)*XN*YN                               
       QUADN(5)  = QUADN(5)  + ZAN(I)*XN*ZN                               
       QUADN(6)  = QUADN(6)  + ZAN(I)*YN*ZN                               
       OCTUN(1)  = OCTUN(1)  + ZAN(I)*XN*XN*XN                            
       OCTUN(2)  = OCTUN(2)  + ZAN(I)*YN*YN*YN                            
       OCTUN(3)  = OCTUN(3)  + ZAN(I)*ZN*ZN*ZN                            
       OCTUN(4)  = OCTUN(4)  + ZAN(I)*XN*XN*YN                            
       OCTUN(5)  = OCTUN(5)  + ZAN(I)*XN*XN*ZN                            
       OCTUN(6)  = OCTUN(6)  + ZAN(I)*XN*YN*YN                            
       OCTUN(7)  = OCTUN(7)  + ZAN(I)*YN*YN*ZN                            
       OCTUN(8)  = OCTUN(8)  + ZAN(I)*XN*ZN*ZN                            
       OCTUN(9)  = OCTUN(9)  + ZAN(I)*YN*ZN*ZN                            
       OCTUN(10) = OCTUN(10) + ZAN(I)*XN*YN*ZN                          
      END DO                                                            
!-----------------------------------------------------------------------
      RETURN
      END
      
! ATOMNAMES
      SUBROUTINE ATOMNAMES(NATOMS,ZNUC,IZCORE,ATMNAME,Cxyz,NPRINT,      &
                           IWRITECXYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER:: IWRITECXYZ      
      CHARACTER*4 ATMNAME(NATOMS)
      DIMENSION ZNUC(NATOMS),IZCORE(NATOMS)
      DIMENSION Cxyz(3,NATOMS)
      CHARACTER*4,DIMENSION(106) :: ATMLAB
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',            &
                  'N   ','O   ','F   ','NE  ','NA  ','MG  ',            &
                  'AL  ','SI  ','P   ','S   ','CL  ','AR  ',            &
                  'K   ','CA  ','SC  ','TI  ','V   ','CR  ',            &
                  'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',            &
                  'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',            &
                  'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',            &
                  'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',            &
                  'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',            &
                  'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',            &
                  'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',            &
                  'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',            &
                  'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',            &
                  'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',            &
                  'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',            &
                  'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',            &
                  'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',            &
                  'LR  ','RF  ','X   ','BQ  '/
!-----------------------------------------------------------------------
      DO I=1,NATOMS
       IZNUC = INT(ZNUC(I))+IZCORE(I)
       ATMNAME(I)=ATMLAB(IZNUC)
      ENDDO
      IF(NPRINT==1.and.IWRITECXYZ==1)THEN
       WRITE(6,1)
       DO I=1,NATOMS
        WRITE(6,2)ATMNAME(I),ZNUC(I)+IZCORE(I),                         &
                  Cxyz(1,I),Cxyz(2,I),Cxyz(3,I)
       ENDDO
      END IF
!-----------------------------------------------------------------------
    1 FORMAT(/1X,'Atom',6X,'Charge',16X,'Coordinates (Bohr)'/           &
              27X,'x',13X,'y',13X,'z')                     
    2 FORMAT(1X,A4,6X,F5.1,3F14.4)                              
!-----------------------------------------------------------------------
      RETURN
      END

!----------------------------------------------------------------------!

! ATOMBASIS
      SUBROUTINE ATOMBASIS(NATOMS,ATMNAME,IMIN,IMAX,NPRIMI,ITYP,ISH,    &
                           EX1,C1,C2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4 ATMNAME(NATOMS)
      DIMENSION IMIN(NATOMS),IMAX(NATOMS),ITYP(NPRIMI),ISH(NPRIMI)
      DIMENSION EX1(NPRIMI),C1(NPRIMI),C2(NPRIMI)
      CHARACTER*2 LABEL(8)
      DATA LABEL/'S ','P ','D ','F ','G ','H ','I ','L'/
!-----------------------------------------------------------------------
      WRITE(6,1)
!-----------------------------------------------------------------------
!     Atomic Basis Set
!
!     NSHELL: THE TOTAL NUMBER OF SHELLS.  
!             P SHELL MEANS X,Y,Z,
!             D SHELL MEANS XX,YY,ZZ,XY,XY,YZ, AND SO ON FOR F,G,H,I.
!     NPRIMI: TOTAL NUMBER OF PRIMITIVE EXPONENTS
!       IMIN: INDEX OF MINIMAL PRIMITIVE for ATOM
!       IMAX: INDEX OF MAXIMAL PRIMITIVE for ATOM
!       ITYP: INDEX for the TYPE of the PRIMITIVE
!        ISH: SHELL for the PRIMITIVE
!        EX1: GAUSSIAN EXPONENTS, FOR EVERY SYMMETRY UNIQUE PRIMITIVE.
!         C1: S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.
!         C2: NORMALLY ONLY C1 ARRAYS WILL BE NON-ZERO,
!             THE EXCEPTION IS "L" SHELLS,
!             WHERE BOTH C1 AND C2 WILL HAVE DIFFERENT VALUES.
!-----------------------------------------------------------------------
      DO I=1,NATOMS
       WRITE(6,2)ATMNAME(I)
       DO J=IMIN(I),IMAX(I)
        IF(ITYP(J)<8)THEN
         WRITE(6,3)ISH(J),LABEL(ITYP(J)),J,EX1(J),C1(J)
        ELSE
         WRITE(6,3)ISH(J),LABEL(ITYP(J)),J,EX1(J),C1(J),C2(J)
        ENDIF
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
    1 FORMAT(//5X,'Atomic Basis Set'/5X,16(1H-),//,2X,                  &
             'THE CONTRACTED BASIS FUNCTIONS ARE NORMALIZED TO UNITY',  &
             //2X,'SHELL TYPE',2X,'PRIMITIVE',8X,'EXPONENT',6X,         &
             'CONTRACTION COEFFICIENT(S)')
    2 FORMAT(/1X,A4,/)
    3 FORMAT(1X,I6,3X,A2,I7,F22.7,2F18.12)
!-----------------------------------------------------------------------
      RETURN
      END

! SYMBOLTABLE
      SUBROUTINE SYMBOLTABLE(KATOM,ATMNAME,INTYP,KLOC,LIMLOW,LIMSUP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      CHARACTER*4 LABELAT,ATMNAME(NATOMS),BFNAM1(35)
      CHARACTER*6 BFNAM2(49)
      DIMENSION KATOM(NSHELL),INTYP(NSHELL),KLOC(NSHELL)
      DIMENSION LIMLOW(NATOMS),LIMSUP(NATOMS),KMIN(8),KMAX(8)
      DIMENSION INTYPS(8,NATOMS)
      DATA KMIN /1,2, 5,11,21,34,57,1/
      DATA KMAX /1,4,10,20,35,56,84,4/
      DATA BFNAM1/'  S ','  X ','  Y ','  Z ',                          &
                  ' XX ',' YY ',' ZZ ',' XY ',' XZ ',' YZ ',            &
                  ' XXX',' YYY',' ZZZ',' XXY',' XXZ',                   &
                  ' YYX',' YYZ',' ZZX',' ZZY',' XYZ',                   &
                  'XXXX','YYYY','ZZZZ','XXXY','XXXZ',                   &
                  'YYYX','YYYZ','ZZZX','ZZZY','XXYY',                   &
                  'XXZZ','YYZZ','XXYZ','YYXZ','ZZXY'/
      DATA BFNAM2/' XXXXX',' YYYYY',' ZZZZZ',' XXXXY',' XXXXZ',         &
                  ' YYYYX',' YYYYZ',' ZZZZX',' ZZZZY',' XXXYY',         &
                  ' XXXZZ',' YYYXX',' YYYZZ',' ZZZXX',' ZZZYY',         &
                  ' XXXYZ',' YYYXZ',' ZZZXY',' XXYYZ',' XXZZY',         &
                  ' YYZZX',                                             &
                  '    X6','    Y6','    Z6','   X5Y','   X5Z',         &
                  '   Y5X','   Y5Z','   Z5X','   Z5Y','  X4Y2',         &
                  '  X4Z2','  Y4X2','  Y4Z2','  Z4X2','  Z4Y2',         &
                  '  X4YZ','  Y4XZ','  Z4XY','  X3Y3','  X3Z3',         &
                  '  Y3Z3',' X3Y2Z',' X3Z2Y',' Y3X2Z',' Y3Z2X',         &
                  ' Z3X2Y',' Z3Y2X','X2Y2Z2'/
!-----------------------------------------------------------------------
!         ----- BASIS FUNCTION SYMBOL TABLE -----
!         S,  X,Y,Z,  XX,YY,ZZ,XY,XZ,YZ,
!         1   2 3 4    5  6  7  8  9 10
!         XXX,YYY,ZZZ,XXY,XXZ,YYX,YYZ,ZZX,ZZY,XYZ, ... G,H,I
!         11  12  13,  14  15  16  17  18  19  20, ... G,H,I
!
!      KATOM: TELLS WHICH ATOM THE SHELL IS CENTERED ON,
!             NORMALLY MORE THAN ONE SHELL EXISTS ON EVERY ATOM.
!
!      KLOC: Gives the location of the shell in the total AO basis 
!
!      INTYP: INDEX for the TYPE of the SHELL
!
!     KMIN AND KMAX ARE THE STARTING AND ENDING INDICES OF THE SHELL.  
!     THESE ARE DEFINED AS
!                    S    P    D    F   G   H   I   L
!             KMIN   1    2    5   11  21  34  57   1
!             KMAX   1    4   10   20  35  56  84   4
!-----------------------------------------------------------------------
      WRITE(4,'(I5)')NBF
      DO J = 1,NSHELL
       IAT = KATOM(J)
       LABELAT = ATMNAME(IAT)
       MINI = KMIN(INTYP(J))
       MAXI = KMAX(INTYP(J))
       DO I = MINI,MAXI
        IF(I<=35)THEN
         WRITE(4,'(A2,I2,A4)')LABELAT,MOD(IAT,100),BFNAM1(I)
        ELSE
         WRITE(4,'(A2,A6)')LABELAT,BFNAM2(I-35)
        END IF
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     INTYPS: 8xNATOMS matrix containing the dimension of each shell
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INTYPS = 0
      LAT = 1
      ISUMTYP = 0
      ITYP0 = INTYP(1)
      NTYP = 1
!
      DO J = 1,NSHELL
       IAT = KATOM(J)
       IF(IAT==LAT)THEN
        IF(INTYP(J)==ITYP0)THEN
         ISUMTYP = ISUMTYP + 1
        ELSE
         ISUMTYP = 1
         ITYP0 = INTYP(J)
        ENDIF
       ELSE
        LAT = IAT
        ISUMTYP = 1
        ITYP0 = INTYP(J)
       ENDIF       
       INTYPS(ITYP0,LAT) = ISUMTYP
      ENDDO
!
      DO J = 1,NATOMS
       WRITE(4,'(9I5)')J,(INTYPS(I,J),I=1,8)
      ENDDO
!-----------------------------------------------------------------------
!     NUMBER OF BASIS FUNCTIONS PER ATOM: LIMLOW(iat) ... LIMSUP(iat)
!-----------------------------------------------------------------------
      IF(NATOMS>100)THEN
       WRITE(6,*)'Stop, NATOMS>100, enlarge the dimensions of limlow'
       CALL ABRT       
      ENDIF
      LAT=1
      J=1
! - - - - - - - - - - - - - -  
      LIMLOW(1)=1  
      DO I=1,NSHELL
       IAT=KATOM(I)
       IF(LAT/=IAT)THEN
        LAT=IAT
        LIMSUP(J)=KLOC(I)-1
        J=J+1
        LIMLOW(J)=KLOC(I)
       ENDIF
      ENDDO
! - - - - - - - - - - - - - -      
      LIMSUP(J)=NBF
      IF(J<NATOMS)THEN
       JP1=J+1
       DO J=JP1,NATOMS
        LIMLOW(J)=NBF
        LIMSUP(J)=1
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! DISTRIBUTION
      SUBROUTINE DISTRIBUTION(IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER:: IPRINTOPT     
      LOGICAL ERIACTIVATED       
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
!-----------------------------------------------------------------------      
#include "mpip.h"
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
!     NINTMX:  Number of 2e-integrals (ERIs) per record (15000)
!     NINTCHK: Integral of NINTMX in each core
!     NPROCS:  Number of cores
!     NCHUNKS: Number of chunks
!     NINTCR:  Dimension of ERIs in Slaves
!     NSTORE:  Dimension of ERIs in Master
!              NIJKL if serial, NINTCR if parallel
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
#ifdef MPI

      if(IERITYP==1 .or. IERITYP==3)then
      
       NINTCHK = INT(NINTMX/(2*NPROCS))*2+2
       NCHUNKS = INT(NIJKL/NINTMX)+1+10
       NINTCR = NINTCHK*NCHUNKS
       NSTORE = NINTCR+NINTMX
       IF(IPRINTOPT==1)THEN
        Write(6,501)
        Write(6,502)NIJKL
        Write(6,503)NINTCHK
        Write(6,504)NCHUNKS
        Write(6,505)NINTCR
        Write(6,506)NSTORE
       ENDIF

      end if

      if(IERITYP==2 .or. IERITYP==3)then       

       NSTOREaux = INT(NBFaux/NPROCS)*NBF*(NBF+1)/2
       IAUXDIM = INT(NBFaux/NPROCS)
       EXTRAS = MOD(NBFaux,NPROCS)
       IF(IPRINTOPT==1)THEN
        Write(6,511)
        Write(6,512)NIJKaux
        IF(EXTRAS==0) THEN
          Write(6,513) NSTOREaux
        ELSE
          Write(6,513) NSTOREaux+NBF*(NBF+1)/2
        END IF
        Write(6,514)NSTOREaux
       ENDIF      

      end if    
      
!-----------------------------------------------------------------------
!     Format Statements Full Center ERIs
!-----------------------------------------------------------------------
  501 FORMAT(/,1X,'Distribution Full ERIs:',/)
  502 FORMAT(1X,'Integrals:                ',I18)
  503 FORMAT(1X,'Integrals/chunk:          ',I18)
  504 FORMAT(1X,'Chunks:                   ',I18)
  505 FORMAT(1X,'Max size per slaves:      ',I18)
  506 FORMAT(1X,'Max size in master:       ',I18)
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!     Format Statements RI b
!-----------------------------------------------------------------------
  511 FORMAT(/,1X,'Distribution b tensor:',/)
  512 FORMAT(1X,'Elements:                 ',I18)
  513 FORMAT(1X,'Max size per slaves:      ',I18)
  514 FORMAT(1X,'Max size in master:       ',I18)
!-----------------------------------------------------------------------
      
#else
      if(IERITYP==1 .or. IERITYP==3)then
       NINTCR = NIJKL
       NSTORE = NINTCR
      end if

      if(IERITYP==2 .or. IERITYP==3)then              
       NINTCRaux = NIJKaux
       NSTOREaux = NINTCRaux
       IAUXDIM = NBFaux
      end if
#endif

!-----------------------------------------------------------------------
      RETURN
      END

! READERIs
      SUBROUTINE READERIs(IERI,ERI,IX2,BUFP2,NINTEGt,IDONTW,NREC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL ERIACTIVATED       
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
#include "mpip.h"
      INTEGER,DIMENSION(NINTEGt) :: IX2
      DOUBLE PRECISION,DIMENSION(NINTEGt) :: BUFP2
      INTEGER,DIMENSION(NSTORE) :: IERI
      DOUBLE PRECISION,DIMENSION(NSTORE) :: ERI
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: XX
#ifdef MPI
      LOGICAL TROUBLE
#endif
!-----------------------------------------------------------------------
      INTTYPE = 1
!      
      IF(IDONTW==0)ALLOCATE(IX(NINTMX),XX(NINTMX))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NINTMX: Total Number of 2e-integrals per record (15000)
!     NIJKL:  Total Number of 2e-integrals
!     IERI:   I,J,K,L Indeces of the integrals
!     ERI:    Value of the integrals
!     NINTCR: Dimension of ERIs in Slaves
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      TROUBLE=.FALSE.
      IF(ERIACTIVATED) THEN
        DO I=1,NPROCS-1
          CALL MPI_SEND(0,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
          CALL MPI_SEND(0,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
        ENDDO
      END IF
      CALL MPI_BCAST(INTTYPE,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR) 
      DO I=1,NPROCS-1
        CALL MPI_SEND(NINTCR,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      END DO
#endif
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
!     III  : Last position of the integrals in the Master
!     JJ   : Pointer of the integrals
!     ITOT : Total integrals read so far
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
      III  = 0
      JJ   = 0
      ITOT = 0
      IRECORD = 0
      IF(IDONTW==0)REWIND(1)
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
   10 CONTINUE
      IF(IDONTW==1)THEN
       IRECORD = IRECORD + 1
       IJBUFi = (IRECORD-1)*NINTMX
       if(IRECORD<NREC)then
        NNINT = NINTMX
        NX = NNINT
       else
        NNINT = NINTEGt - (NREC-1)*NINTMX
        NX = -NNINT
       end if
       IF(NX==0)GOTO 20
       DO M=1,NNINT
        I = M + III
        IERI(I) = IX2(IJBUFi+M)
        ERI(I) = BUFP2(IJBUFi+M)
       ENDDO
      ELSE
       READ(1,END=100)NX,IX,XX
       IF(NX==0)GOTO 20
       NNINT = IABS(NX)
       DO M=1,NNINT
        I = M + III
        IERI(I) = IX(M)
        ERI(I) = XX(M)
       ENDDO
      END IF

#ifdef MPI
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
!      Distributing integrals into chunks of size 2
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
       IPARITY = MOD(NNINT,2)
       NPAIRS = (NNINT+IPARITY)/2
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
!      If non-even number of integrals in a chunk other than last
!      (and only the last, complain!)
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
       IF (IPARITY/=0.AND.TROUBLE) THEN
        Write(6,*) 'Non-even number of integrals, problem!'
        Call Abortx('Non-even number of integrals, problem!')
       ENDIF
       IF (IPARITY/=0) TROUBLE=.TRUE.
       NLEFT=MOD(NPAIRS,NPROCS)
       NCHSZ=(NPAIRS-NLEFT)/NPROCS
       IF (NLEFT>0) NCHSZ=NCHSZ+1
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
!      Sends chunks of integrals to the slaves
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
       III = III+NCHSZ*2
       JJ  = III+1
       NPAIRS=NPAIRS-NCHSZ

       DO I=1,NPROCS-1
        NLEFT=MOD(NPAIRS,NPROCS-I)
        NCHSZ=(NPAIRS-NLEFT)/(NPROCS-I)
        IF (NLEFT>0) NCHSZ=NCHSZ+1
        NPAIRS=NPAIRS-NCHSZ
        NSIZE=NCHSZ*2
        IF (I.EQ.(NPROCS-1).AND.IPARITY.NE.0) NSIZE=NSIZE-1
        CALL MPI_SEND(NSIZE,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
        CALL MPI_SEND(ERI(JJ),NSIZE,MPI_REAL8,I,I,MPI_COMM_WORLD,IERR)
        CALL MPI_SEND(IERI(JJ),NSIZE,MPI_INTEGER8,I,I,MPI_COMM_WORLD,   &
                      IERR)
        JJ=JJ+NSIZE
        ITOT=ITOT+NSIZE
       ENDDO
#else
       III=III+NNINT
#endif
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
      IF(NX>0)GOTO 10
   20 CONTINUE
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
#ifdef MPI
      DO I=1,NPROCS-1
       CALL MPI_SEND(-I,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
      ITOT=ITOT+III
      NINTCR=III
      ERIACTIVATED = .TRUE.       
      IF(ITOT/=NIJKL)THEN
       Call Abortx("Problem with integrals. Not everything shared?!?")
      ENDIF
#endif
!-----------------------------------------------------------------------
      IF(IDONTW==0)DEALLOCATE(XX,IX)
      RETURN
  100 CONTINUE
      WRITE(6,200)
  200 FORMAT(1X,'ERROR - ENCOUNTERED END OF FILE ON UNIT 1',I2)
      STOP
      END

! READERIsAUX
      SUBROUTINE READERIsAUX(ERIaux,BUFP2aux,NINTEGAUXtm)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL ERIACTIVATED       
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
#include "mpip.h"
      DOUBLE PRECISION,DIMENSION(NINTEGAUXtm) :: BUFP2aux
      DOUBLE PRECISION,DIMENSION(NSTOREaux) :: ERIaux
!-----------------------------------------------------------------------
!     NINTMX: Total Number of 2e-integrals per record (15000)
!     NIJKL:  Total Number of 2e-integrals
!     IERI:   I,J,K,L Indeces of the integrals
!     ERI:    Value of the integrals
!     NINTCR: Dimension of ERIs in Slaves
!-----------------------------------------------------------------------
      INTTYPE = 2
#ifdef MPI
      IF(ERIACTIVATED) THEN
        DO I=1,NPROCS-1
          CALL MPI_SEND(0,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
          CALL MPI_SEND(0,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
        ENDDO
      END IF
      CALL MPI_BCAST(INTTYPE,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      L_PER_PROC = INT(NBFaux/NPROCS)
      EXTRAS = MOD(NBFaux,NPROCS)
      DO I=1,NPROCS-1
        NSIZE = L_PER_PROC
        IF (EXTRAS>0) THEN
         NSIZE = NSIZE + 1
         EXTRAS = EXTRAS -1
        END IF
        NINTCRaux = NSIZE*NBF*(NBF+1)/2
        CALL MPI_SEND(NINTCRaux,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      END DO

      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(NBF5,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(NBFaux,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)

      EXTRAS = MOD(NBFaux,NPROCS)
      JJ=1
      DO I=1,NPROCS-1
        NSIZE = L_PER_PROC
        IF (EXTRAS>0) THEN
         NSIZE = NSIZE + 1
         EXTRAS = EXTRAS - 1
        END IF
        NINTCRaux = NSIZE*NBF*(NBF+1)/2
        CALL MPI_SEND(BUFP2aux(JJ),NINTCRaux,MPI_REAL8,I,I,             &
                      MPI_COMM_WORLD,IERR)
        JJ = JJ + NINTCRaux
      END DO
      ERIaux = BUFP2aux(JJ:)
      ERIACTIVATED = .TRUE.       
#else
      ERIaux = BUFP2aux
#endif
!-----------------------------------------------------------------------
      RETURN
      END      

! DEACTIVATEERIs
      SUBROUTINE DEACTIVATEERIs
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL ERIACTIVATED       
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
#include "mpip.h"
#ifdef MPI
      ERIACTIVATED = .FALSE.
#endif
      END      
      
!----------------------------------------------------------------------!
!                                                                      !
!                     Initialize Variables in RunNOF                   !
!                                                                      !
!----------------------------------------------------------------------!

! INITr
      SUBROUTINE INITr(COEF,OVERLAP,GAMMA,FMIUG0,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL CHKORTHO,ORTHO,RESTART
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORTHOGONALITY/CHKORTHO,ORTHO
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA
      INTEGER::IPRINTOPT
!-----------------------------------------------------------------------
!     INPUTGAMMA=0: Initial Values for GAMMA close to Fermi-Dirac dist.
!     INPUTGAMMA=1: Read ONs on file 3 (GCF) and transform to GAMMA
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTGAMMA==0)THEN
       do i=1,ndoc
        GAMMA(i)= DACOS(DSQRT(2.0d0*0.999d0-1.0d0))
        do iw=1,ncwo-1
         ig = ndoc+(i-1)*(ncwo-1)+iw
         GAMMA(ig) = dasin(dsqrt(1.0d0/dfloat(ncwo-iw+1)))
        enddo
       enddo
      ELSEIF(INPUTGAMMA==1)THEN
       CALL READGAMMAr(GAMMA)
      ENDIF
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
!     INPUTC=0: HF Coeffcient Matrix (COEF=CHF) from HFIDr or HCORE
!     INPUTC=1: Reading on file GCF (3)
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTC==1)THEN
       CALL READCOEFMr(COEF,NSQ,NBF)
!      Orthonormalization of the input orbitals (ORTHO=T)
       if(ORTHO)then
!       Check the orthonormality of the input orbitals
        CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
!       Orthonormalize input orbitals if necessary
        if(IVIOORTHO/=0)then
         IF(IPRINTOPT==1)WRITE(6,'(A27)')' Orthogonalize the orbitals'
         CALL ORTHONORMAL(NBF,NBF,NBFT,OVERLAP,COEF,1,IPRINTOPT)
        endif
!      Check the Orthonormality of the input orbitals (CHKORTHO=T)
       elseif(CHKORTHO)then
        CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
       endif
      ENDIF
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
!     INPUTFMIUG=0: Diagonal Elements of F (FMIUG0) = Eigenvalues (E)
!     INPUTFMIUG=1: Read Diagonal Elements of F on file GCF (3)
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTFMIUG==1)CALL READFMIUG0(FMIUG0,NBF,NSQ)
!-----------------------------------------------------------------------
      RETURN
      END
      
! READGAMMAr
      SUBROUTINE READGAMMAr(GAMMA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ      
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::RO,HR
      ALLOCATE (RO(NBF5),HR(ndoc*(ncwo-1)))
!-----------------------------------------------------------------------
!     Read Occupations from the GCF file
!-----------------------------------------------------------------------
      REWIND(3)
      DO I=1,NBF5
       READ(3,'(I6,F30.16)')II,RO(I)
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Obtain GAMMAs (i=1,ndoc*ncwo=nv) from the Occupation Numbers (RO)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      do i=1,NDOC
       in = NO1+i                                     ! in=no1+1,nb
       GAMMA(i) = dacos(dsqrt(2.0d0*RO(in)-1.0d0))
       IF(NCWO/=1)THEN
        ici = (ncwo-1)*(i-1)+1
        icf = (ncwo-1)*i
        HRin = 1.0d0 - RO(in)
        HR(ici:icf) = HRin
        do iw=1,ncwo-1
         ic = (ncwo-1)*(i-1)+iw              ! ic=1,ndoc*(ncwo-1)
         ig = ndoc+ic                        ! ig=ndoc+1,ndoc*ncwo
         in = na+ncwo*(ndoc-i)+iw            ! in=na+1,na+ncwo*ndoc-1         
         if(HR(ic)>0.0d0)then
          ARGUM=sqrt(RO(in)/HR(ic))
          if(ARGUM>1.0d0)ARGUM=1.0d0
          GAMMA(ig)=asin(ARGUM)
         else 
          GAMMA(ig) = 0.0d0
         endif
         if(iw<ncwo-1)then
          do ix=1,ncwo-1-iw
           ic1 = ic+ix                       !ic < ic1 < i*(ncwo-1)
           HR(ic1) = HR(ic1) - RO(in)
          enddo
         endif
        enddo
       ENDIF
      enddo
!-----------------------------------------------------------------------
      DEALLOCATE (RO,HR)
      RETURN
      END

! READCOEFMr
      SUBROUTINE READCOEFMr(C,NSQ,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NSQ)::C
!-----------------------------------------------------------------------
      REWIND(3)
      DO I=1,NBF
       READ(3,'(I6,F30.16)')II,ROI
      ENDDO
      READ(3,'(F30.16)')SS
      DO I = 1,NSQ
       READ(3,'(I6,F30.16)')II,C(I)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! READFMIUG0
      SUBROUTINE READFMIUG0(F,NBF,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF)::F
!-----------------------------------------------------------------------
!     Read diagonal elements of the Gen Fock Operator (FMIUG)
!-----------------------------------------------------------------------
      REWIND(3)
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,ROI
      ENDDO
      READ(3,'(F30.16)')SS
      DO I = 1,NSQ+NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,F(I)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! READCXYZ
      SUBROUTINE READCXYZ(ZNUC,C,NAT,NBF,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NAT):: IZNUC
      DOUBLE PRECISION,DIMENSION(NAT):: ZNUC
      DOUBLE PRECISION,DIMENSION(3,NAT):: C
      DOUBLE PRECISION,PARAMETER:: BOHR = 0.52917724924D+00
!-----------------------------------------------------------------------
!     Read diagonal elements of the Gen Fock Operator (FMIUG)
!-----------------------------------------------------------------------
      REWIND(3)
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      READ(3,'(F30.16)')SS
      DO I = 1,NSQ+NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      READ(3,'(I6,F30.16)')IT,AA
      READ(3,'(I6,F30.16)')IT,AA
      DO I = 1,NAT
       READ(3,'(I6,F30.16,F30.16,F30.16)')                              &
        IZNUC(I),C(1,I),C(2,I),C(3,I)
      ENDDO
      C = C / BOHR
      ZNUC = REAL(IZNUC)
!-----------------------------------------------------------------------
      RETURN
      END
      
!----------------------------------------------------------------------!
!                                                                      !
!   HFIDr Iterative Diagonalization method for the RHF using           !
!         the Iterative Diagonalization method (HFID=T) proposed       !
!         in the J. Comp. Chem. 131, 021102, 2009.                     !
!                                                                      !
!----------------------------------------------------------------------!
      
! HFIDr
      SUBROUTINE HFIDr(AHCORE,IJKL,XIJKL,XIJKaux,CHF,EIHF,USER,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL EFIELDL,RESTART,CONVGDELAG,ERIACTIVATED
      LOGICAL HFID,HighSpin,SCALING
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/CONVERGENCE/DUMEL,PCONV,CONVGDELAG
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_HFID/HFID,NTHRESHEID,THRESHEID,MAXITID,KOOPMANS       
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_COEFOPT/MAXLOOP
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/CONVERGESUM/SUMDIF
      COMMON/ELPROP/IEMOM
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      INTEGER:: IPRINTOPT
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NSTOREaux)::XIJKaux
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,CHF
      DOUBLE PRECISION,DIMENSION(NBF)::EIHF
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::RO10,EVA,TEMP,FMIUG0
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::CJ12HF,CK12HF,ELAG
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::G,FMIUG,W,CHFNEW
!
      DOUBLE PRECISION,PARAMETER::DFAC=2.54174D0    ! Debye
      DOUBLE PRECISION,PARAMETER::QFAC=1.345044D0   ! Buckinham
      DOUBLE PRECISION,PARAMETER::OFAC=7.117668D-01 ! X10**34 ESU-CM**3
!-----------------------------------------------------------------------
!     Initial Values
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INPUTFMIUG_ORI = INPUTFMIUG
      INPUTFMIUG = 0
      NO1_ORI = NO1
      NO1 = NB
      ILOOP = 0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(RO10(NBF5),CJ12HF(NBF5,NBF5),CK12HF(NBF5,NBF5))      
      RO10 = 0.0d0
      DO i=1,NB
       RO10(i) = 1.0d0      
      ENDDO
      IF(NSOC>0)THEN
       DO i=NB+1,NA
        RO10(i) = 0.5d0
       ENDDO
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12HF(j,i) = 2.0d0*RO10(j)*RO10(i)
        CK12HF(j,i) = RO10(j)*RO10(i)
       ENDDO
      ENDDO
      if(MSpin==0.and.NSOC>1)then                     
       DO j=NB+1,NA
        DO i=NB+1,NA
         CK12HF(j,i) = 2.0d0*RO10(j)*RO10(i)
        ENDDO      
       ENDDO
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPRINTOPT==1)WRITE(6,1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate Initial HF Electronic Energy
!     ( QD=USER(N7), DIPN=USER(N11), ADIP=USER[N12-N14] )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ELAG(NBF,NBF),G(NBF,NBF5))
      CALL ENERGY1r(AHCORE,IJKL,XIJKL,XIJKaux,USER(N7),CHF,RO10,CJ12HF, &
                  CK12HF,ELAG,USER(N11),USER(N12),USER(N13),USER(N14),G)
      EHF = EELEC
      CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Itermediate Output of the external iteration
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NPRINT==1.and.IPRINTOPT==1)THEN
       WRITE(6,10)ILOOP,EHF,EHF+EN,0.0,DUMEL
      ENDIF
!-----------------------------------------------------------------------
!                       START SCF-ITERATION CYCLE
!-----------------------------------------------------------------------
      ALLOCATE (FMIUG(NBF,NBF),W(NBF,NBF),EVA(NBF),TEMP(NBF))
      ALLOCATE (CHFNEW(NBF,NBF),FMIUG0(NBF))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO LOOPEXT=1,MAXITID
       IF(LOOPEXT==1)THEN
        MAXLP = 1
       ELSE
        MAXLP = MAXLOOP
       ENDIF
!-----------------------------------------------------------------------
       DO LOOP=1,MAXLP
        ILOOP=ILOOP+1
        EHF_OLD = EHF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Generalized Fock Matrix (FMIUG)
!
!       Convergent technique:
!
!       SCALING:   Decrease FMIUG using a scaling factor.
!                  The scaling factor varies until the number of
!                  ZEROS (.000##) is equal for all elements Fij
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(SCALING)CALL FFMIUG_SCALING(FMIUG,ELAG,FMIUG0,LOOPEXT)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       DIAGONALIZE SQUARE MATRIX (FMIUG) FOR REAL SYMMETRIC CASE
!       W - EIGENVECTORS, EVA-EIGENVALUES IN ALGEBRAIC DESCENDING ORDER
!       HOUSEHOLDER METHOD
!       NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL DIAG(NBF,FMIUG,W,EVA,TEMP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Move EVA -> FMIUG0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        FMIUG0 = EVA
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       New Coefficients (CHFNEW=CHF*W), Move CHFNEW -> CHF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL COEFW(NBF,NBF,CHFNEW,CHF,W)
        CHF = CHFNEW
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Lagrangian Multipliers (ELAG) and one-energies (E)
!       Calculate HF Electronic Energy (EHF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL ENERGY1r(AHCORE,IJKL,XIJKL,XIJKaux,USER(N7),CHF,RO10,      &
         CJ12HF,CK12HF,ELAG,USER(N11),USER(N12),USER(N13),USER(N14),G)
        EHF = EELEC 
        DIF_EHF = EHF - EHF_OLD
        CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
!       Intermediate Output at each interation (Nprint=2)
        IF(NPRINT==2.and.IPRINTOPT==1)THEN
         WRITE(6,10)ILOOP,EHF,EHF+EN,DIF_EHF,DUMEL
        ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Check for energy convergent solution
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF( ABS(DIF_EHF) < THRESHEID )THEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        One-particle HF energies
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         DO i=1,NBF
          EIHF(i) = ELAG(i,i)
         ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        Dipole Moment (QD = USER(N7), DIPN = USER(N11), 
!                       ADIP = USER[N12-N14], DIP = USER[N15-N17] ) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         CALL DIPMOMr(USER(N11),USER(N12),USER(N13),USER(N14),USER(N15),&
                      USER(N16),USER(N17),USER(N7),RO10,DMXe,DMYe,DMZe, &
                      DTx,DTy,DTz,DT)     
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        Quadrupole Moment ( QUADN = USER(N18), AQUAD = USER[N19-N24]
!                            QUAD = USER[N25-N30], QD = USER(N7) )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         IF(IEMOM>=2)THEN
          CALL QUADMOMr(USER(N18),USER(N19),USER(N20),USER(N21),        &
                        USER(N22),USER(N23),USER(N24),USER(N25),        &
                        USER(N26),USER(N27),USER(N28),USER(N29),        &
                        USER(N30),USER(N7),RO10,                        &
                        QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,            &
                        QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)
         ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        Octupole Moment  ( OCTUN = USER(N31), AOCT = USER[N32-N41] )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         IF(IEMOM==3)THEN
          CALL OCTMOMr(USER(N31),USER(N32),USER(N33),USER(N34),         &
                       USER(N35),USER(N36),USER(N37),USER(N38),         &
                       USER(N39),USER(N40),USER(N41),USER(N42),         &
                       USER(N43),USER(N44),USER(N45),USER(N46),         &
                       USER(N47),USER(N48),USER(N49),USER(N50),         &
                       USER(N51),USER(N7),RO10,                         &
                       OMXXXe,OMYYYe,OMZZZe,OMXXYe,OMXXZe,              &
                       OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,              &
                       OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,                   &
                       OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)
         ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        Output
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         INPUTFMIUG = INPUTFMIUG_ORI
         NO1 = NO1_ORI
         IF(IPRINTOPT==0)RETURN
         WRITE(6,10)LOOPEXT,EHF,EHF+EN,DIF_EHF,DUMEL
         CALL PRINTEiHF(EiHF,NA,NBF)
         IF(KOOPMANS==1.and.MSpin==0)THEN
          CALL DIAGELAGHF(ELAG,CHF,RO10,EiHF,CHFNEW,TEMP)
         ENDIF
         WRITE(6,2)EHF
         WRITE(6,3)EHF+EN
         IF(EFIELDL)WRITE(6,4)EX,EY,EZ
         WRITE(6,5)DT*DFAC,DT,DTx,DTy,DTz
         IF(IEMOM>=2)WRITE(6,6)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,           &
                   QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,                       &
                   QTxx,QTyy,QTzz,QTxy,QTxz,QTyz                         
         IF(IEMOM==3)WRITE(6,7)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,        &
                               OTXXY*OFAC,OTXXZ*OFAC,OTXYY*OFAC,        &
                               OTYYZ*OFAC,OTXZZ*OFAC,OTYZZ*OFAC,        &
                               OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,OTXXY,      &
                               OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
         RETURN
        ENDIF
!-----------------------------------------------------------------------
!                       LOOP-END OF SCF-ITERATION
!-----------------------------------------------------------------------
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Final Output
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NPRINT<2.and.IPRINTOPT==1)THEN
        WRITE(6,10)LOOPEXT,EHF,EHF+EN,DIF_EHF,DUMEL
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDDO
!-----------------------------------------------------------------------
!     FORMAT STATEMENTS
!-----------------------------------------------------------------------
    1 FORMAT(//,1X,' HARTREE-FOCK ',/, 1X,'==============',//,          &
                2X,'ITER',5X,'ELECTRONIC ENERGY',6X,'TOTAL ENERGY',     &
                3X,'ENERGY CONVERGENCY',4X,'MAX MUL-LAG DIFF',/)                  
    2 FORMAT(/,4X,'ELECTRONIC HF ENERGY =',F20.10)                       
    3 FORMAT(/,8X,' HF TOTAL ENERGY =',F20.10)                           
    4 FORMAT(/,6X,'ELECTRIC FIELD (',D8.1,',',D8.1,',',D8.1,')')         
    5 FORMAT(/,2X,'------------------',                                 &
              /2X,' HF Dipole Moment',                                  &
              /2X,'------------------',                                 &
            //,3X,F9.4,' Debye',' [',F9.4,                              &
               2X,'(',F9.4,',',F9.4,',',F9.4,')',' ]')                   
    6 FORMAT(/,2X,'----------------------',                             &
              /2X,' HF Quadrupole Moment',                              &
              /2X,'----------------------',                             &
             //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',   &
             //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')         
    7 FORMAT(/,2X,'--------------------',                               &
              /2X,' HF Octupole Moment',                                &
              /2X,'--------------------',                               &
             //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',       &
               5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',       &
             //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',                      &
             //1X,'[',10F9.4,1X,']')
   10 FORMAT(2X,I3,'.',3X,F17.6,4X,F15.6,6X,F13.8,8X,F11.6)
!-----------------------------------------------------------------------
      DEALLOCATE(RO10,CJ12HF,CK12HF)
      DEALLOCATE(FMIUG,W,EVA,TEMP,CHFNEW,ELAG,G,FMIUG0)
      INPUTFMIUG = INPUTFMIUG_ORI
      NO1 = NO1_ORI
      RETURN
      END
      
! PRINTEiHF
      SUBROUTINE PRINTEiHF(EIHF,NA,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF)::EIHF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::E1
!-----------------------------------------------------------------------
!     ORDERING ENERGIES
!-----------------------------------------------------------------------
      ALLOCATE(E1(NBF))
      DO I=1,NBF
       E1(I)=EIHF(I)
      ENDDO
      DO IM=1,NBF
       DUM1= E1(IM)
       MIN = IM
       DO I=IM,NBF
        IF(E1(I)<DUM1)THEN
         DUM1= E1(I)
         MIN = I
        ENDIF
       ENDDO
       IF(MIN/=IM)THEN
        DUM1   = E1(IM)
        E1(IM) = E1(MIN)
        E1(MIN)= DUM1
       ENDIF
      ENDDO
!-----------------------------------------------------------------------
!     WRITE ENERGIES ON THE OUTPUT FILE
!-----------------------------------------------------------------------
      WRITE(6,100)
      DO I=1,NA
       WRITE(6,101)I,E1(I),E1(I)*27.21138386
      ENDDO
!-----------------------------------------------------------------------
  100 FORMAT(/2X,'-------------',/2X,' HF Energies ',                   &
             /2X,'-------------',//19X,'(aU)',14X,'(eV)',20X)
  101 FORMAT(2X,I4,4X,F15.6,4X,F15.6)
!-----------------------------------------------------------------------
      DEALLOCATE(E1)
      RETURN
      END

! DIAGELAGHF
      SUBROUTINE DIAGELAGHF(ELAG,COEF,RO,ELAGN,COEFN,RON)
!=======================================================================
!     DIAGONALIZATION OF LAGRANGE MULTIPLIERS (ELAG)
!=======================================================================
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF)::ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::TEMP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,DENMAT
!-----------------------------------------------------------------------
!     INTERMEDIATE MATRICES
!-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF,NBF),W(NBF,NBF),TEMP(NBF))
!-----------------------------------------------------------------------
!     DIAGONALIZATION OF THE LAGRANGE MULTIPLIERS (ELAG)
!-----------------------------------------------------------------------
!     ELAG -> SQUARE MATRIX (AUX)
!-----------------------------------------------------------------------
      DO I=1,NBF
       DO J=1,I
        AUX(I,J)=ELAG(I,J)
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     DIAGONALIZE SQUARE MATRIX (AUX) FOR REAL SYMMETRIC CASE
!     NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
!     W - EIGENVECTORS, ELAGN - EIGENVALUES 
!-----------------------------------------------------------------------
      CALL DIAG(NBF,AUX,W,ELAGN,TEMP)
!-----------------------------------------------------------------------
!     New Density Matrix (D=Wt*RO*W)
!-----------------------------------------------------------------------
      ALLOCATE(DENMAT(NBF,NBF))
      DO IP=1,NBF
       DO IQ=1,NBF
        DENMAT(IP,IQ)=0.0d0
        do i=1,nbf5
         DENMAT(IP,IQ)=DENMAT(IP,IQ)+W(i,IP)*RO(i)*W(i,IQ)
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     WRITE ONE-PARTICLE ENERGIES and NEW AVERAGE OCCUPATIONS (OUTPUT)
!-----------------------------------------------------------------------
      WRITE(6,1)
      DO I=1,NBF
       RON(I)=2.0d0*DENMAT(I,I)
       IF(RON(I)>1.0d-1)THEN
        WRITE(6,2)I,-ELAGN(I),-ELAGN(I)*27.21138386,RON(I)
       ENDIF
      ENDDO
      CALL DMATMAX(DENMAT,NBF,MAXI,MAXJ,DUM)
      WRITE(6,3)DUM,MAXI,MAXJ
!-----------------------------------------------------------------------
!     Coefficients of Canonical Orbitals (COEFN=COEF*W)
!-----------------------------------------------------------------------
      COEFN = MATMUL(COEF,W)
      ICANHF=0
      IF(ICANHF==1)THEN
       WRITE(6,4)
       CALL PRINTVERO(6,COEFN,ELAGN,RON,NBF,NBF5)
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT(/2X,42('-'),/3X,'Canonical Representation: Koopmans Theo.',&
             /2X,42('-'),//20X,'Ionization Potentials',11X,'1RDM Diag', &
             //19X,'(aU)',14X,'(eV)')                                    
    2 FORMAT(2X,I4,4X,F15.6,4X,F15.6,9X,F8.6)                            
    3 FORMAT(/,15X,'Maximum 1RDM off-diagonal element:',F12.6,          &
               1X,'(',I3,',',I3,')')                                     
    4 FORMAT(/,                                                         &
       18X,'-----------------------',/,                                 &
       18X,' Canonical HF Orbitals ',/,                                 &
       18X,'-----------------------')
!-----------------------------------------------------------------------
      DEALLOCATE (AUX,W,TEMP,DENMAT)
      RETURN
      END

!----------------------------------------------------------------------!
!                                                                      !
!            O C C U P A T I O N    O P T I M I Z A T I O N            !
!                                                                      !
!             Spin-compensated Systems (Restricted Shells)             !
!                                                                      !
!    'Restricted Closed' (rc) Case: MSpin=0 [Singlet and Multiplet]    !
!       Singlet States (S=0,Ms=0) and Multiplet States (S>0,Ms=0)      !
!                                                                      !
!        'Restricted Open' (ro) Case: MSpin>0 [High-Spin State]        !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!     NO1:  Number of inactive doubly occupied orbitals (OCC=1)        !
!     NDOC: Number of strongly doubly occupied MOs                     !
!     NSOC: Number of strongly singly occupied MOs                     !
!     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)           !
!     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ. !
!     NCWO*NDOC: Active orbitals in the virtual subspace               !
!     NO0:  Empty orbitals  (OCC=0)                                    !
!     NVIR: Number of weakly occupied MOs + empty MOs                  !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!         NO1 |  NDOC + NSOC  |   NCWO*NDOC + NO0  = NBF               !                                                                
!         NO1 |      NDNS     |          NVIR      = NBF               !
!             | -NAC- |       |  -   NAC  - |                          !
!                    NB      NA            NBF5                        !
!                                                                      !
!----------------------------------------------------------------------!
!                                                                      !
!   OCCOPTr: Minimize the energy with respect to the occupations (RO)  !
!                                                                      !
!----------------------------------------------------------------------!

! OCCOPTr
      SUBROUTINE OCCOPTr(IFIRSTCALL,CONVG,ATMNAME,ZNUC,OVERLAP,LIMLOW,  &
                         LIMSUP,COEF,GAMMA,FMIUG0,AHCORE,IJKL,XIJKL,    &
                         XIJKaux,ELAG,USER,IZCORE,CX0,CY0,CZ0,KSTART,   &
                         KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC,IMIN,IMAX,    &
                         ISH,ITYP,EX1,C1,C2,CS,CP,CD,CF,CG,CH,CI,ELAGN, &
                         COEFN,RON,IT,ITTOTAL,DIPS,IPRINTOPT,IRUNTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL CONVG,CONVGDELAG,ERIACTIVATED,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/CONVERGENCE/DUMEL,PCONV,CONVGDELAG
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_EINI/IEINI
      COMMON/INPNOF_CGM/ICGMETHOD
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/SUMSZ/SUMS,SUMF
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/WRTGCF/IWRTGCF
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER::IPRINTOPT
!
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP,IZCORE,IMIN,IMAX
      INTEGER,DIMENSION(NPRIMI)::ISH,ITYP
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,C1,C2,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0,ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NSTOREaux)::XIJKaux
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::OVERLAP,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,ELAG,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::GAMMA_OLD,EAHF,E
      DOUBLE PRECISION,DIMENSION(3)::DIPS
!-----------------------------------------------------------------------
!     Define the number of variables in the occupation optimization
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NV = NCWO*NDOC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     IFIRSTCALL
!          = 0  First Call to OCCOPTr (Occupation Optimization)
!          = 1  Iterative Procedure for Occupations and Coefficients
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(GAMMA_OLD(NBF5))
      IF(IFIRSTCALL==0)THEN
       GAMMA_OLD = 0.0d0
      ELSEIF(IFIRSTCALL==1)THEN
       CALL XtoX0(GAMMA,GAMMA_OLD,NBF5)      ! Keep GAMMA in GAMMA_OLD
      ENDIF
!----------------------------------------------------------------------!
!                     Pointers of the USER array                       !
!----------------------------------------------------------------------!
!                                                                      !
!     N1  = 1                  ! USER( N1) = RO(NBF5)                  !
!     N2  = N1  + NBF5         ! USER( N2) = CJ12(NBF5,NBF5)           !
!     N3  = N2  + NSQ5         ! USER( N3) = CK12(NBF5,NBF5)           !
!     N4  = N3  + NSQ5         ! USER( N4) = DR(NBF5,NBF5)             !
!     N5  = N4  + NSQ5         ! USER( N5) = DCJ12r(NBF5,NBF5,NBF5)    !
!     N6  = N5  + NSQ5*NBF5    ! USER( N6) = DCK12r(NBF5,NBF5,NBF5)    !
!     N7  = N6  + NSQ5         ! USER( N7) = QD(NBF,NBF,NBF)           !
!     N8  = N7  + NBF*NSQ      ! USER( N8) = HCORE(NBF5)               !
!     N9  = N8  + NBF5         ! USER( N9) = QJ(NBFT5)                 !
!     N10 = N9  + NBFT5        ! USER(N10) = QK(NBFT5)                 !
!     N11 = N10 + NBFT5        ! USER(N11) = DIPN                      !
!     N12 = N11 + 3            ! USER(N12) = ADIPx                     !
!     N13 = N12 + NSQ          ! USER(N13) = ADIPy                     !
!     N14 = N13 + NSQ          ! USER(N14) = ADIPz                     !
!     N15 = N14 + NSQ          ! USER(N15) = DIPx                      !
!     N16 = N15 + NSQ5         ! USER(N16) = DIPy                      !
!     N17 = N16 + NSQ5         ! USER(N17) = DIPz                      !
!     N18 = N17 + NSQ5         ! USER(N18) = QUADN(6)                  !
!     N19 = N18 + 6            ! USER(N19) = AQUADxx(NSQ)              !
!     N20 = N19 + NSQ          ! USER(N20) = AQUADyy(NSQ)              !
!     N21 = N20 + NSQ          ! USER(N21) = AQUADzz(NSQ)              !
!     N22 = N21 + NSQ          ! USER(N22) = AQUADxy(NSQ)              !
!     N23 = N22 + NSQ          ! USER(N23) = AQUADxz(NSQ)              !
!     N24 = N23 + NSQ          ! USER(N24) = AQUADyz(NSQ)              !
!     N25 = N24 + NSQ          ! USER(N25) = QUADxx(NSQ5)              !
!     N26 = N25 + NSQ5         ! USER(N26) = QUADyy(NSQ5)              !
!     N27 = N26 + NSQ5         ! USER(N27) = QUADzz(NSQ5)              !
!     N28 = N27 + NSQ5         ! USER(N28) = QUADxy(NSQ5)              !
!     N29 = N28 + NSQ5         ! USER(N29) = QUADxz(NSQ5)              !
!     N30 = N29 + NSQ5         ! USER(N30) = QUADyz(NSQ5)              !
!     N31 = N30 + NSQ5         ! USER(N31) = OCTUN(10)                 !
!     N32 = N31 + 10           ! USER(N32) = AOCTxxx(NSQ)              !
!     N33 = N32 + NSQ          ! USER(N33) = AOCTyyy(NSQ)              !
!     N34 = N33 + NSQ          ! USER(N34) = AOCTzzz(NSQ)              !
!     N35 = N34 + NSQ          ! USER(N35) = AOCTxxy(NSQ)              !
!     N36 = N35 + NSQ          ! USER(N36) = AOCTxxz(NSQ)              !
!     N37 = N36 + NSQ          ! USER(N37) = AOCTxyy(NSQ)              !
!     N38 = N37 + NSQ          ! USER(N38) = AOCTyyz(NSQ)              !
!     N39 = N38 + NSQ          ! USER(N39) = AOCTxzz(NSQ)              !
!     N40 = N39 + NSQ          ! USER(N40) = AOCTyzz(NSQ)              !
!     N41 = N40 + NSQ          ! USER(N41) = AOCTxyz(NSQ)              !
!     N42 = N41 + NSQ          ! USER(N42) = OCTXXX(NSQ5)              !
!     N43 = N42 + NSQ5         ! USER(N43) = OCTYYY(NSQ5)              !
!     N44 = N43 + NSQ5         ! USER(N44) = OCTZZZ(NSQ5)              !
!     N45 = N44 + NSQ5         ! USER(N45) = OCTXXY(NSQ5)              !
!     N46 = N45 + NSQ5         ! USER(N46) = OCTXXZ(NSQ5)              !
!     N47 = N46 + NSQ5         ! USER(N47) = OCTXYY(NSQ5)              !
!     N48 = N47 + NSQ5         ! USER(N48) = OCTYYZ(NSQ5)              !
!     N49 = N48 + NSQ5         ! USER(N49) = OCTXZZ(NSQ5)              !
!     N50 = N49 + NSQ5         ! USER(N50) = OCTYZZ(NSQ5)              !
!     N51 = N50 + NSQ5         ! USER(N51) = OCTXYZ(NSQ5)              !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Transform atomic integrals using COEF to obtain HCORE, QJ and QK 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL FORMQHJK(COEF,USER(N7),USER(N8),USER(N9),USER(N10),AHCORE,   &
                    IJKL,XIJKL,XIJKaux)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Output of the MO inter-electronic integrals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NPRINTQJQK = 0
      IF(NPRINTQJQK==1)CALL OUTQJQK(USER(N9),USER(N10))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Output Energy and Properties with the input, and Stop if IEINI=1
!     Note: If ICOEF=2 -> IEINI=1 (see subroutine NAMELIST_NOFINP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IEINI==1.or.NV==0)THEN
       CALL OUTINITIALSr(NV,GAMMA,COEF,                                 &
            USER(N1),USER(N2),USER(N3),USER(N4),USER(N5),USER(N6),      &
            USER(N7),USER(N8),USER(N9),USER(N10),USER(N11),USER(N12),   &
            USER(N13),USER(N14),USER(N15),USER(N16),USER(N17),          &
            USER(N18),USER(N19),USER(N20),USER(N21),USER(N22),          &
            USER(N23),USER(N24),USER(N25),USER(N26),USER(N27),          &
            USER(N28),USER(N29),USER(N30),USER(N31),USER(N32),          &
            USER(N33),USER(N34),USER(N35),USER(N36),USER(N37),          &
            USER(N38),USER(N39),USER(N40),USER(N41),USER(N42),          &
            USER(N43),USER(N44),USER(N45),USER(N46),USER(N47),          &
            USER(N48),USER(N49),USER(N50),USER(N51),                    &
            ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,IT,ITTOTAL,IPRINTOPT)
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Minimization of the total energy with respect to GAMMAs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF( .NOT.CONVGDELAG.and.ICOEF/=2.and.NV>0 )THEN
      IF(ICGMETHOD==1)THEN
       CALL CGOCUPSUMSLr(NV,GAMMA,USER,EELEC)
      ELSE IF(ICGMETHOD==2)THEN
       CALL CGOCUPNAGr(NV,GAMMA,USER,EELEC)
      ELSE IF(ICGMETHOD==3)THEN       
       CALL LBFGSOCUPr(NV,GAMMA,USER,EELEC)
      ENDIF
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     One-particle Energies
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(EAHF(NBF),E(NBF))
      IF(IFIRSTCALL==0)THEN
!      Determine the 1-energies if first call and pass to ELAG
       CALL ENENEWr(USER(N1),USER(N8),USER(N9),USER(N10),USER(N2),      &
                    USER(N3),USER(N15),USER(N16),USER(N17),EAHF,E)
       DO I=1,NBF
        ELAG(I,I) = E(I)
       ENDDO
      ELSEIF(IFIRSTCALL==1)THEN
!      The 1-energies are taken as eigenvalues of the MO optimization
       DO I=1,NBF
        E(I) = ELAG(I,I)
       ENDDO
       if(ICOEF==3)then
!       Determine the 1-energies if fragment calculation
        CALL ENENEWr(USER(N1),USER(N8),USER(N9),USER(N10),USER(N2),     &
                     USER(N3),USER(N15),USER(N16),USER(N17),EAHF,E)
        DO I=1,NBF
         ELAG(I,I) = E(I)
        ENDDO
       endif
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate Dipole Moment if IPRINTOPT=0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPRINTOPT==0)THEN
       CALL DIPMOMr(USER(N11),USER(N12),USER(N13),USER(N14),USER(N15),  &
                    USER(N16),USER(N17),USER(N7),USER(N1),              &
                    DMXe,DMYe,DMZe,DIPS(1),DIPS(2),DIPS(3),DM)  
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Initial Output (IFIRSTCALL==0), Intermediate Output (NPRINT=2)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF((IFIRSTCALL==0.or.(IFIRSTCALL==1.and.NPRINT==2)).and.          &
          IPRINTOPT==1)THEN                                              
       CALL PRINTOCr(E,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,                 &
                     OVERLAP,USER(N1),USER(N2),USER(N3),USER(N7),       &
                     USER(N10),USER(N11),USER(N12),                     &
                     USER(N13),USER(N14),USER(N15),USER(N16),USER(N17), &
                     USER(N18),USER(N19),USER(N20),USER(N21),USER(N22), &
                     USER(N23),USER(N24),USER(N25),USER(N26),USER(N27), &
                     USER(N28),USER(N29),USER(N30),USER(N31),USER(N32), &
                     USER(N33),USER(N34),USER(N35),USER(N36),USER(N37), &
                     USER(N38),USER(N39),USER(N40),USER(N41),USER(N42), &
                     USER(N43),USER(N44),USER(N45),USER(N46),USER(N47), &
                     USER(N48),USER(N49),USER(N50),USER(N51),IZCORE,    &
                     CX0,CY0,CZ0,KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,    &
                     KLOC,IMIN,IMAX,ISH,ITYP,EX1,C1,C2,CS,CP,CD,CF,     &
                     CG,CH,CI,IFIRSTCALL,DIPS,IRUNTYP)
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write GAMMA, COEF, E, and FMIUG0 on File GCF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(IWRTGCF==1)then
       CALL WRITEGCFr(3,USER(N1),SUMS,COEF,E,FMIUG0,NSQ,NBF,NBF5,IT,    &
            EELEC,EN,NO1,NDOC,NSOC,NCWO,NAC,NO0,ZNUC,CX0,CY0,CZ0,NATOMS) 
       IF(EELEC<EELEC_MIN.AND.IPRINTOPT==1)THEN                          
        CALL WRITEGCFr(8,USER(N1),SUMS,COEF,E,FMIUG0,NSQ,NBF,NBF5,IT,   &
            EELEC,EN,NO1,NDOC,NSOC,NCWO,NAC,NO0,ZNUC,CX0,CY0,CZ0,NATOMS)
        EELEC_MIN = EELEC
       ENDIF
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Exit if convergence achieved
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(CONVGDELAG.and.ICOEF/=0)THEN
       CONVG=.TRUE.
       CALL FINALOUTPUTr(E,USER(N1),USER(N2),USER(N3),                  &
                         USER(N7),USER(N8),USER(N9),USER(N10),          &
                         ELAG,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,          &
                         OVERLAP,USER(N11),USER(N12),USER(N13),         &
                         USER(N14),USER(N15),USER(N16),USER(N17),       &
                         USER(N18),USER(N19),USER(N20),USER(N21),       &
                         USER(N22),USER(N23),USER(N24),USER(N25),       &
                         USER(N26),USER(N27),USER(N28),USER(N29),       &
                         USER(N30),USER(N31),USER(N32),USER(N33),       &
                         USER(N34),USER(N35),USER(N36),USER(N37),       &
                         USER(N38),USER(N39),USER(N40),USER(N41),       &
                         USER(N42),USER(N43),USER(N44),USER(N45),       &
                         USER(N46),USER(N47),USER(N48),USER(N49),       &
                         USER(N50),USER(N51),IZCORE,CX0,CY0,CZ0,        &
                         KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC,       &
                         IMIN,IMAX,ISH,ITYP,EX1,C1,C2,CS,CP,CD,CF,      &
                         CG,CH,CI,ELAGN,COEFN,RON,AHCORE,IJKL,XIJKL,    &
                         IFIRSTCALL,DIPS,IPRINTOPT,IRUNTYP)
      ENDIF
!-----------------------------------------------------------------------
      DEALLOCATE(GAMMA_OLD,EAHF,E)
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!       Subroutines for transformations from atomic into molecular     !
!             integrals: Hjj, <ij|ij>, <ij|ji>, <ii|jj>                !
!                                                                      !
!                      HCORE, QJ and QK MATRICES                       !
!                                                                      !
!    FORMQHJK: Density for each j (QDj), HCORE, QJ and QK matrices     !
!    OUTQHJK: Print molecular integrals, that is, QJ and QK matrices   !
!    QHMATm: Calculate Dj matrix keeping in QD(J,:,:) and molec. Hcore !
!    DENMATj: Obtain Density matix for each j (called from QHMATm)     !
!    QJMATm: Coulomb Integrals QJ(i,j)                                 !
!    QKMATm: Exchange Integrals QK(i,j)                                !
!    QJKMATmRI: Coulomb and Exchange Integrals with the RI Approx.     !
!    HSTARJ: Determine the skeleton J from atomic integrals (AUX)      !
!    HSTARK: Determine the skeleton K from atomic integrals (AUX)      !
!    HSTARJKRI: Determine the skeleton J and K from atomic integrals   !
!               with the RI approximation                              !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! FORMQHJK
      SUBROUTINE FORMQHJK(COEF,QD,HCORE,QJ,QK,AHCORE,IJKL,XIJKL,XIJKaux)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL ERIACTIVATED       
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
!
      DIMENSION COEF(NBF,NBF)
      DIMENSION QD(NBF,NBF,NBF),HCORE(NBF5),QJ(NBFT5),QK(NBFT5)
      DIMENSION AHCORE(NBF,NBF),IJKL(NSTORE),XIJKL(NSTORE)
      DOUBLE PRECISION,DIMENSION(NSTOREaux)::XIJKaux
!-----------------------------------------------------------------------
      QJ=0.0d0
      QK=0.0d0
      CALL QHMATm(COEF,QD,HCORE,AHCORE)
      IF(IERITYP==1 .or. (IERITYP==3 .and. MIXSTATE==2) )THEN
       CALL QJMATm(QD,QJ,IJKL,XIJKL)
       CALL QKMATm(QD,QK,IJKL,XIJKL)
      ELSE IF(IERITYP==2 .or. (IERITYP==3 .and. MIXSTATE==1) )THEN 
       CALL QJKMATmRI(QJ,QK,XIJKaux,COEF)
      END IF
!-----------------------------------------------------------------------
      RETURN
      END

! OUTQJQK
      SUBROUTINE OUTQJQK(QJ,QK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DIMENSION QJ(NBFT5),QK(NBFT5)
!-----------------------------------------------------------------------
!     Print molecular integrals (called from OCCOPTr)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
      WRITE(6,1)
      DO J=1,NBF5
       DO I=1,J
        IJ=I+J*(J-1)/2
        WRITE(6,2)I,J,QJ(IJ),QK(IJ)
       ENDDO
      ENDDO
      DO J=1,NBF5
       JJ=J*(J+1)/2
       WRITE(6,3)J,QJ(JJ)/2.0d0
      ENDDO
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
    1 FORMAT(/,                                                         &
      1X,46('-'),/,6X,'I',3X,'J',4X,'QJ(IJ)',2X,'QK(IJ)',/,1X,46('-'),/)
    2 FORMAT(3X,2I4,1X,2F8.3)
    3 FORMAT(3X,I4,1X,F8.3)
!-----------------------------------------------------------------------
      RETURN
      END

! QHMATm
      SUBROUTINE QHMATm(C,QD,HCORE,AHCORE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DIMENSION C(NBF,NBF),QD(NBF,NBF,NBF),HCORE(NBF5),AHCORE(NBF,NBF)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AUX
!-----------------------------------------------------------------------
!     Calculate D matrix for each value J and keep in QD(J,:,:)
!     Calculate molecular Hcore matrix (HCORE)
!-----------------------------------------------------------------------
      ALLOCATE(AUX(NBF,NBF))
      DO J=1,NBF
       CALL DENMATj(J,AUX,C,NBF)
       QD(J,1:NBF,1:NBF) = AUX(1:NBF,1:NBF)
      ENDDO
      DO J=1,NBF5
       AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL TRACEm(HCORE(J),AUX,AHCORE,NBF)
      ENDDO
!-----------------------------------------------------------------------
      DEALLOCATE(AUX)
      RETURN
      END

! DENMATj
      SUBROUTINE DENMATj(J,D,C,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION D(NBF,NBF),C(NBF,NBF)
      DO M=1,NBF
       DO N=M,NBF
        D(M,N)=2.0d0*C(M,J)*C(N,J)
        D(N,M)=D(M,N)
       ENDDO
      ENDDO
      RETURN
      END

! QJMATm
      SUBROUTINE QJMATm(QD,QJ,IJKL,XIJKL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DIMENSION QD(NBF,NBF,NBF),QJ(NBFT5),IJKL(NSTORE),XIJKL(NSTORE)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AUX1,AUX2
      ALLOCATE (AUX1(NBF,NBF),AUX2(NBF,NBF))       ! AUX1:Jj(i,l)
!-----------------------------------------------------------------------
!     Coulomb Integrals QJ(i,j)
!-----------------------------------------------------------------------
      DO J=1,NBF5
       AUX2(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL HSTARJ(AUX1,AUX2,IJKL,XIJKL)
       DO I=1,J
        IJ=I+J*(J-1)/2
        AUX2(1:NBF,1:NBF) = QD(I,1:NBF,1:NBF)
        CALL TRACEm(QJ(IJ),AUX2,AUX1,NBF)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      DEALLOCATE (AUX1,AUX2)
      RETURN
      END

! QKMATm
      SUBROUTINE QKMATm(QD,QK,IJKL,XIJKL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DIMENSION QD(NBF,NBF,NBF),QK(NBFT5),IJKL(NSTORE),XIJKL(NSTORE)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AUX1,AUX2
      ALLOCATE (AUX1(NBF,NBF),AUX2(NBF,NBF))       ! AUX1:Kj(i,l)
!-----------------------------------------------------------------------
!     Exchange Integrals QK(i,j)
!-----------------------------------------------------------------------
      DO J=1,NBF5
       AUX2(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL HSTARK(AUX1,AUX2,IJKL,XIJKL)
       DO I=1,J
        IJ=I+J*(J-1)/2
        AUX2(1:NBF,1:NBF) = QD(I,1:NBF,1:NBF)
        CALL TRACEm(QK(IJ),AUX2,AUX1,NBF)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      DEALLOCATE (AUX1,AUX2)
      RETURN
      END

! QJKMATmRI
      SUBROUTINE QJKMATmRI(QJ,QK,XIJKAUX,C)
!     Coulomb and Exchange Integrals QJ(i,j) and QK(i,j)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL ERIACTIVATED       
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
#include "mpip.h"
      DIMENSION QJ(NBFT5),QK(NBFT5)
      DIMENSION XIJKAUX(NBF*(NBF+1)/2,IAUXDIM)
#ifdef MPI
      DOUBLE PRECISION,DIMENSION(NBFT5)::QQJ,QQK
#endif
!-----------------------------------------------------------------------
      DIMENSION C(NBF,NBF)
      DIMENSION B_IN(NBF5,NBF)
      DIMENSION B_IJ(NBF5,NBF5)
      INTEGER :: I,J,K,M,N
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Wake up the nodes for the task
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      DO I=1,NPROCS-1
       NOPT = 2
       QQJ = 0.0d0
       QQK = 0.0d0
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
      CALL MPI_BCAST(C,NBF*NBF,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO K=1,IAUXDIM

        B_IN(1:NBF5,1:NBF) = 0.0d0
        DO I=1,NBF5
          DO N=1,NBF
            DO M=1,N
              MN = M + N*(N-1)/2
              B_IN(I,N) = B_IN(I,N) + C(M,I)*XIJKAUX(MN,K)
              IF(M.NE.N) B_IN(I,M) = B_IN(I,M)+C(N,I)*XIJKAUX(MN,K)
            END DO
          END DO
        END DO

        B_IJ(1:NBF5,1:NBF5) = 0.0d0
        DO J=1,NBF5
          DO N=1,NBF
            DO I=1,J
              B_IJ(I,J) = B_IJ(I,J) + C(N,J)*B_IN(I,N)
            END DO
          END DO
        END DO

        DO J=1,NBF5
          DO I=1,J
            IJ=I+J*(J-1)/2
            QJ(IJ) = QJ(IJ) + B_IJ(I,I)*B_IJ(J,J)
          END DO
        END DO

        DO J=1,NBF5
          DO I=1,J
            IJ=I+J*(J-1)/2
            QK(IJ) = QK(IJ) + B_IJ(I,J)*B_IJ(I,J)
          END DO
        END DO

      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get the pieces from slaves
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(QJ,QQJ,NBFT5,MPI_REAL8,MPI_SUM,MASTER,            &
                      MPI_COMM_WORLD,IERR)                               
      CALL MPI_REDUCE(QK,QQK,NBFT5,MPI_REAL8,MPI_SUM,MASTER,            &
                      MPI_COMM_WORLD,IERR)
      QJ = QQJ
      QK = QQK
#endif      
!-----------------------------------------------------------------------
      RETURN
      END

! HSTARJ
      SUBROUTINE HSTARJ(FM,PM,IERI,ERI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Wake up the nodes for the task
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=1
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
!----------------------------------------------------------------------
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
!----------------------------------------------------------------------
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

                       F(NIJ)=F(NIJ)+0.5*P(NKL)*XJ
       IF(NIJ/=NKL)    F(NKL)=F(NKL)+0.5*P(NIJ)*XJ
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get the pieces from slaves
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,               &
                      MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE(P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE(P,F)
#endif
!----------------------------------------------------------------------
      RETURN
      END

! HSTARK
      SUBROUTINE HSTARK(FM,PM,IERI,ERI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=2
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       XJ = 0.25*XJ
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)+P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)+P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)+P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)+P(NIL)*XJ
       ENDIF
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get the pieces from slaves
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,               &
                      MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE (P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE (P,F)
#endif
!----------------------------------------------------------------------
      RETURN
      END

! HSTARJKRI
      SUBROUTINE HSTARJKRI(FMJ,FMK,ERIaux,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL ERIACTIVATED       
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
#include "mpip.h"
      DOUBLE PRECISION,DIMENSION(NBF*(NBF+1)/2,IAUXDIM)::ERIaux
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FMJ,FMK
      DOUBLE PRECISION,DIMENSION(NBFT):: FJ
      DOUBLE PRECISION,DIMENSION(NBFT):: FK
#ifdef MPI
      DOUBLE PRECISION,DIMENSION(NBFT)::FFJ,FFK
#endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,DIMENSION(NBF)::C
      DOUBLE PRECISION,DIMENSION(NBF)::B_IN
      DOUBLE PRECISION::B_II
      INTEGER :: M,N,K
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Wake up the nodes for the task
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      DO I=1,NPROCS-1
       NOPT=1
       FFJ = 0.0d0
       FFK = 0.0d0
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
      CALL MPI_BCAST(C,NBF,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif

      FJ(1:NBFT) = 0.0d0
      FK(1:NBFT) = 0.0d0

      DO K=1,IAUXDIM
        B_IN(1:NBF) = 0.0d0
        B_II = 0.0d0

        DO N=1,NBF
          DO M=1,N
            MN = M + N*(N-1)/2
            B_IN(N) = B_IN(N) + C(M)*ERIaux(MN,K)
            IF(M.NE.N) B_IN(M) = B_IN(M)+C(N)*ERIaux(MN,K)
          END DO
        END DO

        DO N=1,NBF
          B_II = B_II + C(N)*B_IN(N)
        END DO

        DO N=1,NBF
          DO M=1,N
            MN = M + N*(N-1)/2
            FJ(MN) = FJ(MN) + B_II*ERIaux(MN,K)
          END DO
        END DO

        DO N=1,NBF
          DO M=1,N
            MN = M + N*(N-1)/2
            FK(MN) = FK(MN) + B_IN(M)*B_IN(N)
          END DO
        END DO
      END DO

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get the pieces from slaves
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(FJ,FFJ,NBFT,MPI_REAL8,MPI_SUM,MASTER,             &
                      MPI_COMM_WORLD,IERR)                               
      CALL MPI_REDUCE(FK,FFK,NBFT,MPI_REAL8,MPI_SUM,MASTER,             &
                      MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FMJ,FFJ,NBF,NBFT)
      CALL TRIANSQUARE(FMK,FFK,NBF,NBFT)
#else      
      CALL TRIANSQUARE(FMJ,FJ,NBF,NBFT)
      CALL TRIANSQUARE(FMK,FK,NBF,NBFT)
#endif      
!----------------------------------------------------------------------
      RETURN
      END

! LABELIJKL
      SUBROUTINE LABELIJKL(LABEL,I,J,K,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
!-----------------------------------------------------------------------
!     Determine label (ijkl) (2**16-1=65535)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      I = ISHFT( LABEL, -48 )                                 
      J = IAND( ISHFT( LABEL, -32 ), 65535 )                  
      K = IAND( ISHFT( LABEL, -16 ), 65535 )                  
      L = IAND( LABEL, 65535 )                                
!-----------------------------------------------------------------------
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!    Minimization of Elec. Energy using CG or LBFGS Algorithms         !
!                                                                      !
!    OCUPACIONr: Calculate Occupation Numbers and their Derivatives    !
!    ENENEWr: Evaluate one-particle energies                           !
!                                                                      !
!    CGOCUPNAGr: Prepare for calling the NAG subroutine E04DGF         !
!    ENERFUNr: External Energy subroutine that calls OCUPENERGYrc,ro   !
!    OCUPENERGYrc,ro: Calculate the electronic energy and gradient     !
!    CGOCUPSUMSLr: Prepare for calling the subroutine SUMSL            !
!    CALCOE: Compute the Occupation Energy                             !
!    CALCOG: Compute the Occupation Energy Gradients                   !
!    LBFGSOCUPr: Optimize occupations by LBFGS algorithm               !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! OCUPACIONr
      SUBROUTINE OCUPACIONr(GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,NV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/SUMSZ/SUMS,SUMF
!
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA       ! NV = NCWO*NDOC
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::DRO,BETA,DBETA,HR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::DB,DHR
!-----------------------------------------------------------------------
!                 Occupations and their Derivatives
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (DRO(NBF5),BETA(NBF5),DBETA(NBF5),DB(NBF5,NV))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RO = 0.0d0
      BETA = 0.0d0
      DRO = 0.0d0
      DBETA = 0.0d0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Occupations (1,NO1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NO1>0)THEN
       DO in=1,NO1
        RO(in) = 1.0d0
        BETA(in) = 1.0d0
       ENDDO
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Occupations (NO1+1,NO1+NDOC)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,NDOC
       in = NO1+i
       RO(in)   = 0.5d0 + 0.5d0*DCOS(GAMMA(i))*DCOS(GAMMA(i))
       DRO(in)  = - 0.5d0*DSIN(2.0d0*GAMMA(i))
       BETA(in) = DSQRT(RO(in))
       DBETA(in)= 0.5d0*DRO(in)/BETA(in)
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Occupations (NO1+NDOC+1,NA=NO1+NDNS)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NSOC>0)THEN
       if(.not.HighSpin)then
        DO i=NDOC+1,NDNS
         in = NO1+i
         MULT1 = NA - NB
         RO(in)  = 0.5d0*MULT1/NSOC
         DRO(in) = 0.0d0
         BETA(in) = DSQRT(RO(in))
         DBETA(in) = 0.0d0
        ENDDO
       else if(HighSpin)then
        DO i=NDOC+1,NDNS
         in = NO1+i
         RO(in)  = 1.0d0
         DRO(in) = 0.0d0
        ENDDO
       end if      
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Occupations (NA+1,NBF5)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)

       DR = 0.0d0
       DB = 0.0d0
       DO i=1,NDOC
        in = NO1+i                               ! in=no1+1,nb 
        DR(in,i) = DRO(in)
        DB(in,i) = DBETA(in)
        icf = na+ndoc-i+1      ! icf=na+ncwo*(ndoc-i)+ncwo with ncwo=1
        RO(icf)   = DSIN(GAMMA(i))*DSIN(GAMMA(i))/2.0d0
        DRO(icf)  = DSIN(2.0d0*GAMMA(i))/2.0d0
        DR(icf,i) = DRO(icf)
        BETA(icf) = DSQRT(RO(icf))
        if(BETA(icf)>0.0d0)then
         DBETA(icf)= 0.5d0*DRO(icf)/BETA(icf)
        else
         DBETA(icf)= 0.0d0
        end if
        DB(icf,i) = DBETA(icf)
       ENDDO

      ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)

       ALLOCATE (HR(NV-NDOC),DHR(NV-NDOC,NV))
       DR = 0.0d0
       DB = 0.0d0
       HR = 0.0d0
       DHR = 0.0d0
       
       DO i=1,NDOC                                ! ig=i=1,ndoc
        in = NO1+i                                ! in=no1+1,nb
        DR(in,i) = DRO(in)
        DB(in,i) = DBETA(in)
        ici = (ncwo-1)*(i-1)+1
        icf = (ncwo-1)*i
         HR(ici:icf)  = 1.0d0 - RO(in)
        DHR(ici:icf,i)= - DRO(in)

!- - - -- - - - - - - - - - (i,iw) <-> ic,ig,in  - - - - - - - - - - - -
        do iw=1,ncwo-1
         ic = (ncwo-1)*(i-1)+iw             ! ic=1,ndoc*(ncwo-1)
         ig = ndoc+ic                       ! ig=ndoc+1,ndoc*ncwo
         im = na+ncwo*(ndoc-i)+iw           ! im=na+1,na+ncwo*ndoc-1
       
         ROn = DSIN(GAMMA(ig))*DSIN(GAMMA(ig))
         DRO(im) = DSIN(2.0d0*GAMMA(ig))
         BETAn = DSQRT(ROn)
         if(BETAn>0.0d0)then
          DBETA(im) = 0.5d0*DRO(im)/BETAn
         else
          DBETA(im) = 0.0d0
         end if
         RO(im) =       HR(ic)*ROn
         RAIZic = DSQRT(HR(ic))
         BETA(im) = RAIZic*BETAn
         DR(im,i) = DHR(ic,i)*ROn
         if(RAIZic>0.0d0)then
          DB(im,i) = 0.5d0*DHR(ic,i)*BETAn/RAIZic
         else 
          DB(im,i) = 0.0d0
         endif
         do ic1=ici,ic-1                           ! ici < ic1 < ic-1
          ig1 = ndoc+ic1                           !   i < ig1 < ig
          DR(im,ig1) =        DHR(ic,ig1)*ROn
          if(RAIZic>0.0d0)then
           DB(im,ig1) = 0.5d0*DHR(ic,ig1)*BETAn/RAIZic
          else 
           DB(im,ig1) = 0.0d0
          endif
         enddo
         DR(im,ig) = HR(ic)*DRO(im)
         DB(im,ig) = RAIZic*DBETA(im)

!- - - - HR(ic+1) - - - - - - - - - - - - - - - -
         if(iw<ncwo-1)then
          do ix=1,ncwo-1-iw
           ic1 = ic+ix                          ! ic < ic1 < i*(ncwo-1)
            HR(ic1)  =  HR(ic1) - RO(im)
           DHR(ic1,i)= DHR(ic1,i) - DR(im,i)
           do icn=ici,ic-1
            ign = ndoc+icn
            DHR(ic1,ign)= DHR(ic1,ign) - DR(im,ign)
           enddo
           DHR(ic1,ig)= DHR(ic1,ig) - DR(im,ig)
          enddo
         endif
!- - - - HR(ic+1) - - - - - - - - - - - - - - - -
        enddo
!- - - -- - - - - - - - - - (i,iw) <-> ic,ig,in  - - - - - - - - - - - -

!- - - - ic = icf - last RO  - - - - - - - - - - - - - -
        ig = ndoc+icf               ! ig=ndoc+i*(ncwo-1)
        im = na+ncwo*(ndoc-i)+ncwo
        Hn = DCOS(GAMMA(ig))*DCOS(GAMMA(ig))
        DRO(im) = -DSIN(2.0d0*GAMMA(ig))
        BETAn = DSQRT(Hn)
        if(BETAn>0.0d0)then
         DBETA(im) = 0.5d0*DRO(im)/BETAn
        else
         DBETA(im) = 0.0d0
        end if       
        RO(im)  =       HR(icf)*Hn
        RAIZicf = DSQRT(HR(icf))
        BETA(im)= RAIZicf*BETAn

        DR(im,i) =        DHR(icf,i)*Hn
        if(RAIZicf>0.0d0)then
         DB(im,i) = 0.5d0*DHR(icf,i)*BETAn/RAIZicf
        else 
         DB(im,i) = 0.0d0
        endif
 
        do ic1=ici,icf-1            ! ici < ic1 < icf-1
         ig1 = ndoc+ic1             !   i < ig1 < ig
         DR(im,ig1) =        DHR(icf,ig1)*Hn
         if(RAIZicf>0.0d0)then
          DB(im,ig1) = 0.5d0*DHR(icf,ig1)*BETAn/RAIZicf
         else 
          DB(im,ig1) = 0.0d0
         endif
        enddo
        DR(im,ig) = HR(icf) *DRO(im)
        DB(im,ig) = RAIZicf*DBETA(im)
!- - - - ic = icf - last RO  - - - - - - - - - - - - - -
       ENDDO
       DEALLOCATE(HR,DHR)       

      ENDIF
      DEALLOCATE(DRO,DBETA)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Sum of the Holes below the Fermi Level (SUMS)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SUMS = DFLOAT(NB)
      do j=1,nb
       SUMS = SUMS - RO(j)
      enddo
!-----------------------------------------------------------------------
!                   CJ12, CK12, DCJ12r, DCK12r
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPNOF==3)THEN
       if(NSOC==0)CALL CJCKD3(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==4)THEN
       if(NSOC==0)CALL CJCKD4(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==5)THEN
       CALL CJCKD5(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==6)THEN
       if(NSOC==0)CALL CJCKD6(NV,RO,DR,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==7)THEN
       CALL CJCKD7(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ENDIF
!-----------------------------------------------------------------------
      DEALLOCATE(BETA,DB)
      RETURN
      END

! ENENEWr
      SUBROUTINE ENENEWr(RO,HCORE,QJ,QK,CJ12,CK12,DIPx,DIPy,DIPz,EAHF,E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/EHFEN/EHF,EN
!
      DOUBLE PRECISION,DIMENSION(NBF)::EAHF,E
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX
!-----------------------------------------------------------------------
!     EAHF: New HF energies
!-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF5,NBF5))
      DO j=1,NBF5
       DO i=1,NBF5
        AUX(j,i) = RO(j)*RO(i)
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,na
       FI2j= RO(j)*(1.0-RO(j))
       FIj = SQRT(FI2j)
        jj = j*(j+1)/2
        ja = NBF5-j+1
       jja = j + ja*(ja-1)/2
       EAHF(j) =  RO(j)*HCORE(j) + 0.5d0*FI2j*QJ(jj)                    &
               - 0.5d0*FIj*QK(jja) - FI2j*(QJ(jja)-0.5d0*QK(jja))        
       do i=1,j                                                          
        ij = i + j*(j-1)/2                                               
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))               
       enddo                                                             
       do i=j+1,NBF5                                                     
        ij = j + i*(i-1)/2                                               
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))               
       enddo                                                             
      ENDDO                                                              
!                                                                        
      DO j=na+1,nbf5                                                     
       FI2j= RO(j)*(1.0-RO(j))                                           
       FIj = SQRT(FI2j)                                                  
        jj = j*(j+1)/2                                                   
        ja = NBF5-j+1                                                    
       jja = ja + j*(j-1)/2                                              
       EAHF(j) =  RO(j)*HCORE(j) + 0.5d0*FI2j*QJ(jj)                    &
               - 0.5d0*FIj*QK(jja) - FI2j*(QJ(jja)-0.5d0*QK(jja))
       do i=1,j
        ij = i + j*(j-1)/2
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))
       enddo
       do i=j+1,NBF5
        ij = j + i*(i-1)/2
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))
       enddo
      ENDDO
!      
      IF(NBF5<NBF)THEN
       DO J=NBF5+1,NBF
        EAHF(J) = 0.0d0
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
!     E: Diagonal of the Lagrangian (ELAG)
!-----------------------------------------------------------------------
      if(MSpin==0)then
       DO J=1,NB
        JJ=J*(J+1)/2
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )                            &
             + PRODCWQWj(J,CJ12,QJ) - PRODCWQWj(J,CK12,QK)               
       ENDDO                                                             
       DO J=NB+1,NA                                                      
        E(J) = RO(J) * HCORE(J)                                         &
             + PRODCWQWj(J,CJ12,QJ)-PRODCWQWj(J,CK12,QK)                 
       ENDDO                                                             
       DO J=NA+1,NBF5                                                    
        JJ=J*(J+1)/2                                                     
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )                            &
             + PRODCWQWj(J,CJ12,QJ) - PRODCWQWj(J,CK12,QK)               
       ENDDO                                                             
      else if(MSpin>0)then                                               
       DO J=1,NB                                                         
        JJ=J*(J+1)/2                                                     
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )                            &
             + PRODCWQWj1(J,CJ12,QJ) - PRODCWQWj1(J,CK12,QK)            &
             + 2.0d0*PRODROQWj1(J,RO,QJ)-PRODROQWj1(J,RO,QK)             
       ENDDO                                                             
       DO J=NB+1,NA                                                      
        E(J) = 0.5d0*( RO(J)*HCORE(J) + PRODROQWj0(J,RO,QJ)             &
                      - PRODROQWj0(J,RO,QK) )                            
       ENDDO                                                             
       DO J=NA+1,NBF5                                                    
        JJ=J*(J+1)/2                                                     
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )                            &
             + PRODCWQWj2(J,CJ12,QJ) - PRODCWQWj2(J,CK12,QK)            &
             + 2.0d0*PRODROQWj2(J,RO,QJ)-PRODROQWj2(J,RO,QK)
       ENDDO
      end if 
!      
      IF(NBF5<NBF)THEN
       DO J=NBF5+1,NBF
        E(J) = 0.0d0                  ! /= ELAG(J,J) !!!
       ENDDO
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Including Electric Field
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EFIELDL)THEN
       DO J=1,NBF5
        E(J) = E(J) + (EX*DIPx(J)+EY*DIPy(J)+EZ*DIPz(J))*RO(J)
       ENDDO
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculation of the Total Energy 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      ETOTAL = 0.0
!      DO J=1,NB
!       ETOTAL = ETOTAL + E(J) + RO(J)*HCORE(J)
!      ENDDO
!      if(MSpin==0)then
!       DO J=NB+1,NA
!        ETOTAL = ETOTAL + E(J) + RO(J)*HCORE(J)       
!       ENDDO
!      else if(MSpin>0)then       
!       DO J=NB+1,NA
!        ETOTAL = ETOTAL + E(J) + 0.5d0*RO(J)*HCORE(J)       
!       ENDDO
!      end if
!      DO J=NA+1,NBF5
!       ETOTAL = ETOTAL + E(J) + RO(J)*HCORE(J)
!      ENDDO
!      IF(EFIELDL)THEN
!       DO J=1,NBF5
!        ETOTAL = ETOTAL + (EX*DIPx(J)+EY*DIPy(J)+EZ*DIPz(J))*RO(J)
!       ENDDO
!      ENDIF
!      write(6,*)'ETOTAL=',ETOTAL + EN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE (AUX)
      RETURN
      END

! CGOCUPSUMSLr
      SUBROUTINE CGOCUPSUMSLr(NV,GAMMA,USER,ENERGY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(NV) :: GAMMA
      DOUBLE PRECISION,DIMENSION(NUSER) :: USER
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IUSER,IV      
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: D,V     
      EXTERNAL CALCOE,CALCOG
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      LIV = 60
      LV = 71+NV*(NV+15)/2
      ALLOCATE( IUSER(1),IV(LIV),D(NV),V(LV) ) 
      IUSER(1) = 1
      IV = 0
      D(1:NV) = 1.0d-1       
      CALL SUMSL(NV,D,GAMMA,CALCOE,CALCOG,IV,LIV,LV,V,IUSER,USER)
      ENERGY = EELEC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(IUSER,IV,D,V)
      RETURN
      END

! CALCOE      
      SUBROUTINE CALCOE(NV,GAMMA,NF,ENERGY,IUSER,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      INTEGER,DIMENSION(1) :: IUSER 
      DOUBLE PRECISION,DIMENSION(NV)   :: GAMMA
      DOUBLE PRECISION,DIMENSION(NUSER):: USER
!-----------------------------------------------------------------------
!     Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NF = NF
      IUSER(1) = IUSER(1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Occupations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OCUPACIONr(GAMMA,USER(N1),USER(N2),USER(N3),                 &
                            USER(N4),USER(N5),USER(N6),NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      if(MSpin==0)then
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NCWO==1)THEN       ! PNOFi(1): Perfect Pairing (NCWO=1)
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj(in,USER(N2),USER(N9))                       &
                - PRODCWQWj(in,USER(N3),USER(N10))                       
        enddo                                                            
        do i=1,NDOC                                                      
         in = NO1+i                                                      
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj(in,USER(N2),USER(N9))                       &
                - PRODCWQWj(in,USER(N3),USER(N10))                       
         in = na+ndoc-i+1                                                
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj(in,USER(N2),USER(N9))                       &
                - PRODCWQWj(in,USER(N3),USER(N10))                       
        enddo                                                            
        if(NSOC>0)then                                                   
         do i=NDOC+1,NDNS                                                
          in = NO1+i                                                     
          ENERGY = ENERGY + 2.0d0*USER(N1-1+in)*USER(N8-1+in)           &
                 + PRODCWQWj(in,USER(N2),USER(N9))                      &
                 - PRODCWQWj(in,USER(N3),USER(N10))
         enddo
        endif
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NCWO>1)THEN        ! PNOFi(Nc): Extended PNOF (NCWO>1)
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj(in,USER(N2),USER(N9))                       &
                - PRODCWQWj(in,USER(N3),USER(N10))                       
        enddo                                                            
        do i=1,NDOC                                                      
         in = NO1+i                                                      
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj(in,USER(N2),USER(N9))                       &
                - PRODCWQWj(in,USER(N3),USER(N10))                       
         do iw=1,ncwo-1                                                  
          in = na+ncwo*(ndoc-i)+iw                                       
          ENERGY = ENERGY + USER(N1-1+in)                               &
                 * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )       &
                 + PRODCWQWj(in,USER(N2),USER(N9))                      &
                 - PRODCWQWj(in,USER(N3),USER(N10))                      
         enddo                                                           
         in = na+ncwo*(ndoc-i)+ncwo                                      
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj(in,USER(N2),USER(N9))                       &
                - PRODCWQWj(in,USER(N3),USER(N10))                       
        enddo                                                            
        if(NSOC>0)then                                                   
         do i=NDOC+1,NDNS                                                
          in = NO1+i                                                     
          ENERGY = ENERGY + 2.0d0*USER(N1-1+in)*USER(N8-1+in)           &
                 + PRODCWQWj(in,USER(N2),USER(N9))                      &
                 - PRODCWQWj(in,USER(N3),USER(N10))
         enddo
        endif
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL)THEN       ! including electric field
        CALL DIPMOMr(USER(N11),USER(N12),USER(N13),USER(N14),          &
                     USER(N15),USER(N16),USER(N17),USER(N7),           &
                     USER(N1),DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        ENERGY = ENERGY - EX*DMX - EY*DMY - EZ*DMZ
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      end if
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --           
!     High-Spin Multiplet State (S>0,Ms=S)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      if(MSpin>0)then
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NCWO==1)THEN       ! PNOFi(1): Perfect Pairing (NCWO=1)
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj1(in,USER(N2),USER(N9))                      &
                - PRODCWQWj1(in,USER(N3),USER(N10))                     &
                + 2.0d0*PRODROQWj1(in,USER(N1),USER(N9))                &
                - PRODROQWj1(in,USER(N1),USER(N10))                      
        enddo                                                            
        do i=1,NDOC                                                      
         in = NO1+i                                                      
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj1(in,USER(N2),USER(N9))                      &
                - PRODCWQWj1(in,USER(N3),USER(N10))                     &
                + 2.0d0*PRODROQWj1(in,USER(N1),USER(N9))                &
                - PRODROQWj1(in,USER(N1),USER(N10))                      
         in = na+ndoc-i+1                                                
         ENERGY = ENERGY + USER(N1-1+in)                                &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )        &
                + PRODCWQWj2(in,USER(N2),USER(N9))                      &
                - PRODCWQWj2(in,USER(N3),USER(N10))                     &
                + 2.0d0*PRODROQWj2(in,USER(N1),USER(N9))                &
                - PRODROQWj2(in,USER(N1),USER(N10))                     
        enddo                                                           
        do i=NDOC+1,NDNS                                                
         in = NO1+i                                                     
         ENERGY = ENERGY + USER(N1-1+in)*USER(N8-1+in)                  &
                + 0.5d0*(PRODROQWj0(in,USER(N1),USER(N9))               &
                - PRODROQWj0(in,USER(N1),USER(N10)))
        enddo
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NCWO>1)THEN        ! PNOFi(Nc): Extended PNOF (NCWO>1)
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + USER(N1-1+in)                               &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )       &
                + PRODCWQWj1(in,USER(N2),USER(N9))                     &
                - PRODCWQWj1(in,USER(N3),USER(N10))                    &
                + 2.0d0*PRODROQWj1(in,USER(N1),USER(N9))               &
                - PRODROQWj1(in,USER(N1),USER(N10))                     
        enddo                                                           
        do i=1,NDOC                                                     
         in = NO1+i                                                     
         ENERGY = ENERGY + USER(N1-1+in)                               &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )       &
                + PRODCWQWj1(in,USER(N2),USER(N9))                     &
                - PRODCWQWj1(in,USER(N3),USER(N10))                    &
                + 2.0d0*PRODROQWj1(in,USER(N1),USER(N9))               &
                - PRODROQWj1(in,USER(N1),USER(N10))                     
         do iw=1,ncwo-1                                                 
          in = na+ncwo*(ndoc-i)+iw                                      
          ENERGY = ENERGY + USER(N1-1+in)                              &
                 * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )      &
                 + PRODCWQWj2(in,USER(N2),USER(N9))                    &
                 - PRODCWQWj2(in,USER(N3),USER(N10))                   &
                 + 2.0d0*PRODROQWj2(in,USER(N1),USER(N9))              &
                 - PRODROQWj2(in,USER(N1),USER(N10))                    
         enddo                                                          
         in = na+ncwo*(ndoc-i)+ncwo                                     
         ENERGY = ENERGY + USER(N1-1+in)                               &
                * ( 2.0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )       &
                + PRODCWQWj2(in,USER(N2),USER(N9))                     &
                - PRODCWQWj2(in,USER(N3),USER(N10))                    &
                + 2.0d0*PRODROQWj2(in,USER(N1),USER(N9))               &
                - PRODROQWj2(in,USER(N1),USER(N10))          
        enddo
        do i=NDOC+1,NDNS
         in = NO1+i
         ENERGY = ENERGY + USER(N1-1+in)*USER(N8-1+in)                 &
                + 0.5d0*(PRODROQWj0(in,USER(N1),USER(N9))              &
                - PRODROQWj0(in,USER(N1),USER(N10)))
        enddo
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL)THEN       ! including electric field
        CALL DIPMOMr(USER(N11),USER(N12),USER(N13),USER(N14),          &
                     USER(N15),USER(N16),USER(N17),USER(N7),           &
                     USER(N1),DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        ENERGY = ENERGY - EX*DMX - EY*DMY - EZ*DMZ
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      end if
!-----------------------------------------------------------------------
      EELEC = ENERGY
      RETURN
      END

! CALCOG      
      SUBROUTINE CALCOG(NV,GAMMA,NF,GRAD,IUSER,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      INTEGER,DIMENSION(1) :: IUSER 
      DOUBLE PRECISION,DIMENSION(NV) :: GAMMA,GRAD
      DOUBLE PRECISION,DIMENSION(NUSER) :: USER
!-----------------------------------------------------------------------
!     Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NF = NF
      IUSER(1) = IUSER(1)
      GAMMA(1) = GAMMA(1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Occupations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      CALL OCUPACIONr(GAMMA,USER(N1),USER(N2),USER(N3),                 &
!                            USER(N4),USER(N5),USER(N6),NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      if(MSpin==0)then
      
       IF(NCWO==1)THEN       ! PNOFi(1): Perfect Pairing (NCWO=1)
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,USER(N5),USER(N9))   &
                             - PRODCWQWjk(nv,in,ig,USER(N6),USER(N10)) ) 
          in = na+ndoc-i+1                                               
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,USER(N5),USER(N9))   &
                             - PRODCWQWjk(nv,in,ig,USER(N6),USER(N10)) )
         enddo
        ENDDO

        if(EFIELDL)then      ! including electric field
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )                             
           in = na+ndoc-i+1                                             
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )
          enddo
         ENDDO
        endif
       END IF

       IF(NCWO>1)THEN        ! PNOFi(Nc): Extended PNOF (NCWO>1)

        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,USER(N5),USER(N9))   &
                             - PRODCWQWjk(nv,in,ig,USER(N6),USER(N10)) ) 
          do iw=1,NCWO-1                                                 
           in = na+ncwo*(ndoc-i)+iw                                      
           GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)              &
                    * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )  &
                    + 2.0d0 * (PRODCWQWjk(nv,in,ig,USER(N5),USER(N9))   &
                              -PRODCWQWjk(nv,in,ig,USER(N6),USER(N10)) ) 
          enddo                                                          
          in = na+ncwo*(ndoc-i)+ncwo                                     
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,USER(N5),USER(N9))   &
                             - PRODCWQWjk(nv,in,ig,USER(N6),USER(N10)) )
         enddo
        ENDDO

        if(EFIELDL)then      ! including electric field
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )                             
           do iw=1,NCWO-1                                               
            in = na+ncwo*(ndoc-i)+iw                                    
            GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)      &
                     * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)         &
                       + EZ*USER(N17-1+in) )                            
           enddo                                                        
           in = na+ncwo*(ndoc-i)+ncwo                                   
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )
          enddo
         ENDDO
        endif

       END IF

      end if
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --           
!     High-Spin Multiplet State (S>0,Ms=S)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      if(MSpin>0)then
      
       IF(NCWO==1)THEN       ! PNOFi(1): Perfect Pairing (NCWO=1)

        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk1(nv,in,ig,USER(N5),USER(N9))  &
                             - PRODCWQWjk1(nv,in,ig,USER(N6),USER(N10)))&
                   + 2.0d0 *   PRODDRQWjk1(nv,in,ig,USER(N4),USER(N9))  &
                   -           PRODDRQWjk1(nv,in,ig,USER(N4),USER(N10))  
          in = na+ndoc-i+1                                               
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,USER(N5),USER(N9))  &
                             - PRODCWQWjk2(nv,in,ig,USER(N6),USER(N10)))&
                   + 2.0d0 *   PRODDRQWjk2(nv,in,ig,USER(N4),USER(N9))  &
                   -           PRODDRQWjk2(nv,in,ig,USER(N4),USER(N10))
         enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        ENDDO

        if(EFIELDL)then      ! including electric field   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )                             
           in = na+ndoc-i+1                                             
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )
          enddo
         ENDDO
        endif

       END IF
       
       IF(NCWO>1)THEN        ! PNOFi(Nc): Extended PNOF (NCWO>1)

        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk1(nv,in,ig,USER(N5),USER(N9))  &
                             - PRODCWQWjk1(nv,in,ig,USER(N6),USER(N10)))&
                   + 2.0d0 *   PRODDRQWjk1(nv,in,ig,USER(N4),USER(N9))  &
                   -           PRODDRQWjk1(nv,in,ig,USER(N4),USER(N10))  
          do iw=1,NCWO-1                                                 
           in = na+ncwo*(ndoc-i)+iw                                      
           GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)              &
                    * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )  &
                    + 2.0d0 * (PRODCWQWjk2(nv,in,ig,USER(N5),USER(N9))  &
                              -PRODCWQWjk2(nv,in,ig,USER(N6),USER(N10)))&
                    + 2.0d0 *  PRODDRQWjk2(nv,in,ig,USER(N4),USER(N9))  &
                    -          PRODDRQWjk2(nv,in,ig,USER(N4),USER(N10))  
          enddo                                                          
          in = na+ncwo*(ndoc-i)+ncwo                                     
          GRAD(ig) = GRAD(ig) + USER(N4-1+in+(ig-1)*nbf5)               &
                   * ( 2.0d0*USER(N8-1+in) + USER(N9-1+in*(in+1)/2) )   &
                   + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,USER(N5),USER(N9))  &
                             - PRODCWQWjk2(nv,in,ig,USER(N6),USER(N10)))&
                   + 2.0d0 *   PRODDRQWjk2(nv,in,ig,USER(N4),USER(N9))  &
                   -           PRODDRQWjk2(nv,in,ig,USER(N4),USER(N10))
         enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -          
        ENDDO

        if(EFIELDL)then      ! including electric field   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )                             
           do iw=1,NCWO-1                                               
            in = na+ncwo*(ndoc-i)+iw                                    
            GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)      &
                     * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)         &
                       + EZ*USER(N17-1+in) )                            
           enddo                                                        
           in = na+ncwo*(ndoc-i)+ncwo                                   
           GRAD(ig) = GRAD(ig) + 2.0d0*USER(N4-1+in+(ig-1)*nbf5)       &
                    * ( EX*USER(N15-1+in) + EY*USER(N16-1+in)          &
                      + EZ*USER(N17-1+in) )
          enddo
         ENDDO
        endif

       ENDIF

      end if
!-----------------------------------------------------------------------
      RETURN
      END
      
! CGOCUPNAGr
      SUBROUTINE CGOCUPNAGr(NV,GAMMA,USER,ENERGY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_THRESH/THRESHL,THRESHE,THRESHEC,THRESHEN
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
      INTEGER,ALLOCATABLE,DIMENSION(:)::IUSER,IWORK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::GRAD,WORK
      EXTERNAL ENERFUNr
      ALLOCATE (IUSER(1),IWORK(NV+1),GRAD(NV),WORK(13*NV))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send output of E04DGF to NAG file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL X04ABF(1,2)                                        
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Function Precision (machine precision**0.9)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(THRESHEN>=1.0d-10)THEN
!nag       CALL E04DKF ('Function Precision = 1.0D-10')           
          ELSEIF(THRESHEN==1.0d-11)THEN                           
!nag       CALL E04DKF ('Function Precision = 1.0D-11')           
          ELSEIF(THRESHEN==1.0d-12)THEN                               
!nag       CALL E04DKF ('Function Precision = 1.0D-12')           
          ELSEIF(THRESHEN==1.0d-13)THEN                               
!nag       CALL E04DKF ('Function Precision = 1.0D-13')           
          ELSEIF(THRESHEN==1.0d-14)THEN                               
!nag       CALL E04DKF ('Function Precision = 1.0D-14')           
          ELSEIF(THRESHEN==1.0d-15)THEN                               
!nag       CALL E04DKF ('Function Precision = 1.0D-15')           
          ELSEIF(THRESHEN<=1.0d-16)THEN                               
!nag       CALL E04DKF ('Function Precision = 1.0D-16')           
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Verify Level (-1 = No checks, 0 = cheap test, 1 = 0 + gradients)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Verify Level = -1')                       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print Level (0 = No output, 1 = The final solution only)
!                 (5 = One line of summary output for each iteration)
!                 (10 = The final solution and one line for each iter.)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Print Level = 0')                         
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Maximum Step Length (Default = 10**20))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Maximum Step Length  = 0.1')              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Linesearch Tolerance (0<r<1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Linesearch Tolerance = 0.01')             
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calling to NAG Library for using the CG method
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IFAIL = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      GAMMA(1) = GAMMA(1)
!nag      CALL E04DGF(NV,ENERFUNr,ITER_E04DGF,ENERGY,GRAD,GAMMA,            &    
!nag                  IWORK,WORK,IUSER,USER,IFAIL)                               
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE (IUSER,IWORK,GRAD,WORK)
      RETURN
      END

! ENERFUNr
      SUBROUTINE ENERFUNr(MODE,NV,X,ENERGY,GRAD,NSTATE,IUSER,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      INTEGER,DIMENSION(*)::IUSER
      DOUBLE PRECISION,DIMENSION(NV)::X,GRAD
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
!-----------------------------------------------------------------------
      NSTATE=NSTATE
      IUSER(1)=IUSER(1)
!-----------------------------------------------------------------------
      if(MSpin==0)then
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
!      Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
       CALL OCUPENERGYrc(MODE,X,USER(N1),USER(N2),USER(N3),USER(N4),    &
                         USER(N5),USER(N6),USER(N7),USER(N8),USER(N9),  &
                         USER(N10),USER(N11),USER(N12),USER(N13),       &
                         USER(N14),USER(N15),USER(N16),USER(N17),       &
                         ENERGY,GRAD,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -   
      else if(MSpin>0)then
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
!      High-Spin Multiplet State (S>0,Ms=S)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
       CALL OCUPENERGYro(MODE,X,USER(N1),USER(N2),USER(N3),USER(N4),    &
                         USER(N5),USER(N6),USER(N7),USER(N8),USER(N9),  &
                         USER(N10),USER(N11),USER(N12),USER(N13),       &
                         USER(N14),USER(N15),USER(N16),USER(N17),       &
                         ENERGY,GRAD,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      end if
!-----------------------------------------------------------------------
      RETURN
      END

! OCUPENERGYrc
      SUBROUTINE OCUPENERGYrc(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r, &
                              QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,    &
                              DIPx,DIPy,DIPz,ENERGY,GRAD,NV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin 
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
!
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA,GRAD
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!----------------------------------------------------------------------- 
!     Occupations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OCUPACIONr(GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,NV)
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!                                ENERGY
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      IF(MODE==0.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)          
        enddo                                                            
        do i=1,NDOC                                                      
         in = NO1+i                                                      
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)          
         in = na+ndoc-i+1                                                
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)          
        enddo                                                            
        if(NSOC>0)then                                                   
         do i=NDOC+1,NDNS                                                
          in = NO1+i                                                     
          ENERGY = ENERGY + 2.0d0*RO(in)*HCORE(in)                      &
                 + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
         enddo
        endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)          
        enddo                                                            
        do i=1,NDOC                                                      
         in = NO1+i                                                      
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)          
         do iw=1,ncwo-1                                                  
          in = na+ncwo*(ndoc-i)+iw                                       
          ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))      &
                 + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)         
         enddo                                                           
         in = na+ncwo*(ndoc-i)+ncwo                                      
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)          
        enddo                                                            
        if(NSOC>0)then                                                   
         do i=NDOC+1,NDNS                                                
          in = NO1+i                                                     
          ENERGY = ENERGY + 2.0d0*RO(in)*HCORE(in)                      &
                 + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
         enddo
        endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
!- - - including Electric Field  - - - - - - - - - - - - - - - - -
       if(EFIELDL)then
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,             &
                     QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        ENERGY = ENERGY - EX*DMX - EY*DMY - EZ*DMZ
       endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!                               GRADIENTS
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      IF(MODE==1.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)           &
                             - PRODCWQWjk(nv,in,ig,DCK12r,QK) )          
          in = na+ndoc-i+1                                               
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)           &
                             - PRODCWQWjk(nv,in,ig,DCK12r,QK) )
         enddo
        ENDDO
!- - -  including Electric Field  - - - - - - - - - - - - - - - -
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )        
           in = na+ndoc-i+1                                              
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)           &
                             - PRODCWQWjk(nv,in,ig,DCK12r,QK) )          
          do iw=1,NCWO-1                                                 
           in = na+ncwo*(ndoc-i)+iw                                      
           GRAD(ig) = GRAD(ig)                                          &
                    + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) ) &
                    + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)          &
                              - PRODCWQWjk(nv,in,ig,DCK12r,QK) )         
          enddo                                                          
          in = na+ncwo*(ndoc-i)+ncwo                                     
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)           &
                             - PRODCWQWjk(nv,in,ig,DCK12r,QK) )
         enddo
        ENDDO
!- - -  including Electric Field  - - - - - - - - - - - - - - - -
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )        
           do iw=1,NCWO-1                                                
            in = na+ncwo*(ndoc-i)+iw                                     
            GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                     &
                     * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )       
           enddo                                                         
           in = na+ncwo*(ndoc-i)+ncwo                                    
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END
      
! OCUPENERGYro
      SUBROUTINE OCUPENERGYro(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r, &
                              QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,    &
                              DIPx,DIPy,DIPz,ENERGY,GRAD,NV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
!
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA,GRAD
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!----------------------------------------------------------------------- 
!     Occupations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OCUPACIONr(GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,NV)
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!                                ENERGY
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      IF(MODE==0.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)       &
                + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)        
        enddo                                                            
        do i=1,NDOC                                                      
         in = NO1+i                                                      
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)       &
                + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)           
         in = na+ndoc-i+1                                                
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj2(in,CJ12,QJ) - PRODCWQWj2(in,CK12,QK)       &
                + 2.0d0*PRODROQWj2(in,RO,QJ)-PRODROQWj2(in,RO,QK)     
        enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        do i=NDOC+1,NDNS
         in = NO1+i
         ENERGY = ENERGY + RO(in)*HCORE(in)                             &
                + 0.5d0*(PRODROQWj0(in,RO,QJ)-PRODROQWj0(in,RO,QK))
        enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)       &
                + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)        
        enddo                                                            
        do i=1,NDOC                                                      
         in = NO1+i                                                      
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)       &
                + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)        
         do iw=1,ncwo-1                                                  
          in = na+ncwo*(ndoc-i)+iw                                       
          ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))      &
                 + PRODCWQWj2(in,CJ12,QJ) - PRODCWQWj2(in,CK12,QK)      &
                + 2.0d0*PRODROQWj2(in,RO,QJ)-PRODROQWj2(in,RO,QK)           
         enddo                                                           
         in = na+ncwo*(ndoc-i)+ncwo                                      
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))       &
                + PRODCWQWj2(in,CJ12,QJ) - PRODCWQWj2(in,CK12,QK)       &
                + 2.0d0*PRODROQWj2(in,RO,QJ)-PRODROQWj2(in,RO,QK)          
        enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        do i=NDOC+1,NDNS
         in = NO1+i
         ENERGY = ENERGY + RO(in)*HCORE(in)                             &
                + 0.5d0*(PRODROQWj0(in,RO,QJ)-PRODROQWj0(in,RO,QK))
        enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
!- - - including Electric Field  - - - - - - - - - - - - - - - - -
       if(EFIELDL)then
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,             &
                     QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        ENERGY = ENERGY - EX*DMX - EY*DMY - EZ*DMZ
       endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!                               GRADIENTS
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      IF(MODE==1.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk1(nv,in,ig,DCJ12r,QJ)          &
                             - PRODCWQWjk1(nv,in,ig,DCK12r,QK) )        &
                   + 2.0d0 *   PRODDRQWjk1(nv,in,ig,DR,QJ)              &
                   -           PRODDRQWjk1(nv,in,ig,DR,QK)               
          in = na+ndoc-i+1                                               
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,DCJ12r,QJ)          &
                             - PRODCWQWjk2(nv,in,ig,DCK12r,QK) )        &
                   + 2.0d0 *   PRODDRQWjk2(nv,in,ig,DR,QJ)              &
                   -           PRODDRQWjk2(nv,in,ig,DR,QK)
         enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        ENDDO
! - - -  including Electric Field  - - - - - - - - - - - - - - - - - - - 
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )        
           in = na+ndoc-i+1                                              
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk1(nv,in,ig,DCJ12r,QJ)          &
                             - PRODCWQWjk1(nv,in,ig,DCK12r,QK) )        &
                   + 2.0d0 *   PRODDRQWjk1(nv,in,ig,DR,QJ)              &
                   -           PRODDRQWjk1(nv,in,ig,DR,QK)               
          do iw=1,NCWO-1                                                 
           in = na+ncwo*(ndoc-i)+iw                                      
           GRAD(ig) = GRAD(ig)                                          &
                    + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) ) &
                    + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,DCJ12r,QJ)         &
                              - PRODCWQWjk2(nv,in,ig,DCK12r,QK) )       &
                    + 2.0d0 *   PRODDRQWjk2(nv,in,ig,DR,QJ)             &
                    -           PRODDRQWjk2(nv,in,ig,DR,QK)              
          enddo                                                          
          in = na+ncwo*(ndoc-i)+ncwo                                     
          GRAD(ig) = GRAD(ig)                                           &
                   + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )  &
                   + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,DCJ12r,QJ)          &
                             - PRODCWQWjk2(nv,in,ig,DCK12r,QK) )        &
                   + 2.0d0 *   PRODDRQWjk2(nv,in,ig,DR,QJ)              &
                   -           PRODDRQWjk2(nv,in,ig,DR,QK)
         enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -          
        ENDDO
! - - -  including Electric Field  - - - - - - - - - - - - - - - - - - -
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )        
           do iw=1,NCWO-1                                                
            in = na+ncwo*(ndoc-i)+iw                                     
            GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                     &
                     * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )       
           enddo                                                         
           in = na+ncwo*(ndoc-i)+ncwo                                    
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)                      &
                    * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! LBFGSOCUPr
      SUBROUTINE LBFGSOCUPr(NV,GAMMA,USER,ENERGY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      LOGICAL::DIAGCO
      INTEGER,PARAMETER::MSAVE=7
      INTEGER::IFLAG,ICALL,N,M,MP,LP,NWORK
      INTEGER,DIMENSION(2)::IPRINT
      DOUBLE PRECISION :: F,EPS,XTOL,GTOL,STPMIN,STPMAX
      DOUBLE PRECISION :: X(NV),G(NV),DIAG(NV)
      DOUBLE PRECISION,DIMENSION(NV) :: GAMMA
      DOUBLE PRECISION,DIMENSION(NUSER) :: USER
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::W
!     The driver for LBFGS must always declare LB2 as EXTERNAL
      EXTERNAL LB2
!-----------------------------------------------------------------------
      NWORK=NV*(2*MSAVE +1)+2*MSAVE
      ALLOCATE(W(NWORK))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calling to LBFGS SUBROUTINE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     CHECK COMMON /LB3, MP SETS UNIT WHERE PRINTING OPTIMIZATION INFO, 
!     AND LP WHERE PRINTING INFO ABOUT ERRORS
      N=NV ! NUMBER OF VARIABLES
      M=5     ! 0 <= M <= 7
      IPRINT(1)= -1
!     IPRINT(1) < 0 : no output is generated,
!     IPRINT(1) = 0 : output only at first and last iteration,
!     IPRINT(1) > 0 : output every IPRINT(1) iterations.      
      IPRINT(2)= 0
!     IPRINT(2) = 0 : iteration count, number of function 
!                     evaluations, function value, norm of the
!                     gradient, and steplength,
!     IPRINT(2) = 1 : same as IPRINT(2)=0, plus vector of
!                     variables and  gradient vector at the
!                     initial point,
!     IPRINT(2) = 2 : same as IPRINT(2)=1, plus vector of
!                     variables,
!     IPRINT(2) = 3 : same as IPRINT(2)=2, plus gradient vector.      
!
!     We do not wish to provide the diagonal matrices Hk0, and 
!     therefore set DIAGCO to FALSE.
      DIAGCO= .FALSE.
      EPS= 1.0D-5
      XTOL= 1.0D-16
      ICALL=0
      IFLAG=0
      X = GAMMA ! INITIAL ESTIMATE OF THE SOLUTION VECTOR
      MODE = 2
      DO
       if(NSOC==0)then
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!       Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        CALL OCUPENERGYrc(MODE,X,USER(N1),USER(N2),USER(N3),            &
                          USER(N4),USER(N5),USER(N6),USER(N7),          &
                          USER(N8),USER(N9),USER(N10),USER(N11),        &
                          USER(N12),USER(N13),USER(N14),USER(N15),      &
                          USER(N16),USER(N17),ENERGY,G,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --     
       else
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!       High-Spin Multiplet State (S>0,Ms=S)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        CALL OCUPENERGYro(MODE,X,USER(N1),USER(N2),USER(N3),            &
                          USER(N4),USER(N5),USER(N6),USER(N7),          &
                          USER(N8),USER(N9),USER(N10),USER(N11),        &
                          USER(N12),USER(N13),USER(N14),USER(N15),      &
                          USER(N16),USER(N17),ENERGY,G,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       end if
!      F CONTAINS THE VALUE OF THE FUNCTION AT THE POINT X
!      G CONTAINS THE COMPONENTS OF GRADIENT AT X
       F = ENERGY
       CALL LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
       GAMMA = X
       IF(IFLAG.LE.0) EXIT
       ICALL=ICALL + 1
!      We allow at most 1000 evaluations of F and G
       IF(ICALL.GT.1000) EXIT
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --       
      ENDDO
      DEALLOCATE(W)
!     FINAL CALL TO COMPUTE ENERGY AT EQUILIBRIUM POINT
      MODE = 1
      if(NSOC==0)then
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYrc(MODE,X,USER(N1),USER(N2),USER(N3),             &
                         USER(N4),USER(N5),USER(N6),USER(N7),           &
                         USER(N8),USER(N9),USER(N10),USER(N11),         &
                         USER(N12),USER(N13),USER(N14),USER(N15),       &
                         USER(N16),USER(N17),ENERGY,G,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --     
      else
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      High-Spin Multiplet State (S>0,Ms=S)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYro(MODE,X,USER(N1),USER(N2),USER(N3),             &
                         USER(N4),USER(N5),USER(N6),USER(N7),           &
                         USER(N8),USER(N9),USER(N10),USER(N11),         &
                         USER(N12),USER(N13),USER(N14),USER(N15),       &
                         USER(N16),USER(N17),ENERGY,G,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      end if
!-----------------------------------------------------------------------
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!          Subroutines related to occupation optimization of           !
!          spin-compensated systems using different PNOFs              !
!                                                                      !
!  CJCKD3: Define the coefficientes in front J,K,L integrals for PNOF3 !
!          ( J. Chem. Phys. 132, 031103, 2010 )                        !
!  CJCKD4: Define the coefficientes in front J,K,L integrals for PNOF4 !
!          ( J. Chem. Phys. 133, 111101, 2010 )                        !
!  CJCKD5: Define the coefficientes in front J,K,L integrals for PNOF5 !
!          ( J. Chem. Phys. 134, 164102, 2011; 139, 234109, 2013 )     !
!  CJCKD6: Define the coefficientes in front J,K,L integrals for PNOF6 !
!          ( J. Chem. Phys. 141, 044107, 2014 )                        !
!  AACOMP: Add parallel spin components in PNOFi (i=4,5,6) if Daa=Dab  !
!  CJCKD7: Define the coefficientes in front J,K,L integrals for PNOF7 !
!          ( PRL 119, 063002, 2017; PRA 100, 032508, 2019 )            !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! CJCKD3 = PNOF3 + pairing conditions
      SUBROUTINE CJCKD3(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/SUMSZ/SUMS,SUMF
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::DSUMS(:)
!-----------------------------------------------------------------------
!                  CJ12, CK12, DCJ12r and DCK12r
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     CJpq = 2NpNq, CKpq = SQRT(NpNq)  (Note: in PNOF3 Daa = 0.0)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = 2.0d0*RO(j)*RO(i)
        CK12(j,i) = BETA(j)*BETA(i)
        do k=1,nv        
         DCJ12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         DCK12r(j,i,k) = DB(j,k)*BETA(i)
        enddo
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Derivatives of SUMS, FSUMS = (1-S)/S, and its derivatives
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SUMS<=1.0d0)THEN
       ALLOCATE(DSUMS(NV))
       do k=1,nv
        DSUMS(k) = 0.0d0
        DO j=1,NB
         DSUMS(k) = DSUMS(k) - DR(j,k)
        ENDDO
       enddo
       if(SUMS>1.0d-20)then
        FSUMS = 1.0d0/SUMS - 1.0d0
        do k=1,nv
        DSUMS(k) = DSUMS(k)/(SUMS*SUMS)           ! DSUMS is changed
       enddo
       else
        FSUMS = 0.0d0
        DSUMS = 0.0d0
       endif
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Including interactions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SUMS<=1.0d0)THEN
       DO j=1,NB
        Hj = 1.0d0-RO(j)
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         CJ12(j,i) = CJ12(j,i) - Hj*Hi
         do k=1,nv
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DR(j,k)*Hi
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = CJ12(j,i) - FSUMS*Hj*RO(i)
         CK12(j,i) = CK12(j,i) + DSQRT(Hj*RO(i))
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DSUMS(k)*Hj*RO(i)             &
                        + FSUMS*DR(j,k)*RO(i)                            
          if(Hj>0.0d0)DCK12r(j,i,k) = DCK12r(j,i,k)                     &
                      - 0.5d0*DSQRT(Hj*RO(i))*DR(j,k)/Hj                 
         enddo                                                           
        ENDDO                                                            
       ENDDO                                                             
       DO j=NB+1,NBF5                                                    
        DO i=1,NB                                                        
         Hi = 1.0d0-RO(i)                                                
         CJ12(j,i) = CJ12(j,i) - FSUMS*RO(j)*Hi                          
         CK12(j,i) = CK12(j,i) + DSQRT(RO(j)*Hi)                         
         do k=1,nv                                                       
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - FSUMS*DR(j,k)*Hi               
          if(RO(j)>0.0d0)DCK12r(j,i,k) = DCK12r(j,i,k)                  &
                         + 0.5d0*DSQRT(RO(j)*Hi)*DR(j,k)/RO(j)
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = CJ12(j,i) - RO(j)*RO(i)
         CK12(j,i) = - CK12(j,i)
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DR(j,k)*RO(i)
          DCK12r(j,i,k) = - DCK12r(j,i,k)
         enddo
        ENDDO
       ENDDO
      ELSE
       WRITE(6,*)'STOP PNOF3: SUMS > 1'
       STOP
      ENDIF
!-----------------------------------------------------------------------
      IF(SUMS<=1.0d0)DEALLOCATE(DSUMS)
      RETURN
      END

! CJCKD4 = PNOF4 + pairing conditions + SUMS>1 implementation as PNOF6
      SUBROUTINE CJCKD4(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/SUMSZ/SUMS,SUMF
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::DSUMS(:),G(:),FI(:),DG(:,:),DF(:,:),DSUMF(:),DSUMG(:)
!-----------------------------------------------------------------------
!          Alpha-Beta Components of CJ12, CK12, DCJ12 and DCK12
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!                         CJpq = NpNq, CKpq = 0
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      CK12 = 0.0d0
      DCK12r = 0.0d0
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = RO(j)*RO(i)
        do k=1,nv        
         DCJ12r(j,i,k) = DR(j,k)*RO(i)
        enddo
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Derivatives of SUMS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DSUMS(NV))
      do k=1,nv
       DSUMS(k) = 0.0d0
       DO j=1,NB
        DSUMS(k) = DSUMS(k) - DR(j,k)
       ENDDO
      enddo
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
!                 Including interactions in CJ and CK
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      IF(SUMS<=1.0d0)THEN                                  ! SUMS <= 1
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      FSUMS = (1-S)/S, and its derivatives
!- - - - - - - - - - - - - - - - - - - - - - 
       if(SUMS>1.0d-20)then
        FSUMS = 1.0d0/SUMS - 1.0d0
        do k=1,nv
!        DSUMS is changed
         DSUMS(k) = DSUMS(k)/(SUMS*SUMS)
        enddo
       else
        FSUMS = 0.0d0
        DSUMS = 0.0d0
       endif
!- - - - - - - - - - - - - - - - - - - - - - 
       DO j=1,NB
        Hj = 1.0d0-RO(j)
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         CJ12(j,i) = CJ12(j,i) - Hj*Hi
         CK12(j,i) = DSQRT(Hj*Hi)
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DR(j,k)*Hi
          if(DABS(Hj)>0.0d0)DCK12r(j,i,k)=-0.5d0*CK12(j,i)*DR(j,k)/Hj
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = CJ12(j,i) - FSUMS*Hj*RO(i)
         CK12ji = Hj*RO(i)/SUMS
         CK12(j,i) = DSQRT( CK12ji*(RO(j)-RO(i)) + CK12ji*CK12ji )
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DSUMS(k)*Hj*RO(i)             &
                        + FSUMS*DR(j,k)*RO(i)                            
          DCK12jik = - DR(j,k)*RO(i)/SUMS - DSUMS(k)*Hj*RO(i)            
          if(DABS(CK12(j,i))>0.0d0)                                     &
           DCK12r(j,i,k) = ( DCK12jik*(RO(j)-RO(i)) + CK12ji*DR(j,k)    &
                         + 2.0d0*CK12ji*DCK12jik ) / (2.0d0*CK12(j,i))   
         enddo                                                           
        ENDDO                                                            
       ENDDO                                                             
       DEALLOCATE(DSUMS)                                                 
       DO j=NB+1,NBF5                                                    
        DO i=1,NB                                                        
         Hi = 1.0d0-RO(i)                                                
         CJ12(j,i) = CJ12(j,i) - FSUMS*RO(j)*Hi                          
         CK12ji = RO(j)*Hi/SUMS                                          
         CK12(j,i) = DSQRT( CK12ji*(RO(i)-RO(j)) + CK12ji*CK12ji )       
         do k=1,nv                                                       
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - FSUMS*DR(j,k)*Hi               
          DCK12jik = DR(j,k)*Hi/SUMS                                     
          if(DABS(CK12(j,i))>0.0d0)                                     &
           DCK12r(j,i,k) = ( DCK12jik*(RO(i)-RO(j)) - CK12ji*DR(j,k)    &
                         + 2.0d0*CK12ji*DCK12jik ) / (2.0d0*CK12(j,i))
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = 0.0d0
         CK12(j,i) = - BETA(j)*BETA(i)
         do k=1,nv        
          DCJ12r(j,i,k) = 0.0d0
          DCK12r(j,i,k) = - DB(j,k)*BETA(i)
         enddo
        ENDDO
       ENDDO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ELSE                                                 ! SUMS > 1
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      Gq, FIq = Nq*Hq + Gq*Gq - Gq*S, SUMF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(G(NBF5),DG(NBF5,NV))
       RHc = 0.5d0
       SUMS1 = 1.0d0-SUMS                  ! SUMS1 is negative
       DO j=1,NB
        Hj = 1.0d0 - RO(j)
        G(j) = HEAV(SUMS1)*Hj + (1.0d0-HEAV(SUMS1))*Hj*DEXP(-Hj/RHc)
        do k=1,nv
         DG(j,k) = -HEAV(SUMS1)*DR(j,k) - (1.0d0-HEAV(SUMS1))           &
                 * (1.0d0-Hj/RHc)*DR(j,k)*DEXP(-Hj/RHc)                 &
                 + (DEXP(-Hj/RHc)-1.0d0)*Hj*DHEAV(SUMS1)*DSUMS(k)        
        enddo                                                            
       ENDDO                                                             
       DO j=NB+1,NBF5                                                    
        G(j) = HEAV(SUMS1)*RO(j)                                        &
             + (1.0d0-HEAV(SUMS1))*RO(j)*DEXP(-RO(j)/RHc)                
        do k=1,nv                                                        
         DG(j,k) = HEAV(SUMS1)*DR(j,k) + (1.0d0-HEAV(SUMS1))            &
                 * (1.0d0-RO(j)/RHc)*DR(j,k)*DEXP(-RO(j)/RHc)           &
                 +(DEXP(-RO(j)/RHc)-1.0d0)*RO(j)*DHEAV(SUMS1)*DSUMS(k)
        enddo
       ENDDO
       DEALLOCATE(DSUMS)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       SUMG = 0.0d0
       DO j=NB+1,NBF5
        SUMG = SUMG + G(j) 
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(DSUMG(NV))
       do k=1,nv
        DSUMG(k) = 0.0d0
        DO j=NB+1,NBF5
         DSUMG(k) = DSUMG(k) + DG(j,k)
        ENDDO
       enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(FI(NBF5),DF(NBF5,NV))
       DO j=1,NBF5
        FI(j) = RO(j)*(1.0d0-RO(j)) + G(j)*(G(j)-SUMG)
        do k=1,nv        
         DF(j,k) = (1.0d0-2.0d0*RO(j))*DR(j,k) + DG(j,k)*(G(j)-SUMG)    &
                 + G(j)*(DG(j,k)-DSUMG(k))
        enddo
       ENDDO
       DEALLOCATE(DSUMG)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       SUMF = 0.0d0
       DO j=NB+1,NBF5
        SUMF = SUMF + FI(j) 
       ENDDO
       IF(SUMF==0.0d0)SUMF=1.0d-6      ! to avoid dividing by zero
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(DSUMF(NV))
       do k=1,nv
        DSUMF(k) = 0.0d0
        DO j=NB+1,NBF5
         DSUMF(k) = DSUMF(k) + DF(j,k)
        ENDDO
        DSUMF(k) = DSUMF(k) / (SUMF*SUMF)
       enddo
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
       DO j=1,NB
        Hj = 1.0d0-RO(j)
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         Deltaji = G(j)*G(i)
         CJ12(j,i) = CJ12(j,i) - Deltaji
         F1ji = RO(j)*Hi + Deltaji
         F2ji = Hj*RO(i) + Deltaji
         CK12(j,i) = DSQRT( F1ji*F2ji )
         do k=1,nv
          DDeltajik = DG(j,k)*G(i)
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik
          DF1jik =  DR(j,k)*Hi    + DDeltajik
          DF2jik = -DR(j,k)*RO(i) + DDeltajik
          if(DABS(F1ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji   
          if(DABS(F2ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji   
         enddo                                                           
        ENDDO                                                            
        DO i=NB+1,NBF5                                                   
         Hi = 1.0d0-RO(i)                                                
         Deltaji = FI(j)*FI(i)/SUMF                                      
         CJ12(j,i) = CJ12(j,i) - Deltaji                                 
         F1ji = RO(j)*Hi + Deltaji                                       
         F2ji = Hj*RO(i) + Deltaji                                       
         CK12(j,i) = DSQRT( F1ji*F2ji )                                  
         do k=1,nv                                                       
          DDeltajik = DF(j,k)*FI(i)/SUMF                                 
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik                      
          DF1jik =  DR(j,k)*Hi    + DDeltajik                            
          DF2jik = -DR(j,k)*RO(i) + DDeltajik                            
          if(DABS(F1ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji   
          if(DABS(F2ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji   
         enddo                                                           
        ENDDO                                                            
       ENDDO                                                             
       DO j=NB+1,NBF5                                                    
        Hj = 1.0d0-RO(j)                                                 
        DO i=1,NB                                                        
         Hi = 1.0d0-RO(i)                                                
         Deltaji = FI(j)*FI(i)/SUMF                                      
         CJ12(j,i) = CJ12(j,i) - Deltaji                                 
         F1ji = RO(j)*Hi + Deltaji                                       
         F2ji = Hj*RO(i) + Deltaji                                       
         CK12(j,i) = DSQRT( F1ji*F2ji )                                  
         do k=1,nv                                                       
          DDeltajik = DF(j,k)*FI(i)/SUMF - FI(j)*FI(i)*DSUMF(k)          
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik                      
          DF1jik= DR(j,k)*Hi    + DDeltajik                              
          DF2jik=-DR(j,k)*RO(i) + DDeltajik                              
          if(DABS(F1ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji   
          if(DABS(F2ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
         enddo
        ENDDO
        DO i=NB+1,NBF5
         Hi = 1.0d0-RO(i)
         Deltaji = G(j)*G(i)
         CJ12(j,i) = CJ12(j,i) - Deltaji
         F1ji = RO(j)*Hi + Deltaji
         F2ji = Hj*RO(i) + Deltaji
         CK12(j,i) = - DSQRT( F1ji*F2ji )
         do k=1,nv
          DDeltajik = DG(j,k)*G(i)
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik
          DF1jik =  DR(j,k)*Hi    + DDeltajik
          DF2jik = -DR(j,k)*RO(i) + DDeltajik
          if(DABS(F1ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji   
          if(DABS(F2ji)>0.0d0)                                          &
           DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
         enddo
        ENDDO
       ENDDO
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
       DEALLOCATE(G,DG,FI,DF,DSUMF)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ENDIF
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!                Alpha-Alpha Components (N > 2), Daa = Dab
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(NTWOPAR/=1)CALL AACOMP(NV,CJ12,CK12,DCJ12r,DCK12r)
!-----------------------------------------------------------------------
      RETURN
      END

! CJCKD6 = PNOF6(Nc)
      SUBROUTINE CJCKD6(NV,RO,DR,CJ12,CK12,DCJ12r,DCK12r)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/SUMSZ/SUMS,SUMF
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::DSUMS(:),G(:),FI(:),DG(:,:),DF(:,:),DSUMF(:),DSUMG(:)
!-----------------------------------------------------------------------
!          Alpha-Beta Components of CJ12, CK12, DCJ12r and DCK12r
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!                         CJpq = NpNq, CKpq = 0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CK12 = 0.0d0
      DCK12r = 0.0d0
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = RO(j)*RO(i)
        do k=1,nv        
         DCJ12r(j,i,k) = DR(j,k)*RO(i)
        enddo
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Derivatives of SUMS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DSUMS(NV))
      do k=1,nv
       DSUMS(k) = 0.0d0
       DO j=1,NB
        DSUMS(k) = DSUMS(k) - DR(j,k)
       ENDDO
      enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Gq, DGqk
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(G(NBF5),DG(NBF5,NV))
      DO j=1,NB
       Hj = 1.0d0 - RO(j)
       G(j) = Hj*DEXP(-SUMS)
       do k=1,nv
        DG(j,k) = - ( DR(j,k) + Hj*DSUMS(k) ) * DEXP(-SUMS)
       enddo
      ENDDO
      DO j=NB+1,NBF5
       G(j) = RO(j)*DEXP(-SUMS)
       do k=1,nv        
        DG(j,k) = ( DR(j,k) - RO(j)*DSUMS(k) ) * DEXP(-SUMS)
       enddo
      ENDDO
      DEALLOCATE(DSUMS)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     SUMG, DSUMG
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SUMG = 0.0d0
      DO j=NB+1,NBF5
       SUMG = SUMG + G(j) 
      ENDDO
!- - - - - - - - - - - - - - - - - - - - 
      ALLOCATE(DSUMG(NV))
      do k=1,nv
       DSUMG(k) = 0.0d0
       DO j=NB+1,NBF5
        DSUMG(k) = DSUMG(k) + DG(j,k)
       ENDDO
      enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     FIq = Nq*Hq + Gq*Gq - Gq*S
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(FI(NBF5),DF(NBF5,NV))
      DO j=1,NBF5
       FI(j) = RO(j)*(1.0d0-RO(j)) + G(j)*(G(j)-SUMG)
       do k=1,nv        
        DF(j,k) = (1.0d0-2.0d0*RO(j))*DR(j,k) + DG(j,k)*(G(j)-SUMG)     &
                + G(j)*(DG(j,k)-DSUMG(k))
       enddo
      ENDDO
      DEALLOCATE(DSUMG)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     SUMF, DSUMF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SUMF = 0.0d0
      DO j=NB+1,NBF5
       SUMF = SUMF + FI(j) 
      ENDDO
      IF(SUMF==0.0d0)SUMF=1.0d-6      ! to avoid dividing by zero
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DSUMF(NV))
      do k=1,nv
       DSUMF(k) = 0.0d0
       DO j=NB+1,NBF5
        DSUMF(k) = DSUMF(k) + DF(j,k)
       ENDDO
       DSUMF(k) = DSUMF(k) / (SUMF*SUMF)
      enddo
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
!                 Including interactions in CJ and CK
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      DO j=1,NB
       Hj = 1.0d0-RO(j)
       DO i=1,NB
        Hi = 1.0d0-RO(i)
        CJ12(j,i) = CJ12(j,i) - G(j)*G(i)
        CK12(j,i) = DSQRT(G(j)*G(i))
        do k=1,nv        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DG(j,k)*G(i)
         if(G(j)>0.0d0)DCK12r(j,i,k) = 0.5d0*CK12(j,i)*DG(j,k)/G(j)
        enddo
       ENDDO
       DO i=NB+1,NBF5                    
        Hi = 1.0d0-RO(i)
        Deltaji = FI(j)*FI(i)/SUMF
        CJ12(j,i) = CJ12(j,i) - Deltaji
        F1ji = RO(j)*Hi + Deltaji
        F2ji = Hj*RO(i) + Deltaji
        CK12(j,i) = DSQRT( F1ji*F2ji )
        do k=1,nv        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DF(j,k)*FI(i)/SUMF
         DF1jik =  DR(j,k)*Hi    + DF(j,k)*FI(i)/SUMF
         DF2jik = -DR(j,k)*RO(i) + DF(j,k)*FI(i)/SUMF
         if(DABS(F1ji)>0.0d0)                                           &
          DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji    
         if(DABS(F2ji)>0.0d0)                                           &
          DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji    
        enddo                                                            
       ENDDO                                                             
      ENDDO                                                              
      DO j=NB+1,NBF5                                                     
       Hj = 1.0d0-RO(j)                                                  
       DO i=1,NB                                                         
        Hi = 1.0d0-RO(i)                                                 
        Deltaji = FI(j)*FI(i)/SUMF                                       
        CJ12(j,i) = CJ12(j,i) - Deltaji                                  
        F1ji = RO(j)*Hi + Deltaji                                        
        F2ji = Hj*RO(i) + Deltaji                                        
        CK12(j,i) = DSQRT( F1ji*F2ji )                                   
        do k=1,nv                                                        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DF(j,k)*FI(i)/SUMF             &
                       + FI(j)*FI(i)*DSUMF(k)                            
         DF1jik= DR(j,k)*Hi   +DF(j,k)*FI(i)/SUMF-FI(j)*FI(i)*DSUMF(k)   
         DF2jik=-DR(j,k)*RO(i)+DF(j,k)*FI(i)/SUMF-FI(j)*FI(i)*DSUMF(k)   
         if(DABS(F1ji)>0.0d0)                                           &
          DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji    
         if(DABS(F2ji)>0.0d0)                                           &
          DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
        enddo
       ENDDO
       DO i=NB+1,NBF5
        Hi = 1.0d0-RO(i)
        CJ12(j,i) = CJ12(j,i) - G(j)*G(i)
        CK12(j,i) = - DSQRT(G(j)*G(i))
        do k=1,nv        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DG(j,k)*G(i)
         if(G(j)>0.0d0)DCK12r(j,i,k) = 0.5d0*CK12(j,i)*DG(j,k)/G(j)
        enddo
       ENDDO
      ENDDO
!-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      DEALLOCATE(G,DG,FI,DF,DSUMF)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!             Alpha-Alpha Components (N > 2), Daa = Dab
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(NTWOPAR/=1)CALL AACOMP(NV,CJ12,CK12,DCJ12r,DCK12r)
!-----------------------------------------------------------------------
      RETURN
      END

! AACOMP
      SUBROUTINE AACOMP(NV,CJ12,CK12,DCJ12r,DCK12r)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
!-----------------------------------------------------------------------
      DO j=1,NBF5
       DO i=1,NBF5
        CK12(j,i) = CK12(j,i) +  CJ12(j,i)
        CJ12(j,i) = 2.0d0*CJ12(j,i)
        do k=1,nv
         DCK12r(j,i,k) = DCK12r(j,i,k) + DCJ12r(j,i,k)
         DCJ12r(j,i,k) = 2.0d0*DCJ12r(j,i,k) 
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! CJCKD5 = PNOF5(Nc)
      SUBROUTINE CJCKD5(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Extended (Nc>1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
!-----------------------------------------------------------------------
!                Inter-pair interactions for PNOF5(Nc)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     CJpq = 2NpNq, CKpq = NpNq [ DCJpqk = 2DNpk*Nq, DCKpq = DNpk*Nq ]
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!           NO1 |     NDNS     |              NVIR         = NBF               
!           NO1 | NDOC + NSOC  |     NCWO*NDOC     + NO0   = NBF               
!                      | NSOC  | NBF5 - NDNS - NO1 | NO0   = NBF
!                      NB      NA                NBF5
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = 2.0d0*RO(j)*RO(i)
        CK12(j,i) = RO(j)*RO(i)
        do k=1,nv
         DCJ12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         DCK12r(j,i,k) = DR(j,k)*RO(i)
        enddo
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - -              
      if(MSpin==0.and.NSOC>1)then                     
       DO j=NB+1,NA
        DO i=NB+1,NA
         CK12(j,i) = 2.0d0*RO(j)*RO(i)
         do k=1,nv
          DCK12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         enddo
        ENDDO      
       ENDDO
      end if
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!                Intra-pair interactions for PNOF5(Nc)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      DO l=1,NDOC
       ln = NO1+l
       DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        in = NO1+i
        CJ12(ln,in) = 0.0d0
        CJ12(in,ln) = 0.0d0
        CK12(ln,in) = BETA(ln)*BETA(in)
        CK12(in,ln) = BETA(in)*BETA(ln)
        do k=1,nv
         DCJ12r(ln,in,k) = 0.0d0
         DCJ12r(in,ln,k) = 0.0d0
         DCK12r(ln,in,k) = DB(ln,k)*BETA(in)
         DCK12r(in,ln,k) = DB(in,k)*BETA(ln)
        enddo
        DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         jn = NO1+j
         CJ12(jn,in) = 0.0d0
         CK12(jn,in) = - BETA(jn)*BETA(in)
         do k=1,nv
          DCJ12r(jn,in,k) = 0.0d0
          DCK12r(jn,in,k) = - DB(jn,k)*BETA(in)
         enddo
        ENDDO
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! CJCKD7 = PNOF7n(Nc)(Ista=0) and PNOF7s(Nc)(Ista=1)
      SUBROUTINE CJCKD7(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_STATIC/Ista
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::FIs(:),DFIs(:,:)
!-----------------------------------------------------------------------
!     FIs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(FIs(NBF5),DFIs(NBF5,NV))
      FIs = 0.0d0      
      DFIs = 0.0d0
      if(Ista==0)then
!- - - - - - - - - - - - - - - - - - - - - - - - - - -  
!      FIs = (Np*Hp)^1/2
!- - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        FIs(j) = DSQRT( RO(j)*(1.0d0-RO(j)) )
        if(FIs(j)>1.0d-20)then
         do k=1,nv        
          DFIs(j,k) = (0.5d0-RO(j))*DR(j,k)/FIs(j)
         enddo
        endif
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - -              
      else if(Ista==1)then
!- - - - - - - - - - - - - - - - - - - - - - - - - - -  
!      FIs = (4*Np*Hp)^0.5*(Np*Hp)^0.5 = 2*Np*Hp
!- - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        FIs(j) = 2.0d0*RO(j)*(1.0d0-RO(j))
        do k=1,nv        
         DFIs(j,k) = 2.0d0*(1.0d0-2.0d0*RO(j))*DR(j,k)
        enddo
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - -       
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                  - Interpair Electron Correlation -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!           NO1 |     NDNS     |              NVIR         = NBF               
!           NO1 | NDOC + NSOC  |     NCWO*NDOC     + NO0   = NBF               
!                      | NSOC  | NBF5 - NDNS - NO1 | NO0   = NBF
!                      NB      NA                NBF5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = 2.0d0*RO(j)*RO(i)
        CK12(j,i) = RO(j)*RO(i) + FIs(j)*FIs(i)        
        do k=1,nv
         DCJ12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         DCK12r(j,i,k) = DR(j,k)*RO(i) + DFIs(j,k)*FIs(i)   
        enddo
       ENDDO
      ENDDO
      DEALLOCATE(FIs,DFIs)      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(MSpin==0.and.NSOC>1)then
       DO j=NB+1,NA
        DO i=NB+1,NA
         CK12(j,i) = 2.0d0*RO(j)*RO(i)
         do k=1,nv
          DCK12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         enddo
        ENDDO      
       ENDDO
      end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                  - Intrapair Electron Correlation -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO l=1,NDOC
       ln = NO1+l
       DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        in = NO1+i
        CJ12(ln,in) = 0.0d0
        CJ12(in,ln) = 0.0d0
        CK12(ln,in) = BETA(ln)*BETA(in)
        CK12(in,ln) = BETA(in)*BETA(ln)
        do k=1,nv
         DCJ12r(ln,in,k) = 0.0d0
         DCJ12r(in,ln,k) = 0.0d0
         DCK12r(ln,in,k) = DB(ln,k)*BETA(in)
         DCK12r(in,ln,k) = DB(in,k)*BETA(ln)
        enddo
        DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         jn = NO1+j
         CJ12(jn,in) = 0.0d0
         CK12(jn,in) = - BETA(jn)*BETA(in)
         do k=1,nv
          DCJ12r(jn,in,k) = 0.0d0
          DCK12r(jn,in,k) = - DB(jn,k)*BETA(in)
         enddo
        ENDDO
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                           Output Routines                            !
!                                                                      !
!  OUTINITIALSr: Output of properties with the input, stop if IEINI=1  !
!  GENOUTPUTr: Print Occupations, 1-Energies, Sum Occ                  !
!  PRINTOCr: Initial and Intermediate Outputs                          !
!  WRITEGCFr: Write ONs, NOs, and diag-elements of F on NFILE unix     !
!  FINALOUTPUTr: Final Output of the occupation optimization results   !
!  DIAGELAG: Diagonalization of Lagrange Multiplier Matrix if DIAGLAG  !
!  PRINTV: Print vectors V(N) without heading on NFILE unix            !
!  PRINTVERO: Print vectors V(N) with heading En-Occ on NFILE unix     !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! OUTINITIALSr
      SUBROUTINE OUTINITIALSr(NV,GAMMA,COEF,RO,CJ12,CK12,               &
                              DR,DCJ12r,DCK12r,QD,HCORE,QJ,QK,          &
                              DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,    &
                              QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,    &
                              AQUADxz,AQUADyz,QUADxx,QUADyy,QUADzz,     &
                              QUADxy,QUADxz,QUADyz,OCTUN,AOCTxxx,       &
                              AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,AOCTxyy,  &
                              AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,   &
                              OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,&
                              OCTxzz,OCTyzz,OCTxyz,ATMNAME,ZNUC,LIMLOW, &
                              LIMSUP,OVERLAP,IT,ITTOTAL,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin,SCALING
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/ELPROP/IEMOM
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
!
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA,RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxx,QUADyy,QUADzz,QUADxy
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxz,QUADyz      
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxx,OCTyyy,OCTzzz,OCTxxy
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxz,OCTxyy,OCTyyz,OCTxzz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTyzz,OCTxyz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxy,AOCTxxz,AOCTxyy
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyyz,AOCTxzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::GRAD,EAHF,E
      INTEGER::IPRINTOPT
!
      DOUBLE PRECISION,PARAMETER::DFAC=2.54174D0    ! Debye
      DOUBLE PRECISION,PARAMETER::QFAC=1.345044D0   ! Buckinham
      DOUBLE PRECISION,PARAMETER::OFAC=7.117668D-01 ! X10**34 ESU-CM**3
!-----------------------------------------------------------------------
!     Evaluate the Electronic Energy
!-----------------------------------------------------------------------
      ALLOCATE(GRAD(NV))
!
      MODE = 0
      if(MSpin==0)then
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYrc(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,      &
                         QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,         &
                         DIPx,DIPy,DIPz,EELEC,GRAD,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --    
      else if(MSpin>0)then
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      High-Spin Multiplet State (S>0,Ms=S)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYro(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,      &
                         QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,         &
                         DIPx,DIPy,DIPz,EELEC,GRAD,NV)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      end if
!      
      DEALLOCATE(GRAD)
!-----------------------------------------------------------------------
      IF(ICOEF/=2.and.NV>0)THEN                         ! ICOEF/=2
!-----------------------------------------------------------------------
!      Initial Values
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NZEROS<=NZEROSm)WRITE(6,1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      One-particle Energies
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(EAHF(NBF),E(NBF))
       CALL ENENEWr(RO,HCORE,QJ,QK,CJ12,CK12,DIPx,DIPy,DIPz,EAHF,E)
       DEALLOCATE(EAHF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Write Coeficient Matrix (Natural Orbitals)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IWRITEC==1.AND.IPRINTOPT==1)THEN
        WRITE(6,11)
        CALL PRINTVERO(6,COEF,E,RO,NBF,NBF5)                
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Mulliken Population Analysis
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IMULPOP==1.AND.IPRINTOPT==1)THEN
        WRITE(6,12)
        if(MSpin==0)then
         CALL MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,RO,QD)
        else if(MSpin>0)then
!        CALL MULLIKENro        to do!
        end if
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      General Output (Occupations)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IPRINTOPT==1)CALL GENOUTPUTr(RO,E)
       DEALLOCATE(E)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Print Electric Field
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL.AND.IPRINTOPT==1)WRITE(6,13)EX,EY,EZ
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Calculate Electrostatic Moments and print on the main output (6)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IEMOM>=1.AND.IPRINTOPT==1)THEN
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,             &
                     QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)                
        WRITE(6,14)DM*DFAC,DM,DMX,DMY,DMZ                                
       END IF                                                            
       IF(IEMOM>=2.AND.IPRINTOPT==1)THEN                                 
        CALL QUADMOMr(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,    &
                      AQUADyz,QUADxx,QUADyy,QUADzz,QUADxy,QUADxz,QUADyz,&
                      QD,RO,QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,        &
                      QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)                     
        WRITE(6,15)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,                       &
                   QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,                       &
                   QTxx,QTyy,QTzz,QTxy,QTxz,QTyz                         
       ENDIF                                                             
       IF(IEMOM==3.AND.IPRINTOPT==1)THEN                                 
        CALL OCTMOMr(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,     &
                     AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,    &
                     OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,OCTxzz,  &
                     OCTyzz,OCTxyz,QD,RO,OMXXXe,OMYYYe,OMZZZe,OMXXYe,   &
                     OMXXZe,OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,         &
                     OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,                     &
                     OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)                      
        WRITE(6,16)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,OTXXY*OFAC,         &
                   OTXXZ*OFAC,OTXYY*OFAC,OTYYZ*OFAC,OTXZZ*OFAC,         &
                   OTYZZ*OFAC,OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,             &
                   OTXXY,OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Energy Output
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IPRINTOPT==0)STOP
       IF(NZEROS<=NZEROSm)THEN
        WRITE(6,100)
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN
        WRITE(6,103)EELEC-EHF
       ELSE
        WRITE(6,104)
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN
        WRITE(6,103)EELEC-EHF
        WRITE(6,105)IT,ITTOTAL
        WRITE(6,200)
       ENDIF
       STOP
!-----------------------------------------------------------------------
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT(/3X,'INITIAL VALUES'                                       &
           ,/2X,'=================')
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   11 FORMAT(/,                                                         &
       18X,'------------------------------------------',/,              &
       18X,' NATURAL ORBITALS IN ATOMIC ORBITAL BASIS ',/,              &
       18X,'------------------------------------------')                 
   12 FORMAT(                                                           &
         2X,'------------------------------',/,                         &
         2X,' Mulliken Population Analysis ',/,                         &
         2X,'------------------------------')                            
   13 FORMAT(/,6X,'ELECTRIC FIELD (',D8.1,',',D8.1,',',D8.1,')')         
   14 FORMAT(/,2X,'---------------',                                    &
              /2X,' Dipole Moment',                                     &
              /2X,'---------------',                                    &
            //,3X,F9.4,' Debye',' [',F9.4,                              &
               2X,'(',F9.4,',',F9.4,',',F9.4,')',' ]')                   
   15 FORMAT(/,2X,'-------------------',                                &
              /2X,' Quadrupole Moment',                                 &
              /2X,'-------------------',                                &
             //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',   &
             //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')         
   16 FORMAT(/,2X,'-----------------',                                  &
              /2X,' Octupole Moment',                                   &
              /2X,'-----------------',                                  &
             //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',       &
               5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',       &
             //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',                      &
             //1X,'[',10F9.4,1X,']')
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  100 FORMAT(//2X,'INITIAL ENERGY (AU)',                                &
             /1X,'=====================')                                
  101 FORMAT(/,8X,' HF Total Energy =',F14.6)                            
  102 FORMAT(  8X,'NOF Total Energy =',F14.6)                            
  103 FORMAT(  6X,'Correlation Energy =',F14.6,/)                        
  104 FORMAT(//3X,'ENERGY (AU)',                                        &
             /2X,'=============')                                        
  105 FORMAT(/2X,'**************************************************',  &
             /2X,'*         No. EXTERNAL ITER =',I6,'              *',  &
             /2X,'*         No. of TOTAL ITER =',I6,'              *',  &
             /2X,'**************************************************')
!----------------------------------------------------------------------
  200 FORMAT(//2X,'**************************************************', &
              /2X,'*                                                *', &
              /2x,'*       SINGLE-POINT PNOF CALCULATION            *', &
              /2X,'*                                                *', &
              /2X,'*       BE CAREFUL NZEROS > NZEROSm!             *', &
              /2X,'*                                                *', &
              /2x,'*  FINAL RESULTS   FINAL RESULTS  FINAL RESULTS  *', &
              /2X,'*                                                *', &
              /2X,'**************************************************', &
              /)
!----------------------------------------------------------------------
      END

! GENOUTPUTr
      SUBROUTINE GENOUTPUTr(RO,E)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,E
!-----------------------------------------------------------------------
!     Print the Occupations
!     SUMRO: Sum of the Occupations
!-----------------------------------------------------------------------
      WRITE(6,1)
      SUMRO = 0.0d0
      
      DO J=1,NB
       WRITE(6,2)J,2.0*RO(J),E(J)
       SUMRO = SUMRO + 2.0d0*RO(J)       
      ENDDO
      
      IF(NSOC>0)THEN      
       if(.not.HighSpin)then      
        DO J=NB+1,NA
         WRITE(6,2)J,2.0*RO(J),E(J)
         SUMRO = SUMRO + 2.0d0*RO(J)         
        ENDDO
       else if(HighSpin)then      
        DO J=NB+1,NA
         WRITE(6,2)J,RO(J),E(J)
         SUMRO = SUMRO + RO(J)         
        ENDDO
       end if
      END IF 
      
      DO J=NA+1,NBF5
       WRITE(6,2)J,2.0*RO(J),E(J)
       SUMRO = SUMRO + 2.0d0*RO(J)       
      ENDDO
      
      WRITE(6,3)NE,SUMRO
!-----------------------------------------------------------------------
    1 FORMAT(/,3X,'OM',5X,'Occupation',6X,'Elag Diag',/)
    2 FORMAT(2X,I3,2F15.7)
    3 FORMAT(/3X,'RO Sum (',I3,') =',F8.2)
!-----------------------------------------------------------------------     
      RETURN
      END

! PRINTOCr
      SUBROUTINE PRINTOCr(E,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,            &
                          OVERLAP,RO,CJ12,CK12,QD,QK,                   &
                          DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,        &
                          QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,        &
                          AQUADxz,AQUADyz,QUADxx,QUADyy,QUADzz,         &
                          QUADxy,QUADxz,QUADyz,OCTUN,                   &
                          AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,      &
                          AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,      &
                          OCTxxx,OCTyyy,OCTzzz,OCTxxy,OCTxxz,           &
                          OCTxyy,OCTyyz,OCTxzz,OCTyzz,OCTxyz,           &
                          IZCORE,CX0,CY0,CZ0,KSTART,KNG,                &
                          KKMIN,KKMAX,KATOM,KTYPE,KLOC,IMIN,IMAX,       &
                          ISH,ITYP,EX1,C1,C2,CS,CP,CD,CF,CG,CH,CI,      &
                          IFIRSTCALL,DIPS,IRUNTYP)                          
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      LOGICAL EFIELDL,RESTART,APSG,OIMP2,HighSpin
      LOGICAL MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_APSG/APSG,NTHAPSG,THAPSG
      COMMON/INPNOF_OIMP2/OIMP2
      COMMON/INPNOF_MBPT/MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/INPNOF_ARDM/THRESHDM,NOUTRDM,NSQT,NTHRESHDM      
      COMMON/INPNOF_CJK/NOUTCJK,NTHRESHCJK,THRESHCJK
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/CorrNonDynamic/ECnd,ECndl,ECndHF
      COMMON/ELPROP/IEMOM      
!
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP,IZCORE,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NPRIMI)::ISH,ITYP
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,C1,C2,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxx,QUADyy,QUADzz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxy,QUADxz,QUADyz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxx,OCTyyy,OCTzzz,OCTxxy
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxz,OCTxyy,OCTyyz,OCTxzz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTyzz,OCTxyz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QK
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12      
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxy,AOCTxxz,AOCTxyy
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyyz,AOCTxzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,DIMENSION(3):: DIPS
!
      DOUBLE PRECISION,PARAMETER::DFAC=2.54174D0    ! Debye
      DOUBLE PRECISION,PARAMETER::QFAC=1.345044D0   ! Buckinham
      DOUBLE PRECISION,PARAMETER::OFAC=7.117668D-01 ! X10**34 ESU-CM**3
!-----------------------------------------------------------------------
      KLOC(1) = KLOC(1)
      IFIRSTCALL = IFIRSTCALL
!-----------------------------------------------------------------------
!     Skip Printing if NPRINT/=2
!-----------------------------------------------------------------------
      IF(ICOEF==0.or.NPRINT==2)THEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Write Header on output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(ICOEF/=2)WRITE(6,1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      General Output (Occupations and N-representability conditions)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL GENOUTPUTr(RO,E)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Electric Field and Electrostatic Moments
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL)WRITE(6,7)EX,EY,EZ
       IF(IEMOM>=1)THEN
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,             &
                     QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)                
        DIPS(1) = DMX                                                    
        DIPS(2) = DMY                                                    
        DIPS(3) = DMZ                                                    
        WRITE(6,8)DM*DFAC,DM,DMX,DMY,DMZ                                 
       END IF                                                            
       IF(IEMOM>=2)THEN                                                  
        CALL QUADMOMr(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,    &
                      AQUADyz,QUADxx,QUADyy,QUADzz,QUADxy,QUADxz,QUADyz,&
                      QD,RO,QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,        &
                      QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)                     
        WRITE(6,9)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,                        &
                  QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,                        &
                  QTxx,QTyy,QTzz,QTxy,QTxz,QTyz                          
       ENDIF                                                             
       IF(IEMOM==3)THEN                                                  
        CALL OCTMOMr(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,     &
                     AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,    &
                     OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,OCTxzz,  &
                     OCTyzz,OCTxyz,QD,RO,OMXXXe,OMYYYe,OMZZZe,OMXXYe,   &
                     OMXXZe,OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,         &
                     OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,                     &
                     OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)                      
        WRITE(6,10)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,OTXXY*OFAC,         &
                   OTXXZ*OFAC,OTXYY*OFAC,OTYYZ*OFAC,OTXZZ*OFAC,         &
                   OTYZZ*OFAC,OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,             &
                   OTXXY,OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
       ENDIF       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Coeficient matrix and one-particle occupations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IWRITEC==1)THEN
        IF(ICOEF==0)THEN
         WRITE(6,3)
        ELSE
         WRITE(6,4)
        ENDIF
        CALL PRINTVERO(6,COEF,E,RO,NBF,NBF5)        
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Mulliken Population Analysis
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IMULPOP==1.and.MSpin==0)THEN
        WRITE(6,5)
        CALL MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,RO,QD)
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Energy Output
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       WRITE(6,100)
       IF(INPUTC==0.and.EHF<0.0)THEN
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN
        WRITE(6,103)EELEC-EHF
       ELSE
        WRITE(6,102)EELEC+EN
       ENDIF
!-----------------------------------------------------------------------
      END IF
!
      IF(ICOEF==0)THEN
!-----------------------------------------------------------------------
!      Bader's analysis: Write information into wavefunction file (WFN) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IAIMPAC==1.and.MSpin==0)THEN
        CALL AIMMEMrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,    &
                      KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Write information into formatted checkpoint file (FCHK) [Unit=19]
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IFCHK==1.and.MSpin==0)THEN
        CALL FCHKrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KNG,KATOM,KTYPE,       &
                    RO,E,EX1,C1,C2,IMIN,IMAX,ISH,DIPS,IRUNTYP)
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Write information into a file in Molden Format (MLD) [Unit=17]
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(MOLDEN==1.and.MSpin==0)THEN
        CALL MOLDENrc(ATMNAME,IZCORE,ZNUC,CX0,CY0,CZ0,IMIN,IMAX,        &
                      ISH,ITYP,EX1,C1,C2,RO,E,COEF)        
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      APSG File for the APSG generating wavefunction of PNOF5(Nc)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(APSG.and.NSOC==0.and.IPNOF==5)THEN
        REWIND(9)
!       Coefficient matrix
        WRITE(9,'(A5)')' $VEC'
        CALL PUNCHVEC(COEF,NBF)
        WRITE(9,'(A5)')' $END'
!       APSG Expansion Coefficients of the Generating PNOF5-wavefunction
        WRITE(9,'(A6)')' $APSG'
        CALL PUNCHAPSG(NO1,NCWO,NA,NBF5,RO,SUMA,THAPSG)
        WRITE(9,'(A5)')' $END'
        WRITE(9,'(1X,A16,F15.10)')'EXP. COEF. SUM =',SUMA
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      PRINT CJ12 and CK12 (MOLECULAR RDMs) IN CJK FILE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTCJK==1.and.MSpin==0)CALL OUTPUTCJKrc(RO,CJ12,CK12)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      PRINT ATOMIC RDMs IN .1dm and .2dm FILES
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTRDM==1.and.MSpin==0)THEN
        CALL OUTPUTRDMrc(OVERLAP,RO,QD,CJ12,CK12)
       ENDIF
!-----------------------------------------------------------------------       
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Non-Dynamic Correction if OIMP2 or MBPT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(OIMP2.or.MBPT)CALL ECorrNonDyn(RO,QK,ECndl)
!----------------------------------------------------------------------
    1 FORMAT(//2X,'RESULTS OF THE OCCUPATION OPTIMIZATION'              &
            ,/1X,'========================================')             
!   2 FORMAT(/,3X,'Chem Pot =',F12.6,4X,F15.6)                           
    3 FORMAT(/,                                                         &
       18X,'------------------------------------------',/,              &
       18X,' NATURAL ORBITALS IN ATOMIC ORBITAL BASIS ',/,              &
       18X,'------------------------------------------')                 
    4 FORMAT(/,                                                         &
       2X,'--------------------',/,                                     &
       2X,' COEFFICIENT MATRIX',/,                                      &
       2X,'--------------------')                                        
    5 FORMAT(                                                           &
       /,2X,'------------------------------',/,                         &
         2X,' Mulliken Population Analysis ',/,                         &
         2X,'------------------------------')                            
!   6 FORMAT( 2X,'-------------',                                       &
!            /2X,' Occupations',                                        &
!            /2X,'-------------')                                        
    7 FORMAT(/,6X,'Electric Field (',D8.1,',',D8.1,',',D8.1,')')         
    8 FORMAT(/,2X,'---------------',                                    &
              /2X,' Dipole Moment',                                     &
              /2X,'---------------',                                    &
            //,3X,F9.4,' Debye',' [',F9.4,                              &
               2X,'(',F15.10,',',F15.10,',',F15.10,')',' ]')            
    9 FORMAT(/,2X,'-------------------',                                &
              /2X,' Quadrupole Moment',                                 &
              /2X,'-------------------',                                &
             //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',   &
             //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')         
   10 FORMAT(/,2X,'-----------------',                                  &
              /2X,' Octupole Moment',                                   &
              /2X,'-----------------',                                  &
             //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',       &
               5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',       &
             //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',                      &
             //1X,'[',10F9.4,1X,']')
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  100 FORMAT(/,                                                         &
       2X,'----------------------------------------',/,                 &
       2X,' Energies after Occupation Optimization ',/,                 &
       2X,'----------------------------------------')
  101 FORMAT(/,8X,' HF Total Energy =',F14.6)
  102 FORMAT(  8X,'NOF Total Energy =',F14.6)
  103 FORMAT(  6X,'Correlation Energy =',F14.6,/)
!-----------------------------------------------------------------------
      RETURN
      END

! WRITEGCFr
      SUBROUTINE WRITEGCFr(NFILE,RO,SUMS,C,E,F,NSQ,NBF,NBF5,IT,EELEC,EN,&
                        NO1,NDOC,NSOC,NCWO,NAC,NO0,ZNUC,CX0,CY0,CZ0,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION RO(NBF5),C(NSQ),E(NBF),F(NBF)
      DOUBLE PRECISION,DIMENSION(NAT):: ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,PARAMETER::BOHR = 0.52917724924D+00
!-----------------------------------------------------------------------
      REWIND(NFILE)
      DO I=1,NBF5
       WRITE(NFILE,'(I6,F30.16)')I,RO(I)
      ENDDO
      DO I=NBF5+1,NBF
       WRITE(NFILE,'(I6,F30.16)')I,0.0d0
      ENDDO
      WRITE(NFILE,'(F30.16)')SUMS
      DO J = 1,NBF
       DO I = 1,NBF
        WRITE(NFILE,'(I6,F30.16)')I,C(I+(J-1)*NBF)
       ENDDO
      ENDDO
      DO I = 1,NBF
       WRITE(NFILE,'(I6,F30.16)')I,E(I)
      ENDDO
      DO I = 1,NBF
       WRITE(NFILE,'(I6,F30.16)')I,F(I)
      ENDDO
      WRITE(NFILE,'(I6,F30.16)')IT,EELEC+EN
      WRITE(NFILE,'(6I6)')NO1,NDOC,NSOC,NCWO,NAC,NO0
      DO I = 1,NAT
       WRITE(NFILE,'(I6,F30.16,F30.16,F30.16)')                         &
                       INT(ZNUC(I)),BOHR*CX0(I),BOHR*CY0(I),BOHR*CZ0(I)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! FINALOUTPUTr
      SUBROUTINE FINALOUTPUTr(E,RO,CJ12,CK12,QD,HCORE,QJ,QK,            &
                              ELAG,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,     &
                              OVERLAP,DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy, &
                              DIPz,QUADN,AQUADxx,AQUADyy,AQUADzz,       &
                              AQUADxy,AQUADxz,AQUADyz,QUADxx,QUADyy,    &
                              QUADzz,QUADxy,QUADxz,QUADyz,OCTUN,        &
                              AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,  &
                              AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,  &
                              OCTxxx,OCTyyy,OCTzzz,OCTxxy,OCTxxz,       &
                              OCTxyy,OCTyyz,OCTxzz,OCTyzz,OCTxyz,       &
                              IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,      &
                              KKMAX,KATOM,KTYPE,KLOC,IMIN,IMAX,ISH,ITYP,&
                              EX1,C1,C2,CS,CP,CD,CF,CG,CH,CI,ELAGN,     &
                              COEFN,RON,AHCORE,IJKL,XIJKL,IFIRSTCALL,   &
                              DIPS,IPRINTOPT,IRUNTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,CONVGDELAG,PRINTLAG,DIAGLAG,APSG,CHKORTHO,ORTHO
      LOGICAL OIMP2,HighSpin
      LOGICAL MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/CONVERGENCE/DUMEL,PCONV,CONVGDELAG
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_LAGRANGE/PRINTLAG,DIAGLAG
      COMMON/INPNOF_APSG/APSG,NTHAPSG,THAPSG 
      COMMON/INPNOF_ORTHOGONALITY/CHKORTHO,ORTHO
      COMMON/INPNOF_OIMP2/OIMP2
      COMMON/INPNOF_MBPT/MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/INPNOF_EKT/IEKT
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/INPNOF_ARDM/THRESHDM,NOUTRDM,NSQT,NTHRESHDM      
      COMMON/INPNOF_CJK/NOUTCJK,NTHRESHCJK,THRESHCJK
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/ELPROP/IEMOM      
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/CorrNonDynamic/ECnd,ECndl,ECndHF
!
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP,IZCORE,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NPRIMI)::ISH,ITYP
      INTEGER,DIMENSION(NIJKL)::IJKL
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,C1,C2,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBF5)::HCORE,RO,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxx,QUADyy,QUADzz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxy,QUADxz,QUADyz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxx,OCTyyy,OCTzzz,OCTxxy
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxz,OCTxyy,OCTyyz,OCTxzz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTyzz,OCTxyz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF)::E,ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxy,AOCTxxz,AOCTxyy
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyyz,AOCTxzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEFN,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,DIMENSION(NIJKL)::XIJKL
      DOUBLE PRECISION,DIMENSION(3):: DIPS
      INTEGER::IPRINTOPT
!      
      DOUBLE PRECISION,PARAMETER::DFAC=2.54174D0    ! Debye
      DOUBLE PRECISION,PARAMETER::QFAC=1.345044D0   ! Buckinham
      DOUBLE PRECISION,PARAMETER::OFAC=7.117668D-01 ! X10**34 ESU-CM**3
!-----------------------------------------------------------------------
      KLOC(1) = KLOC(1)
      IFIRSTCALL = IFIRSTCALL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check the orthonormality
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(CHKORTHO)CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
!-----------------------------------------------------------------------
      IF(IPRINTOPT==1)THEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Write Header on output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(ICOEF/=2)WRITE(6,1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      General Output
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL GENOUTPUTr(RO,E)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Electric Field and Electrostatic Moments
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL)WRITE(6,7)EX,EY,EZ
       IF(IEMOM>=1)THEN
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,             &
                     QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)                
        DIPS(1) = DMX                                                    
        DIPS(2) = DMY                                                    
        DIPS(3) = DMZ                                                    
        WRITE(6,8)DM*DFAC,DM,DMX,DMY,DMZ                                 
       END IF                                                            
       IF(IEMOM>=2)THEN                                                  
        CALL QUADMOMr(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,    &
                      AQUADyz,QUADxx,QUADyy,QUADzz,QUADxy,QUADxz,QUADyz,&
                      QD,RO,QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,        &
                      QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)                     
        WRITE(6,9)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,                        &
                  QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,                        &
                  QTxx,QTyy,QTzz,QTxy,QTxz,QTyz                          
       END IF                                                            
       IF(IEMOM==3)THEN                                                  
        CALL OCTMOMr(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,     &
                     AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,    &
                     OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,OCTxzz,  &
                     OCTyzz,OCTxyz,QD,RO,OMXXXe,OMYYYe,OMZZZe,OMXXYe,   &
                     OMXXZe,OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,         &
                     OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,                     &
                     OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)                      
        WRITE(6,10)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,OTXXY*OFAC,         &
                   OTXXZ*OFAC,OTXYY*OFAC,OTYYZ*OFAC,OTXZZ*OFAC,         &
                   OTYZZ*OFAC,OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,             &
                   OTXXY,OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
       END IF
!-----------------------------------------------------------------------
!      Skip Printing if NPRINT=0, otherwise print EKT,ELAG,COEF,MulPop
!-----------------------------------------------------------------------
       IF(NPRINT>0)THEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Coefficient matrix (NOs) and one-particle occupations
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(IWRITEC==1)THEN
         WRITE(6,4)
         CALL PRINTVERO(6,COEF,E,RO,NBF,NBF5)        
        ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Extended Koopmans Theorem (EKT)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(IEKT==1.and.MSpin==0)THEN       
         CALL EXTKOOPMANSrc(ELAG,COEF,OVERLAP,AHCORE,IJKL,XIJKL,RO)
        END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Print Lagrange Multipliers (ELAG Matrix) on main output (6)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(PRINTLAG)THEN
         WRITE(6,3)
         CALL PRINTV(6,ELAG,NBF)
        ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Diagonalization of Lagrange Multipliers (ELAG)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(DIAGLAG)CALL DIAGELAG(ELAG,COEF,RO,ELAGN,COEFN,RON)       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Mulliken Population Analysis 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(IMULPOP==1.and.MSpin==0)THEN
         WRITE(6,5)
         CALL MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,RO,QD)
        ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       Calculate the chemical potential (CHEMP) for PNOF5,7(Nc)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ICHEMPOT=0
        IF(ICHEMPOT==1.and.MSpin==0.and.(IPNOF==5.or.IPNOF==7))         &
         CALL CHEMPOTrc(HCORE,QJ,QK,RO,DIPx,DIPy,DIPz)       
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Energy Output
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       WRITE(6,100)
       IF(EHF<0.0)THEN
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN,DUMEL,ABS(EELEC_OLD-EELEC)
        WRITE(6,103)EELEC-EHF
       ELSE
        WRITE(6,102)EELEC+EN,DUMEL,ABS(EELEC_OLD-EELEC)
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Bader's analysis:Write information into a wavefunction file (WFN) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IAIMPAC==1.and.MSpin==0)THEN
        CALL AIMMEMrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,    &
                      KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Write information into formatted checkpoint file (FCHK) [Unit=19]
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IFCHK==1.and.MSpin==0)THEN
        CALL FCHKrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KNG,KATOM,KTYPE,       &
                    RO,E,EX1,C1,C2,IMIN,IMAX,ISH,DIPS,IRUNTYP)
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Write information into a file in Molden Format (MLD) [Unit=17]
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(MOLDEN==1.and.MSpin==0)THEN
        if(NPRINT>0.and.DIAGLAG)then   ! Canonical Orbitals
         RON = RON/2.0d0
         CALL MOLDENrc(ATMNAME,IZCORE,ZNUC,CX0,CY0,CZ0,IMIN,IMAX,       &
                       ISH,ITYP,EX1,C1,C2,RON,ELAGN,COEFN)               
        else                           ! Natural Orbitals                
         CALL MOLDENrc(ATMNAME,IZCORE,ZNUC,CX0,CY0,CZ0,IMIN,IMAX,       &
                       ISH,ITYP,EX1,C1,C2,RO,E,COEF)        
        endif
       END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      APSG File for the APSG generating wavefunction of PNOF5(Nc)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(APSG .and. NSOC==0 .and. IPNOF==5)THEN
        REWIND(9)
!       Coefficient matrix
        WRITE(9,'(A5)')' $VEC'
        CALL PUNCHVEC(COEF,NBF)
        WRITE(9,'(A5)')' $END'
!       APSG Expansion Coefficients of the Generating PNOF5-wavefunction
        WRITE(9,'(A6)')' $APSG'
        CALL PUNCHAPSG(NO1,NCWO,NA,NBF5,RO,SUMA,THAPSG)
        WRITE(9,'(A5)')' $END'
        WRITE(9,'(1X,A16,F15.10)')'EXP. COEF. SUM =',SUMA
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      PRINT CJ12 and CK12 (MOLECULAR RDMs) IN CJK FILE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTCJK==1.and.MSpin==0)THEN
        CALL OUTPUTCJKrc(RO,CJ12,CK12)
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      PRINT ATOMIC RDMs IN .1dm and .2dm FILES
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTRDM==1.and.MSpin==0)THEN
        CALL OUTPUTRDMrc(OVERLAP,RO,QD,CJ12,CK12)
       ENDIF
!-----------------------------------------------------------------------       
      END IF 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Non-Dynamic Correction if OIMP2 or MBPT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(OIMP2.or.MBPT)CALL ECorrNonDyn(RO,QK,ECndl)
!-----------------------------------------------------------------------
    1 FORMAT(//2X,'RESULTS OF THE OCCUPATION OPTIMIZATION'              &
            ,/1X,'========================================')
!   2 FORMAT(/,3X,'Chem Pot =',F12.6,4X,F15.6)
    3 FORMAT(/,                                                         &
       18X,'--------------------------------',/,                        &
       18X,' MATRIX OF LAGRANGE MULTIPLIERS ',/,                        &
       18X,'--------------------------------')                           
    4 FORMAT(/,                                                         &
       18X,'------------------------------------------',/,              &
       18X,' NATURAL ORBITALS IN ATOMIC ORBITAL BASIS ',/,              &
       18X,'------------------------------------------')                 
    5 FORMAT(/,                                                         &
       /,2X,'------------------------------',/,                         &
         2X,' Mulliken Population Analysis ',/,                         &
         2X,'------------------------------')
!   6 FORMAT(/2X,' Occupations ',                                       &
!             /2X,'-------------')
    7 FORMAT(/,6X,'Electric Field (',D8.1,',',D8.1,',',D8.1,')')
    8 FORMAT(/,2X,'---------------',                                    &
              /2X,' Dipole Moment',                                     &
              /2X,'---------------',                                    &
            //,3X,F9.4,' Debye',' [',F9.4,                              &
               2X,'(',F9.4,',',F9.4,',',F9.4,')',' ]')                   
    9 FORMAT(/,2X,'-------------------',                                &
              /2X,' Quadrupole Moment',                                 &
              /2X,'-------------------',                                &
             //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',   &
             //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')         
   10 FORMAT(/,2X,'-----------------',                                  &
              /2X,' Octupole Moment',                                   &
              /2X,'-----------------',                                  &
             //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',       &
               5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',       &
             //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',                      &
             //1X,'[',10F9.4,1X,']')
!-----------------------------------------------------------------------
  100 FORMAT(/,                                                         &
       1X,'----------------',/,                                         &
       1X,' Final Energies  ',/,                                        &
       1X,'----------------',/)                                          
  101 FORMAT(8X,' HF Total Energy =',F20.10)                             
  102 FORMAT(2X,'Final NOF Total Energy =',                             &
                   F20.10,' (',ES7.0,1X,',',ES7.0,' )')
  103 FORMAT(6X,'Correlation Energy =',F20.10,/)
!-----------------------------------------------------------------------
      RETURN
      END

! DIAGELAG 
      SUBROUTINE DIAGELAG(ELAG,COEF,RO,ELAGN,COEFN,RON)
!=======================================================================
!     DIAGONALIZATION OF LAGRANGE MULTIPLIERS (ELAG)
!=======================================================================
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF)::ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::TEMP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,DENMAT
!-----------------------------------------------------------------------
!     INTERMEDIATE MATRICES
!-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF,NBF),W(NBF,NBF),TEMP(NBF))
!-----------------------------------------------------------------------
!     DIAGONALIZATION OF THE LAGRANGE MULTIPLIERS (ELAG)
!-----------------------------------------------------------------------
!     ELAG -> SQUARE MATRIX (AUX)
!-----------------------------------------------------------------------
      DO I=1,NBF
       DO J=1,I
        AUX(I,J)=ELAG(I,J)
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     DIAGONALIZE SQUARE MATRIX (AUX) FOR REAL SYMMETRIC CASE
!     NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
!     W - EIGENVECTORS, ELAGN - EIGENVALUES 
!-----------------------------------------------------------------------
      CALL DIAG(NBF,AUX,W,ELAGN,TEMP)
!-----------------------------------------------------------------------
!     New Density Matrix (D=Wt*RO*W)
!-----------------------------------------------------------------------
      ALLOCATE(DENMAT(NBF,NBF))
      DO IP=1,NBF
       DO IQ=1,NBF
        DENMAT(IP,IQ)=0.0d0
        do i=1,nbf5
         DENMAT(IP,IQ)=DENMAT(IP,IQ)+W(i,IP)*RO(i)*W(i,IQ)
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     WRITE ONE-PARTICLE ENERGIES and NEW AVERAGE OCCUPATIONS (OUTPUT)
!-----------------------------------------------------------------------
      WRITE(6,1)
      DO I=1,NBF
       RON(I)=2.0d0*DENMAT(I,I)
       IF(RON(I)>1.0d-6)THEN
        WRITE(6,2)I,ELAGN(I),ELAGN(I)*27.21138386,RON(I)
       ENDIF
      ENDDO
      CALL DMATMAX(DENMAT,NBF,MAXI,MAXJ,DUM)
      WRITE(6,3)DUM,MAXI,MAXJ
!-----------------------------------------------------------------------
!     Coefficients of Canonical Orbitals (COEFN=COEF*W)
!-----------------------------------------------------------------------
      COEFN = MATMUL(COEF,W)
      WRITE(6,4)
      CALL PRINTVERO(6,COEFN,ELAGN,RON,NBF,NBF5)
!-----------------------------------------------------------------------
    1 FORMAT(/2X,26('-'),/3X,'Canonical Representation',/2X,26('-'),/,  &
             /20X,'One-Particle Energies',11X,'1RDM Diag',              &
             //19X,'(aU)',14X,'(eV)')                                    
    2 FORMAT(2X,I4,4X,F15.6,4X,F15.6,9X,F8.6)                            
    3 FORMAT(/,15X,'Maximum 1RDM off-diagonal element:',F12.6,          &
               1X,'(',I3,',',I3,')')                                     
    4 FORMAT(/,                                                         &
       18X,'---------------------------------',/,                       &
       18X,' Eigenvectors of Lagrange Matrix ',/,                       &
       18X,'---------------------------------')
!-----------------------------------------------------------------------
      DEALLOCATE (AUX,W,TEMP,DENMAT)
      RETURN
      END

! PRINTV
      SUBROUTINE PRINTV(NFILE,V,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::V
!-----------------------------------------------------------------------
      MAX=0
  10  MIN=MAX+1
      MAX=MAX+5
      IF(MAX>N)MAX=N
      WRITE(NFILE,1)(J,J=MIN,MAX)
      WRITE(NFILE,*)
      DO I=1,N
       WRITE(NFILE,2)I,(V(I,J),J=MIN,MAX)
      ENDDO
      IF(MAX<N) GOTO 10
      WRITE(NFILE,3)
!-----------------------------------------------------------------------
    1 FORMAT(/,7X,5(4X,I4,3X))
    2 FORMAT(I5,2X,5F11.6)
    3 FORMAT(/)
!-----------------------------------------------------------------------
      RETURN
      END

! PRINTVERO
      SUBROUTINE PRINTVERO(NFILE,V,E,RO,N,NL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*2 LABELAT
      CHARACTER*4 BFNAM1
      CHARACTER*6 BFNAM2
      DOUBLE PRECISION,DIMENSION(N)::E,RO
      DOUBLE PRECISION,DIMENSION(N,N)::V
!-----------------------------------------------------------------------
      MAX=0
  10  MIN=MAX+1
      MAX=MAX+5
      IF(MAX>NL) MAX=NL
      WRITE(NFILE,1)(J,J=MIN,MAX)
      WRITE(NFILE,*)      
      WRITE(NFILE,2)(RO(J),J=MIN,MAX)
      WRITE(NFILE,2)(E(J),J=MIN,MAX)      
      REWIND(4)
      READ(4,'(I5)')N0
      DO I=1,N
       IF(I<=35)THEN
        READ(4,3)LABELAT,IAT,BFNAM1
        WRITE(NFILE,4) I,LABELAT,IAT,BFNAM1,(V(I,J),J=MIN,MAX)
       ELSE
        READ(4,5)LABELAT,BFNAM2
        WRITE(NFILE,6) I,LABELAT,BFNAM2,(V(I,J),J=MIN,MAX)
       ENDIF
      ENDDO
      IF(MAX<NL) GOTO 10
      WRITE(NFILE,7)
!-----------------------------------------------------------------------
    1 FORMAT(/,15X,5(4X,I4,3X))
    2 FORMAT(15X,5F11.4)
    3 FORMAT(A2,I2,A4)
    4 FORMAT(I5,2X,A2,I2,A4,5F11.6)
    5 FORMAT(A2,A6)
    6 FORMAT(I5,2X,A2,A6,5F11.6)
    7 FORMAT(/)
!-----------------------------------------------------------------------
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!              P R O P E R T Y       S U B R O U T I N E S             !
!                                                                      !
!   NUCDIST: Internuclear distances                                    !
!                                                                      !
!   MULLIKENrc: Calculate Mulliken populations on Atoms and every MO   !
!   WRITEMULLAPMOrc: Print Mulliken atomic populations in each MO      !
!   ATDENMATrc: Compute atomic density matrix                          !
!                                                                      !
!   Extended Koopmans' Theorem (EKT): J. Chem. Phys. 136, 174116, 2012 !
!   EXTKOOPMANSrc: Ionization Potentials by Ext. Koopmans' theorem     !
!   DYSONORB: Dyson molecular orbitals (related to EKT)                !
!   DYSVECOUTrc: Print Dyson eigenvectors (related to EKT)             !
!                                                                      !
!   AIMMEMrc: Create an input file for Bader's AIMPAC Program          !
!   AIMPACrc: Write information into a WFN file (7)                    !
!                                                                      !
!   FCHKrc: Create a formatted checkpoint (FCHK) input file (19)       !
!                                                                      !
!   MOLDENrc: Create an input file (MLD) in Molden Format (17)         !
!                                                                      !
!   PUNCHVEC,PUNCHAPSG,OneNCO,OddNCO,EvenNCO: JCP 139, 234109, 2013    !
!   Create an input APSG File (9) containing generating wfn of PNOF5   !
!                                                                      !
!   CHEMPOTrc: Chemical Potential ( IJQC 116, 805, 2016 )              !
!                                                                      !
!   OUTPUTCJKrc: Print CJ12 & CK12 (Molecular RDMs) in 'CJK' File (12) !
!   OUTPUTTijab_rc: Print non-dynamic CK12 & Tijab (MP2 amplitudes)    !
!                   to 'CND' File (13)                                 !
!                                                                      !
!   Print Atomic RDMs in 1DM and 2DM Files (NOUTRDM=1)                 !
!   NSQT=0: 2DM (14), 1DM (15) [formatted files]                       !
!   NSQT=1: 2DM (14), 1DM (15), N2DM (16) [unformatted f iles]         !
!   OUTPUTRDMrc: Calculate, check norms and print atomic DMs           !
!   SUMDDL: Perform the trasformation from NOs to atomic MOs for 2DM   !
!   SUMDL: Perform the trasformation from NOs to atomic MOs for 1DM    !
!   RDM1NORM: Calculate and print the 1DM norm                         !
!   RDM2NORM: Calculate and print the 2DM norm                         !
!   DENSI: Calculate density for each 2DM(ijkl)                        !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! NUCDIST
      SUBROUTINE NUCDIST(NV,NAT,Cxyz)
      IMPLICIT NONE
      INTEGER,INTENT(IN):: NV,NAT
      DOUBLE PRECISION,DIMENSION(NV),INTENT(IN)::Cxyz
      DOUBLE PRECISION,DIMENSION(NAT)::DIST
      DOUBLE PRECISION::RR
      INTEGER::I,J,MAXX,MINN
      DOUBLE PRECISION,PARAMETER::BOHR = 0.52917724924D+00               
!-----------------------------------------------------------------------
      WRITE(11,'(1X)')
      WRITE(11,*)'Internuclear distances (Angs)'
      MAXX=0
      DO
      MINN = MAXX+1
      MAXX = MAXX+5
      IF(MAXX>NAT) MAXX=NAT
      WRITE(11,'(1X)')
      WRITE(11,'(10X,7(I4,8X))') (J,J=MINN,MAXX)
      WRITE(11,'(1X)')
!      
      DO I = 1,NAT
       DO J = MINN,MAXX
        RR = (Cxyz(1+(I-1)*3)-Cxyz(1+(J-1)*3))**2 +                     &
             (Cxyz(2+(I-1)*3)-Cxyz(2+(J-1)*3))**2 +                     &
             (Cxyz(3+(I-1)*3)-Cxyz(3+(J-1)*3))**2
        RR = DSQRT(RR)
        DIST(J) = RR*BOHR
       ENDDO
       WRITE(11,'(I4,7(F12.4))')I,(DIST(J),J=MINN,MAXX)
      ENDDO
      IF(.NOT.(MAXX<NAT)) EXIT
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! MULLIKENrc
      SUBROUTINE MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,S,RO,QD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      CHARACTER*4 ATMNAME(NATOMS)
      DIMENSION ZNUC(NATOMS),LIMLOW(NATOMS),LIMSUP(NATOMS)
      DIMENSION S(NBF,NBF),RO(NBF5),QD(NBF,NBF,NBF)
      ALLOCATABLE:: CMUL(:,:),QMOAT(:,:)
      ALLOCATABLE:: AOVLPOP(:,:),OVLPOP(:,:),POPAT(:)
!-----------------------------------------------------------------------
!     Mulliken Population:
!     CMUL:    Atomic Orbital populations in each Molecular Orbital
!     QMOAT:   Atomic populations in each Molecular Orbital
!     AOVLPOP: Atomic Overlap Populations
!     OVLPOP:  Overlap Populations
!     POPAT:   Populations on Atoms
!-----------------------------------------------------------------------
!     Compute Mulliken population of each AO in every MO
!-----------------------------------------------------------------------
      ALLOCATE(CMUL(NBF,NBF5))
      DO IQ=1,NBF5
       DO J=1,NBF
        SCSC=0.0d0
        DO K=1,NBF
         SCSC=SCSC+QD(IQ,K,J)*S(J,K)
        ENDDO
        CMUL(J,IQ)=SCSC*RO(IQ)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     Condense to atoms
!-----------------------------------------------------------------------
      ALLOCATE (QMOAT(NATOMS,NBF5))
      DO IQ=1,NBF5
       DO IAT=1,NATOMS
        SCMUL = 0.0d0
        IMIN=LIMLOW(IAT)
        IMAX=LIMSUP(IAT)
        DO J=IMIN,IMAX
         SCMUL = SCMUL + CMUL(J,IQ)
        ENDDO
        QMOAT(IAT,IQ) = SCMUL
       ENDDO
      ENDDO      
!-----------------------------------------------------------------------
!     Print Atomic populations in each Molecular Orbital
!-----------------------------------------------------------------------
      WRITE(6,1)
      CALL WRITEMULLAPMOrc(QMOAT,RO,NBF5,NATOMS)
!-----------------------------------------------------------------------
!     Calculate Overlap Atomic Populations
!-----------------------------------------------------------------------
      ALLOCATE(AOVLPOP(NBF,NBF))
      AOVLPOP=0.0d0
      DO K=1,NBF
       DO L=1,NBF
        AOVLPOP(K,L) = AOVLPOP(K,L)                                     &
                     + ATDENMATrc(K,L,RO,QD,NBF,NBF5)*S(K,L)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     Compress Overlap Atomic Populations to Atoms
!-----------------------------------------------------------------------
      ALLOCATE(OVLPOP(NATOMS,NATOMS))
      DO I=1,NATOMS
       IMIN=LIMLOW(I)
       IMAX=LIMSUP(I)
       DO J=1,NATOMS
        JMIN=LIMLOW(J)
        JMAX=LIMSUP(J)
        OVLPOP(I,J)=0.0d0
        IF(IMIN<=IMAX)THEN
         DO K=IMIN,IMAX
          IF(JMIN<=JMAX)THEN
           DO L=JMIN,JMAX
            OVLPOP(I,J) = OVLPOP(I,J) + AOVLPOP(K,L)
           ENDDO
          ENDIF
         ENDDO
        ENDIF
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     Calculate total populations on Atoms
!-----------------------------------------------------------------------
      WRITE(6,2)
      WRITE(6,3)
      ALLOCATE(POPAT(NATOMS))
      DO I=1,NATOMS
       POPAT(I)=0.0d0
       DO J=1,NATOMS
        POPAT(I)=POPAT(I)+OVLPOP(I,J)
       ENDDO
!-----------------------------------------------------------------------
!      Print total Populations
!-----------------------------------------------------------------------
       WRITE(6,4)I,ATMNAME(I),POPAT(I),ZNUC(I)-POPAT(I)
      ENDDO
!-----------------------------------------------------------------------
    1 FORMAT(                                                           &
      /2X,' Atomic populations in each Molecular Orbital ',/,           &
       2X,'- - - - - - - - - - - - - - - - - - - - - - - -')             
    2 FORMAT(/,                                                         &
      /2X,' Total Populations on Atoms ',/,                             &
       2X,'- - - - - - - - - - - - - - -',/)
    3 FORMAT(9X,'Atom',8X,'Pop.',7X,'Charge',/)
    4 FORMAT(1X,I4,1X,A8,2F12.4)
!-----------------------------------------------------------------------
      DEALLOCATE(CMUL,QMOAT,AOVLPOP,OVLPOP)
      RETURN
      END

! WRITEMULLAPMOrc
      SUBROUTINE WRITEMULLAPMOrc(QMOAT,RO,NBF5,NATOMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION QMOAT(NATOMS,NBF5),RO(NBF5)
!-----------------------------------------------------------------------
!     Print Atomic populations in each Molecular Orbital
!-----------------------------------------------------------------------
      IMAX=0
  10  IMIN=IMAX+1
      IMAX=IMAX+10
      IF(IMAX>NBF5)IMAX=NBF5
      WRITE(6,1)
      WRITE(6,2)(I,I=IMIN,IMAX)
      WRITE(6,1)
      WRITE(6,3)(2*RO(I),I=IMIN,IMAX)
      WRITE(6,1)
      DO J=1,NATOMS
       WRITE(6,4)J,(QMOAT(J,I),I=IMIN,IMAX)
      ENDDO
      IF(IMAX<NBF5)GOTO 10
!-----------------------------------------------------------------------
    1 FORMAT(1X)
    2 FORMAT(9X,10(3X,I4,2X))
    3 FORMAT(9X,10F9.4)
    4 FORMAT(I5,4X,10F9.4)
!-----------------------------------------------------------------------
      RETURN
      END

! ATDENMATrc
      FUNCTION ATDENMATrc(K,L,RO,QD,NBF,NBF5)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION RO(NBF5),QD(NBF,NBF,NBF)
!-----------------------------------------------------------------------
      ATDENMATrc = 0.0d0
      DO J =1,NBF5
       ATDENMATrc = ATDENMATrc + RO(J)*QD(J,K,L)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! EXTKOOPMANSrc
      SUBROUTINE EXTKOOPMANSrc(ELAG,COEF,OVERLAP,AHCORE,IJKL,XIJKL,RO)
!-----------------------------------------------------------------------
!                Extended Koopmans' Theorem (EKT)
!                This subroutine is called when IEKT=1
!-----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
!
      INTEGER,DIMENSION(NIJKL)::IJKL
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,OVERLAP,AHCORE
      DOUBLE PRECISION,DIMENSION(NIJKL)::XIJKL
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,TEMP,OCCD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,DYSON
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::DM,GFOCK,COEFT
!-----------------------------------------------------------------------
!     Intermediate matrices
!-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF,NBF),W(NBF,NBF),EVA(NBF),TEMP(NBF))
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
!     Ionization Potentials:
!     Diagonalization of -ELAG/RAIZ[RO*RO], ELAG: Lagrangian
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
!     ELAG/RAIZ[RO*RO] -> square symmetric matrix (AUX)
!-----------------------------------------------------------------------
      DO I=1,NBF5
       BETAi=DSQRT(RO(i))
       DO J=1,I
        BETAj=DSQRT(RO(j))
        IF( (DABS(BETAi)>1.0d-6).and.(DABS(BETAj)>1.0d-6) )THEN
         AUX(I,J)=ELAG(I,J)/(BETAi*BETAj)
        ELSE
         AUX(I,J)=0.0d0
        ENDIF
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
      DO I=NBF5+1,NBF
       DO J=1,I
        AUX(I,J)=0.0d0
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     Diagonalize square matrix (AUX)
!     W - Eigenvectors, EVA - EIGENVALUES
!-----------------------------------------------------------------------
      CALL DIAG(NBF,AUX,W,EVA,TEMP)
!-----------------------------------------------------------------------
!     Write Ionization Energies (Output File)
!     Coefficients of Dyson Orbitals (DYSON=COEF*BETA*W)
!-----------------------------------------------------------------------
      ALLOCATE (DYSON(NBF,NBF5),OCCD(NBF5))
      CALL DYSONORB(OCCD,DYSON,COEF,RO,W,OVERLAP)
      WRITE(6,1)
      DO I=1,NBF5
       IF(EVA(I)<0.0d0.and.OCCD(I)>0.45d0)THEN
        WRITE(6,2)I,-EVA(I),-EVA(I)*27.21138386
       ENDIF
      ENDDO
!      
      IWRITEDYSON=0
      IF(IWRITEDYSON==1)THEN
       WRITE(6,4)
       CALL DYSVECOUTrc(DYSON,OCCD,NBF,NBF5,NBF5)
      ENDIF
      DEALLOCATE (DYSON)
!-----------------------------------------------------------------------
!     Write Cation Energy if ICATION=1 (Output File)
!     Ecation = Eelec + EN + MinVal IonPotential obtained with EKT
!-----------------------------------------------------------------------
      ICATION=0                                          ! ICATION=0
      IF(NSOC==0.and.ICATION==1)THEN
       TEMP = 1.0d06
       DO I=1,NBF5
        IF(-EVA(I)>0.0d0.and.OCCD(I)>0.45d0)TEMP(I)=-EVA(I)
       ENDDO
       PIMIN = MINVAL(TEMP,NBF5)
       WRITE(6,3)EELEC+EN+PIMIN
      ENDIF
      DEALLOCATE (OCCD)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
!     Electron Affinities:
!     Diagonalization of (ELAG-GFOCK)/RAIZ[(1-RO)*(1-RO)]
!     GFOCK: Generalized Fock Matrix, ELAG: Lagrangian
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEA=0                                                 ! IEA=0
      IF(IEA==1)THEN
!-----------------------------------------------------------------------
!      Form the Generalized Fock Matrix
!-----------------------------------------------------------------------
       ALLOCATE (DM(NBF,NBF),GFOCK(NBF,NBF))
       CALL DENMATrc(DM,COEF,RO)
       CALL FORM2JK(AUX,DM,IJKL,XIJKL)
       DEALLOCATE(DM)
       GFOCK = AHCORE + AUX
       AUX  = MATMUL(GFOCK,COEF)
       ALLOCATE (COEFT(NBF,NBF))
       COEFT = TRANSPOSE(COEF)     
       GFOCK = MATMUL(COEFT,AUX)
       DEALLOCATE (COEFT)
!-----------------------------------------------------------------------
!      (ELAG-GFOCK)/RAIZ[(1-RO)*(1-RO)] -> square symmetric matrix (AUX)
!-----------------------------------------------------------------------
       DO I=1,NB
        AUX(I,I) = -DABS(ELAG(I,I)-GFOCK(I,I)) / (1.0d0-RO(i))
       ENDDO

       DO I=NB+1,NBF5
        AUX(I,I) = (ELAG(I,I)-GFOCK(I,I)) / (1.0d0-RO(i))
       ENDDO

       DO I=1,NBF5
        BETAi=DSQRT(1.0d0-RO(i))
        DO J=1,I-1
         BETAj=DSQRT(1.0d0-RO(j))
         IF( (DABS(BETAi)>1.0d-3).and.(DABS(BETAj)>1.0d-3) )THEN
          AUX(I,J) = (ELAG(I,J)-GFOCK(I,J)) / (BETAi*BETAj)
         ELSE
          AUX(I,J)=0.0d0
         ENDIF
         AUX(J,I)=AUX(I,J)
        ENDDO
       ENDDO

       DO I=NBF5+1,NBF
        DO J=1,I
         AUX(I,J) = -GFOCK(I,J)
         AUX(J,I) = AUX(I,J)
        ENDDO
       ENDDO

       DEALLOCATE (GFOCK)
!-----------------------------------------------------------------------      
!      Diagonalize square matrix (AUX)
!      W - Eigenvectors, EVA - Eigenvalues
!-----------------------------------------------------------------------
       CALL DIAG(NBF,AUX,W,EVA,TEMP)
!-----------------------------------------------------------------------
!      Write electron affinities (Output File)
!-----------------------------------------------------------------------
       WRITE(6,5)
       DO I=1,NBF
        WRITE(6,2)I,EVA(I),EVA(I)*27.2107
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT(/2X,'--------------------------------------------------',  &
             /2X,' Extended Koopmans'' Theorem (Ionization Energies) ', &
             /2X,'--------------------------------------------------',  &
            //4X,'OM',14X,'(aU)',14X,'(eV)',/)                           
    2 FORMAT(2X,I4,4X,F15.3,4X,F15.3,10X,F7.3)                           
    3 FORMAT(/,3X,'NOF Total Cation Energy (aU) =',F16.6)                
    4 FORMAT(/,                                                         &
       18X,'----------------------------------------',/,                &
       18X,' DYSON ORBITALS IN ATOMIC ORBITAL BASIS ',/,                &
       18X,'----------------------------------------')                   
    5 FORMAT(/2X,'-------------------------------------------------',   &
             /2X,' EXTENDED KOOPMANS THEOREM (ELECTRON AFFINITIES) ',   &
             /2X,'-------------------------------------------------',   &
            //20X,'(aU)',14X,'(eV)',/)
!-----------------------------------------------------------------------
      DEALLOCATE (AUX,W,EVA,TEMP)
      RETURN
      END

! DYSONORB
      SUBROUTINE DYSONORB(OCCD,DYSON,COEF,RO,W,OVERLAP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,OCCD
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,W,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF5)::DYSON
!-----------------------------------------------------------------------
!     DYSON=COEF*BETA*WC (unnormalized)
!-----------------------------------------------------------------------
      DO NIU=1,NBF
       DO IQ=1,NBF5
        DYSON(NIU,IQ)=0.0d0
        do i=1,nbf5
         BETAi = DSQRT(RO(i))
         DYSON(NIU,IQ)=DYSON(NIU,IQ)+COEF(NIU,i)*BETAi*W(i,IQ)
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     Occupation Number of Dyson Orbital (Normalization Factor)
!-----------------------------------------------------------------------
      DO IQ=1,NBF5
       OCCD(IQ)=0.0d0
       do niu=1,nbf
        OCCD(IQ) = OCCD(IQ) + DYSON(niu,IQ)*FC(niu,IQ,OVERLAP,DYSON)
       enddo
      ENDDO
!-----------------------------------------------------------------------
!     Normalized Dyson Orbitals
!-----------------------------------------------------------------------
      DO IQ=1,NBF5
       DO niu=1,nbf
        DYSON(niu,IQ)=DYSON(niu,IQ)/DSQRT(OCCD(IQ))
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! DYSVECOUTrc
      SUBROUTINE DYSVECOUTrc(V,RO,NBF,NBF5,NL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
!-----------------------------------------------------------------------
!     Print Eigenvectors
!-----------------------------------------------------------------------
      CHARACTER*2 LABELAT
      CHARACTER*4 BFNAM1
      CHARACTER*6 BFNAM2
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::V
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::DOSRO
      ALLOCATE(DOSRO(NBF))
!-----------------------------------------------------------------------
      DO J=1,NBF5
       DOSRO(J)=2.0*RO(J)
      ENDDO
      DO J=NBF5+1,NBF
       DOSRO(J)=0.0
      ENDDO
      MAX=0
  10  MIN=MAX+1
      MAX=MAX+5
      IF(MAX>NL) MAX=NL
      WRITE(6,1)(J,J=MIN,MAX)
      WRITE(6,2)(DOSRO(J),J=MIN,MAX)
      WRITE(6,*)
      REWIND(4)
      READ(4,'(I5)')NBF0
      DO I=1,NBF
       IF(I<=35)THEN
        READ(4,3)LABELAT,IAT,BFNAM1
        WRITE(6,4) I,LABELAT,IAT,BFNAM1,(V(I,J),J=MIN,MAX)
       ELSE
        READ(4,5)LABELAT,BFNAM2
        WRITE(6,6) I,LABELAT,BFNAM2,(V(I,J),J=MIN,MAX)
       ENDIF
      ENDDO
      IF(MAX<NL) GOTO 10
      WRITE(6,7)
!-----------------------------------------------------------------------
    1 FORMAT(/,15X,5(4X,I4,3X))
    2 FORMAT(/,15X,5F11.4)
    3 FORMAT(A2,I2,A4)
    4 FORMAT(I5,2X,A2,I2,A4,5F11.6)
    5 FORMAT(A2,A6)
    6 FORMAT(I5,2X,A2,A6,5F11.6)
    7 FORMAT(/)
!-----------------------------------------------------------------------
      DEALLOCATE(DOSRO)
      RETURN
      END

! DENMATrc
      SUBROUTINE DENMATrc(DM,C,RO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::DM,C
!----------------------------------------------------------------------
      DO M=1,NBF
       DO N=M,NBF
       DM(M,N)=0.0d0
       DO J=1,NBF5
        DM(M,N)=DM(M,N)+ RO(J)*C(M,J)*C(N,J)
       ENDDO
       DM(N,M)=DM(M,N)
       ENDDO
      ENDDO
      DM=2.0d0*DM
!----------------------------------------------------------------------
      RETURN
      END

! AIMMEMrc
      SUBROUTINE AIMMEMrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,&
                        KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
!-----------------------------------------------------------------------
!     Create an input File for Bader's AIMPAC Program
!-----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      INTEGER,DIMENSION(NATOMS)::IZCORE
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,CS,CP,CD,CF,CG,CH,CI
!-----------------------------------------------------------------------
      NPRIMS = 0
      DO I = 1,NSHELL
       NPRIMS = NPRIMS + KNG(I) * (KKMAX(I)-KKMIN(I)+1)
      ENDDO
!-----------------------------------------------------------------------
      CALL AIMPACrc(NBF5,NPRIMS,COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,    &
           KNG,KKMIN,KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
!-----------------------------------------------------------------------
      RETURN
      END

! AIMPACrc
      SUBROUTINE AIMPACrc(NMO,NPRIMS,VEC,ZNUC,IZCORE,CX0,CY0,CZ0,       &
                          KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,RO,E,      &
                          EX1,CS,CP,CD,CF,CG,CH,CI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      CHARACTER(80) :: TITLE
      COMMON/TIT/TITLE
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/VirialRatio/Virial                             ! RHF
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      CHARACTER*4,DIMENSION(106)::ATMLAB
      INTEGER,DIMENSION(NATOMS)::IZCORE
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE
      INTEGER,DIMENSION(NPRIMS)::ICENT,ITYPE
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::VEC
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NPRIMS)::EXPON,AIC,ACO
!-----------------------------------------------------------------------
      DATA ATMLAB/'  H ','  HE','  LI','  BE','  B ','  C ',            &
                  '  N ','  O ','  F ','  NE','  NA','  MG',            &
                  '  AL','  SI','  P ','  S ','  CL','  AR',            &
                  '  K ','  CA','  SC','  TI','  V ','  CR',            &
                  '  MN','  FE','  CO','  NI','  CU','  ZN',            &
                  '  GA','  GE','  AS','  SE','  BR','  KR',            &
                  '  RB','  SR','  Y ','  ZR','  NB','  MO',            &
                  '  TC','  RU','  RH','  PD','  AG','  CD',            &
                  '  IN','  SN','  SB','  TE','  I ','  XE',            &
                  '  CS','  BA','  LA','  CE','  PR','  ND',            &
                  '  PM','  SM','  EU','  GD','  TB','  DY',            &
                  '  HO','  ER','  TM','  YB','  LU','  HF',            &
                  '  TA','  W ','  RE','  OS','  IR','  PT',            &
                  '  AU','  HG','  TL','  PB','  BI','  PO',            &
                  '  AT','  RN','  FR','  RA','  AC','  TH',            &
                  '  PA','  U ','  NP','  PU','  AM','  CM',            &
                  '  BK','  CF','  ES','  FM','  MD','  NO',            &
                  '  LR','    ','    ','    '/
!-----------------------------------------------------------------------
      REWIND(7)
      WRITE(7,1)TITLE
      WRITE(7,2)NMO,NPRIMS,NATOMS
!-----------------------------------------------------------------------
!     CX0,CY0,CZ0: Cartesian nuclear coordinate arrays
!     ZNUC: Nuclear charge array (1,NATOMS)
!     IZCORE: Number of electrons removed from each atom (ECP)
!-----------------------------------------------------------------------
      DO I=1,NATOMS
       IZNUC = INT(ZNUC(I))+IZCORE(I)
       WRITE(7,3)ATMLAB(IZNUC),I,I,CX0(I),CY0(I),CZ0(I),                &
                 ZNUC(I)+IZCORE(I)
      ENDDO
!-----------------------------------------------------------------------
!     Fill AIC (CONTRACTION COEFFS)
!-----------------------------------------------------------------------
      L = 0
      DO I = 1,NSHELL
       JST = KSTART(I)
       JEN = JST + KNG(I) - 1
       MINK = KKMIN(I)
       MAXK = KKMAX(I)
       DO K = MINK,MAXK
        DO J = JST,JEN
         L = L + 1
         ICENT(L) = KATOM(I)
         ITYPE(L) = K
         EXPON(L) = EX1(J)
         IF( K==1          )AIC(L) = CS(J)
         IF( 2<=K.and.K<= 4)AIC(L) = CP(J)
         IF( 5<=K.and.K<=10)AIC(L) = CD(J)
         IF(11<=K.and.K<=20)AIC(L) = CF(J)
         IF(21<=K.and.K<=35)AIC(L) = CG(J)
         IF(36<=K.and.K<=56)AIC(L) = CH(J)
         IF(57<=K.and.K<=84)AIC(L) = CI(J)
        ENDDO
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
!     Write primitive information: ICENT, ITYPE, EXPON
!-----------------------------------------------------------------------
      WRITE(7,4) (ICENT(I),I=1,NPRIMS)
      WRITE(7,5) (ITYPE(I),I=1,NPRIMS)
      WRITE(7,6) (EXPON(I),I=1,NPRIMS)
!-----------------------------------------------------------------------
!     Expand the Natural Orbitals in the Atomic Orbital Basis
!     into the primitive representation. Write NOs and their OCC and E.
!-----------------------------------------------------------------------
      SQRT3 = SQRT(3.0D0)
      SQRT5 = SQRT(5.0D0)
      SQRT7 = SQRT(7.0D0)
      DO II=1,NMO
       L = 0
       M = 0
       DO I=1,NSHELL
        KST = KSTART(I)
        KEN = KST + KNG(I) - 1
        JMIN= KKMIN(I)
        JMAX= KKMAX(I)
        ITYP= KTYPE(I)
        DO J=JMIN,JMAX
         M = M+1
         DO K=KST,KEN
          L = L+1
          ACO(L) = VEC(M,II)*AIC(L)
          IF(ITYP==3)THEN
           IF(J>=8)ACO(L) = ACO(L)*SQRT3
          END IF
          IF(ITYP==4)THEN
           IF(J>=14)ACO(L)=ACO(L)*SQRT5
           IF(J==17)THEN
            DUMMY    = ACO(L-1)
            ACO(L-1) = ACO(L)
            ACO(L)   = DUMMY
           ENDIF
           IF(J==20)ACO(L) = ACO(L)*SQRT3
          ENDIF
          IF(ITYP==5)THEN
           IF(J>=24)ACO(L) = ACO(L)*SQRT7
           IF(J>=30)ACO(L) = ACO(L)*SQRT5/SQRT3
           IF(J>=33)ACO(L) = ACO(L)*SQRT3
          ENDIF
         ENDDO
        ENDDO
       ENDDO
       WRITE(7,7) II,2.0*RO(II),E(II)
       WRITE(7,8) (ACO(L),L=1,NPRIMS)
      ENDDO
!-----------------------------------------------------------------------
!     Terminate data, add SCF Energy and Virial
!-----------------------------------------------------------------------
      WRITE(7,9)
      WRITE(7,10)'THE RHF ',EELEC+EN,Virial
!-----------------------------------------------------------------------
    1 FORMAT(A80)
    2 FORMAT ('GAUSSIAN',10X,I5,' MOL ORBITALS',1X,I6,' PRIMITIVES',    &
              4X,I5,' NUCLEI')                                           
    3 FORMAT(A4,I4,4X,'(CENTRE',I3,')',1X,3F12.8,'  CHARGE =',F5.1)      
    4 FORMAT('CENTRE ASSIGNMENTS',2X,20I3)                               
    5 FORMAT('TYPE ASSIGNMENTS',4X,20I3)                                 
    6 FORMAT('EXPONENTS',1X,1P,5E14.7)                                   
    7 Format('MO',I5,5X,'MO 0.0',8X,'OCC NO = ',F12.7,                  &
             '  ORB. ENERGY =', F12.6)
    8 FORMAT(1P,5E16.8)
    9 FORMAT('END DATA')
   10 FORMAT(A8,' ENERGY =',F20.12,' THE VIRIAL(-V/T)=',F13.8)
!-----------------------------------------------------------------------
      RETURN
      END

! FCHKrc
      SUBROUTINE FCHKrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KNG,KATOM,KTYPE,   &
                        RO,E,EX1,C1,C2,IMIN,IMAX,ISH,DIPS,IRUNTYP)
!-----------------------------------------------------------------------
!     Create a Formatted Checkpoint input File for Gaussview
!-----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER(80) :: TITLE
      COMMON/TIT/TITLE
      CHARACTER(80) :: BASIS_FILE
      COMMON/BASIS_FILE/BASIS_FILE
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/CONV/ACURCY,EN,Etot,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/VirialRatio/Virial                             ! RHF
      INTEGER,DIMENSION(NATOMS)::IZCORE,IMIN,IMAX
      INTEGER,DIMENSION(NPRIMI)::ISH
      INTEGER,DIMENSION(NSHELL)::KNG,KATOM,KTYPE
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,C1,C2
      DOUBLE PRECISION,DIMENSION(3):: DIPS

      INTEGER,ALLOCATABLE,DIMENSION(:) :: NUMPRIMi,IZNUC,ISHELLTYP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DMs
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: DM
      CHARACTER(6),DIMENSION(4) :: RUNTYP
      DATA RUNTYP/'ENERGY','GRAD  ','OPTGEO','HESS  '/
!----------------------------------------------------------------------- 
      REWIND(19)
      WRITE(19,1)TITLE
!     Run Type, Functional, Basis
      WRITE(19,2)RUNTYP(IRUNTYP),IPNOF,BASIS_FILE
!     
      WRITE(19,3)NATOMS
      WRITE(19,4)ICH
      WRITE(19,5)MUL
      WRITE(19,6)NE
      WRITE(19,7)NA
      WRITE(19,8)NB
      WRITE(19,9)NBF
      WRITE(19,10)NBF5
      WRITE(19,11)NSHELL
!     Highest angular momentum 
      CALL BASCHK(MAXANG,KTYPE,NSHELL)
      WRITE(19,12)MAXANG  
!     Largest degree of contraction 
      ALLOCATE(NUMPRIMi(NSHELL))
      LDCONT = 1
      DO I=1,NATOMS
       ISH1 = ISH(IMIN(I))
       NSHELLi = 1
       NUMPRIMi(NSHELLi) = 0
!      Number of primitives per shell of Atom 'i'
       DO J=IMIN(I),IMAX(I)
        if(ISH(J)==ISH1)then
         NUMPRIMi(NSHELLi) = NUMPRIMi(NSHELLi) + 1
        else
         NSHELLi = NSHELLi + 1
         NUMPRIMi(NSHELLi) = 1
         ISH1 = ISH(J)
        endif
       END DO
       LDCONTi = MAXVAL(NUMPRIMi(1:NSHELLi))
       if( LDCONTi > LDCONT ) LDCONT = LDCONTi
      END DO
      DEALLOCATE(NUMPRIMi)
      WRITE(19,13)LDCONT
!
      WRITE(19,14)NPRIMI
      WRITE(19,15)Virial
      WRITE(19,16)Etot    
      WRITE(19,17)EELEC + EN
!     Atomic numbers & Nuclear charges
      ALLOCATE(IZNUC(NATOMS))
      DO i=1,NATOMS
       IZNUC(i) = INT(ZNUC(i))+IZCORE(i)
      END DO
      WRITE(19,18)NATOMS
      WRITE(19,19)(IZNUC(i),i=1,NATOMS)
      DEALLOCATE(IZNUC)
      WRITE(19,20)NATOMS
      WRITE(19,21)(ZNUC(i)+IZCORE(i),i=1,NATOMS)
      WRITE(19,22)3*NATOMS
      WRITE(19,21)(CX0(i),CY0(i),CZ0(i),i=1,NATOMS)
      WRITE(19,23)NSHELL
      ALLOCATE(ISHELLTYP(NSHELL))
!     Shell Types (KTYPE-1) 
      LSHELL = 0
      DO I=1,NSHELL
       if(KTYPE(I)<8)then
        ISHELLTYP(I) = KTYPE(I) - 1
       else
        ISHELLTYP(I) = -1
        LSHELL = 1
       end if
      END DO
      WRITE(19,19)(ISHELLTYP(i),i=1,NSHELL)
      DEALLOCATE(ISHELLTYP)
!
      WRITE(19,24)NSHELL
      WRITE(19,19)(KNG(i),i=1,NSHELL)
      WRITE(19,25)NSHELL
      WRITE(19,19)(KATOM(i),i=1,NSHELL)
      WRITE(19,26)3*NSHELL
      WRITE(19,21)(CX0(KATOM(i)),CY0(KATOM(i)),CZ0(KATOM(i)),i=1,NSHELL)
      WRITE(19,27)NPRIMI
      WRITE(19,21)(EX1(i),i=1,NPRIMI)
      WRITE(19,28)NPRIMI
      WRITE(19,21)(C1(i),i=1,NPRIMI)
      if(LSHELL==1)then
       WRITE(19,29)NPRIMI
       WRITE(19,21)(C2(i),i=1,NPRIMI)
      end if
      WRITE(19,30)NBF
      WRITE(19,21)(E(i),i=1,NBF)
      WRITE(19,31)NBF
      WRITE(19,21)(E(i),i=1,NBF)
      WRITE(19,32)NSQ
      WRITE(19,21)((COEF(i,j),i=1,NBF),j=1,NBF)
      WRITE(19,33)NSQ
      WRITE(19,21)((COEF(i,j),i=1,NBF),j=1,NBF)
!     Total SCF Density  
      WRITE(19,34)NBFT
      ALLOCATE (DM(NBF,NBF),DMs(NBFT))
      CALL DENMATrc(DM,COEF,RO)
      NZ=0
      DO I=1,NBF
       DO J=1,I
        NZ=NZ+1
        DMs(NZ)=DM(I,J)
       ENDDO
      ENDDO
      WRITE(19,21)(DMs(i),i=1,NBFT)
      DEALLOCATE (DM,DMs)
      WRITE(19,35)NBF5
      WRITE(19,21)(RO(i),i=1,NBF5)
      WRITE(19,36)
      WRITE(19,21)(DIPS(i),i=1,3)
!-----------------------------------------------------------------------
    1 FORMAT(A80)
    2 FORMAT(A6,4X,'PNOF',I1,4X,A80)
    3 FORMAT('Number of atoms                ',12X,'I',5X,I12)
    4 FORMAT('Charge                         ',12X,'I',5X,I12)
    5 FORMAT('Multiplicity                   ',12X,'I',5X,I12)
    6 FORMAT('Number of electrons            ',12X,'I',5X,I12)
    7 FORMAT('Number of alpha electrons      ',12X,'I',5X,I12)
    8 FORMAT('Number of beta electrons       ',12X,'I',5X,I12)
    9 FORMAT('Number of basis functions      ',12X,'I',5X,I12)
   10 FORMAT('Number of independant functions',12X,'I',5X,I12)
   11 FORMAT('Number of contracted shells    ',12X,'I',5X,I12)
   12 FORMAT('Highest angular momentum       ',12X,'I',5X,I12)
   13 FORMAT('Largest degree of contraction  ',12X,'I',5X,I12)
   14 FORMAT('Number of primitive shells     ',12X,'I',5X,I12)
   15 FORMAT('Virial Ratio                   ',12X,'R',5X,ES22.15)
   16 FORMAT('SCF Energy                     ',12X,'R',5X,ES22.15)
   17 FORMAT('Total Energy                   ',12X,'R',5X,ES22.15)
   18 FORMAT('Atomic numbers                 ',12X,'I   N=',I12)
   19 FORMAT(6I12) 
   20 FORMAT('Nuclear charges                ',12X,'R   N=',I12)
   21 FORMAT(5ES22.15)
   22 FORMAT('Current cartesian coordinates  ',12X,'R   N=',I12)
   23 FORMAT('Shell types                    ',12X,'I   N=',I12)
   24 FORMAT('Number of primitives per shell ',12X,'I   N=',I12)
   25 FORMAT('Shell to atom map              ',12X,'I   N=',I12)
   26 FORMAT('Coordinates of each shell      ',12X,'R   N=',I12)
   27 FORMAT('Primitive exponents            ',12X,'R   N=',I12)            
   28 FORMAT('Contraction coefficients       ',12X,'R   N=',I12)
   29 FORMAT('P(S=P) Contraction coefficients',12X,'R   N=',I12)
   30 FORMAT('Alpha Orbital Energies         ',12X,'R   N=',I12)
   31 FORMAT('Beta Orbital Energies          ',12X,'R   N=',I12)
   32 FORMAT('Alpha MO coefficients          ',12X,'R   N=',I12)
   33 FORMAT('Beta MO coefficients           ',12X,'R   N=',I12)
   34 FORMAT('Total SCF Density              ',12X,'R   N=',I12)
   35 FORMAT('Natural orbital occupancies    ',12X,'R   N=',I12)
   36 FORMAT('Dipole Moment                  ',12X,'R   N=',11X,'3')
!-----------------------------------------------------------------------              
      RETURN
      END
      
! MOLDENrc
      SUBROUTINE MOLDENrc(ATMNAME,IZCORE,ZNUC,CX0,CY0,CZ0,IMIN,IMAX,ISH,&
                          ITYP,EX1,C1,C2,RO,E,COEF)
!-----------------------------------------------------------------------
!     Create an input File to interface to the Molden program
!-----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      CHARACTER(80) :: TITLE
      COMMON/TIT/TITLE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::IZCORE,IMIN,IMAX
      INTEGER,DIMENSION(NPRIMI)::ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,C1,C2
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF
      CHARACTER*4,DIMENSION(106) :: ATMLAB
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',            &
                  'N   ','O   ','F   ','NE  ','NA  ','MG  ',            &
                  'AL  ','SI  ','P   ','S   ','CL  ','AR  ',            &
                  'K   ','CA  ','SC  ','TI  ','V   ','CR  ',            &
                  'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',            &
                  'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',            &
                  'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',            &
                  'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',            &
                  'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',            &
                  'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',            &
                  'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',            &
                  'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',            &
                  'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',            &
                  'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',            &
                  'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',            &
                  'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',            &
                  'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',            &
                  'LR  ','RF  ','X   ','BQ  '/
      CHARACTER*2 LABEL(8)
      DATA LABEL/'s ','p ','d ','f ','g ','h ','i ','sp'/
      INTEGER,ALLOCATABLE,DIMENSION(:)::NUMPRIM
!-----------------------------------------------------------------------
      REWIND(17)
      WRITE(17,1)
      WRITE(17,2)TITLE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Coordinates for the Electron Density / Molecular orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(17,3)      
      DO I=1,NATOMS
       IZNUC = INT(ZNUC(I))+IZCORE(I)
       ATMNAME(I)=ATMLAB(IZNUC)
      ENDDO
      DO I=1,NATOMS
       IZNUC = INT(ZNUC(I))+IZCORE(I)
       WRITE(17,4)ATMNAME(I),I,IZNUC,CX0(I),CY0(I),CZ0(I)
      ENDDO      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Specification of the basis-set consisting of Contracted GTOs
!     Recognized shell_labels by Molden: s,p,d,f,g,sp
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(17,5)
      ALLOCATE(NUMPRIM(NSHELL))
      DO I=1,NATOMS
       WRITE(17,6)I,0
!      Number of primitives per shell of Atom 'i'
       ISH1 = ISH(IMIN(I))
       NSHELLi = 1
       NUMPRIM(NSHELLi) = 0
       DO J=IMIN(I),IMAX(I)
        if(ISH(J)==ISH1)then
         NUMPRIM(NSHELLi) = NUMPRIM(NSHELLi) + 1
        else
         NSHELLi = NSHELLi + 1
         NUMPRIM(NSHELLi) = 1
         ISH1 = ISH(J)
        endif
       ENDDO
!      shell_label, number_of_primitives
       I1 = IMIN(I)
       DO K=1,NSHELLi
        WRITE(17,7)LABEL(ITYP(I1)),NUMPRIM(K),1.00
!       exponent_primitive, contraction_coefficient
        do j=I1,I1+NUMPRIM(K)-1
         if(ITYP(J)<8)then
          WRITE(17,8)EX1(j),C1(j)
         else
          WRITE(17,8)EX1(j),C1(j),C2(j)
         endif
        enddo        
        I1 = I1 + NUMPRIM(K) 
       ENDDO
       write(17,*)  ! empty line
      ENDDO
      DEALLOCATE(NUMPRIM)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Specification of the molecular orbitals    
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(17,9)
      DO I=1,NBF5
       WRITE(17,10)I
       WRITE(17,11)E(I)
       WRITE(17,12)
       WRITE(17,13)2.0d0*RO(I)
       DO J=1,NBF
        WRITE(17,14)J,COEF(J,I)
       ENDDO
      ENDDO
      DO I=NBF5+1,NBF
       WRITE(17,10)I
       WRITE(17,11)E(I)
       WRITE(17,12)
       WRITE(17,13)0.0d0
       DO J=1,NBF
        WRITE(17,14)J,COEF(J,I)
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
!-----------------------------------------------------------------------
    1 FORMAT('[Molden Format]')
    2 FORMAT(A80)
    3 FORMAT('[Atoms] AU')
    4 FORMAT(1X,A4,2I6,3F14.4)                              
    5 FORMAT('[GTO]')
    6 FORMAT(I5,I2)
    7 FORMAT(A2,I4,F5.2)
    8 FORMAT(1X,F20.12,2E20.12)
    9 FORMAT('[MO]')
   10 FORMAT('Sym=',I6,'a')
   11 FORMAT('Ene=',E16.6)
   12 FORMAT('Spin= Alpha')
   13 FORMAT('Occup=',F9.6)
   14 FORMAT(I6,1X,F12.6)
!-----------------------------------------------------------------------
      END

! PUNCHVEC
      SUBROUTINE PUNCHVEC(V,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::V
!-----------------------------------------------------------------------
      DO J = 1,NBF
       K = 0
       MAX = 0
    1  MIN = MAX + 1
       MAX = MAX + 5
       K = K + 1
       IF(MAX>NBF)MAX = NBF
       MODJ = MOD(J,100)
       WRITE(9,10) MODJ,K,(V(I,J),I = MIN,MAX)
       IF (MAX<NBF)GOTO 1
      ENDDO
!-----------------------------------------------------------------------
   10 FORMAT(I2,I3,1P,5E15.8)
      RETURN
      END

! PUNCHAPSG
      SUBROUTINE PUNCHAPSG(NO1,NCWO,NCO,NBF5,RO,SUMA,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      ALLOCATABLE::IOCU(:),BB(:,:)
!-----------------------------------------------------------------------
!     NCO:  Number of HF occupied MOs (OCC=1)
!     NVIR: Number of HF virtual  MOs (OCC=0)
!
!     NO1:  Number of inactive doubly occupied orbitals (OCC=1)
!     NDOC: Number of strongly occupied MOs
!     NCWO: Number of coupled weakly occupied MOs per strongly occupied
!     NCWO*NDOC: Active orbitals in the virtual subspace
!     NO0: Empty orbitals  (OCC=0)
!     NAC:  Dimension of the active natural orbital subspace
!
!           NCO     |       NVIR          = NBF
!       NO1 + NDOC  |  NCWO*NDOC + NO0    = NBF
!           |      NAC           |
!-----------------------------------------------------------------------
      NO1NAC=NCO+NCWO*(NCO-NO1)                             ! NO1+NAC
      ALLOCATE(IOCU(NO1NAC),BB(NCO,NO1NAC))
      IOCU = 0
      SUMA = 0.0d0

!     HF Fermi Vacuum
      D0 = 1.0d0
      do i=1,NCO
       IOCU(i) = i
       D0 = D0*DSQRT(RO(i))
      enddo
      WRITE(9,1)D0,(IOCU(i),-IOCU(i),i=1,NCO)
      SUMA = SUMA + D0*D0

      do i=NO1+1,NCO
       do j=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        BB(i,j) = DSQRT(RO(j)/RO(i))
       enddo
      enddo

      CALL OneNCO(NO1,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,D0,THAPSG)
      IF(NCO>1)THEN
       do ig=2,NCO
        if(mod(ig, 2)==0)then
         CALL EvenNCO(NO1,NCO-ig+2,NCWO,NCO,NO1NAC,                     &
                      IOCU,BB,SUMA,D0,THAPSG)                            
        else                                                             
         CALL  OddNCO(NO1,NCO-ig+3,NCWO,NCO,NO1NAC,                     &
                      IOCU,BB,SUMA,D0,THAPSG)
        endif
       enddo
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT(F20.16,2X,99I4)
      DEALLOCATE(IOCU,BB)
      RETURN
      END

! OneNCO
      SUBROUTINE OneNCO(I1,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,DD,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      INTEGER,DIMENSION(NO1NAC)::IOCU
      DOUBLE PRECISION,DIMENSION(NCO,NO1NAC)::BB
!-----------------------------------------------------------------------
      do i=I1+1,NCO
       do ip=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        IOCU(i)=ip
        Di = -DD*BB(i,ip)
        IF(DABS(Di)>THAPSG)THEN
         WRITE(9,1)Di,(IOCU(ii),-IOCU(ii),ii=1,NCO)
         SUMA = SUMA + Di*Di
        ENDIF
        IOCU(i) = i
       enddo
      enddo
!-----------------------------------------------------------------------
    1 FORMAT(F20.16,2X,99I4)
      RETURN
      END

! OddNCO
      SUBROUTINE OddNCO(I1,I2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,DD,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NO1NAC)::IOCU
      DOUBLE PRECISION,DIMENSION(NCO,NO1NAC)::BB
!-----------------------------------------------------------------------
      do i=I1+1,I2-2
       do ip=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        IOCU(i) = ip
        Di = -DD*BB(i,ip)
        CALL EvenNCO(i,I2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,Di,THAPSG)
        IOCU(i) = i
       enddo
      enddo
!-----------------------------------------------------------------------
      RETURN
      END

! EvenNCO
      SUBROUTINE EvenNCO(I1,I2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,DD,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NO1NAC)::IOCU
      DOUBLE PRECISION,DIMENSION(NCO,NO1NAC)::BB
!-----------------------------------------------------------------------
      do i=I1+1,I2-1
       do ip=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        IOCU(i) = ip
        Di = -DD*BB(i,ip)
        if(I2==NCO)then
         CALL OneNCO(i,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,Di,THAPSG)
        else
         CALL OddNCO(i,I2+2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,Di,THAPSG)
        endif
        IOCU(i) = i
       enddo
      enddo
!-----------------------------------------------------------------------
      RETURN
      END

! CHEMPOTrc
      SUBROUTINE CHEMPOTrc(HCORE,QJ,QK,RO,DIPx,DIPy,DIPz)
!-----------------------------------------------------------------------
!     This subroutine is called when ICHEMPOT = 1 for PNOF5 and PNOF7
!-----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPNOF_STATIC/Ista
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
!
      DOUBLE PRECISION,DIMENSION(NBF5)::HCORE,RO,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      ALLOCATABLE::CMIU(:),DCJ12DRO(:,:),DCK12DRO(:,:)
!-----------------------------------------------------------------------
      ALLOCATE (DCJ12DRO(NBF5,NBF5),DCK12DRO(NBF5,NBF5))
      DCJ12DRO = 0.0d0
      DCK12DRO = 0.0d0
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!                      Inter-pair interactions
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(IPNOF==5)THEN                 ! PNOF5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=1,NBF5
        DO i=1,NBF5
         DCJ12DRO(j,i) = 2.0d0*RO(i)
         DCK12DRO(j,i) = RO(i)
        ENDDO
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
      ELSE IF(IPNOF==7)THEN            ! PNOF7
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       if(Ista==0)then
        DO j=1,NBF5
         DO i=1,NBF5
          DCJ12DRO(j,i) = 2.0d0*RO(i)
          FIj = DSQRT(RO(j)*(1.0d0-RO(j)))
          IF(FIj/=0.0d0)THEN          
           DCK12DRO(j,i) = RO(i)                                        &
                         + (0.5d0-RO(j))*DSQRT(RO(i)*(1.0d0-RO(i)))/FIj  
          ENDIF                                                          
         ENDDO                                                           
        ENDDO                                                            
       else if(Ista==1)then                                              
        DO j=1,NBF5                                                      
         DO i=1,NBF5                                                     
          DCJ12DRO(j,i) = 2.0d0*RO(i)                                    
          DCK12DRO(j,i) = RO(i)                                         &
                        + 4.0d0*(1.0d0-2.0d0*RO(j))*RO(i)*(1.0d0-RO(i))
         ENDDO
        ENDDO
       end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      END IF       
!      
      if(MSpin==0.and.NSOC>1)then                     
       DO j=NB+1,NA
        DO i=NB+1,NA
         DCK12DRO(j,i) = 2.0d0*RO(i)        
        ENDDO      
       ENDDO
      endif
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!                      Intra-pair interactions
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     below-above Fermi level interaction
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NDOC
       jn = NO1+j
       DO i=NDNS+NCWO*(NDOC-j)+1,NDNS+NCWO*(NDOC-j+1)
        in = NO1+i
        DCJ12DRO(jn,in) = 0.0d0
        DCJ12DRO(in,jn) = 0.0d0
        IF(RO(jn)/=0.0d0)THEN
         DCK12DRO(jn,in) = DSQRT(RO(in))/(2.0*DSQRT(RO(jn)))
        ELSE
         DCK12DRO(jn,in) = 0.0d0
        ENDIF
        IF(RO(in)/=0.0d0)THEN
         DCK12DRO(in,jn) = DSQRT(RO(jn))/(2.0*DSQRT(RO(in)))
        ELSE
         DCK12DRO(in,jn) = 0.0d0
        ENDIF
       ENDDO
      ENDDO
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     above-above Fermi level interaction for each geminal 'l'
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO l=1,NDOC
       DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        jn = NO1+j
        DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         in = NO1+i
         DCJ12DRO(jn,in) = 0.0d0
         IF(RO(jn)/=0.0d0)THEN
          DCK12DRO(jn,in) = - DSQRT(RO(in))/(2.0*DSQRT(RO(jn)))
         ELSE
          DCK12DRO(jn,in) = 0.0d0
         ENDIF
        ENDDO
       ENDDO
      ENDDO
!-----------------------------------------------------------------------      
!     Chemical Potential for each subspace      
!-----------------------------------------------------------------------
      ALLOCATE (CMIU(NBF5))
!
      DO j=1,NDOC
       jn = NO1+j      
       jj = jn*(jn+1)/2
       CMIU(jn) = HCORE(jn) + QJ(jj)/2.0 + PRODCWQWj(jn,DCJ12DRO,QJ)    &
                                         - PRODCWQWj(jn,DCK12DRO,QK)     
      ENDDO                                                              
      IF(MSpin==0.and.NSOC>1)THEN                                        
       DO j=NDOC+1,NDNS                                                  
        jn = NO1+j                                                       
        jj = jn*(jn+1)/2                                                 
        CMIU(jn) = HCORE(jn) + PRODCWQWj(jn,DCJ12DRO,QJ)                &
                             - PRODCWQWj(jn,DCK12DRO,QK)
       ENDDO
      ENDIF       
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Including Electric Field
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EFIELDL)THEN
       DO j=1,NDNS
        jn = NO1+j      
        CMIU(jn) = CMIU(jn) - (EX*DIPX(jn)+EY*DIPY(jn)+EZ*DIPZ(jn))
       ENDDO
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      write(6,'(/,11X,A19,/)')'Chemical Potentials'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      DO j=1,NDNS
!       jn = NO1+j      
!       write(6,'(I6,2F19.6)')jn,CMIU(jn),CMIU(jn)*27.21138386
!      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CHEPOT = -1.0d10
      DO j=1,NDNS
       jn = NO1+j
       if(CMIU(jn)>CHEPOT)CHEPOT=CMIU(jn)
      ENDDO
      write(6,1)CHEPOT,CHEPOT*27.21138386             
!-----------------------------------------------------------------------
    1 FORMAT(/,3X,'Chemical Potential =',F10.4,2X,'(',F10.4,1X,'eV )')
      DEALLOCATE (CMIU,DCJ12DRO,DCK12DRO)
      RETURN
      END

! OUTPUTCJKrc
      SUBROUTINE OUTPUTCJKrc(RO,CJ12,CK12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_CJK/NOUTCJK,NTHRESHCJK,THRESHCJK      
      COMMON/INPNOF_Tijab/NOUTTijab,NTHRESHTijab,THRESHTijab      
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::BETA,FIs
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::CK12nd
!----------------------------------------------------------------------- 
!     Print CJ12 and -CK12
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,NBF5
       if(RO(i)>THRESHCJK)WRITE(12)i,i,i,i,RO(i)    ! CLii = CJii
       DO j=1,i-1
        if(DABS(CJ12(i,j))>THRESHCJK)then
         WRITE(12)i,j,i,j,CJ12(i,j)
         WRITE(12)j,i,j,i,CJ12(i,j)
        end if
        if(DABS(CK12(i,j))>THRESHCJK)then            ! Print -CK12
         WRITE(12)i,j,j,i,-CK12(i,j)
         WRITE(12)j,i,i,j,-CK12(i,j)
        end if
       ENDDO
      ENDDO
      WRITE(12)0,0,0,0,0.0d0
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!                   CK12nd: Non-Dynamic (Static) CK12
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(NOUTTijab==1)THEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       ALLOCATE(FIs(NBF5),BETA(NBF5),CK12nd(NBF5,NBF5))
       FIs = 0.0d0
       BETA = 0.0d0
       CK12nd = 0.0d0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      FIs(j)  = 2*RO(j)*HOLE(j)
!      BETA(j) = DSQRT(2*HOLE(j)) * DSQRT(RO(j))
!      BETA(j) = DSQRT(2*RO(j))   * DSQRT(RO(j))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        FIs(j) = 2.0d0*RO(j)*(1.0d0-RO(j))
        Cj = 1.0d0 - DABS(1.0d0-2.0d0*RO(j))
        BETA(j) = DSQRT( Cj*RO(j) )
       ENDDO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      Inter-pair Non-Dynamic (Static) Electron Correlation
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        DO i=NO1+1,NBF5
         CK12nd(j,i) = FIs(j)*FIs(i)
        ENDDO
       ENDDO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      Intra-pair Non-Dynamic (Static) Electron Correlation
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      below-above Fermi level interaction
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=1,NDOC
        jn = NO1+j
        DO i=NDOC+NCWO*(NDOC-j)+1,NDOC+NCWO*(NDOC-j+1)
         in = NO1+i
         CK12nd(jn,in) = BETA(jn)*BETA(in)
         CK12nd(in,jn) = BETA(in)*BETA(jn)
        ENDDO
       ENDDO
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      above-above Fermi level interaction for each geminal 'l'
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO l=1,NDOC
        DO j=NDOC+NCWO*(NDOC-l)+1,NDOC+NCWO*(NDOC-l+1)
         jn = NO1+j
         DO i=NDOC+NCWO*(NDOC-l)+1,NDOC+NCWO*(NDOC-l+1)
          in = NO1+i
          CK12nd(jn,in) = - BETA(jn)*BETA(in)
         ENDDO
        ENDDO
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Print -CK12nd
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO i=1,NBF5
        DO j=1,i-1
         if(DABS(CK12nd(i,j))>THRESHCJK)then        
          WRITE(13)i,j,j,i,-CK12nd(i,j)
          WRITE(13)j,i,i,j,-CK12nd(i,j)
         end if
        ENDDO
       ENDDO
       WRITE(13)0,0,0,0,0.0d0       
       DEALLOCATE(FIs,BETA,CK12nd)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END IF
!-----------------------------------------------------------------------
      RETURN
      END

! OUTPUTTijab_rc
      SUBROUTINE OUTPUTTijab_rc(NOC,NVI,NN,Tijab)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_Tijab/NOUTTijab,NTHRESHTijab,THRESHTijab      
      DOUBLE PRECISION,DIMENSION(NN)::Tijab
!-----------------------------------------------------------------------  
      DO i=1,NOC
       DO j=1,NOC
         DO k=1,NVI
          ki = (k-1)*noc + i
          DO l=1,NVI
           ijkl =  i + (j-1)*noc + (k-1)*noc*noc + (l-1)*noc*noc*nvi
           ijlk =  i + (j-1)*noc + (l-1)*noc*noc + (k-1)*noc*noc*nvi
           TTijab = 2.0*Tijab(ijkl)-Tijab(ijlk)
           IF(DABS(TTijab)>THRESHTijab)THEN
            in = NO1+i
            jn = NO1+j
            kn = NO1+noc+k
            ln = NO1+noc+l
            WRITE(13)in,jn,kn,ln,TTijab
           ENDIF
          ENDDO
         ENDDO
       ENDDO
      ENDDO
      WRITE(13)0,0,0,0,0.0d0
!-----------------------------------------------------------------------
      RETURN
      END

! OUTPUTRDMrc
      SUBROUTINE OUTPUTRDMrc(OVERLAP,RO,QD,CJ12,CK12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPNOF_ARDM/THRESHDM,NOUTRDM,NSQT,NTHRESHDM      
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      ALLOCATABLE::IDXD(:),BUFD(:)
!-----------------------------------------------------------------------
!     2DM
!-----------------------------------------------------------------------
      LBUFDM = 10000       ! Length of buffer for Density Matrix values
      IF(NSQT==1)THEN
!      ifort -i8 in PNOF, MAX=2**64-1, MAX_NBF=2**16-1=65535 !!!
       NSHI1=2**16
!      NSH2=2**32
       NSHI2=NSHI1*NSHI1
!      NSH3=2**48
       NSHI3=NSHI2*NSHI1
       ALLOCATE (IDXD(LBUFDM),BUFD(LBUFDM))
       NBINT=0
       NREC=0
       DO IETA=1,NBF
        DO IMIU=1,NBF
         DO INIU=1,NBF
          DO ILAM=1,NBF
           RDM2 = SUMDDL(IETA,IMIU,INIU,ILAM,RO,QD,CJ12,CK12)
           IF(DABS(RDM2)>THRESHDM)THEN
            NBINT=NBINT+1
!           CHANGE INDEXES ( IMIU <-> INIU ) for Ugalde's Program
            IDXD(NBINT)=NSHI3*IETA+NSHI2*INIU+NSHI1*IMIU+ILAM
            BUFD(NBINT)=RDM2
!           Write: IDXD(IETA,INIU,IMIU,ILAM) ; BUFD(RDM2)
            IF(NBINT==LBUFDM)THEN
             WRITE(14)NBINT,(IDXD(M),M=1,NBINT),(BUFD(M),M=1,NBINT)
             NBINT=0
             NREC=NREC+1
            ENDIF
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
!      Write the last record on file 14
       IF(NBINT/=0)THEN
        WRITE(14)NBINT,(IDXD(M),M=1,NBINT),(BUFD(M),M=1,NBINT)
        NREC=NREC+1
       ENDIF
!      Total number of written integrals
       NBINT=NBINT+(NREC-1)*LBUFDM
!      Write the number of records and 2DMS
       WRITE(16,3)NREC,NBINT
       DEALLOCATE (IDXD,BUFD)
      ELSEIF(NSQT==0)THEN
       DO IETA=1,NBF
        DO IMIU=1,NBF
         DO INIU=1,NBF
          DO ILAM=1,NBF
           RDM2 = SUMDDL(IETA,IMIU,INIU,ILAM,RO,QD,CJ12,CK12)
           IF(DABS(RDM2)>THRESHDM)THEN
!           Change indexes ( IMIU <-> INIU ) for Ugalde's Program
!           WRITE(14,1)IETA,INIU,IMIU,ILAM,RDM2
            WRITE(14,1)IETA,IMIU,INIU,ILAM,RDM2
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
!     1DM
!-----------------------------------------------------------------------
      DO IETA=1,NBF
       DO IMIU=1,NBF
        RDM1 = SUMDL(IETA,IMIU,RO,QD)
        IF(DABS(RDM1)>THRESHDM)THEN
         WRITE(15,2)IETA,IMIU,RDM1
        ENDIF
       ENDDO
      ENDDO
!     Check the normalization of the 2RDM
      CALL RDM1NORM(OVERLAP,RO,QD)
      CALL RDM2NORM(OVERLAP,RO,QD,CJ12,CK12)
!-----------------------------------------------------------------------
1     FORMAT(4I4,D20.10)
2     FORMAT(2I4,D20.10)
3     FORMAT(I4,I20)
      RETURN
      END
  
! SUMDDL (2RDM)
      FUNCTION SUMDDL(IETA,IMIU,INIU,ILAM,RO,QD,CJ12,CK12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPNOF_ARDM/THRESHDM,NOUTRDM,NSQT,NTHRESHDM      
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      ALLOCATABLE::Dj(:,:),Di(:,:)
      ALLOCATE (Dj(NBF,NBF),Di(NBF,NBF))
!-----------------------------------------------------------------------
      SUMDDL=0.0d0
      DO j=1,NBF5
       Dj = QD(j,1:NBF,1:NBF)
       DO i=1,NBF5
        Di = QD(i,1:NBF,1:NBF)
        IF(i==j)THEN
         SUMDDL = SUMDDL + RO(j)*Dj(IETA,INIU)*Di(IMIU,ILAM)
        ELSE
         SUMDDL = SUMDDL + CJ12(j,i)*Dj(IETA,INIU)*Di(IMIU,ILAM)        &
                         - CK12(j,i)*Dj(IETA,ILAM)*Di(IMIU,INIU)        
!L                       - CK12(j,i)*Dj(IETA,IMIU)*Di(INIU,ILAM)
        ENDIF
       ENDDO
      ENDDO
      DO j=NB+1,NA
       Dj = QD(j,1:NBF,1:NBF)
       SUMDDL = SUMDDL - RO(j)*Dj(IETA,INIU)*Dj(IMIU,ILAM)
      ENDDO
      
      SUMDDL = SUMDDL/4.0d0
      IF(DABS(SUMDDL)<=THRESHDM)SUMDDL = 0.0d0
      DEALLOCATE (Dj,Di)
!-----------------------------------------------------------------------
      RETURN
      END

! SUMDL (1RDM)
      FUNCTION SUMDL(IETA,IMIU,RO,QD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!-----------------------------------------------------------------------
      SUMDL=0.0d0
      DO J=1,NB
       SUMDL = SUMDL + RO(J) * QD(J,IETA,IMIU)
      ENDDO
      IF(NSOC>0)THEN
       DO J=NB+1,NA
       if(HighSpin)THEN
        SUMDL = SUMDL + 0.5d0 * RO(J) * QD(J,IETA,IMIU)
       else
        SUMDL = SUMDL + RO(J) * QD(J,IETA,IMIU)
       endif
       ENDDO
      ENDIF
      DO J=NA+1,NBF5
       SUMDL = SUMDL + RO(J) * QD(J,IETA,IMIU)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! RDM1NORM
      SUBROUTINE RDM1NORM(S,RO,QD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::S
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!-----------------------------------------------------------------------
      SUMNORM=0.0d0
      DO IETA=1,NBF
       DO IMIU=1,IETA
        SUMNORM=SUMNORM+2.0*S(IETA,IMIU)*SUMDL(IETA,IMIU,RO,QD)
       ENDDO
       SUMNORM=SUMNORM-S(IETA,IETA)*SUMDL(IETA,IETA,RO,QD)
      ENDDO
      WRITE(6,1)SUMNORM
!-----------------------------------------------------------------------     
1     FORMAT(/' RDM Norms ',/,                                          &
              ' ---------  ',//,1X,'1RDM Norm =',F7.3)
      RETURN
      END

! RDM2NORM
      SUBROUTINE RDM2NORM(S,RO,QD,CJ12,CK12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::S
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!-----------------------------------------------------------------------
      TWONORMA=0.D0
      DO I=1,NBF
       DO K=1,I
        DO J=1,NBF
         DO L=1,J
          DENSITY = DENSI(I,J,K,L,RO,QD,CJ12,CK12)
          TWONORMA=TWONORMA+DENSITY*S(I,K)*S(J,L)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      WRITE(6,1)TWONORMA
1     FORMAT(1X,'2RDM Norm =',F7.3)
!-----------------------------------------------------------------------
      RETURN
      END

! DENSI
      DOUBLE PRECISION FUNCTION DENSI(II,JJ,KK,LL,RO,QD,CJ12,CK12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!-----------------------------------------------------------------------
      IF((II==KK).AND.(JJ==LL))THEN
       DENSI=SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)
       RETURN
      ELSE IF((II==KK).AND.(JJ/=LL))THEN
       DENSI = SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)                      &
             + SUMDDL(ii,ll,kk,jj,RO,QD,CJ12,CK12)                       
       RETURN                                                            
      ELSE IF((II/=KK).AND.(JJ==LL))THEN                                 
       DENSI = SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)                      &
             + SUMDDL(kk,jj,ii,ll,RO,QD,CJ12,CK12)                       
       RETURN                                                            
      ELSE IF((II/=KK).AND.(JJ/=LL))THEN                                 
       DENSI = SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)                      &
             + SUMDDL(ii,ll,kk,jj,RO,QD,CJ12,CK12)                      &
             + SUMDDL(kk,jj,ii,ll,RO,QD,CJ12,CK12)                      &
             + SUMDDL(kk,ll,ii,jj,RO,QD,CJ12,CK12)
       RETURN
      ELSE
       WRITE(6,*)' *** ERROR IN DENSI SUBROUTINE ***'
       STOP
      END IF
!----------------------------------------------------------------------- 
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!             E L E C T R O S T A T I C     M O M E N T S              !
!                                                                      !
!      2015 Electrostatic dipole, quadrupole and octupole moments      !
!                                                                      !
!                     implemented by Ion Mitxelena                     !
!                                                                      !
!                 ( J. Chem. Phys. 144, 204108, 2016 )                 !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!   DIPMOMr:  Electronic, nuclear and total dipole moments             !
!   QUADMOMr: Electronic, nuclear and total quadrupole moments         !
!   OCTMOMr:  Electronic, nuclear and total octupole moments           !
!                                                                      !
!   PASSDIPUSER:  Pass atomic dipole matrices to USER(13,14,15,16)     !
!   PASSUSERDIP:  Pass USER(13,14,15,16) to atomic dipole matrices     !
!   PASSQUADUSER: Pass atomic quadrupole matrices to USER(18-24)       !
!   PASSUSERQUAD: Pass USER(18-24) to atomic quadrupole matrices       !
!   PASSOCTUSER:  Pass atomic octupole matrices to USER(31-41)         !
!   PASSUSEROCT:  Pass USER(31-41) to atomic octupole matrices         !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
                                                                       
! DIPMOMr
      SUBROUTINE DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,QD,RO, &
                         DM1e,DM2e,DM3e,DM1,DM2,DM3,DTOTAL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(3),INTENT(IN)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF),INTENT(IN)::QD
      DOUBLE PRECISION,INTENT(OUT)::DM1,DM2,DM3,DTOTAL
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX
!-----------------------------------------------------------------------
!     Electron Contribution to Dipole Moment
!-----------------------------------------------------------------------
      DM1e = 0.0
      DM2e = 0.0
      DM3e = 0.0
!
      ALLOCATE (AUX(NBF,NBF))
      DO J=1,NB
       AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL TRACEm(DIPx(J),AUX,ADIPx,NBF)
       DM1e = DM1e - 2.0*RO(J)*DIPx(J)
       CALL TRACEm(DIPy(J),AUX,ADIPy,NBF)
       DM2e = DM2e - 2.0*RO(J)*DIPy(J)
       CALL TRACEm(DIPz(J),AUX,ADIPz,NBF)
       DM3e = DM3e - 2.0*RO(J)*DIPz(J)
      ENDDO
!      
      IF(NSOC>0)THEN
       if(.not.HighSpin)then
        DO J=NB+1,NA
         AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
         CALL TRACEm(DIPx(J),AUX,ADIPx,NBF)
         DM1e = DM1e - 2.0*RO(J)*DIPx(J)
         CALL TRACEm(DIPy(J),AUX,ADIPy,NBF)
         DM2e = DM2e - 2.0*RO(J)*DIPy(J)
         CALL TRACEm(DIPz(J),AUX,ADIPz,NBF)
         DM3e = DM3e - 2.0*RO(J)*DIPz(J)
        ENDDO
       else if(HighSpin)then
        DO J=NB+1,NA
         AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
         CALL TRACEm(DIPx(J),AUX,ADIPx,NBF)
         DM1e = DM1e - RO(J)*DIPx(J)
         CALL TRACEm(DIPy(J),AUX,ADIPy,NBF)
         DM2e = DM2e - RO(J)*DIPy(J)
         CALL TRACEm(DIPz(J),AUX,ADIPz,NBF)
         DM3e = DM3e - RO(J)*DIPz(J)
        ENDDO
       end if      
      ENDIF
!       
      DO J=NA+1,NBF5
       AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL TRACEm(DIPx(J),AUX,ADIPx,NBF)
       DM1e = DM1e - 2.0*RO(J)*DIPx(J)
       CALL TRACEm(DIPy(J),AUX,ADIPy,NBF)
       DM2e = DM2e - 2.0*RO(J)*DIPy(J)
       CALL TRACEm(DIPz(J),AUX,ADIPz,NBF)
       DM3e = DM3e - 2.0*RO(J)*DIPz(J)
      ENDDO
      DEALLOCATE (AUX)
!-----------------------------------------------------------------------
!     Nuclear Contribution to Dipole Moment
!-----------------------------------------------------------------------
      DM1 = DIPN(1) + DM1e
      DM2 = DIPN(2) + DM2e
      DM3 = DIPN(3) + DM3e
!-----------------------------------------------------------------------
!     Total Dipole Moment
!-----------------------------------------------------------------------
      DTOTAL = SQRT(DM1*DM1+DM2*DM2+DM3*DM3)
      RETURN
!-----------------------------------------------------------------------
      END SUBROUTINE DIPMOMr

! QUADMOMr
      SUBROUTINE QUADMOMr(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,        &
                          AQUADxz,AQUADyz,QUADxx,QUADyy,QUADzz,QUADxy, &
                          QUADxz,QUADyz,QD,RO,QM1e,QM2e,QM3e,QM4e,QM5e, &
                          QM6e,QM1,QM2,QM3,QM4,QM5,QM6)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      INTEGER :: J
      DOUBLE PRECISION, DIMENSION(NBF,NBF,NBF), INTENT(IN) :: QD
      DOUBLE PRECISION, DIMENSION(NBF5), INTENT(IN) :: RO(NBF5)
      DOUBLE PRECISION, DIMENSION(6), INTENT(IN) :: QUADN
      DOUBLE PRECISION, DIMENSION(NBF,NBF), INTENT(IN) :: AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION, DIMENSION(NBF,NBF), INTENT(IN) :: AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION, DIMENSION(NBF5) :: QUADxx,QUADyy,QUADzz,QUADxy,QUADxz,QUADyz
      DOUBLE PRECISION, INTENT(OUT) :: QM1,QM2,QM3,QM4,QM5,QM6
      DOUBLE PRECISION :: QM1e,QM2e,QM3e,QM4e,QM5e,QM6e
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX
!-----------------------------------------------------------------------
!     Electron Contribution to Quadrupole Moment
!-----------------------------------------------------------------------
      QM1e=0.0d0
      QM2e=0.0d0
      QM3e=0.0d0
      QM4e=0.0d0
      QM5e=0.0d0
      QM6e=0.0d0
!
      ALLOCATE (AUX(NBF,NBF))
      DO J=1,NB
       AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL TRACEm(QUADxx(J),AUX,AQUADxx,NBF)
       QM1e = QM1e - 2.d0*RO(J)*QUADxx(J)
       CALL TRACEm(QUADyy(J),AUX,AQUADyy,NBF)
       QM2e = QM2e - 2.d0*RO(J)*QUADyy(J)
       CALL TRACEm(QUADzz(J),AUX,AQUADzz,NBF)
       QM3e = QM3e - 2.d0*RO(J)*QUADzz(J)
       CALL TRACEm(QUADxy(J),AUX,AQUADxy,NBF)
       QM4e = QM4e - 2.d0*RO(J)*QUADxy(J)
       CALL TRACEm(QUADxz(J),AUX,AQUADxz,NBF)
       QM5e = QM5e - 2.d0*RO(J)*QUADxz(J)
       CALL TRACEm(QUADyz(J),AUX,AQUADyz,NBF)
       QM6e = QM6e - 2.d0*RO(J)*QUADyz(J)
      END DO
!      
      IF(NSOC>0)THEN
       if(.not.HighSpin)then
        DO J=NB+1,NA
         AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
         CALL TRACEm(QUADxx(J),AUX,AQUADxx,NBF)
         QM1e = QM1e - 2.d0*RO(J)*QUADxx(J)
         CALL TRACEm(QUADyy(J),AUX,AQUADyy,NBF)
         QM2e = QM2e - 2.d0*RO(J)*QUADyy(J)
         CALL TRACEm(QUADzz(J),AUX,AQUADzz,NBF)
         QM3e = QM3e - 2.d0*RO(J)*QUADzz(J)
         CALL TRACEm(QUADxy(J),AUX,AQUADxy,NBF)
         QM4e = QM4e - 2.d0*RO(J)*QUADxy(J)
         CALL TRACEm(QUADxz(J),AUX,AQUADxz,NBF)
         QM5e = QM5e - 2.d0*RO(J)*QUADxz(J)
         CALL TRACEm(QUADyz(J),AUX,AQUADyz,NBF)
         QM6e = QM6e - 2.d0*RO(J)*QUADyz(J)
        END DO
       else if(HighSpin)then        
        DO J=NB+1,NA
         AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
         CALL TRACEm(QUADxx(J),AUX,AQUADxx,NBF)
         QM1e = QM1e - RO(J)*QUADxx(J)
         CALL TRACEm(QUADyy(J),AUX,AQUADyy,NBF)
         QM2e = QM2e - RO(J)*QUADyy(J)
         CALL TRACEm(QUADzz(J),AUX,AQUADzz,NBF)
         QM3e = QM3e - RO(J)*QUADzz(J)
         CALL TRACEm(QUADxy(J),AUX,AQUADxy,NBF)
         QM4e = QM4e - RO(J)*QUADxy(J)
         CALL TRACEm(QUADxz(J),AUX,AQUADxz,NBF)
         QM5e = QM5e - RO(J)*QUADxz(J)
         CALL TRACEm(QUADyz(J),AUX,AQUADyz,NBF)
         QM6e = QM6e - RO(J)*QUADyz(J)
        END DO
       end if
      END IF
!
      DO J=NA+1,NBF5
       AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL TRACEm(QUADxx(J),AUX,AQUADxx,NBF)
       QM1e = QM1e - 2.d0*RO(J)*QUADxx(J)
       CALL TRACEm(QUADyy(J),AUX,AQUADyy,NBF)
       QM2e = QM2e - 2.d0*RO(J)*QUADyy(J)
       CALL TRACEm(QUADzz(J),AUX,AQUADzz,NBF)
       QM3e = QM3e - 2.d0*RO(J)*QUADzz(J)
       CALL TRACEm(QUADxy(J),AUX,AQUADxy,NBF)
       QM4e = QM4e - 2.d0*RO(J)*QUADxy(J)
       CALL TRACEm(QUADxz(J),AUX,AQUADxz,NBF)
       QM5e = QM5e - 2.d0*RO(J)*QUADxz(J)
       CALL TRACEm(QUADyz(J),AUX,AQUADyz,NBF)
       QM6e = QM6e - 2.d0*RO(J)*QUADyz(J)
      END DO
      DEALLOCATE (AUX)
!-----------------------------------------------------------------------
!     Add Nuclear Contribution to Quadrupole Moment
!-----------------------------------------------------------------------
      QM1e = QUADN(1) + QM1e
      QM2e = QUADN(2) + QM2e
      QM3e = QUADN(3) + QM3e
      QM4e = QUADN(4) + QM4e
      QM5e = QUADN(5) + QM5e
      QM6e = QUADN(6) + QM6e
!-----------------------------------------------------------------------
!     Form Quadrupole Tensor (BUCKINHAM)
!-----------------------------------------------------------------------
      QM1 = 0.5D0*(QM1e + QM1e - QM2e - QM3e)
      QM2 = 0.5D0*(QM2e + QM2e - QM1e - QM3e)
      QM3 = 0.5D0*(QM3e + QM3e - QM1e - QM2e)
      QM4 = 1.5D0*QM4e
      QM5 = 1.5D0*QM5e
      QM6 = 1.5D0*QM6e
!-----------------------------------------------------------------------    
      RETURN
      END SUBROUTINE QUADMOMr

! OCTMOMr
      SUBROUTINE OCTMOMr(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,                 &
                         AOCTxxy,AOCTxxz,AOCTxyy,AOCTyyz,AOCTxzz,       &
                         AOCTyzz,AOCTxyz,OCTxxx,OCTyyy,OCTzzz,          &
                         OCTxxy,OCTxxz,OCTxyy,OCTyyz,OCTxzz,            &
                         OCTyzz,OCTxyz,                                 &
                         QD,RO,OMXXXe,OMYYYe,OMZZZe,                    &
                         OMXXYe,OMXXZe,OMXYYe,OMYYZe,OMXZZe,            &
                         OMYZZe,OMXYZe,OXXX,OYYY,OZZZ,                  &
                         OXXY,OXXZ,OXYY,OYYZ,OXZZ,                      &
                         OYZZ,OXYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      INTEGER :: J
      DOUBLE PRECISION, DIMENSION(NBF,NBF,NBF), INTENT(IN) :: QD
      DOUBLE PRECISION, DIMENSION(NBF5), INTENT(IN) :: RO(NBF5)
      DOUBLE PRECISION, DIMENSION(10), INTENT(IN) :: OCTUN(10)
      DOUBLE PRECISION, DIMENSION(NBF,NBF), INTENT(IN) :: AOCTxxx,AOCTyyy,AOCTzzz
      DOUBLE PRECISION, DIMENSION(NBF,NBF), INTENT(IN) :: AOCTxyy,AOCTyyz,AOCTxzz
      DOUBLE PRECISION, DIMENSION(NBF,NBF), INTENT(IN) :: AOCTxxy,AOCTxxz
      DOUBLE PRECISION, DIMENSION(NBF,NBF), INTENT(IN) :: AOCTyzz,AOCTxyz
      DOUBLE PRECISION, DIMENSION(NBF5) :: OCTxxx,OCTyyy,OCTzzz,OCTxxy,OCTxxz
      DOUBLE PRECISION, DIMENSION(NBF5) :: OCTxyy,OCTyyz,OCTxzz,OCTyzz,OCTxyz
      DOUBLE PRECISION :: OMXXXe,OMYYYe,OMZZZe,OMXXYe,OMXXZe
      DOUBLE PRECISION :: OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe
      DOUBLE PRECISION, INTENT(OUT) :: OXXX,OYYY,OZZZ,OXXY,OXXZ
      DOUBLE PRECISION, INTENT(OUT) :: OXYY,OYYZ,OXZZ,OYZZ,OXYZ
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX
!-----------------------------------------------------------------------
!     Electron Contribution to Quadrupole Moment
!-----------------------------------------------------------------------
      OMXXXe=0.0d0
      OMYYYe=0.0d0
      OMZZZe=0.0d0
      OMXXYe=0.0d0
      OMXXZe=0.0d0
      OMXYYe=0.0d0
      OMYYZe=0.0d0
      OMXZZe=0.0d0
      OMYZZe=0.0d0
      OMXYZe=0.0d0
!
      ALLOCATE (AUX(NBF,NBF))
      DO J=1,NB
        AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
        CALL TRACEm(OCTxxx(J),AUX,AOCTxxx,NBF)
        OMXXXe = OMXXXe - 2.d0*RO(J)*OCTxxx(J)
        CALL TRACEm(OCTyyy(J),AUX,AOCTyyy,NBF)
        OMYYYe = OMYYYe - 2.d0*RO(J)*OCTyyy(J)
        CALL TRACEm(OCTzzz(J),AUX,AOCTzzz,NBF)
        OMZZZe = OMZZZe - 2.d0*RO(J)*OCTzzz(J)
        CALL TRACEm(OCTxxy(J),AUX,AOCTxxy,NBF)
        OMXXYe = OMXXYe - 2.d0*RO(J)*OCTxxy(J)
        CALL TRACEm(OCTxxz(J),AUX,AOCTxxz,NBF)
        OMXXZe = OMXXZe - 2.d0*RO(J)*OCTxxz(J)
        CALL TRACEm(OCTxyy(J),AUX,AOCTxyy,NBF)
        OMXYYe = OMXYYe - 2.d0*RO(J)*OCTxyy(J)
        CALL TRACEm(OCTyyz(J),AUX,AOCTyyz,NBF)
        OMYYZe = OMYYZe - 2.d0*RO(J)*OCTyyz(J)
        CALL TRACEm(OCTxzz(J),AUX,AOCTxzz,NBF)
        OMXZZe = OMXZZe - 2.d0*RO(J)*OCTxzz(J)
        CALL TRACEm(OCTyzz(J),AUX,AOCTyzz,NBF)
        OMYZZe = OMYZZe - 2.d0*RO(J)*OCTyzz(J)
        CALL TRACEm(OCTxyz(J),AUX,AOCTxyz,NBF)
        OMXYZe = OMXYZe - 2.d0*RO(J)*OCTxyz(J)
      END DO
!      
      IF(NSOC>0)THEN
       if(.not.HighSpin)then
        DO J=NB+1,NA
          AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
          CALL TRACEm(OCTxxx(J),AUX,AOCTxxx,NBF)
          OMXXXe = OMXXXe - 2.d0*RO(J)*OCTxxx(J)
          CALL TRACEm(OCTyyy(J),AUX,AOCTyyy,NBF)
          OMYYYe = OMYYYe - 2.d0*RO(J)*OCTyyy(J)
          CALL TRACEm(OCTzzz(J),AUX,AOCTzzz,NBF)
          OMZZZe = OMZZZe - 2.d0*RO(J)*OCTzzz(J)
          CALL TRACEm(OCTxxy(J),AUX,AOCTxxy,NBF)
          OMXXYe = OMXXYe - 2.d0*RO(J)*OCTxxy(J)
          CALL TRACEm(OCTxxz(J),AUX,AOCTxxz,NBF)
          OMXXZe = OMXXZe - 2.d0*RO(J)*OCTxxz(J)
          CALL TRACEm(OCTxyy(J),AUX,AOCTxyy,NBF)
          OMXYYe = OMXYYe - 2.d0*RO(J)*OCTxyy(J)
          CALL TRACEm(OCTyyz(J),AUX,AOCTyyz,NBF)
          OMYYZe = OMYYZe - 2.d0*RO(J)*OCTyyz(J)
          CALL TRACEm(OCTxzz(J),AUX,AOCTxzz,NBF)
          OMXZZe = OMXZZe - 2.d0*RO(J)*OCTxzz(J)
          CALL TRACEm(OCTyzz(J),AUX,AOCTyzz,NBF)
          OMYZZe = OMYZZe - 2.d0*RO(J)*OCTyzz(J)
          CALL TRACEm(OCTxyz(J),AUX,AOCTxyz,NBF)
          OMXYZe = OMXYZe - 2.d0*RO(J)*OCTxyz(J)
        END DO
       else if(HighSpin)then
        DO J=NB+1,NA
          AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
          CALL TRACEm(OCTxxx(J),AUX,AOCTxxx,NBF)
          OMXXXe = OMXXXe - RO(J)*OCTxxx(J)
          CALL TRACEm(OCTyyy(J),AUX,AOCTyyy,NBF)
          OMYYYe = OMYYYe - RO(J)*OCTyyy(J)
          CALL TRACEm(OCTzzz(J),AUX,AOCTzzz,NBF)
          OMZZZe = OMZZZe - RO(J)*OCTzzz(J)
          CALL TRACEm(OCTxxy(J),AUX,AOCTxxy,NBF)
          OMXXYe = OMXXYe - RO(J)*OCTxxy(J)
          CALL TRACEm(OCTxxz(J),AUX,AOCTxxz,NBF)
          OMXXZe = OMXXZe - RO(J)*OCTxxz(J)
          CALL TRACEm(OCTxyy(J),AUX,AOCTxyy,NBF)
          OMXYYe = OMXYYe - RO(J)*OCTxyy(J)
          CALL TRACEm(OCTyyz(J),AUX,AOCTyyz,NBF)
          OMYYZe = OMYYZe - RO(J)*OCTyyz(J)
          CALL TRACEm(OCTxzz(J),AUX,AOCTxzz,NBF)
          OMXZZe = OMXZZe - RO(J)*OCTxzz(J)
          CALL TRACEm(OCTyzz(J),AUX,AOCTyzz,NBF)
          OMYZZe = OMYZZe - RO(J)*OCTyzz(J)
          CALL TRACEm(OCTxyz(J),AUX,AOCTxyz,NBF)
          OMXYZe = OMXYZe - RO(J)*OCTxyz(J)
        END DO
       end if
      END IF
!       
      DO J=1,NBF5
        AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
        CALL TRACEm(OCTxxx(J),AUX,AOCTxxx,NBF)
        OMXXXe = OMXXXe - 2.d0*RO(J)*OCTxxx(J)
        CALL TRACEm(OCTyyy(J),AUX,AOCTyyy,NBF)
        OMYYYe = OMYYYe - 2.d0*RO(J)*OCTyyy(J)
        CALL TRACEm(OCTzzz(J),AUX,AOCTzzz,NBF)
        OMZZZe = OMZZZe - 2.d0*RO(J)*OCTzzz(J)
        CALL TRACEm(OCTxxy(J),AUX,AOCTxxy,NBF)
        OMXXYe = OMXXYe - 2.d0*RO(J)*OCTxxy(J)
        CALL TRACEm(OCTxxz(J),AUX,AOCTxxz,NBF)
        OMXXZe = OMXXZe - 2.d0*RO(J)*OCTxxz(J)
        CALL TRACEm(OCTxyy(J),AUX,AOCTxyy,NBF)
        OMXYYe = OMXYYe - 2.d0*RO(J)*OCTxyy(J)
        CALL TRACEm(OCTyyz(J),AUX,AOCTyyz,NBF)
        OMYYZe = OMYYZe - 2.d0*RO(J)*OCTyyz(J)
        CALL TRACEm(OCTxzz(J),AUX,AOCTxzz,NBF)
        OMXZZe = OMXZZe - 2.d0*RO(J)*OCTxzz(J)
        CALL TRACEm(OCTyzz(J),AUX,AOCTyzz,NBF)
        OMYZZe = OMYZZe - 2.d0*RO(J)*OCTyzz(J)
        CALL TRACEm(OCTxyz(J),AUX,AOCTxyz,NBF)
        OMXYZe = OMXYZe - 2.d0*RO(J)*OCTxyz(J)
      END DO
      DEALLOCATE (AUX)
!-----------------------------------------------------------------------
!     Nuclear Contribution to Quadrupole Moment
!-----------------------------------------------------------------------
      OMXXXe = OCTUN(1) + OMXXXe
      OMYYYe = OCTUN(2) + OMYYYe
      OMZZZe = OCTUN(3) + OMZZZe
      OMXXYe = OCTUN(4) + OMXXYe
      OMXXZe = OCTUN(5) + OMXXZe
      OMXYYe = OCTUN(6) + OMXYYe
      OMYYZe = OCTUN(7) + OMYYZe
      OMXZZe = OCTUN(8) + OMXZZe
      OMYZZe = OCTUN(9) + OMYZZe
      OMXYZe = OCTUN(10) + OMXYZe
!-----------------------------------------------------------------------
!     Form Octupole Tensor
!-----------------------------------------------------------------------
      OXXX = OMXXXe - 1.5D+00*OMXYYe - 1.5D+00*OMXZZe
      OYYY = OMYYYe - 1.5D+00*OMXXYe - 1.5D+00*OMYZZe
      OZZZ = OMZZZe - 1.5D+00*OMXXZe - 1.5D+00*OMYYZe
      OXXY = 2.0D+00*OMXXYe - 0.5D+00*OMYYYe - 0.5D+00*OMYZZe
      OXXZ = 2.0D+00*OMXXZe - 0.5D+00*OMYYZe - 0.5D+00*OMZZZe
      OXYY = 2.0D+00*OMXYYe - 0.5D+00*OMXXXe - 0.5D+00*OMXZZe
      OYYZ = 2.0D+00*OMYYZe - 0.5D+00*OMXXZe - 0.5D+00*OMZZZe
      OXZZ = 2.0D+00*OMXZZe - 0.5D+00*OMXXXe - 0.5D+00*OMXYYe
      OYZZ = 2.0D+00*OMYZZe - 0.5D+00*OMXXYe - 0.5D+00*OMYYYe
      OXYZ = 2.5D+00*OMXYZe
!-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE OCTMOMr

! PASSDIPUSER
      SUBROUTINE PASSDIPUSER(DIPN,ADIPx,ADIPy,ADIPz,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
!-----------------------------------------------------------------------
      CALL XtoX0(DIPN ,USER(N11),  3)
      CALL XtoX0(ADIPx,USER(N12),NSQ)
      CALL XtoX0(ADIPy,USER(N13),NSQ)
      CALL XtoX0(ADIPz,USER(N14),NSQ)
!-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE PASSDIPUSER

! PASSUSERDIP
      SUBROUTINE PASSUSERDIP(DIPN,ADIPx,ADIPy,ADIPz,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
!-----------------------------------------------------------------------
      CALL XtoX0(USER(N11),DIPN ,  3)
      CALL XtoX0(USER(N12),ADIPx,NSQ)
      CALL XtoX0(USER(N13),ADIPy,NSQ)
      CALL XtoX0(USER(N14),ADIPz,NSQ)
!-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE PASSUSERDIP

! PASSQUADUSER
      SUBROUTINE PASSQUADUSER(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy, &
                              AQUADxz,AQUADyz,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!      
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
!-----------------------------------------------------------------------
      CALL XtoX0(QUADN  ,USER(N18),  6)
      CALL XtoX0(AQUADxx,USER(N19),NSQ)
      CALL XtoX0(AQUADyy,USER(N20),NSQ)
      CALL XtoX0(AQUADzz,USER(N21),NSQ)
      CALL XtoX0(AQUADxy,USER(N22),NSQ)
      CALL XtoX0(AQUADxz,USER(N23),NSQ)
      CALL XtoX0(AQUADyz,USER(N24),NSQ)
!-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE PASSQUADUSER

! PASSUSERQUAD
      SUBROUTINE PASSUSERQUAD(QUADN,AQUADxx,AQUADyy,AQUADzz,         &
                                    AQUADxy,AQUADxz,AQUADyz,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
!-----------------------------------------------------------------------
      CALL XtoX0(USER(N18),QUADN  ,  6)
      CALL XtoX0(USER(N19),AQUADxx,NSQ)
      CALL XtoX0(USER(N20),AQUADyy,NSQ)
      CALL XtoX0(USER(N21),AQUADzz,NSQ)
      CALL XtoX0(USER(N22),AQUADxy,NSQ)
      CALL XtoX0(USER(N23),AQUADxz,NSQ)
      CALL XtoX0(USER(N24),AQUADyz,NSQ)
!-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE PASSUSERQUAD

! PASSOCTUSER
      SUBROUTINE PASSOCTUSER(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,   &
                             AOCTxxz,AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz, &
                             AOCTxyz,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
!-----------------------------------------------------------------------
      CALL XtoX0(OCTUN  ,USER(N31), 10)
      CALL XtoX0(AOCTxxx,USER(N32),NSQ)
      CALL XtoX0(AOCTyyy,USER(N33),NSQ)
      CALL XtoX0(AOCTzzz,USER(N34),NSQ)
      CALL XtoX0(AOCTxxy,USER(N35),NSQ)
      CALL XtoX0(AOCTxxz,USER(N36),NSQ)
      CALL XtoX0(AOCTxyy,USER(N37),NSQ)
      CALL XtoX0(AOCTyyz,USER(N38),NSQ)
      CALL XtoX0(AOCTxzz,USER(N39),NSQ)
      CALL XtoX0(AOCTyzz,USER(N40),NSQ)
      CALL XtoX0(AOCTxyz,USER(N41),NSQ)
!-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE PASSOCTUSER

! PASSUSEROCT
      SUBROUTINE PASSUSEROCT(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,   &
                             AOCTxxz,AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz, &
                             AOCTxyz,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,   &
                          N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,  &
                          N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,  &
                          N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,  &
                          N47,N48,N49,N50,N51,NUSER
!
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
!-----------------------------------------------------------------------
      CALL XtoX0(USER(N31),OCTUN  , 10)
      CALL XtoX0(USER(N32),AOCTxxx,NSQ)
      CALL XtoX0(USER(N33),AOCTyyy,NSQ)
      CALL XtoX0(USER(N34),AOCTzzz,NSQ)
      CALL XtoX0(USER(N35),AOCTxxy,NSQ)
      CALL XtoX0(USER(N36),AOCTxxz,NSQ)
      CALL XtoX0(USER(N37),AOCTxyy,NSQ)
      CALL XtoX0(USER(N38),AOCTyyz,NSQ)
      CALL XtoX0(USER(N39),AOCTxzz,NSQ)
      CALL XtoX0(USER(N40),AOCTyzz,NSQ)
      CALL XtoX0(USER(N41),AOCTxyz,NSQ)
!-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE PASSUSEROCT

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                     Thermodynamic Properties                         !
!                                                                      !
!      2018 Thermodynamic Properties implemented by Xabier Lopez       ! 
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! THERMO    
      SUBROUTINE THERMO(NC1,NROTRA,FREQ,Cxyz,ZMASS,ISIGMA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
!
!     THE FORMULAE USED HERE ARE BASED ON
!     OF 'MOLECULAR THERMODYNAMICS' BY McQuarrie
!
!     INPUT: NC1: number of coordinates 3*NATOMS 
!            FREQ(C1): Vibrational Frequencies
!            NROTRA: number of rotations and translations
!            Cxyz: Atom coordinates
!            ZMASS: Mass of the atoms
!            ISIGMA: Rotational symm number
!     OUTPUT: Thermochemistry is written in CGO file (11)
!
      INTEGER, INTENT(IN) :: NC1,ISIGMA
      INTEGER, INTENT(IN) :: NROTRA
      DOUBLE PRECISION,DIMENSION(NC1),INTENT(IN) :: FREQ, Cxyz
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN) :: ZMASS
      DOUBLE PRECISION, DIMENSION(NC1) :: THETA,ZPVE,QVIB,SVIB,EVIB
      DOUBLE PRECISION, DIMENSION(3) :: VMOI,CMASS
      DOUBLE PRECISION, DIMENSION(NATOMS)   :: ZMS(NATOMS)
      DOUBLE PRECISION, DIMENSION(3,NATOMS) :: CC,COM

      LOGICAL LINEAR
      DOUBLE PRECISION KT,JPCAL
!
      PARAMETER (PLANCK=6.62606957D-34, BOLTZ=1.38064852D-23,           &
                 PASCAL=1.01325D+05,                                    &
                 AVOGAD=6.022140857D+23, TOANGS=0.52917724924D+00,      &
                 JPCAL=4.184D+00, CLIGHT=2.99792458D+08,                &
                 TOCM=2.194746D+05, TOKCAL=627.51D+00,                  &
                 TWO=2.0D+00, ONEPT5=1.5D+00, TWOPT5=2.5D+00,           &
                 ONE=1.0D+00, ZERO=0.0D+00,   TM3=1.0D-03,              &
                 EIGHT=8.0D+00, RMASSU=1.660539040D-27)
     
!     Definition of some constants and parameters 
      TEMP = 298.0 
      SCLFAC = ONE ! Posibility to scale the frequencies 
      PI = ACOS(-ONE)
      P = PASCAL
      R = BOLTZ * AVOGAD
      RKCAL = R/(JPCAL*1.0D03)
      KT = BOLTZ * TEMP
      RT = R * TEMP
      RTKCAL=RT/(JPCAL*1.0D03)
      BOHR = 5.29177249D-11
      CATOM = 12.011D+00
!
!     LOAD -CC- AND -ZMS- WITH COORDINATES AND MASSES ---
!     COMPUTING ALSO TOTAL MASS OF THE SYSTEM ZMASST
!
      DO I=1,NATOMS
         CC(1,I) = Cxyz(3*(I-1)+1)
         CC(2,I) = Cxyz(3*(I-1)+2)
         CC(3,I) = Cxyz(3*(I-1)+3)
         ZMS(I) = ZMASS(I)
      END DO
      CALL CENMASd(NATOMS,CC,COM,ZMASST,CMASS,ZMASS)

!     ----- ELECTRONIC -----
!     SINCE THE EXCITATION TO EXCITED STATES IS UNKNOWN, AND WE ALSO
!     KNOW NOTHING ABOUT SPIN-ORBIT SPLITTINGS, WE ASSUME THAT ONLY
!     ONE ELECTRONIC STATE CONTRIBUTES TO THE PARTITION FUNCTION.
!     IN ADDITION, SINCE WE DON'T KNOW WHAT THE SPATIAL DEGENERACY OF
!     THIS STATE IS, WE TAKE THE ELECTRONIC DEGENERATCY TO BE JUST
!     THE SPIN MULTIPLICITY.
!
      QELEC = MUL
      QELOG = LOG(QELEC)
      HELEC = EELEC ! EELEC is taken from the NOF calculation 
!
      SELEC = RKCAL*QELOG
      GELEC = HELEC - TEMP * SELEC /TOKCAL ! in a.u.
!
!     ----- TRANSLATION -----
!
!     qtrans = ((2*pi*M*kBT/h**2)**3/2)*V 
!            = (2*pi*M*kBT/h**2)**3/2*kbT/P
!            = ((2Pi)**3/2*(kBT)**5/2*M**3/2)/P
!
      FTRAN=(KT**2.5D+00/AVOGAD**1.5D+00)/PLANCK**3.0D+00 
      FTRAN=(1.0D+00/P)*FTRAN*(2.0D+00*PI)**1.5D+00 ! All in S.I. units
      QTRAN=FTRAN*(TM3*ZMASST)**1.5D+00

      WEIGHT = TM3 * ZMASST / AVOGAD
      TTEMP = TWO*PI*(WEIGHT/PLANCK)*(KT/PLANCK)
      QTRAN = TTEMP**ONEPT5 * KT/P

      QTLOG =DLOG(QTRAN)
      ETRAN = ONEPT5 * RTKCAL
      HTRAN = TWOPT5 * RTKCAL
      STRAN = RKCAL * (QTLOG + TWOPT5)
      GTRAN = HTRAN - TEMP * STRAN
!
!     ----- ROTATION -----
!           
!
!     ----- SET UP FOR POSSIBLE MONATOMIC -----
!
      IF(NATOMS.EQ.1) THEN
         QROT = ONE
         QRLOG = ZERO
         EROT = ZERO
         HROT = ZERO
         CVROT = ZERO
         CPROT = ZERO
         SROT = ZERO
         GROT = ZERO
         QVIB = ONE
         QVLOG = ZERO
         EVIB = ZERO
         HVIB = ZERO
         CVVIB = ZERO
         CPVIB = ZERO
         SVIB = ZERO
         GVIB = ZERO
         GO TO 700
      END IF
!
!     THE ROTATIONAL SYMMETRY NUMBER SHOULD BE SET CORRECTLY
!     C1    1
!     Cs    1  
!     C2    2 
!     C2v   2 
!     C3v   3 
!     Cv   1 
!     D2h   4  
!     D3h   6 
!     D5h  10 
!     Dh   2  
!     D3d   6 
!     Td   12 
!     Oh   24
!
!     At this time this is done through the input section since we 
!     do not consider symmetry in the program, there is the exception of
!     linear molecules, where we can easily detect whether there is a
!     center of symmetry (sigma=2) or not (sigma=1)
!
      SIGMA=DFLOAT(ISIGMA)

      CALL INRTIA(CC,COM,ZMS,VMOI,NATOMS)
      LINEAR = VMOI(1).LT.TM3
      IF(LINEAR) THEN
         SIGMA=ONE
         DO K=2,NATOMS
            IF(ABS(COM(1,1)+COM(1,K)).LT.TM3  .AND.                     &
               ABS(COM(2,1)+COM(2,K)).LT.TM3  .AND.                     &
               ABS(COM(3,1)+COM(3,K)).LT.TM3  .AND.                     &
               ZMS(1).EQ.ZMS(K)) SIGMA=TWO
         END DO
      END IF
      FACT1 = (CATOM*BOHR*BOHR)/(12.0D+03*AVOGAD)
      FACT2 = PLANCK/(8.0D+09*PI*PI)
      ACONST = ZERO
      BCONST = ZERO
      CCONST = ZERO
      IF(VMOI(1).GT.0.001D+00) ACONST = FACT2/(FACT1*VMOI(1))
      IF(VMOI(2).GT.0.001D+00) BCONST = FACT2/(FACT1*VMOI(2))
      IF(VMOI(3).GT.0.001D+00) CCONST = FACT2/(FACT1*VMOI(3))
      WRITE(11,9011) ACONST, BCONST, CCONST ! These are in G(HZ)

!     ROTATIONAL TEMPERATURES in K-1

      FTROT=4.79924466221135D-02             ! (h/kb)*10**9
      TROTA=FTROT*ACONST
      TROTB=FTROT*BCONST
      TROTC=FTROT*CCONST

      WRITE(11,9112) 'TROT(K): ', TROTA, TROTB, TROTC

      IF(LINEAR) THEN
       QROT = TEMP/(TROTC*SIGMA)
       QRLOG = LOG(QROT)
       EROT = RTKCAL
       SROT = RKCAL * (QRLOG + ONE)
      ELSE
       QROT =(SQRT(PI)/SIGMA)*((TEMP**1.5D0)/(DSQRT(TROTA*TROTB*TROTC)))
       QRLOG = LOG(QROT)
       EROT  = ONEPT5 * RTKCAL
       SROT = RKCAL * (QRLOG + ONEPT5)
      END IF
      HROT = EROT
      GROT = HROT - TEMP * SROT
!
!     ----- VIBRATION -----
!
      FACTHE=1.439773398663405D0 ! PLANCK*CLIGHT/BOLTZ*100 
                                 ! we apply to freq(cm-1)
				 ! to get the vib. temp. (K)
      DO I=1,NC1
         THETA(i)=FACTHE*FREQ(i)*SCLFAC
      END DO
      QVIBT = ZERO
      EVIBT = ZERO
      SVIBT = ZERO
      ZPVET = ZERO
      DO I=NROTRA+1,NC1
         IF(THETA(I).EQ.ZERO) THEN
            WRITE(11,9200) I
            CALL ABRT
         END IF
!        Prefactor is 0.5hc*Nav/JPCAL         
         ZPVE(i) = 1.430561440340379D0*FREQ(i)*1.0D-03 
         QVIB(i)=DEXP(-0.5D0*THETA(i)/TEMP)/                            &
              (1.0D0 - DEXP(-1.0D0*THETA(i)/TEMP))                       
         THETAT=THETA(i)/TEMP                                            
         SVIB(i)= RKCAL*((THETAT)/(DEXP(THETAT)-1.0D0) -                &
               DLOG(1-DEXP(-1.0D0*THETAT)))
         EVIB(i)=RKCAL*THETA(i)*(0.5D0+1.0D0/(DEXP(THETAT)-1.0D0))

         QVIBT = QVIBT + QVIB(I)
         SVIBT = SVIBT + SVIB(I)
         EVIBT = EVIBT + EVIB(I)
         ZPVET = ZPVET + ZPVE(I)
      END DO
      HVIBT=EVIBT
      GVIBT = HVIBT - TEMP * SVIBT

!
!     ----- TOTALS -----
!     Summing up Elec + Trans + Rot+ Vib
!
  700 CONTINUE
      QTOT = QELEC * QTRAN * QROT  * QVIBT
      WRITE(11,9071)
      WRITE(11,*) '####################################'
      WRITE(11,*) '#     THERMOCHEMISTRY ANALYSIS     #'
      WRITE(11,*) '####################################'
      write(11,9069) TEMP,SCLFAC
      WRITE(11,9071)
      WRITE(11,*)    '  Q   '
      WRITE(11,9080) 'ELEC. ',QELEC
      WRITE(11,9080) 'TRANS.',QTRAN
      WRITE(11,9081) 'ROT.  ',QROT,' with sigma ',SIGMA
      WRITE(11,9080) 'VIB.  ',QVIBT
      WRITE(11,9080) 'TOT.  ',QTOT

! 
!     thermal energies in kcal/mol
!
      WRITE(11,9090)
      WRITE(11,9100)
      WRITE(11,9110) 'TRANS.      ',ETRAN,HTRAN,GTRAN,STRAN*1.0D+03
      WRITE(11,9110) 'ROT.        ',EROT,HROT,GROT,SROT*1.0D+03
      WRITE(11,9110) 'VIB(Total)  ',EVIBT,HVIBT,GVIBT,SVIBT*1.0D+03
      WRITE(11,9114) 
      DO I=NROTRA+1,NC1
       WRITE(11,9113)I,FREQ(i),EVIB(i),SVIB(I)*1.0D+03 
      END DO   
!
!     Transforming to a.u. 
!
      ETRAN=ETRAN/TOKCAL
      HTRAN=HTRAN/TOKCAL
      GTRAN=GTRAN/TOKCAL

      EROT =EROT/TOKCAL
      HROT =HROT/TOKCAL
      GROT =GROT/TOKCAL

      ZPVET=ZPVET/TOKCAL
      EVIBT=EVIBT/TOKCAL
      HVIBT=HVIBT/TOKCAL
      GVIBT=GVIBT/TOKCAL

      CORRE = ETRAN + EROT + EVIBT
      CORRH = HTRAN + HROT + HVIBT
      CORRG = GTRAN + GROT + GVIBT
!
!  --- Final Results written to unit 100 ----
!
      WRITE(11,9071)
      WRITE(11,9101) 
      WRITE(11,9111) 'Zero-point correction                   =',ZPVET
      WRITE(11,9111) 'Thermal correction to Energy            =',CORRE
      WRITE(11,9111) 'Thermal correction to Enthalpy          =',CORRH
      WRITE(11,9111) 'Thermal correction to Gibbs Free Energy =',CORRG

      WRITE(11,9071)

      WRITE(11,9111) 'Ee + EN + ZPVE                   = ',             &
                       EELEC+EN+ZPVET                                    
      WRITE(11,9111) 'Ee + EN + thermal Energies       = ',             &
                       EELEC+EN+CORRE                                    
      WRITE(11,9111) 'Ee + EN + thermal Enthalpies     = ',             &
                       EELEC+EN+CORRH                                    
      WRITE(11,9111) 'Ee + EN + thermal Free Energies  = ',             &
                       EELEC+EN+CORRG
      WRITE(11,9101) 

      RETURN
!-----------------------------------------------------------------------
 9011 FORMAT(1X,'THE ROTATIONAL CONSTANTS ARE (IN GHZ)',/               &
             1X,3F12.5)                                                  
 9069 FORMAT(/1X,'TEMPERATURE ',F10.4, 4X,'SCALE FACTOR ',F10.4)
 9071 FORMAT(/1X)
 9080 FORMAT(1X,A6,1P,E15.5)
 9081 FORMAT(1X,A6,1P,E15.5,A15,E10.2)
 9090 FORMAT(/20X,'E',12X,'H',12X,'G',12X,'S')
 9100 FORMAT(17X,'KCAL/MOL',6X,'KCAL/MOL',6X,'KCAL/MOL',5X,'CAL/MOL-K')
 9101 FORMAT(1X,/,71(1H-),/)
 9110 FORMAT(1X,A10,3F14.6,3X,E14.6)
 9113 FORMAT(5X,I4,4X,F10.2,1X,F15.6,5X,E14.6)
 9114 FORMAT(/8X,'#',7X'Freq(cm-1)   EVIB(KCAL/MOL)  SVIB(CAL/MOL-K)')
 9111 FORMAT(1X,A40,F14.6," (a.u.) ")
 9112 FORMAT(1X,A10,3F14.6)
 9200 FORMAT(1X,'FREQUENCY NUMBER',I4,' IS UNEXPECTEDLY ZERO!')
      END
      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!             Orthonormalization subroutines used in DoNOF             !
!                                                                      !
!   ORTHONORMAL: Orthogonalize and Orthonormalize MOs (COEF)           !
!   CANORTORB: Form Canonical Orthonormal Orbitals that diagonalize S  !
!   ORTHOGONALIZE: Project COEF into W vectors                         !
!   ORTHONORMALIZE: Orthonormalize COEF                                !
!   CHECKORTHO: Check the Orthonormality of the MOs                    !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! ORTHONORMAL
      SUBROUTINE ORTHONORMAL(NV,NBF,NBFT,OVERLAP,COEF,ICHECK,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NV)::COEF
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::OVERLAP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,AUXE,S
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,COEFN
      INTEGER::IPRINTOPT
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Form Canonical Orthonormal Orbitals: Diagonalize the Overlap (AUX)
!     W - eigenvectors, EVA - eigenvalues
!     LIV - number of linearly independent eigenvectors 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(AUX(NBF,NBF),W(NBF,NBF),EVA(NBF),AUXE(NBF))
      AUX = OVERLAP
      CALL CANORTORB(AUX,W,EVA,AUXE,LIV,NBF)       ! LIV <= NBF
      DEALLOCATE(AUX)
!     Square OVERLAP -> Symmetric S
      ALLOCATE(S(NBFT))
      NZ=0
      DO I=1,NBF
       DO J=1,I
        NZ=NZ+1
        S(NZ)=OVERLAP(I,J)
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Orthogonalize orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Project COEF into W vectors
      CALL ORTHOGONALIZE(W,S,COEF,AUXE,NBF,LIV,NBFT)
!     Orthonormalize COEF
      CALL ORTHONORMALIZE(COEF,NBF,LIV)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     New Coefficients: Back-Transform to first basis (COEFN=COEF*W)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(COEFN(NBF,NV))
      CALL COEFW(NBF,LIV,COEFN,W,COEF)
      COEF=COEFN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check the Orthonormality of the new orbitals at least 3 times
!     and if not, then get the correct orthonormality for COEF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICHECK==1)THEN
       CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
       ITO=0
       DO WHILE(ITO<=1)
        ITO=ITO+1
        IF(IVIOORTHO/=0)THEN
         CALL ORTHOGONALIZE(W,S,COEF,AUXE,NBF,LIV,NBFT)
         CALL ORTHONORMALIZE(COEF,NBF,LIV)
         CALL COEFW(NBF,LIV,COEFN,W,COEF)
         COEF=COEFN
         CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
        ENDIF
       ENDDO
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(COEFN,W,EVA,AUXE,S)
      RETURN
      END

! CANORTORB
      SUBROUTINE CANORTORB(S,Q,EIG,AUX,LIV,N)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION S(N,N),Q(N,N),EIG(N),AUX(N)
!-----------------------------------------------------------------------
      CALL DIAG(N,S,Q,EIG,AUX)
      DUM = EIG(1)
      J = 0
      K = 0
      DO I = 1,N
       IF(EIG(I)<1.0D-16)THEN
        K = K+1
       ELSE
        J = J+1
        EIG(J) = 1.0D0/SQRT(EIG(I))
        Q(1,J)=Q(1,I)
       ENDIF
      ENDDO
      LIV = N-K                                ! LIV <= N

      DO J=1,LIV
       DO i=1,N
        QiJ=Q(i,J)*EIG(J)
        IF(ABS(QiJ)<1.0D-16)QiJ=0.0d0
        Q(i,J)=QiJ
       ENDDO
      ENDDO

!      IF(LIV/=N)THEN
!       WRITE(6,'(/,50A,I5,/)')
!     & 'The number of linearly independent eigenvectors is',LIV
!       STOP
!      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! ORTHOGONALIZE
      SUBROUTINE ORTHOGONALIZE(Q,S,V,T,N,LIV,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      DIMENSION Q(N,LIV),S(NT),V(N,N),T(N)
!-----------------------------------------------------------------------
      DO J=1,N
       IK=0
       DO I=1,N
        DUM = 0.0d0
        VDUM = V(I,J)
        IF(I>1) THEN
         DO K=1,I-1
          IK = IK+1
          DUM = DUM+S(IK)*V(K,J)
          T(K) = T(K)+S(IK)*VDUM
         ENDDO
        ENDIF
        IK = IK+1
        T(I) = DUM+S(IK)*VDUM
       ENDDO
       DO I=1,N
        V(I,J) = T(I)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      DO J=1,N
       DO I=1,LIV
        T(I) = DDOT(N,Q(1,I),1,V(1,J),1)
       ENDDO
       DO I=1,LIV
        V(I,J) = T(I)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! ORTHONORMALIZE
      SUBROUTINE ORTHONORMALIZE(V,N,LIV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION V(N,N)
!-----------------------------------------------------------------------
!     Orthonormalize first LIV Orbitals
!-----------------------------------------------------------------------
      IF(LIV>0)THEN
       DO I=1,LIV
        DUMI = 0.0d0
        DO K=1,N
         DUMI = DUMI + V(K,I)*V(K,I)
        ENDDO
        DUMI = 1.0d0/ SQRT(DUMI)
        DO K=1,N
         V(K,I) = V(K,I)*DUMI
        ENDDO
        IF(I<LIV)THEN
         DO J=I+1,LIV
          DUM = -DDOT(N,V(1,J),1,V(1,I),1)
          CALL DAXPY(N,DUM,V(1,I),1,V(1,J),1)
         ENDDO
        ENDIF
       ENDDO
      ENDIF
      IF(LIV==N)RETURN
!-----------------------------------------------------------------------
!     Get Orthogonal Space
!-----------------------------------------------------------------------
      I = LIV
      J = 0
    1 I0 = I
      I = I+1
      IF(I>N)RETURN
    2 J = J+1
      IF(J>N)THEN
       WRITE(6,10)I0,N
       STOP
      ENDIF
      DO K=1,N
       V(K,I) = 0.0d0
      ENDDO
      V(J,I) = 1.0d0
      DO L=1,I0
       DUM = -DDOT(N,V(1,L),1,V(1,I),1)
       CALL DAXPY(N,DUM,V(1,L),1,V(1,I),1)
      ENDDO
      DUMI = 0.0d0
      DO K=1,N
       DUMI = DUMI+V(K,I)*V(K,I)
      ENDDO
      IF(ABS(DUMI)<1.0D-16)GOTO 2
      DUMI = 1.0d0/ SQRT(DUMI)
      DO K=1,N
       V(K,I) = V(K,I)*DUMI
      ENDDO
      GOTO 1
   10 FORMAT(1X,'Orthogonalizing found a redundant set of vectors'/     &
             1X,'only',I5,' independent vectors found but there'/       &
             1X,'should be',I5,' MOs')
!-----------------------------------------------------------------------
      END
      
! CHECKORTHO
      SUBROUTINE CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DIMENSION COEF(NBF,NBF),OVERLAP(NBF,NBF)
      INTEGER::IPRINTOPT
!-----------------------------------------------------------------------
      IVIOORTHO=0
      CSCMAX=0.0d0
      DO IQ=1,NBF
       DO JQ=1,IQ
        CSC=0.0d0
        do i=1,nbf
         CSC = CSC + COEF(i,IQ)*FC(i,JQ,OVERLAP,COEF)
        enddo
        IF(IQ==JQ.and.ABS(1.0-CSC)>1.0d-6)THEN
         IVIOORTHO=IVIOORTHO+1
         if(CSCMAX<ABS(1.0-CSC))CSCMAX=ABS(1.0-CSC)
!         write(6,*)IQ,JQ,CSC         
        ELSEIF(IQ/=JQ.and.ABS(CSC)>1.0d-6)THEN
         IVIOORTHO=IVIOORTHO+1
         if(CSCMAX<ABS(CSC))CSCMAX=ABS(CSC)
!         write(6,*)IQ,JQ,CSC         
        ENDIF
       ENDDO
      ENDDO
      IF(IPRINTOPT==0)RETURN
      IF(IVIOORTHO==0)THEN
       WRITE(6,1)
      ELSE
       WRITE(6,2)IVIOORTHO,CSCMAX
      ENDIF
      RETURN
!-----------------------------------------------------------------------
!     Format definitions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(/,' No violations of the orthonormality')
    2 FORMAT(/,' Orthonormality violations:',I8,                        &
               ', Maximum Violation:',F10.6)
!-----------------------------------------------------------------------
      END
      
!----------------------------------------------------------------------!
!                                                                      !
!             O R B I T A L       O P T I M I Z A T I O N              !
!                                                                      !
!                  ( J. Comp. Chem. 30, 2078, 2009 )                   !
!                                                                      !
!             Spin-compensated Systems (Restricted Shells)             !
!                                                                      !
!    'Restricted Closed' (rc) Case: MSpin=0 [Singlet and Multiplet]    !
!       Singlet States (S=0,Ms=0) and Multiplet States (S>0,Ms=0)      !
!                                                                      !
!        'Restricted Open' (ro) Case: MSpin>0 [High-Spin State]        !
!                                                                      !
!            Variables: MOs {Cvq}  (NVAR = NSQ = NBF*NBF)              !
!                                                                      !
!   ORBOPTr: Minimize the energy with respect to the MOs {Cvq} = COEF  !
!   ENERGY1r: Calculate the Electronic Energy (EELEC) and Lagrangian   !
!   PCONVE: Check for the symmetry of Lagrangian [ ELAG(ij)-ELAG(ji) ] !
!   FFJMN1rc,ro: Calculate the generalized Fock matrix Fj(m,n)         !
!   ELG: Calculate the Lagrange Multipliers                            !
!   EELECTRr: Trace( Ct*RO*H*C + Ct*G )                                !
!   EELECTRr_EFIELD: Trace [ Ct*RO*(Ei*ADIPi)*C ] - Ei*DIPN(i)         !
!   FFMIUG_SCALING: Decrease gen-Fock matrix using a scaling factor    !
!   F01: Fij = Fij*0.1                                                 !
!   FFMIUG_DIIS: Direct Inversion in the Iterative Subspace Technique  !
!   TRACEFF: Calculate the trace by i,j of F(m,i,j)*F(idiis,j,i)       !
!                                                                      !
!----------------------------------------------------------------------!

! ORBOPTr
      SUBROUTINE ORBOPTr(ITCALL,ITLIM,AHCORE,IJKL,XIJKL,XIJKaux,QD,     &
                         COEF,RO,CJ12,CK12,ELAG,FMIUG0,DIPN,ADIPx,      &
                         ADIPy,ADIPz,ILOOP,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL DIIS,PERDIIS,CONVGDELAG,RESTART,ERIACTIVATED,SCALING
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/CONVERGENCE/DUMEL,PCONV,CONVGDELAG
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_DIIS_1/DIIS,PERDIIS,NDIIS,NTHDIIS,THDIIS
      COMMON/INPNOF_THRESH/THRESHL,THRESHE,THRESHEC,THRESHEN
      COMMON/INPNOF_COEFOPT/MAXLOOP
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/RUNTYPE/IRUNTYP
      COMMON/CONVERGESUM/SUMDIF
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/SUMDIF/SUMDIF_OLD
!
      INTEGER::IPRINTOPT
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NSTOREaux)::XIJKaux
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,TEMP,CFM
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::FMIUG,W,COEFNEW,BFM,G
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:)::FK
!-----------------------------------------------------------------------
      CONVGDELAG=.FALSE.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     First Call to ORBOPTr
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ITCALL==1)THEN
       IF(IRUNTYP==3.or.IRUNTYP==4)NZEROS=NZEROSr
       IF(IPRINTOPT==1)WRITE(6,1)
       EELEC_OLD=EELEC
       SUMDIF_OLD=0.0d0
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate Initial Electronic Energy (EELEC) and Lagrangian
!     Note: This Energy is equal to EELEC from MOLOCUPrc
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (G(NBF,NBF5))      
      CALL ENERGY1r(AHCORE,IJKL,XIJKL,XIJKaux,QD,COEF,RO,CJ12,CK12,ELAG,&
                    DIPN,ADIPx,ADIPy,ADIPz,G)
      CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     DIF_EELEC=EELEC-EELEC_OLD
!     EELEC_OLD=EELEC   ! To see energy diff. in the internal loop
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Output of the first evaluated energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     IF(ILOOP==0.and.IPRINTOPT==1)                                     &
!      WRITE(6,2)0,EELEC,EELEC+EN,DIF_EELEC,DUMEL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check for the Symmetry of Lagrangian & Energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      PCONV=ABS(DIF_EELEC)
      IF( DUMEL<THRESHL .and. PCONV < THRESHE )THEN
       IF(IPRINTOPT==1)THEN
        if(ITCALL==1)then
         WRITE(6,2)0,EELEC,EELEC+EN,DIF_EELEC,DUMEL
        else if(ITCALL>1)then
         WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL 
        end if
       END IF
       CONVGDELAG=.TRUE.
       RETURN
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check for the Symmetry of Lagrangian (ELAG(IQJQ)-ELAG(JQIQ))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      IF( DUMEL<THRESHL )THEN
!       if(ITCALL==1.and.IPRINTOPT==1)then
!        WRITE(6,2)0,EELEC,EELEC+EN,EELEC,DUMEL
!       endif
!       CONVGDELAG=.TRUE.
!       RETURN
!      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check ITCALL and SUMDIF for changing the scaling factor
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SCALING.and.ITCALL>2.and.ITCALL>ITLIM.and.                     &
         SUMDIF>SUMDIF_OLD)THEN
       NZEROS=NZEROS+1
       ITLIM=ITCALL+ITZITER
!      NZEROS>NZEROSm -> Restart from here with NZEROSr
       IF(NZEROS>NZEROSm)THEN
        NZEROS=NZEROSr
       ENDIF
      ENDIF
      SUMDIF_OLD=SUMDIF
!-----------------------------------------------------------------------
!                       START SCF-ITERATION CYCLE
!-----------------------------------------------------------------------
      ALLOCATE(FMIUG(NBF,NBF),W(NBF,NBF),EVA(NBF))
      ALLOCATE(TEMP(NBF),FK(MAXLOOP,NBF,NBF))
      ALLOCATE(COEFNEW(NBF,NBF),BFM(MAXLOOP+1,MAXLOOP+1),CFM(MAXLOOP+1))
      IF(ITCALL==1.and.INPUTFMIUG==0)THEN
       MAXLP=1
      ELSE
       MAXLP=MAXLOOP
      ENDIF
!-----------------------------------------------------------------------
      ILOOP=0
      IDIIS=0
      DO LOOP=1,MAXLP
       ILOOP=ILOOP+1
       EELEC_OLD2=EELEC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Generalized Fock Matrix (FMIUG)
!
!      Convergent technique:
!
!      1) SCALING:   Decrease FMIUG using a scaling factor.
!                    The scaling factor varies until the number of
!                    ZEROS (.000##) is equal for all elements Fij
!      3) DIIS       Direct Inversion in the Iterative Subspace 
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(SCALING)CALL FFMIUG_SCALING(FMIUG,ELAG,FMIUG0,ITCALL)
       IF(DIIS.and.DUMEL<THDIIS)THEN
        CALL FFMIUG_DIIS(NBF,FMIUG,CFM,BFM,FK,IDIIS)
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      DIAGONALIZE SQUARE MATRIX (FMIUG) FOR REAL SYMMETRIC CASE
!      W - EIGENVECTORS, EVA - EIGENVALUES IN ALGEBRAIC DESCENDING ORDER
!      HOUSEHOLDER METHOD
!      NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL DIAG(NBF,FMIUG,W,EVA,TEMP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Move EVA -> FMIUG0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO I=1,NBF
        FMIUG0(I) = EVA(I)
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      New Coefficients (COEFNEW=COEF*W), Move COEFNEW -> COEF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL COEFW1(NBF,NBF,COEFNEW,COEF,W)
       COEF = COEFNEW
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Calculate Dj(miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,nbf)
!      Keep Matrices Jj, Kj in WJj, WKj
!      Form F Matrix and keep it in WF
!      Compute G, Lagrangian Multipliers (ELAG) and one-energies (E)
!      Calculate Electronic Energy (EELEC)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL ENERGY1r(AHCORE,IJKL,XIJKL,XIJKaux,QD,COEF,RO,CJ12,CK12,    &
                     ELAG,DIPN,ADIPx,ADIPy,ADIPz,G)                      
       DIF_EELEC2=EELEC-EELEC_OLD2                                       
!      Intermediate Output (Nprint=2)                                    
       IF(NPRINT==2.AND.IPRINTOPT==1)                                   &
        WRITE(6,3)LOOP,EELEC,EELEC+EN,DIF_EELEC2
       CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Check for energy convergent solution
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF( DABS(DIF_EELEC2) < THRESHEC )THEN
        DEALLOCATE (COEFNEW,FMIUG,W,EVA,TEMP)
        DIF_EELEC=EELEC-EELEC_OLD
        EELEC_OLD=EELEC
        IF(IPRINTOPT==1)WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL
        RETURN
       ENDIF
!------------------------------------------------------------------------
!                       LOOP-END OF SCF-ITERATION
!-----------------------------------------------------------------------
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Itermediate Output of the external iteration
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DIF_EELEC=EELEC-EELEC_OLD
      EELEC_OLD=EELEC
      DEALLOCATE (COEFNEW,FMIUG,W,EVA,TEMP,CFM,BFM,FK,G)
      IF(IPRINTOPT==1)WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL
      RETURN
!-----------------------------------------------------------------------
!     FORMAT STATEMENTS
!-----------------------------------------------------------------------
    1 FORMAT(//2X,'RESULTS OF OCCUPATION-COEFFICIENT S.C.F. PROCEDURE'  &
            ,/1X,'====================================================',&
        //2X,'Iter',5X,'Electronic Energy',6X,'Total Energy',           &
          3X,'Energy Convergency',4X,'Max Mul-Lag Diff',/)
    2 FORMAT(I5,'.',1X,F20.10,1X,F19.10,2X,F15.10,8X,F11.6)
    3 FORMAT(2X,I3,'.',3X,F17.8,4X,F15.8,6X,F11.6)
!-----------------------------------------------------------------------
      END

! ENERGY1r
      SUBROUTINE ENERGY1r(AHCORE,IJKL,XIJKL,XIJKaux,QD,COEF,RO,CJ12,    &
                          CK12,ELAG,DIPN,ADIPx,ADIPy,ADIPz,G)
!-----------------------------------------------------------------------
!     Calculate the Electronic Energy and Lagrange Multipliers
!-----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,ERIACTIVATED,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/ERIACT/ERIACTIVATED,NIJKaux,NINTCRaux,NSTOREaux,IAUXDIM
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      LOGICAL SMCD
      COMMON/ERITYPE/IERITYP,IGEN,ISTAR,MIXSTATE,SMCD
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
!
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NSTOREaux)::XIJKaux
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF5)::G      
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::WJj,WKj,WF,AUX1
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX2,AUX3
!-----------------------------------------------------------------------
!     Calculate Dj: QD(j,miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,NBF5) 
!-----------------------------------------------------------------------
      ALLOCATE (WJj(NSQ,NBF5),WKj(NSQ,NBF5),AUX2(NSQ))

      IF(IERITYP==1 .or. (IERITYP==3 .and. MIXSTATE==2))THEN
       ALLOCATE(AUX1(NBF,NBF))
       DO j=1,NBF5
        CALL DENMATj(j,AUX1,COEF,NBF)
        QD(j,1:NBF,1:NBF) = AUX1(1:NBF,1:NBF) 
        CALL HSTARJ(AUX2,AUX1,IJKL,XIJKL)
        WJj(1:NSQ,j) = AUX2(1:NSQ)
        CALL HSTARK(AUX2,AUX1,IJKL,XIJKL)
        WKj(1:NSQ,j) = AUX2(1:NSQ)
       ENDDO
       DEALLOCATE(AUX1)
      ELSE IF(IERITYP==2 .or. (IERITYP==3 .and. MIXSTATE==1))THEN 
       ALLOCATE(AUX3(NSQ))
       DO j=1,NBF5
        CALL HSTARJKRI(AUX2,AUX3,XIJKaux,COEF(1:NBF,j))
        WJj(1:NSQ,j) = AUX2(1:NSQ)
        WKj(1:NSQ,j) = AUX3(1:NSQ)
       ENDDO
       DEALLOCATE(AUX3)
      END IF
      DEALLOCATE(AUX2)
!-----------------------------------------------------------------------
!     Form F Matrix and keep it in WF
!-----------------------------------------------------------------------
      ALLOCATE (WF(NSQ,NBF5))
      if(MSpin==0)then
       CALL FFJMN1rc(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)
      else if(MSpin>0)then
       CALL FFJMN1ro(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)      
      end if      
      DEALLOCATE (WJj,WKj)
!-----------------------------------------------------------------------
!     Calculate G Matrix
!-----------------------------------------------------------------------
      DO IQ=1,NBF5
       do i=1,nbf
        G(i,IQ) = FC(i,IQ,WF(1,IQ),COEF)
       enddo
      ENDDO
      DEALLOCATE (WF)
!-----------------------------------------------------------------------
!     Lagrangian Multipliers (ELAG)
!-----------------------------------------------------------------------
      CALL ELG(ELAG,COEF,G)
!-----------------------------------------------------------------------
!     Calculate ELECTRONIC ENERGY
!-----------------------------------------------------------------------
!     Calculate Trace ( Ct*RO*H*C + Ct*G )
      CALL EELECTRr(EELEC,AHCORE,ELAG,COEF,RO)
!     Include Nuclear Dipoles if electric field =/ 0
      IF(EFIELDL)THEN
       CALL EELECTRr_EFIELD(EELEC_EF,COEF,RO,DIPN,ADIPX,ADIPY,ADIPZ)
       EELEC=EELEC+EELEC_EF
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! PCONVE
      SUBROUTINE PCONVE(ELAG,DUM,MAXI,MAXJ,SUMDIF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG
!-----------------------------------------------------------------------
!     Check for the symmetry of Lagrangian [ ELAG(ij)-ELAG(ji) ], i.e.,
!     the convergence of the difference of Lagrange multipliers
!-----------------------------------------------------------------------
      DUM=0.0d0
      SUMDIF=0.0d0
      DO IQ=1,NBF
       DO JQ=1,NBF
        GCF=ABS(ELAG(IQ,JQ)-ELAG(JQ,IQ))
        SUMDIF=SUMDIF+GCF
        IF(GCF>DUM)THEN
         DUM=GCF
         MAXI=IQ
         MAXJ=JQ
        ENDIF
       ENDDO
      ENDDO
!      WRITE(6,'(2I4,2F10.5)')MAXI,MAXJ,ELAG(MAXI,MAXJ),ELAG(MAXJ,MAXI)
!-----------------------------------------------------------------------
      RETURN
      END

! FFJMN1rc
      SUBROUTINE FFJMN1rc(RO,CJ12,CK12,H,DJ,DK,F,ADIPx,ADIPy,ADIPz)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL,HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::DJ,DK,F
!-----------------------------------------------------------------------
!     Calculate Fj(m,n)
!-----------------------------------------------------------------------
      IF(NO1>1)THEN
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         F(ik,1) = H(i,k) + PRODWCWij(ik,DJ,CJ12)-PRODWCWij(ik,DK,CK12)
         DO J=NO1+1,NB
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)  
         ENDDO                                                           
         if(NSOC>0)then                                                  
          DO J=NB+1,NA                                                   
           F(ik,J) = RO(J) * H(i,k)                                     &
                   + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12) 
          ENDDO                                                          
         end if                                                          
         DO J=NA+1,NBF5                                                  
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
         ENDDO
        enddo
       enddo
       DO J=2,NO1
        F(1:NSQ,J) = F(1:NSQ,1)
       ENDDO
      ELSE
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         DO J=1,NB
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)  
         ENDDO                                                           
         if(NSOC>0)then                                                  
          DO J=NB+1,NA                                                   
           F(ik,J) = RO(J) * H(i,k)                                     &
                   + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12) 
          ENDDO                                                          
         end if                                                          
         DO J=NA+1,NBF5                                                  
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
         ENDDO
        enddo
       enddo
      ENDIF
!-----------------------------------------------------------------------
!     Including Electric Field ( Note: FEikj is constant )
!-----------------------------------------------------------------------
      IF(EFIELDL)THEN
       DO J=1,NBF5
        do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         FEikj = RO(J)*(EX*ADIPx(i,k)+EY*ADIPy(i,k)+EZ*ADIPz(i,k))
         F(ik,J) = F(ik,J) + FEikj
        enddo
        enddo
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END
      
! FFJMN1ro
      SUBROUTINE FFJMN1ro(RO,CJ12,CK12,H,DJ,DK,F,ADIPx,ADIPy,ADIPz)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL EFIELDL
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::DJ,DK,F
!-----------------------------------------------------------------------
!     Calculate Fj(m,n)
!-----------------------------------------------------------------------
      IF(NO1>1)THEN
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         F(ik,1) = H(i,k)+PRODWCWij1(ik,DJ,CJ12)-PRODWCWij1(ik,DK,CK12) &
                 + SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK)                  
         DO J=NO1+1,NB                                                   
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq1(ik,J,DJ,CJ12)-PRODWCWijq1(ik,J,DK,CK12) &
                  + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )          
         ENDDO                                                           
         DO J=NB+1,NA                                                    
          F(ik,J) = 0.50d0 * ( H(i,k)+SUMWijq(ik,J,DJ)-SUMWijq(ik,J,DK) &
                      + 2.0d0*PRODWROij(ik,DJ,RO)-PRODWROij(ik,DK,RO) )  
         ENDDO                                                           
         DO J=NA+1,NBF5                                                  
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq2(ik,J,DJ,CJ12)-PRODWCWijq2(ik,J,DK,CK12) &
                  + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )          
         ENDDO                                                           
        enddo                                                            
       enddo                                                             
       DO J=2,NO1                                                        
        F(1:NSQ,J) = F(1:NSQ,1)                                          
       ENDDO                                                             
      ELSE                                                               
       do i=1,nbf                                                        
        do k=1,nbf                                                       
         ik=i+(k-1)*nbf                                                  
         DO J=1,NB                                                       
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq1(ik,J,DJ,CJ12)-PRODWCWijq1(ik,J,DK,CK12) &
                  + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )          
         ENDDO                                                           
         DO J=NB+1,NA                                                    
          F(ik,J) = 0.50d0 * ( H(i,k)+SUMWijq(ik,J,DJ)-SUMWijq(ik,J,DK) &
                      + 2.0d0*PRODWROij(ik,DJ,RO)-PRODWROij(ik,DK,RO) )  
         ENDDO                                                           
         DO J=NA+1,NBF5                                                  
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )                       &
                  + PRODWCWijq2(ik,J,DJ,CJ12)-PRODWCWijq2(ik,J,DK,CK12) &
                  + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )         

         ENDDO
        enddo
       enddo
      ENDIF
!-----------------------------------------------------------------------
!     Including Electric Field ( Note: FEikj is constant )
!-----------------------------------------------------------------------
      IF(EFIELDL)THEN
       DO J=1,NBF5
        do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         FEikj = RO(J)*(EX*ADIPx(i,k)+EY*ADIPy(i,k)+EZ*ADIPz(i,k))
         F(ik,J) = F(ik,J) + FEikj
        enddo
        enddo
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! ELG
      SUBROUTINE ELG(ELAG,C,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,C
      DOUBLE PRECISION,DIMENSION(NBF,NBF5)::G
!-----------------------------------------------------------------------
!     Calculate the Lagrange Multipliers
!-----------------------------------------------------------------------
      DO IQ=1,NBF
       DO JQ=1,NBF5
        ELAG(IQ,JQ) = 0.0d0
        do i=1,nbf
         ELAG(IQ,JQ) = ELAG(IQ,JQ) + C(i,IQ)*G(i,JQ)
        enddo
       ENDDO
       DO JQ=NBF5+1,NBF
        ELAG(IQ,JQ) = 0.0d0
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! EELECTRr
      SUBROUTINE EELECTRr(ENERGIA,H,ELAG,C,RO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ELAG,C
!-----------------------------------------------------------------------
!     Calculate the electronic energy [ Trace( Ct*RO*H*C + Ct*G ) ]
!-----------------------------------------------------------------------
      ENERGIA = 0.0d0
      DO IQ=1,NB
       ENERGIA = ENERGIA + ELAG(IQ,IQ)
       do i=1,nbf
        ENERGIA = ENERGIA + RO(IQ)*C(i,IQ)*FC(i,IQ,H,C)
       enddo
      ENDDO
!
      if(NSOC>0)then
       if(.not.HighSpin)then
        DO IQ=NB+1,NA
         ENERGIA = ENERGIA + ELAG(IQ,IQ)
         do i=1,nbf
          ENERGIA = ENERGIA + RO(IQ)*C(i,IQ)*FC(i,IQ,H,C)
         enddo
        ENDDO
       else if(HighSpin)then
        DO IQ=NB+1,NA
         ENERGIA = ENERGIA + ELAG(IQ,IQ)
         do i=1,nbf
          ENERGIA = ENERGIA +  0.50d0*C(i,IQ)*FC(i,IQ,H,C)
         enddo
        ENDDO
       end if
      end if       
!      
      DO IQ=NA+1,NBF5
       ENERGIA = ENERGIA + ELAG(IQ,IQ)
       do i=1,nbf
        ENERGIA = ENERGIA + RO(IQ)*C(i,IQ)*FC(i,IQ,H,C)
       enddo
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! EELECTRr_EFIELD
      SUBROUTINE EELECTRr_EFIELD(EELEC_EF,C,RO,DIPN,ADIPx,ADIPy,ADIPz)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL EFIELDL
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::C,ADIPx,ADIPy,ADIPz
!-----------------------------------------------------------------------
!     Calculate the electronic energy associated to the electric field
!     EELEC_EF = Trace [ Ct*RO*(Ei*ADIPi)*C ] - Ei*DIPN(i)
!-----------------------------------------------------------------------
      EELEC_EF=0.0d0
      DO IQ=1,NBF5
       do i=1,nbf
        EELEC_EF = EELEC_EF + RO(IQ)*C(i,IQ)*( EX*FC(i,IQ,ADIPx,C) +    &
                            EY*FC(i,IQ,ADIPy,C) + EZ*FC(i,IQ,ADIPz,C) )
       enddo
      ENDDO
      EELEC_EF = EELEC_EF - EX*DIPN(1) - EY*DIPN(2) - EZ*DIPN(3)
!-----------------------------------------------------------------------
      RETURN
      END

! FFMIUG_SCALING
      SUBROUTINE FFMIUG_SCALING(FMIUG,ELAG,FMIUG0,ITCALL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL RESTART,SCALING
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
!
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::FMIUG,ELAG
!-----------------------------------------------------------------------
!     Generalized Fock Matrix (FMIUG)
!-----------------------------------------------------------------------
      IF(itcall==1.AND.INPUTFMIUG==0)THEN          ! only for itcall==1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO IQ=1,NBF
        DO JQ=1,IQ-1
         FMIUG(IQ,JQ)=(ELAG(IQ,JQ)+ELAG(JQ,IQ))/2.0        ! Nondiagonal 
         FMIUG(JQ,IQ)=FMIUG(IQ,JQ)
        ENDDO
        FMIUG(IQ,IQ)=ELAG(IQ,IQ)                            ! Diagonal
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO IQ=1,NBF
        DO JQ=1,IQ-1
         FMIUG(IQ,JQ)=ELAG(IQ,JQ)-ELAG(JQ,IQ)              ! Nondiagonal 
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
!        Decrease FMIUG using a scaling factor
!        The scaling factor varies until the number of
!        ZEROS (.000##) is equal for all elements Fij
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         CALL F01(NZEROS+9,FMIUG(IQ,JQ))
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         FMIUG(JQ,IQ)=FMIUG(IQ,JQ)                         ! Fji=Fij
        ENDDO
        FMIUG(IQ,IQ)=FMIUG0(IQ)                            ! Diagonal
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! F01
      SUBROUTINE F01(imax,Fij)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      do i=0,imax
       VAL=ABS(Fij)
       if(VAL>10.0d0**(9-i).and.VAL<10.0d0**(10-i))then
        Fij = Fij * 0.1d0
       endif
      enddo
      RETURN
      END

! FFMIUG_DIIS
      SUBROUTINE FFMIUG_DIIS(NUM,FMIUG,CFM,BFM,FK,IDIIS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL DIIS,PERDIIS
      COMMON/INPNOF_DIIS_1/DIIS,PERDIIS,NDIIS,NTHDIIS,THDIIS
      COMMON/INPNOF_COEFOPT/MAXLOOP
!
      DOUBLE PRECISION,DIMENSION(MAXLOOP+1)::CFM
      DOUBLE PRECISION,DIMENSION(MAXLOOP+1,MAXLOOP+1)::BFM
      DOUBLE PRECISION,DIMENSION(NUM,NUM)::FMIUG
      DOUBLE PRECISION,DIMENSION(MAXLOOP,NUM,NUM)::FK
!
      INTEGER,ALLOCATABLE,DIMENSION(:)::IPIV
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::A
!-----------------------------------------------------------------------
      IDIIS = IDIIS+1
      FK(IDIIS,1:NUM,1:NUM) = FMIUG(1:NUM,1:NUM)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Form BFM(1:idiis,idiis)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NN = idiis+1
      do m=1,idiis
       BFM(m,idiis) = TRACEFF(MAXLOOP,NUM,m,idiis,FK)
       BFM(idiis,m) = BFM(m,idiis)
       BFM(m,NN)    = -1.0d0
       BFM(NN,m)    = -1.0d0
      enddo
      BFM(NN,NN) = 0.0d0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(idiis>NDIIS)then
!- - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE (A(NN,NN),IPIV(NN))
       IPIV = 0
       A = BFM(1:NN,1:NN)
       CFM(1:idiis) = 0.0d0
       CFM(NN) =  -1.0d0
!- - - - - - - - - - - - - - - - - - - - - - -
       CALL DGESV(NN,1,A,NN,IPIV,CFM,NN,INFO)
       DEALLOCATE (A,IPIV)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      New Generalized Fock Matrix: F'=SUM_k [CFM(k)*F(k)]
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       do i=1,NUM
        do j=1,i-1
         FMIUG(i,j) = 0.0d0
         do k=1,idiis
          FMIUG(i,j) = FMIUG(i,j) + CFM(k) * FK(k,i,j)
         enddo
         FMIUG(j,i) = FMIUG(i,j)
        enddo
       enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      IDIIS is nullified for a periodic DIIS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(PERDIIS)IDIIS = 0
!- - - - - - - - - - - - - - - - - - - - - - -
      endif
!-----------------------------------------------------------------------
      RETURN
      END

! TRACEFF
      FUNCTION TRACEFF(maxloop,N,m,idiis,F)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(maxloop,N,N)::F
!-----------------------------------------------------------------------
      TRACEFF = 0.0d0
      do i=1,N
       do j=1,i-1
        TRACEFF = TRACEFF + F(m,i,j)*F(idiis,j,i)
       enddo
      enddo
!-----------------------------------------------------------------------
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!             Multipurpose-Product Functions used in DoNOF             !
!                                                                      !
!   PRODCWQWj: PRODCWQW(j) = CW12j*QWj excluding i=j                   !
!   PRODCWQWjk: PRODCWQWjk = CW12jk*QWj excluding i=j                  !
!   PRODROQWj: PRODROQWj = RO*QWj                                      !
!   PRODWCWij: PRODWCWij = W(ij)*CW12                                  !
!   PRODWCWijq: PRODWCWijq = W(ij)*CW12(q) excluding q'=q              !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! PRODCWQWj
      FUNCTION PRODCWQWj(J,CW12,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODCWQWj = CW12j*QWj. Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODCWQWj = 0.0d0
      DO I=1,J-1
       PRODCWQWj = PRODCWQWj + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWj = PRODCWQWj + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODCWQWj1
      FUNCTION PRODCWQWj1(J,CW12,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODCWQWj1 = CW12j*QWj, j<NB (NSOC is excluded from the Sum)
!     Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODCWQWj1 = 0.0d0
      DO I=1,J-1
       PRODCWQWj1 = PRODCWQWj1 + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NB
       PRODCWQWj1 = PRODCWQWj1 + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
      DO I=NA+1,NBF5
       PRODCWQWj1 = PRODCWQWj1 + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END      

! PRODCWQWj2
      FUNCTION PRODCWQWj2(J,CW12,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODCWQWj2 = CW12j*QWj, j>NA (NSOC is excluded from the Sum)
!     Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODCWQWj2 = 0.0d0
      DO I=1,NB
       PRODCWQWj2 = PRODCWQWj2 + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=NA+1,J-1
       PRODCWQWj2 = PRODCWQWj2 + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWj2 = PRODCWQWj2 + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END
      
! PRODCWQWjk
      FUNCTION PRODCWQWjk(NV,J,K,CW12,QW)
!     Called from occopt.f for obtaining the gradients
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODCWQWjk = CW12jk*QWj. Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODCWQWjk=0.0d0
      DO I=1,J-1
       PRODCWQWjk = PRODCWQWjk + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWjk = PRODCWQWjk + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODCWQWjk1
      FUNCTION PRODCWQWjk1(NV,J,K,CW12,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODCWQWjk = CW12jk*QWj, j<NB (NSOC is excluded from the Sum)
!     Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODCWQWjk1 = 0.0d0
      DO I=1,J-1
       PRODCWQWjk1 = PRODCWQWjk1 + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NB
       PRODCWQWjk1 = PRODCWQWjk1 + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
      DO I=NA+1,NBF5
       PRODCWQWjk1 = PRODCWQWjk1 + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODCWQWjk2
      FUNCTION PRODCWQWjk2(NV,J,K,CW12,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODCWQWjk = CW12jk*QWj, j>NA (NSOC is excluded from the Sum)
!     Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODCWQWjk2 = 0.0d0
      DO I=1,NB
       PRODCWQWjk2 = PRODCWQWjk2 + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=NA+1,J-1
       PRODCWQWjk2 = PRODCWQWjk2 + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWjk2 = PRODCWQWjk2 + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END
      
! PRODROQWj
      FUNCTION PRODROQWj(J,RO,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODROQWj = RO*QWj    Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODROQWj=0.0d0
      DO I=1,J-1
       PRODROQWj = PRODROQWj + RO(I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODROQWj = PRODROQWj + RO(I)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODROQWj0
      FUNCTION PRODROQWj0(J,RO,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODROQWj0 = RO*QWj  (Sum only for NSOC)
!     Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODROQWj0 = 0.0d0
      DO I=NB+1,J-1
       PRODROQWj0 = PRODROQWj0 + RO(I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NA
       PRODROQWj0 = PRODROQWj0 + RO(I)*QW(J+I*(I-1)/2)
      ENDDO
!--------------------------------------------------------------------      
      RETURN
      END
      
! PRODROQWj1
      FUNCTION PRODROQWj1(J,RO,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODROQWj = RO*QWj, j<NB<i (Sum only for NSOC)
!-----------------------------------------------------------------------
      PRODROQWj1 = 0.0d0
      DO I=NB+1,NA
       PRODROQWj1 = PRODROQWj1 + RO(J)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------      
      RETURN
      END

! PRODROQWj2
      FUNCTION PRODROQWj2(J,RO,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODROQWj = RO*QWj, j>NA>i (Sum only for NSOC)
!-----------------------------------------------------------------------
      PRODROQWj2 = 0.0d0
      DO I=NB+1,NA
       PRODROQWj2 = PRODROQWj2 + RO(J)*QW(I+J*(J-1)/2)
      ENDDO
!-----------------------------------------------------------------------      
      RETURN
      END

! PRODDRQWjk1
      FUNCTION PRODDRQWjk1(NV,J,K,DR,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODDRQWjk1 = DRjk*QWj, j<NB (NSOC is excluded from the Sum)
!     Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODDRQWjk1=0.0d0
      DO I=NB+1,NA
       PRODDRQWjk1 = PRODDRQWjk1 + DR(J,K)*QW(J+I*(I-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODDRQWjk2
      FUNCTION PRODDRQWjk2(NV,J,K,DR,QW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
!-----------------------------------------------------------------------
!     PRODDRQWjk2 = DRjk*QWj, j>NA (NSOC is excluded from the Sum)
!     Note: Term with I=J is not included
!-----------------------------------------------------------------------
      PRODDRQWjk2=0.0d0
      DO I=NB+1,NA
       PRODDRQWjk2 = PRODDRQWjk2 + DR(J,K)*QW(I+J*(J-1)/2)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODWCWij
      FUNCTION PRODWCWij(ij,W,CW12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*CW12(1,*) by IQP
!-----------------------------------------------------------------------
      PRODWCWij = 0.0d0
      DO IQP=1,NBF5
       PRODWCWij = PRODWCWij + W(ij,IQP)*CW12(1,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODWCWij1
      FUNCTION PRODWCWij1(ij,W,CW12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*CW12(1,*) by IQP. NSOC terms are excluded from the Sum.
!-----------------------------------------------------------------------
      PRODWCWij1 = 0.0d0
      DO IQP=1,NB
       PRODWCWij1 = PRODWCWij1 + W(ij,IQP)*CW12(1,IQP)
      ENDDO
      DO IQP=NA+1,NBF5
       PRODWCWij1 = PRODWCWij1 + W(ij,IQP)*CW12(1,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END
      
! PRODWCWijq
      FUNCTION PRODWCWijq(ij,IQ,W,CW12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*CW12(IQ,*) by IQP, IQ is not considered
!-----------------------------------------------------------------------
      PRODWCWijq = 0.0d0
      DO IQP=1,IQ-1
       PRODWCWijq = PRODWCWijq + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=IQ+1,NBF5
       PRODWCWijq = PRODWCWijq + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODWCWijq1
      FUNCTION PRODWCWijq1(ij,IQ,W,CW12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*CW12(IQ,*) by IQP, IQ is not considered (IQ<NB)
!     NSOC terms are excluded from the Sum.
!-----------------------------------------------------------------------
      PRODWCWijq1 = 0.0d0
      DO IQP=1,IQ-1
       PRODWCWijq1 = PRODWCWijq1 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=IQ+1,NB
       PRODWCWijq1 = PRODWCWijq1 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=NA+1,NBF5
       PRODWCWijq1 = PRODWCWijq1 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END
      
! PRODWCWijq2
      FUNCTION PRODWCWijq2(ij,IQ,W,CW12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*CW12(IQ,*) by IQP, IQ is not considered (IQ>NA)
!     NSOC terms are excluded from the Sum.
!-----------------------------------------------------------------------
      PRODWCWijq2 = 0.0d0
      DO IQP=1,NB
       PRODWCWijq2 = PRODWCWijq2 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=NA+1,IQ-1
       PRODWCWijq2 = PRODWCWijq2 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=IQ+1,NBF5
       PRODWCWijq2 = PRODWCWijq2 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! SUMWij
      FUNCTION SUMWij(ij,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W      
!-----------------------------------------------------------------------
!     Sum Wij for NSOC terms
!-----------------------------------------------------------------------
      SUMWij = 0.0d0
      DO IQP=NB+1,NA
       SUMWij = SUMWij + W(ij,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! SUMWijq
      FUNCTION SUMWijq(ij,IQ,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum Wij for NSOC terms, IQ is not considered
!-----------------------------------------------------------------------
      SUMWijq = 0.0d0
      DO IQP=NB+1,IQ-1
        SUMWijq = SUMWijq + W(ij,IQP)
      ENDDO
      DO IQP=IQ+1,NA
        SUMWijq = SUMWijq + W(ij,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODWROij
      FUNCTION PRODWROij(ij,W,RO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*RO. NSOC terms are excluded from the Sum.
!-----------------------------------------------------------------------
      PRODWROij = 0.0d0
      DO IQP=1,NB
       PRODWROij = PRODWROij + W(ij,IQP)*RO(IQP)
      ENDDO
      DO IQP=NA+1,NBF5
       PRODWROij = PRODWROij + W(ij,IQP)*RO(IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END
      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                  U T I L       S U B R O U T I N E S                 !
!                                                                      !
!   ABRT: Generic Stop Subroutine                                      !
!   XtoX0: It keeps the linear arrangement X(N) in X0(N)               !
!   TRACE: Calculate the trace of a symmetric matrix A(N,N)            !
!   TRACEm: Calculate the trace (E) of a symmetric matrix A(N,N)       !
!   SQUARETRIAN: Put square matrix FM(N,N) in triangular form F(NT)    !
!   TRIANSQUARE: Put triangular F(NT) in square matrix form FM(N,N)    !
!   CeqAtB: C = At*B where C(NA,NB), A(NA,MA) and B((NA,NB))           !
!   COEFW: COEFN = COEF*W  where COEFN(N,L), COEF(N,N) and W(N,L)      !
!   COEFW1: COEFN = COEF*W where COEFN(L,N), COEF(L,N) and W(N,N)      !
!   FC: FC(i,IQ) = Sum_j[F(i,j)*C(j,IQ)], Sym. F(nbf,nbf), C(nbf,nbf)  !
!   DMATMAX: Determine the maximum off-diagonal element of symmetric A !
!   HEAV and DHEAV: Heaviside function and its derivative              !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! ABRT
      SUBROUTINE ABRT  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*24 STAMP                                                
      DOUBLE PRECISION TIMSTR(3)  
!-----------------------------------------------------------------------
      CALL FDATE(STAMP)                                                 
      READ(UNIT=STAMP,FMT='(3A8)')TIMSTR                               
      WRITE(6,1)TIMSTR
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
!     GENERIC STOP, IN CASE YOU GET THIS FAR
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
      STOP 'IN ABRT'                                                    
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
    1 FORMAT(1X,'Execution terminated abnormally at ',3A8)                                           
      END                                                               

! XtoX0
      SUBROUTINE XtoX0(X,X0,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N)::X,X0
!-----------------------------------------------------------------------
      DO I=1,N
       X0(I) = X(I)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! IXtoIX0
      SUBROUTINE IXtoIX0(IX,IX0,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(N)::IX,IX0
!-----------------------------------------------------------------------
      DO I=1,N
       IX0(I) = IX(I)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END
      
! TRACE
      FUNCTION TRACE(D,A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::D,A
!-----------------------------------------------------------------------
!     Calculate the trace of a symmetric matrix A(N,N)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TRACE = 0.0
      DO K=1,N
       DO L=1,K
        TRACE = TRACE + A(K,L)*D(K,L)
       ENDDO
       TRACE = TRACE - A(K,K)*D(K,K)*0.5
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! TRACEm
      SUBROUTINE TRACEm(E,D,AA,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION D(N,N),AA(N,N)
!-----------------------------------------------------------------------
!     Calculate the trace (E) of a symmetric matrix A(N,N)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E = 0.0d0
      DO K=1,N
       DO L=1,K
        E = E + AA(K,L)*D(K,L)
       ENDDO
       E = E - AA(K,K)*D(K,K)*0.5d0
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! TRACEP                                           
      DOUBLE PRECISION FUNCTION TRACEP(A,B,N)                           
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(*),B(*)                                               
      N2 = (N*N+N)/2                                                    
      TRACE = DDOT(N2,A,1,B,1)                                          
      TRACE = TRACE+TRACE                                               
      K = 0                                                             
      DO I = 1,N                                                    
       K = K+I                                                        
       TRACE = TRACE - A(K)*B(K)                                      
      END DO
      TRACEP = TRACE                                                    
      RETURN                                                            
      END                                                               
      
! SQUARETRIAN
      SUBROUTINE SQUARETRIAN(FM,F,N,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::FM
      DOUBLE PRECISION,DIMENSION(NT)::F
!-----------------------------------------------------------------------
!     PUT SQUARE FM IN TRIANGULAR FORM F
!-----------------------------------------------------------------------
      NZ=0
      DO I=1,N
       DO J=1,I
        NZ=NZ+1
        F(NZ)=FM(I,J)+FM(I,J)
       ENDDO
       F(NZ)=F(NZ)-FM(I,I)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! TRIANSQUARE
      SUBROUTINE TRIANSQUARE(FM,F,N,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::FM
      DOUBLE PRECISION,DIMENSION(NT)::F
!-----------------------------------------------------------------------
!     PUT TRIANGULAR F IN SQUARE FORM FM
!-----------------------------------------------------------------------
      NZ=0
      DO I=1,N
       DO J=1,I
        NZ=NZ+1
        FM(I,J)=F(NZ)
        FM(J,I)=F(NZ)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! CeqAtB
      SUBROUTINE CeqAtB(C,A,NA,MA,B,NB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NA,MA)::A
      DOUBLE PRECISION,DIMENSION(NA,NB)::B
      DOUBLE PRECISION,DIMENSION(NA,NB)::C
!-----------------------------------------------------------------------
!     C = At * B
!-----------------------------------------------------------------------
      DO i=1,MA
       DO j=1,NB
        C(i,j) = 0.0d0
        do k=1,NA
         C(i,j) = C(i,j) + A(k,i)*B(k,j)
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! COEFW
      SUBROUTINE COEFW(N,L,COEFN,COEF,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,L)::COEFN,W
      DOUBLE PRECISION,DIMENSION(N,N)::COEF
!-----------------------------------------------------------------------
!     COEFN = COEF*W
!-----------------------------------------------------------------------
      DO i=1,N
       DO j=1,L
        COEFN(i,j)=0.0d0
        do k=1,N
         COEFN(i,j)=COEFN(i,j)+COEF(i,k)*W(k,j)
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! COEFW1
      SUBROUTINE COEFW1(L,N,COEFN,COEF,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(L,N)::COEFN,COEF
      DOUBLE PRECISION,DIMENSION(N,N)::W
!-----------------------------------------------------------------------
!     COEFN = COEF*W
!-----------------------------------------------------------------------
      DO i=1,L
       DO j=1,N
        COEFN(i,j)=0.0d0
        do k=1,N
         COEFN(i,j) = COEFN(i,j) + COEF(i,k)*W(k,j)
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! FC
      FUNCTION FC(i,IQ,F,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::F,C
!-----------------------------------------------------------------------
!     FC(i,IQ) = Sum_j[F(i,j)*C(j,IQ)], F:Sym, C(nbf,nbf)
!-----------------------------------------------------------------------
      FC = 0.0d0
      do j=1,NBF
       FC = FC + F(i,j) * C(j,IQ)
      enddo
!-----------------------------------------------------------------------
      RETURN
      END

! DMATMAX
      SUBROUTINE DMATMAX(A,N,MAXI,MAXJ,DUM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::A
!-----------------------------------------------------------------------
!     Determine the maximum off-diagonal element of symmetric matrix A 
!-----------------------------------------------------------------------
      DUM=0.0d0
      DO IQ=1,N
       DO JQ=1,IQ-1
        DMij=ABS(A(IQ,JQ))
        IF(DMij>DUM)THEN
         DUM=DMij
         MAXI=IQ
         MAXJ=JQ
        ENDIF
       ENDDO
      ENDDO
!      WRITE(6,1)MAXI,MAXJ,DUM
!-----------------------------------------------------------------------
!    1 FORMAT(4X,'(',I3,',',I3,')',4X,F15.6)
      RETURN
      END

! Heaviside
      FUNCTION HEAV(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      IF(X>=0.0d0)THEN
       HEAV = 1.0d0
      ELSE
       HEAV = 0.0d0
      ENDIF
      RETURN
      END

! Derivative of Heaviside
      FUNCTION DHEAV(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)               
      IF(X>=0.0d0)THEN
       DHEAV = 0.0d0
      ELSE
       DHEAV = 0.0d0
      ENDIF
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!   DIAG: Diagonalization of real symmetric matrix using Houselholder  !
!         method. NAN is the maximum possible size = 5000.             !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! DIAG
      SUBROUTINE DIAG(NN,A,VEC,EIG,W)                                  
!**********************************************************************!
!     MATRIX DIAGNOLIZATION ROUTINE FOR REAL SYMMETRIC CASE            !
!     HOUSEHOLDER METHOD                                               !
!     RHOSQ = UPPER LIMIT FOR OFF-DIAGONAL ELEMENT                     !
!     NN= SIZE OF MATRIX                                               !
!     A = MATRIX (ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED)     !
!     EIG = RETURNED EIGENVALUES IN ALGEBRAIC DESCENDING ORDER         !
!     VEC = RETURNED EIGENVECTORS IN COLUMNS                           !
!**********************************************************************!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      PARAMETER (NAN = 5000)
      INTEGER,DIMENSION(NAN)::IPOSV,IORD,IVPOS
      DOUBLE PRECISION,DIMENSION(NAN)::GAMMA,BETA,P,Q,BETASQ
      DOUBLE PRECISION,DIMENSION(NN)::EIG,W
      DOUBLE PRECISION,DIMENSION(NN,NN)::A,VEC
      EQUIVALENCE (P,Q,IVPOS,BETA),(IPOSV,GAMMA),(IORD,BETASQ)
      DATA ZERO/0.0d0/,PT5/0.5d0/,ONE/1.0d0/,TWO/2.0d0/,RHOSQ/1.0D-30/
!-----------------------------------------------------------------------
      N=NN
      IF(N)10,550,10
   10 N1=N-1
      N2=N-2
      GAMMA(1)=A(1,1)
      IF(N2) 180,170,20
   20 DO 160 NR=1,N2
      B=A(NR+1,NR)
      S=ZERO
      DO 30 I=NR,N2
   30 S=S+A(I+2,NR)**2
!     PREPARE FOR POSSIBLE BYPASS OF TRANSFORMATION
      A(NR+1,NR)=ZERO
      IF (S) 150,150,40
   40 S=S+B*B
      SGN=+ONE
      IF (B) 50,60,60
   50 SGN=-ONE
   60 SQRTS= SQRT(S)
      D=SGN/(SQRTS+SQRTS)
      TEMP= SQRT(PT5+B*D)
      W(NR)=TEMP
      A(NR+1,NR)=TEMP
      D=D/TEMP
      B=-SGN*SQRTS
!     D IS FACTOR OF PROPORTIONALITY. NOW COMPUTE AND SAVE W VECTOR.
!     EXTRA SINGLY SUBSCRIPTED W VECTOR USED FOR SPEED.
      DO 70 I=NR,N2
      TEMP=D*A(I+2,NR)
      W(I+1)=TEMP
   70 A(I+2,NR)=TEMP
!     PREMULTIPLY VECTOR W BY MATRIX A TO OBTAIN P VECTOR.
!     SIMULTANEOUSLY ACCUMULATE DOT PRODUCT WP,(THE SCALAR K)
      WTAW=ZERO
      DO 120 I=NR,N1
      SUM=ZERO
      DO 80 J=NR,I
   80 SUM=SUM+A(I+1,J+1)*W(J)
      I1=I+1
      IF(N1-I1) 110,90,90
   90 DO 100 J=I1,N1
  100 SUM=SUM+A(J+1,I+1)*W(J)
  110 P(I)=SUM
  120 WTAW=WTAW+SUM*W(I)
!     P VECTOR AND SCALAR K  NOW STORED. NEXT COMPUTE Q VECTOR
      DO 130 I=NR,N1
  130 Q(I)=P(I)-WTAW*W(I)
!     NOW FORM PAP MATRIX, REQUIRED PART
      DO 140 J=NR,N1
      QJ=Q(J)
      WJ=W(J)
      DO 140 I=J,N1
  140 A(I+1,J+1)=A(I+1,J+1)-TWO*(W(I)*QJ+WJ*Q(I))
  150 BETA(NR)=B
      BETASQ(NR)=B*B
  160 GAMMA(NR+1)=A(NR+1,NR+1)
  170 B=A(N,N-1)
      BETA(N-1)=B
      BETASQ(N-1)=B*B
      GAMMA(N)=A(N,N)
  180 BETASQ(N)=ZERO
!     ADJOIN AN IDENTIFY MATRIX TO BE POSTMULTIPLIED BY ROTATIONS.
      DO 200 I=1,N
      DO 190 J=1,N
  190 VEC(I,J)=ZERO
  200 VEC(I,I)=ONE
      M=N
      SUM=ZERO
      NPAS=1
      GO TO 330
  210 SUM=SUM+SHIFT
      COSA=ONE
      G=GAMMA(1)-SHIFT
      PP=G
      PPBS=PP*PP+BETASQ(1)
      PPBR= SQRT(PPBS)
      DO 300 J=1,M
      COSAP=COSA
      IF(PPBS)230,220,230
  220 SINA=ZERO
      SINA2=ZERO
      COSA=ONE
      GO TO 270
  230 SINA=BETA(J)/PPBR
      SINA2=BETASQ(J)/PPBS
      COSA=PP/PPBR
!     POSTMULTIPLY IDENTITY BY P-TRANSPOSE MATRIX
      NT=J+NPAS
      IF(NT-N)250,240,240
  240 NT=N
  250 DO 260 I=1,NT
      TEMP=COSA*VEC(I,J)+SINA*VEC(I,J+1)
      VEC(I,J+1)=-SINA*VEC(I,J)+COSA*VEC(I,J+1)
  260 VEC(I,J)=TEMP
  270 DIA=GAMMA(J+1)-SHIFT
      U=SINA2*(G+DIA)
      GAMMA(J)=G+U
      G=DIA-U
      PP=DIA*COSA-SINA*COSAP*BETA(J)
      IF(J-M)290,280,290
  280 BETA(J)=SINA*PP
      BETASQ(J)=SINA2*PP*PP
      GO TO 310
  290 PPBS=PP*PP+BETASQ(J+1)
      PPBR= SQRT(PPBS)
      BETA(J)=SINA*PPBR
  300 BETASQ(J)=SINA2*PPBS
  310 GAMMA(M+1)=G
!     TEST FOR CONVERGENCE OF LAST DIAGONAL ELEMENT
      NPAS=NPAS+1
      IF(BETASQ(M)-RHOSQ)320,320,350
  320 EIG(M+1)=GAMMA(M+1)+SUM
  330 BETA(M)=ZERO
      BETASQ(M)=ZERO
      M=M-1
      IF(M)340,380,340
  340 IF(BETASQ(M)-RHOSQ)320,320,350
!     TAKE ROOT OF CORNER 2 BY 2 NEAREST TO LOWER DIAGONAL IN VALUE
!     AS ESTIMATE OF EIGENVALUE TO USE FOR SHIFT
  350 A2=GAMMA(M+1)
      R2=PT5*A2
      R1=PT5*GAMMA(M)
      R12=R1+R2
      DIF=R1-R2
      TEMP= SQRT(DIF*DIF+BETASQ(M))
      R1=R12+TEMP
      R2=R12-TEMP
      DIF= ABS(A2-R1)- ABS(A2-R2)
      IF(DIF)370,360,360
  360 SHIFT=R2
      GO TO 210
  370 SHIFT=R1
      GO TO 210
  380 EIG(1)=GAMMA(1)+SUM
!     INITIALIZE AUXILIARY TABLES REQUIRED FOR REARRANGING THE VECTORS
      DO 390 J=1,N
      IPOSV(J)=J
      IVPOS(J)=J
  390 IORD(J)=J
!     USE A TRANSPOSITION SORT TO ORDER THE EIGENVALUES
      M=N
      GO TO 430
  400 DO 420 J=1,M
      IF(EIG(J)-EIG(J+1))420,420,410
  410 TEMP=EIG(J)
      EIG(J)=EIG(J+1)
      EIG(J+1)=TEMP
      ITEMP=IORD(J)
      IORD(J)=IORD(J+1)
      IORD(J+1)=ITEMP
  420 CONTINUE
  430 M=M-1
      IF(M)400,440,400
  440 IF(N1)450,490,450
  450 DO 480 L=1,N1
      NV=IORD(L)
      NP=IPOSV(NV)
      IF(NP-L)460,480,460
  460 LV=IVPOS(L)
      IVPOS(NP)=LV
      IPOSV(LV)=NP
      DO 470 I=1,N
      TEMP=VEC(I,L)
      VEC(I,L)=VEC(I,NP)
  470 VEC(I,NP)=TEMP
  480 CONTINUE
!     BACK TRANSFORM THE VECTORS OF THE TRIPLE DIAGONAL MATRIX
  490 DO 540 NRR=1,N
      K=N1
  500 K=K-1
      IF(K)540,540,510
  510 SUM=ZERO
      DO 520 I=K,N1
  520 SUM=SUM+VEC(I+1,NRR)*A(I+1,K)
      SUM=SUM+SUM
      DO 530 I=K,N1
  530 VEC(I+1,NRR)=VEC(I+1,NRR)-SUM*A(I+1,K)
      GO TO 500
  540 CONTINUE
  550 RETURN
      END

!----------------------------------------------------------------------!
!                                                                      !
!                F R A G M E N T   S U B R O U T I N E S               !
!                                                                      !
!                  ( Theor. Chem. Acc. 134, 151, 2015 )                !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!   ORBOPTFrc: Optimize Orbitals of the Core-Fragment                  !
!   COEFW_F: COEFN = COEF*W where COEFN(N,Nf), COEF(N,N) and W(Nf,Nf)  !
!            Note: the sum index k runs within fragment kf = INDf(k)   !
!   ENERGYFr: Calculate the electronic energy and Lagrange Multipliers !
!   FFJMNFrc: Calculate the gen. Fock matrices Fj(m,n) and Frj(m,n)    !
!   PRODWCWFik: PRODWCWFik = W(ik)*CW12(q)                             !
!   PRODWCWFikq: PRODWCWFikq = W(ik)*CW12(q) excluding q'=q            !
!   ELGF: Calculate the Lagrange Multipliers of the fragment 'f'       !              
!   PCONVE_F: Check for the symmetry of Lagrangian of the fragment 'f' !
!   FFMIUG_SCALING_F: Decrease gen-Fock using a scaling factor of 'f'  !
!                                                                      !
!----------------------------------------------------------------------!

! ORBOPTFrc
      SUBROUTINE ORBOPTFrc(ITCALL,ITLIM,AHCORE,IJKL,XIJKL,QD,COEF,RO,   &
                           CJ12,CK12,ELAG,FMIUG0,DIPN,ADIPx,ADIPy,ADIPz,&
                           ILOOP,IRUNTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL DIIS,PERDIIS,CONVGDELAG,RESTART,SCALING
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/CONVERGENCE/DUMEL,PCONV,CONVGDELAG
      COMMON/INPNOF_DIIS_1/DIIS,PERDIIS,NDIIS,NTHDIIS,THDIIS
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPNOF_THRESH/THRESHL,THRESHE,THRESHEC,THRESHEN
      COMMON/INPNOF_COEFOPT/MAXLOOP
      COMMON/INPNOF_PRINT/NPRINT,IWRITEC,IMULPOP,IAIMPAC,IFCHK
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/CONVERGESUM/SUMDIF
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
!
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
!
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,TEMP,CFM
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::FMIUG,W,COEFNEW,BFM
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:)::FK
!
      INTEGER,ALLOCATABLE,DIMENSION(:)::INO1,INDOC,INCWO,INAC,INO0,INDf
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::WFr
!-----------------------------------------------------------------------
!     Read fragment information on the FILE 10 (FRAG)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      REWIND(10)
      READ(10,'(I6)')NFRAG
      ALLOCATE (INO1(NFRAG),INDOC(NFRAG),INCWO(NFRAG))
      ALLOCATE (INAC(NFRAG),INO0(NFRAG))
      DO i=1,NFRAG
       READ(10,'(6I6)')INO1(i),INDOC(i),INSOC,INCWO(i),INAC(i),INO0(i)
      ENDDO 
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
!
!     NO1f:  Number of inactive doubly occupied orbitals (OCC=1)
!     NDOCf: Number of strongly occupied MOs
!     NCWOf: Number of coupled weakly occupied MOs per strongly occupied
!     NO0f: Empty orbitals  (OCC=0)
!
!     NCOf:  Number of HF occupied MOs (OCC=1)
!     NVIRf: Number of HF virtual  MOs (OCC=0)
!     NCWOf*NDOCf: Active orbitals in the virtual subspace
!     NACf: Dimension of the active natural orbital subspace
!
!           NCOf      |       NVIRf          = NBFf
!       NO1f + NDOCf  |  NCWOf*NDOCf + NO0f  = NBFf
!            |      NACf             |
!
! -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      NO1f=INO1(1)
      NDOCf=INDOC(1)
      NCWOf=INCWO(1)
      NO0f=INO0(1)

      NCOf = NO1f + NDOCf
      NVIRf= NCWOf*NDOCf + NO0f
      NACf = NDOCf * ( 1 + NCWOf )
      NBFf = NO1f + NACf + NO0f

      NBF5f = NO1f + NACf
      IF(NBF5f>NBFf)NBF5f = NBFf
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Index correspondence
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (INDf(NBFf))
      DO i=1,NO1f 
       INDf(i) = i                       ! 1,NO1f
      ENDDO
      DO i=1,NACf                
       INDf(NO1f+i) = NCO-NDOCf+i        ! NCO-NDOCf+1,NCO+NCWOf*NDOCf
      ENDDO
      DO i=1,NO0f                     
       INDf(NO1f+NACf+i) = NBF-NO0f+i    ! NBF-NO0f+1,NBF
      ENDDO
!-----------------------------------------------------------------------
!                          Orbital Optimization
!-----------------------------------------------------------------------
      CONVGDELAG=.FALSE.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     First Call to ORBOPTFrc
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ITCALL==1)THEN
       IF(IRUNTYP==3.or.IRUNTYP==4)NZEROS=NZEROSr      
       WRITE(6,1)
       EELEC_OLD=EELEC
       SUMDIF_OLD=0.0d0
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate Initial Electronic Energy (EELEC) and Lagrangian
!     Note: This Energy is equal to EELEC from MOLOCUPrc
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (WFr(NSQ,NBF5f))
      CALL ENERGYFrc(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,ELAG,       &
                     DIPN,ADIPx,ADIPy,ADIPz,INDf,WFr,0)
      CALL PCONVE_F(INDf,ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
      DIF_EELEC=EELEC-EELEC_OLD
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Output of the first evaluated energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check ITCALL and SUMDIF for changing the scaling factor
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SCALING.and.ITCALL>2.and.ITCALL>ITLIM.and.                     &
         SUMDIF>SUMDIF_OLD)THEN
       NZEROS=NZEROS+1
       ITLIM=ITCALL+ITZITER
!      NZEROS>NZEROSm -> Restart from here with NZEROSr
       IF(NZEROS>NZEROSm)THEN
        NZEROS=NZEROSr
       ENDIF
      ENDIF
      SUMDIF_OLD=SUMDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check for the Symmetry of Lagrangian (ELAG(IQJQ)-ELAG(JQIQ))
!     for ITCALL>1 (do not stop in the first call)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      PCONV=ABS(DIF_EELEC)
      IF( ITCALL>1 .and. DUMEL<THRESHL .and. PCONV < THRESHE )THEN
       CONVGDELAG=.TRUE.
       RETURN
      ENDIF
!-----------------------------------------------------------------------
!                       START SCF-ITERATION CYCLE
!-----------------------------------------------------------------------
      ALLOCATE (FMIUG(NBFf,NBFf),W(NBFf,NBFf),EVA(NBFf),TEMP(NBFf))
      ALLOCATE (COEFNEW(NBF,NBFf),FK(MAXLOOP,NBFf,NBFf))
      ALLOCATE (BFM(MAXLOOP+1,MAXLOOP+1),CFM(MAXLOOP+1))
!
      IF(ITCALL==1.and.INPUTFMIUG==0)THEN
       MAXLP=1
      ELSE
       MAXLP=MAXLOOP
      ENDIF
!-----------------------------------------------------------------------
      ILOOP=0
      IDIIS=0
      DO LOOP=1,MAXLP
       ILOOP=ILOOP+1
       EELEC_OLD2=EELEC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Generalized Fock Matrix (FMIUG)
!
!      Convergent technique:
!
!      1) SCALING:   Decrease FMIUG using a scaling factor.
!                    The scaling factor varies until the number of
!                    ZEROS (.000##) is equal for all elements Fij
!      3) DIIS       Direct Inversion in the Iterative Subspace 
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(SCALING)CALL FFMIUG_SCALING_F(INDf,FMIUG,ELAG,FMIUG0,ITCALL)
       IF(DIIS.and.DUMEL<THDIIS)THEN
        CALL FFMIUG_DIIS(NBFf,FMIUG,CFM,BFM,FK,IDIIS)
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      DIAGONALIZE SQUARE MATRIX (FMIUG) FOR REAL SYMMETRIC CASE
!      W - EIGENVECTORS, EVA - EIGENVALUES IN ALGEBRAIC DESCENDING ORDER
!      HOUSEHOLDER METHOD
!      NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL DIAG(NBFf,FMIUG,W,EVA,TEMP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Move EVA -> FMIUG0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO I=1,NBFf
        IQ=INDf(i)
        FMIUG0(IQ)=EVA(I)
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      New Coefficients (COEFNEW=COEF*W), Move COEFNEW -> COEF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL COEFW_F(INDf,NBF,NBFf,COEFNEW,COEF,W)
       DO j=1,NBFf
        JQ=INDf(j)
        DO i=1,NBF
         COEF(i,JQ) = COEFNEW(i,j)
        ENDDO
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Calculate Dj(miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,nbf)
!      Keep Matrices Jj, Kj in WJj, WKj
!      Form F Matrix and keep it in WF
!      Compute G, Lagrangian Multipliers (ELAG) and one-energies (E)
!      Calculate Electronic Energy (EELEC)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL ENERGYFrc(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,ELAG,      &
                      DIPN,ADIPx,ADIPy,ADIPz,INDf,WFr,1)
       DIF_EELEC2=EELEC-EELEC_OLD2
!      Intermediate Output (Nprint=2)
       IF(NPRINT==2)WRITE(6,3)LOOP,EELEC,EELEC+EN,DIF_EELEC2
       CALL PCONVE_F(INDf,ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      Check for energy convergent solution
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF( DABS(DIF_EELEC2) < THRESHEC )THEN
        DEALLOCATE (COEFNEW,FMIUG,W,EVA,TEMP)
        DIF_EELEC=EELEC-EELEC_OLD
        EELEC_OLD=EELEC
        RETURN
       ENDIF
!------------------------------------------------------------------------
!                       LOOP-END OF SCF-ITERATION
!-----------------------------------------------------------------------
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Itermediate Output of the external iteration
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DIF_EELEC=EELEC-EELEC_OLD
      EELEC_OLD=EELEC
!-----------------------------------------------------------------------
!     FORMAT STATEMENTS
!-----------------------------------------------------------------------
    1 FORMAT(/2X,'RESULTS OF OCCUPATION-COEFFICIENT S.C.F. PROCEDURE'   &
            ,/1X,'===================================================', &
        //2X,'Iter',5X,'Electronic Energy',6X,'Total Energy',           &
          3X,'Energy Convergency',4X,'Max Mul-Lag Diff',/)
    2 FORMAT(I5,'.',1X,F20.10,1X,F19.10,2X,F15.10,8X,F11.6)
    3 FORMAT(2X,I3,'.',3X,F17.8,4X,F15.8,6X,F11.6)
!-----------------------------------------------------------------------
      DEALLOCATE (INO1,INDOC,INCWO,INAC,INO0,INDf,WFr)
      RETURN
      END

! COEFW_F
      SUBROUTINE COEFW_F(INDf,N,Nf,COEFN,COEF,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(Nf)::INDf
      DOUBLE PRECISION,DIMENSION(N,Nf)::COEFN
      DOUBLE PRECISION,DIMENSION(N,N)::COEF
      DOUBLE PRECISION,DIMENSION(Nf,Nf)::W
!-----------------------------------------------------------------------
!     COEFN = COEF*W
!-----------------------------------------------------------------------
      DO i=1,N
       DO j=1,Nf
        COEFN(i,j)=0.0d0
        do k=1,Nf
         kf = INDf(k)
         COEFN(i,j) = COEFN(i,j) + COEF(i,kf)*W(k,j)
        enddo
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! ENERGYFrc
      SUBROUTINE ENERGYFrc(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,      &
                            ELAG,DIPN,ADIPx,ADIPy,ADIPz,INDf,WFr,IE)
!-----------------------------------------------------------------------
!     Calculate the electronic energy and Lagrange Multipliers
!-----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
!
      INTEGER,DIMENSION(NBFf)::INDf
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5f)::WFr
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::WJj,WKj,WF,G,AUX1
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::AUX2
!-----------------------------------------------------------------------
!     Calculate Dj: QD(j,miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,NBF5) 
!-----------------------------------------------------------------------
      ALLOCATE (WJj(NSQ,NBF5),WKj(NSQ,NBF5),AUX1(NBF,NBF),AUX2(NSQ))
      DO j=1,NBF5
       CALL DENMATj(j,AUX1,COEF,NBF)
       QD(j,1:NBF,1:NBF) = AUX1(1:NBF,1:NBF)
       CALL HSTARJ(AUX2,AUX1,IJKL,XIJKL)
       WJj(1:NSQ,j) = AUX2(1:NSQ)
       CALL HSTARK(AUX2,AUX1,IJKL,XIJKL)
       WKj(1:NSQ,j) = AUX2(1:NSQ)
      ENDDO
      DEALLOCATE (AUX1,AUX2)
!-----------------------------------------------------------------------
!     Form F Matrix and keep it in WF
!     WFr: Constant part of F related to the interactions with fragments
!-----------------------------------------------------------------------
      ALLOCATE (WF(NSQ,NBF5f))
      CALL FFJMNFrc(INDf,RO,CJ12,CK12,AHCORE,WJj,WKj,WF,WFr,            &
                    ADIPx,ADIPy,ADIPz,IE)
      DEALLOCATE (WJj,WKj)
!-----------------------------------------------------------------------
!     Calculate G Matrix
!-----------------------------------------------------------------------
      ALLOCATE (G(NBF,NBF5f))
      DO jf=1,NBF5f
       IQ = INDf(jf)
       do i=1,nbf
        G(i,jf) = FC(i,IQ,WF(1,jf),COEF) + FC(i,IQ,WFr(1,jf),COEF)
       enddo
      ENDDO
      DEALLOCATE (WF)
!-----------------------------------------------------------------------
!     Lagrangian Multipliers (ELAG)
!-----------------------------------------------------------------------
      CALL ELGF(INDf,ELAG,COEF,G)
      DEALLOCATE (G)
!-----------------------------------------------------------------------
!     Calculate ELECTRONIC ENERGY
!-----------------------------------------------------------------------
!     Calculate Trace(Ct*RO*H*C+Ct*G)
      CALL EELECTRr(EELEC,AHCORE,ELAG,COEF,RO)
!     Include Nuclear Dipoles if electric field =/ 0
      IF(EFIELDL)THEN
       CALL EELECTRr_EFIELD(EELEC_EF,COEF,RO,DIPN,ADIPX,ADIPY,ADIPZ)
       EELEC=EELEC+EELEC_EF
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! FFJMNFrc
      SUBROUTINE FFJMNFrc(INDf,RO,CJ12,CK12,H,DJ,DK,F,Fr,               &
                          ADIPx,ADIPy,ADIPz,IE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL EFIELDL
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f 
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
!
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::DJ,DK
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5f)::F,Fr
!-----------------------------------------------------------------------
!                            Calculate Fj(m,n)
!-----------------------------------------------------------------------
      IF(NO1f>1)THEN
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         F(ik,1) = H(i,k) + PRODWCWFik(ik,INDf,DJ,CJ12)                 &
                          - PRODWCWFik(ik,INDf,DK,CK12)                  
         DO jf=NO1f+1,NBF5f                                              
          j = INDf(jf)                                                   
          F(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )                      &
                   + PRODWCWFikq(ik,jf,INDf,DJ,CJ12)                    &
                   - PRODWCWFikq(ik,jf,INDf,DK,CK12)
         ENDDO
        enddo
       enddo
       DO jf=2,NO1f
        F(1:NSQ,jf) = F(1:NSQ,1)
       ENDDO
      ELSE
       DO jf=1,NBF5f
        j = INDf(jf)
        do i=1,nbf
         do k=1,nbf
          ik=i+(k-1)*nbf
          F(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )                      &
                   + PRODWCWFikq(ik,jf,INDf,DJ,CJ12)                    &
                   - PRODWCWFikq(ik,jf,INDf,DK,CK12)
         enddo
        enddo
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
!                          Calculate Frj(m,n)
!-----------------------------------------------------------------------
      IF(IE==0)THEN
       IF(NO1f>1)THEN
        do i=1,nbf
         do k=1,nbf
          ik=i+(k-1)*nbf
          Fr(ik,1) = H(i,k)+PRODWCWij(ik,DJ,CJ12)-PRODWCWij(ik,DK,CK12)
          Fr(ik,1) = Fr(ik,1)-F(ik,1)
          DO jf=NO1f+1,NBF5f
           j = INDf(jf)
           Fr(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )                    &
                     + PRODWCWijq(ik,j,DJ,CJ12)-PRODWCWijq(ik,j,DK,CK12) 
           Fr(ik,jf) = Fr(ik,jf) - F(ik,jf)                              
          ENDDO                                                          
         enddo                                                           
        enddo                                                            
        DO jf=2,NO1f                                                     
         Fr(1:NSQ,jf) = Fr(1:NSQ,1)                                      
        ENDDO                                                            
       ELSE                                                              
        DO jf=1,NBF5f                                                    
         j = INDf(jf)                                                    
         do i=1,nbf                                                      
          do k=1,nbf                                                     
           ik=i+(k-1)*nbf                                                
           Fr(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )                    &
                     + PRODWCWijq(ik,j,DJ,CJ12)-PRODWCWijq(ik,j,DK,CK12)
           Fr(ik,jf) = Fr(ik,jf) - F(ik,jf)
          enddo
         enddo
        ENDDO
       ENDIF
!-----------------------------------------------------------------------
!      Including Electric Field
!      Note: FEikj is constant, so can be keeped in Fr
!-----------------------------------------------------------------------
       IF(EFIELDL)THEN
        DO jf=1,NBF5f
         j = INDf(jf)
         do i=1,nbf
         do k=1,nbf
          ik=i+(k-1)*nbf
          FEikj = ( EX*ADIPx(i,k)+EY*ADIPy(i,k)+EZ*ADIPz(i,k) ) * RO(j)
          Fr(ik,jf) = Fr(ik,jf) + FEikj
         enddo
         enddo
        ENDDO
       ENDIF
!-----------------------------------------------------------------------
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! PRODWCWFik
      FUNCTION PRODWCWFik(ik,INDf,W,CW12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f      
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
!
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*CW12(1,*) por IQP
!-----------------------------------------------------------------------
      IQ = INDf(1)
      PRODWCWFik = 0.0d0
      DO j=1,NBF5f
       IQP = INDf(j)
       PRODWCWFik = PRODWCWFik + W(ik,IQP)*CW12(IQ,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PRODWCWFikq
      FUNCTION PRODWCWFikq(ik,jf,INDf,W,CW12)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f      
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
!
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
!-----------------------------------------------------------------------
!     Sum W*CW12(IQ,*) por IQP, IQ is not considered
!-----------------------------------------------------------------------
      PRODWCWFikq = 0.0d0
      IQ = INDf(jf)
      DO j=1,jf-1
       IQP = INDf(j)
       PRODWCWFikq = PRODWCWFikq + W(ik,IQP)*CW12(IQ,IQP)
      ENDDO
      DO j=jf+1,NBF5f
       IQP = INDf(j)
       PRODWCWFikq = PRODWCWFikq + W(ik,IQP)*CW12(IQ,IQP)
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! ELGF
      SUBROUTINE ELGF(INDf,ELAG,C,G)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f      
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,C
      DOUBLE PRECISION,DIMENSION(NBF,NBF5f)::G
!-----------------------------------------------------------------------
!     Calculate the Lagrangian Multipliers
!-----------------------------------------------------------------------
      DO i=1,NBFf
       IQ=INDf(i)
       DO j=1,NBF5f
        JQ=INDf(j)
        ELAG(IQ,JQ) = 0.0d0
        do k=1,nbf
         ELAG(IQ,JQ) = ELAG(IQ,JQ) + C(k,IQ)*G(k,j)
        enddo
       ENDDO
       DO j=NBF5f+1,NBFf
        JQ=INDf(j)
        ELAG(IQ,JQ) = 0.0d0
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PCONVE_F
      SUBROUTINE PCONVE_F(INDf,ELAG,DUM,MAXI,MAXJ,SUMDIF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f      
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG
!-----------------------------------------------------------------------
!     MAXIMUM LAGRANGE MULTYPLIER DIFFERENCE [ELAG(IQ,JQ)-ELAG(JQ,IQ)]
!-----------------------------------------------------------------------
      DUM=0.0d0
      SUMDIF=0.0d0
      DO i=1,NBFf
       IQ=INDf(i)
       DO j=1,NBFf
        JQ=INDf(j)
        GCF=DABS(ELAG(IQ,JQ)-ELAG(JQ,IQ))
        SUMDIF=SUMDIF+GCF
        IF(GCF>DUM)THEN
         DUM=GCF
         MAXI=IQ
         MAXJ=JQ
        ENDIF
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! FFMIUG_SCALING_F
      SUBROUTINE FFMIUG_SCALING_F(INDf,FMIUG,ELAG,FMIUG0,ITCALL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL RESTART,SCALING
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPSCALING/SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER
      COMMON/INPNOF_RSTRT/RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
      COMMON/INPFILE_FRAG/NO1f,NBFf,NBF5f      
!
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBFf,NBFf)::FMIUG
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG
!-----------------------------------------------------------------------
!     Generalized Fock Matrix (FMIUG)
!-----------------------------------------------------------------------
      IF(itcall==1.AND.INPUTFMIUG==0)THEN          ! only for itcall==1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO i=1,NBFf
        IQ=INDf(i)
        DO j=1,i-1
         JQ=INDf(j)
         FMIUG(i,j)=(ELAG(IQ,JQ)+ELAG(JQ,IQ))/2.0        ! Nondiagonal 
         FMIUG(j,i)=FMIUG(i,j)
        ENDDO
        FMIUG(i,i)=ELAG(IQ,IQ)                            ! Diagonal
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO i=1,NBFf
        IQ=INDf(i)
        DO j=1,i-1
         JQ=INDf(j)
         FMIUG(i,j)=ELAG(IQ,JQ)-ELAG(JQ,IQ)              ! Nondiagonal 
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
!        Decrease FMIUG using a scaling factor
!        The scaling factor varies until the number of
!        ZEROS (.000##) is equal for all elements Fij
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         CALL F01(NZEROS+9,FMIUG(i,j))
!-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         FMIUG(j,i)=FMIUG(i,j)                           ! Fji=Fij
        ENDDO
        FMIUG(i,i)=FMIUG0(IQ)                            ! Diagonal
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

!----------------------------------------------------------------------!
!                                                                      !
!                 N O F - M P 2   S U B R O U T I N E S                !
!                                                                      !
!            ( PRL 119, 063002, 2017; PRA 98, 022504, 2018 )           !
!                                                                      !
!----------------------------------------------------------------------!

! ECorrNonDyn
      SUBROUTINE ECorrNonDyn(RO,QK,ENonDEnergy)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/CorrNonDynamic/ECnd,ECndl,ECndHF
!
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::BETA,FIs
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::CK12nd
!-----------------------------------------------------------------------
      ALLOCATE(FIs(NBF5),CK12nd(NBF5,NBF5))
      CK12nd = 0.0d0      
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --      
!                       FIs(j)  = 2*RO(j)*HOLE(j)      
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      FIs = 0.0d0
      DO j=NO1+1,NBF5
       FIs(j) = 2.0d0*RO(j)*(1.0d0-RO(j))
      ENDDO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!          Inter-pair Non-Dynamic (Static) Electron Correlation
!                  CK12ji = +- FIs(j)*FIs(i) (-+PIs)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      DO j=NO1+1,NBF5
       DO i=NO1+1,NBF5
        CK12nd(j,i) = FIs(j)*FIs(i)        
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(FIs)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!           Intra-pair Non-Dynamic (Static) Electron Correlation
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     BETA(j) = DSQRT(2*HOLE(j)) * DSQRT(RO(j))
!     BETA(j) = DSQRT(2*RO(j))   * DSQRT(RO(j))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(BETA(NBF5))
      DO j=1,NBF5
       Cj = 1.0d0 - DABS(1.0d0-2.0d0*RO(j))
       BETA(j) = DSQRT( Cj*RO(j) )
      ENDDO
!      
      DO l=1,NDOC
       ln = NO1+l
       DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        in = NO1+i
        CK12nd(ln,in) = BETA(ln)*BETA(in)
        CK12nd(in,ln) = BETA(in)*BETA(ln)
        DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         jn = NO1+j
         CK12nd(jn,in) = - BETA(jn)*BETA(in)         
        ENDDO
       ENDDO
      ENDDO
      DEALLOCATE(BETA)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     Non-Dynamic Correlation Energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(MSpin==0)then
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       ENonDEnergy = 0.0d0
       ECndHF = 0.0d0       
       do i=1,ndoc
        in = no1+i
        ENonDEnergy = ENonDEnergy - PRODCWQWj(in,CK12nd,QK)
        do iw=1,ncwo
         in = na+ncwo*(ndoc-i)+iw
         ENonDEnergy = ENonDEnergy -PRODCWQWj(in,CK12nd,QK)
        enddo
       enddo
       if(NSOC>0)then
        do i=ndoc+1,ndns
         in = no1+i
         ENonDEnergy = ENonDEnergy - PRODCWQWj(in,CK12nd,QK) 
         ECndHF = ECndHF - CK12nd(in,in)*QK(in*(in+1)/2)             
        end do
       end if
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      else if(MSpin>0)then
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       ENonDEnergy = 0.0d0
       do i=1,ndoc
        in = no1+i
        ENonDEnergy = ENonDEnergy - PRODCWQWj1(in,CK12nd,QK)
        do iw=1,ncwo
         in = na+ncwo*(ndoc-i)+iw
         ENonDEnergy = ENonDEnergy -PRODCWQWj2(in,CK12nd,QK)
        enddo
       enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      end if
!-----------------------------------------------------------------------
      DEALLOCATE(CK12nd)
      RETURN
      END

! ORBINVMP2 (OIMP2)
      SUBROUTINE ORBINVMP2(ELAG,COEF,RO,CJ12,CK12,AHCORE,IERI,ERI,ADIPx,ADIPy,ADIPz)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL HighSpin
      LOGICAL MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_GENERALINF/ICOEF,MAXIT
      COMMON/INPNOF_MBPT/MBPT,TDHF,TUNEMBPT,MBPTMEM
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/INPFILE_NO1PT2/NO1PT2,NEX
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/CorrNonDynamic/ECnd,ECndl,ECndHF
      COMMON/INPNOF_Tijab/NOUTTijab,NTHRESHTijab,THRESHTijab
      COMMON/NumLinIndOrb/NQMT
!
      INTEGER,DIMENSION(NIJKL) :: IERI
      DOUBLE PRECISION,DIMENSION(NIJKL) :: ERI
      DOUBLE PRECISION,DIMENSION(NBF5) :: RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5) :: CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: AHCORE,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: ELAG,COEF
!      
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: OCC,EIG,FI1,FI2,Tijab
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: VEC,FOCKm
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:) :: ERImol
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:,:) :: ERImolMBPT
!-----------------------------------------------------------------------
!     NO1:  Number of inactive doubly occupied orbitals (OCC=1)         
!     NDOC: Number of strongly doubly occupied MOs                      
!     NSOC: Number of strongly singly occupied MOs                      
!     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)                        
!     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
!     NCWO*NDOC: Active orbitals in the virtual subspace                
!     NO0:  Empty orbitals  (OCC=0)                                      
!     NVIR: Number of weakly occupied MOs + empty MOs                   
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!           NO1 | NDOC  + NSOC  |   NCWO*NDOC + NO0  = NBF               
!           NO1 |      NDNS     |          NVIR      = NBF 
!               | -NAC- |       |  -   NAC  - |
!                      NB      NA            NBF5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                               !  CLOSED (NB=NA=NCO,NSOC=0)
!     NDOC = NB - NO1           !  NDOC = NCO - NO1, NO1 <= NCO
!     NDNS = NDOC + NSOC        !  NDNS = NDOC      
!     NA   = NO1 + NDNS         !  NA = NB = NCO
!     NVIR = NBF - NA           !  NBF - NCO
!-----------------------------------------------------------------------
!     Calculation of the Matrix of Lagrange Multipliers if ICOEF=0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==0)CALL ELAGCOEF0(ELAG,COEF,RO,CJ12,CK12,AHCORE,         &
                                 ADIPx,ADIPy,ADIPz,IERI,ERI)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Substracting core orbitals (NO1PT2)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NOCB = NB - NO1PT2
      NOC = NA - NO1PT2
      NVI = NQMT - NA 
      NORB = NQMT - NO1PT2
      if(.not.MBPT) WRITE(6,1)NO1PT2,NOC,NVI,NORB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NOCNC = NOC + NCWO*NOCB <= NORB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NOCNC = NOC + NCWO*NOCB
      NOCNCT = NOCNC*(NOCNC+1)/2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If NOCNC > NORB: Check the value of NCWO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOCNC>NORB)THEN
       NCWO1 = (NORB-NSOC)/NOCB - 1 
       IF(NCWO>NCWO1)THEN
        WRITE(6,4)                                                      &
        'NCWO is too large, reduce the value at least to',NCWO1        
        STOP
       ENDIF
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If NO1PT2<NO1: Check the value of NCWO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NCWO1 = (NQMT-NO1-NSOC)/NOC - 1 
      IF(NO1PT2<NO1.and.NCWO>NCWO1)THEN
       WRITE(6,4)                                                       &
       'NCWO is too large, reduce the value at least to',NCWO1        
       STOP
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     OCC,VEC: Occupations and Molecular Orbitals without Core
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(OCC(NOCNC),VEC(NBF,NORB))
      DO i=1,NOC
       OCC(i) = RO(i+NO1PT2)
      ENDDO
      DO i=NOC+1,NOCNC
       if(NOCNC+NO1PT2<=NBF5)then      
        OCC(i) = RO(i+NO1PT2)
       else
        OCC(i) = 0.0d0       
       end if
      ENDDO
      DO j=1,NORB
       do i=1,NBF
        VEC(i,j) = COEF(i,j+NO1PT2)
       enddo
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     EIG: Energy Eigenvalues without Core
!     FOCKm: Fock Matrix in the Molecular Basis
!     EHFL = E(0) + E(1) : HF Energy with Non-HF Orbitals (COEF/=CHF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(EIG(NORB),FOCKm(NORB,NORB))
      CALL FOCKMOL(NORB,COEF,VEC,ELAG,EIG,FOCKm,AHCORE,IERI,ERI,EHFL)      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Integral transformation ( Form <ab|rs> )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ERImol(NOC,NBFT,NBF))
!     FORM (pq/rj)
      CALL ERIC1(ERImol,IERI,ERI,VEC,NOC,NORB)
!     FORM (ai/rj) for all a,i
      CALL ERIC23(ERImol,VEC,NVI,NOC,NORB)
!     FORM (ai/bj) for all b
      CALL ERIC4(ERImol,VEC(1,NOC+1),NOC,NVI,NORB)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If it is NOF-X (X=RPA, GW, etc),  MBPT=TRUE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(MBPT) then
       if(NORB/=NBF .and. NO1PT2/=1) then
        write(*,*) 'MBPT corrections only available with NO1PT2=1 and NORB=NBF'
        CALL ABRT       
       end if
       ALLOCATE(ERImolMBPT(NBF,NBF,NBF,NBF))
       ERImolMBPT=0.0D0
       iai = 0
       do ia=1,nvi
        do i=1,noc
         iai = iai+1
         do ib=1,nvi
          do j=1,noc
           ERImolMBPT(j,i,ia+noc,ib+noc) = ERImol(j,iai,ib)
           ERImolMBPT(j,ia+noc,i,ib+noc) = ERImolMBPT(j,i,ia+noc,ib+noc)
           ERImolMBPT(ib+noc,ia+noc,i,j) = ERImolMBPT(j,i,ia+noc,ib+noc)
           ERImolMBPT(ib+noc,i,ia+noc,j) = ERImolMBPT(j,i,ia+noc,ib+noc)
           ERImolMBPT(i,j,ib+noc,ia+noc) = ERImolMBPT(j,i,ia+noc,ib+noc)
           ERImolMBPT(i,ib+noc,j,ia+noc) = ERImolMBPT(j,i,ia+noc,ib+noc)
           ERImolMBPT(ia+noc,ib+noc,j,i) = ERImolMBPT(j,i,ia+noc,ib+noc)
           ERImolMBPT(ia+noc,j,ib+noc,i) = ERImolMBPT(j,i,ia+noc,ib+noc)
          end do
         end do
        end do
       end do
       DEALLOCATE(ERImol)
       call MBPTCALC(NBF,NCO,NA,NCWO,NO1PT2,EHFL,EN,ECndHF,ECndl,EELEC,COEF,OCC,EIG,FOCKm,&
       ERImolMBPT,ADIPx,ADIPy,ADIPz,TUNEMBPT,MBPTMEM,TDHF)
       DEALLOCATE(EIG,FOCKm,ERImolMBPT,OCC,VEC)
      else
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!           Calculate second-order Dynamic Correlation E(2)
!         Calculate excitation amplitudes to determine Psi(1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       NN1 = NOC*NOC*NVI*NVI
       NN2 = NOC*NVI
       ALLOCATE (Tijab(NN1),FI1(NORB),FI2(NORB))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                              FI1 and FI2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     like in PRL (NOF-MP2) (best result with PNOF7s)
!     Note: Ci=DSQRT[4*(1-OCCi)*OCCi],FI2i=1-Ci*Ci -> (1-2*OCCi)**2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       FI1 = 1.0d0
       DO i=1,NOCNC             ! best for H2
        Ci = 1.0d0 - DABS(1.0d0-2.0d0*OCC(i))
        FI1(i) = 1.0d0 - Ci*Ci
       ENDDO
!- - - - - - - - - - - - - - - - - - - - - - -      
       FI2 = 1.0d0    
       DO i=NOC+1,NOCNC
        Ci = DABS(1.0d0-2.0d0*OCC(i))
        FI2(i) = Ci*Ci
       ENDDO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     Calculate Tijab amplitude solving Sparse Sym. Linear System
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL CALTijabIsym(NOCB,NOC,NVI,NORB,NN1,EIG,FOCKm,ERImol,Tijab,FI1,FI2)                                         
       if(NOUTTijab==1)CALL OUTPUTTijab_rc(NOC,NVI,NN1,Tijab)             
       CALL ORBINVE2Totalsym(NOCB,NOC,NVI,NN1,NBF,NBFT,ERImol,Tijab,ECd)
       WRITE(6,2)EHFL+EN+ECndHF
       WRITE(6,3)ECd,ECndl,ECd+ECndl,EHFL+ECd+ECndl+EN+ECndHF
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       DEALLOCATE(OCC,VEC,FI1,FI2,EIG,FOCKm,ERImol,Tijab)
      endif
      RETURN
!-----------------------------------------------------------------------
    1 FORMAT(//,2X,'NOF-MP2',/1X,9('='),//,                             &
               1X,'NUMBER OF CORE ORBITALS  (NO1PT2) =',I5,/,           &
               1X,'NUMBER OF Doubly OCC. ORBS. (NOC) =',I5,/,           &
               1X,'NUMBER OF VIRTUAL ORBS.     (NVI) =',I5,/,           &
               1X,'NUMBER OF LIN. IND. ORBS.  (NORB) =',I5)              
    2 FORMAT(/3X,'          Ehfc =',F20.10)                              
    3 FORMAT(/3X,'           ECd =',F20.10,/,                           &
              3X,'          ECnd =',F20.10,/,                           &
              3X,'         ECorr =',F20.10,/,                           &
              3X,'     E(NOFMP2) =',F20.10)
    4 FORMAT(/1X,A47,I5)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END

! CALTijabIsym
      SUBROUTINE CALTijabIsym(NOCB,NOC,NVI,NORB,NN,EIG,FOCKm,           &
                              ERImol,Tijab,FI1,FI2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_CGM/ICGMETHOD
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
!
      DOUBLE PRECISION,DIMENSION(NN) :: Tijab
      DOUBLE PRECISION,DIMENSION(NORB) :: EIG,FI1,FI2
      DOUBLE PRECISION,DIMENSION(NORB,NORB) :: FOCKm
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF) :: ERImol
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IROW,ICOL,NPAIR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: A,B
!-----------------------------------------------------------------------
!     NPAIR: number of the pair to which the virtual orbital belongs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(npair(nvi))
      do i=1,nocb
       do iw=1,ncwo
        k = ncwo*(nocb-i) + iw
        npair(k) = i
       end do
      end do
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NN:  the order of the original sparse matrix
!     NNZ: the number of non-zero elements in the lower triangular of A
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NNZM = 2*NOC*NOC*NVI*NVI*NORB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     A: array (NNZ) that contains the non-zero elements of the lower 
!        triangular part of the original matrix, ordered by increasing
!        row index and by increasing column index within each row
!     IROW: the row indices of non-zero elements given in A
!     ICOL: the column indices of non-zero elements given in A
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(A(NNZM),IROW(NNZM),ICOL(NNZM))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Elements A(ijab,i'j'a'b')
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      nnz = 0
      nnz_end = 0

      do ib=1,nvi
       do ia=1,nvi
        do j=1,noc
         do i=1,noc

          jab =     (j-1)*noc + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi
          iab = i             + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi
          ijb = i + (j-1)*noc                  + (ib-1)*noc*noc*nvi
          ija = i + (j-1)*noc + (ia-1)*noc*noc
          ijab= i + (j-1)*noc + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi

          nnz = nnz + 1
          nnz_ini = nnz_end + 1
          A(nnz) = FOCKm(ia+noc,ia+noc) + FOCKm(ib+noc,ib+noc)          &
                 - FOCKm(i,i) - FOCKm(j,j)    ! diagonal elem.

          IROW(nnz) = ijab
          ICOL(nnz) = i + jab

          do k=1,i-1
           IF(DABS(FOCKm(i,k))>1.0d-10)THEN
            nnz = nnz + 1
            Cki = FI2(k)*FI2(i)
            A(nnz) = - Cki*FOCKm(i,k)
            IROW(nnz) = ijab
            ICOL(nnz) = k + jab
           ENDIF
          end do

          do k=1,j-1
           IF(DABS(FOCKm(j,k))>1.0d-10)THEN
            nnz = nnz + 1
            Ckj = FI2(k)*FI2(j)
            A(nnz) = - Ckj*FOCKm(j,k)
            IROW(nnz) = ijab
            ICOL(nnz) = (k-1)*noc + iab
           ENDIF
          end do

          do k=1,ia-1
           IF(DABS(FOCKm(ia+noc,k+noc))>1.0d-10)THEN
            nnz = nnz + 1
            if(npair(k)==npair(ia))then
             Ckia = FI1(k+noc)*FI1(ia+noc)
            else
             Ckia = FI2(k+noc)*FI2(ia+noc)
            endif
            A(nnz) = Ckia*FOCKm(ia+noc,k+noc)
            IROW(nnz) = ijab
            ICOL(nnz) = (k-1)*noc*noc + ijb
           ENDIF
          end do

          do k=1,ib-1
           IF(DABS(FOCKm(ib+noc,k+noc))>1.0d-10)THEN
            nnz = nnz + 1
            if(npair(k)==npair(ib))then
             Ckib = FI1(k+noc)*FI1(ib+noc)
            else
             Ckib = FI2(k+noc)*FI2(ib+noc)
            endif
            A(nnz) = Ckib*FOCKm(ib+noc,k+noc)
            IROW(nnz) = ijab
            ICOL(nnz) = (k-1)*noc*noc*nvi + ija
           ENDIF
          end do

          nnz_end = nnz
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!         Sort Column Index for a given IROW = ijab
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          do k=nnz_ini,nnz_end-1
           do l=k+1,nnz_end
            if(ICOL(k)>ICOL(l))then
             ITEMPCOL = ICOL(l)
             TEMPVECT = A(l)
              ICOL(l) = ICOL(k)
                 A(l) = A(k)
              ICOL(k) = ITEMPCOL
                 A(k) = TEMPVECT
            endif
           end do
          end do
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         end do
        end do      
       end do
      end do
      DEALLOCATE(NPAIR)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Tijab: Initial approximation for the vector Tijab
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      iai = 0
      do ia=1,nvi
       do i=1,noc
        iai = iai+1
        do ib=1,nvi
         do j=1,noc
          ijab = i + (j-1)*noc + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi
          Eijab = EIG(ib+noc) + EIG(ia+noc) - EIG(j) - EIG(i)
          Tijab(ijab) = - ERImol(j,iai,ib)/Eijab
         end do
        end do      
       end do
      end do
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     B: the right-hand side vector
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(B(NN))
      do i=1,noc
       lmin_i = noc+ncwo*(noc-i)+1
       lmax_i = noc+ncwo*(noc-i)+ncwo
       do j=1,noc
        if(j==i)then
!--------------------------------------------------------------------
!        excitations inside the subspace 'i'
!--------------------------------------------------------------------
         do k=1,nvi
          ik = i + (k-1)*noc
          kn = k + noc
          do l=1,nvi
           ln = l + noc
           if(      (lmin_i<=kn.and.kn<=lmax_i)                         &
              .and. (lmin_i<=ln.and.ln<=lmax_i) )then
            Ciikl = FI1(kn)*FI1(ln)*FI1(i)*FI1(i)
           else
            Ciikl = FI2(kn)*FI2(ln)*FI2(i)*FI2(i)
           endif
           iikl =  i + (i-1)*noc + (k-1)*noc*noc + (l-1)*noc*noc*nvi
           B(iikl) = - Ciikl*ERImol(i,ik,l)
          enddo
         enddo
!--------------------------------------------------------------------
        else
!--------------------------------------------------------------------
         do k=1,nvi
          ik = i + (k-1)*noc
          kn = k + noc
          do l=1,nvi
           ln = l + noc
           ijkl =  i + (j-1)*noc + (k-1)*noc*noc + (l-1)*noc*noc*nvi
           Cijkl = FI2(kn)*FI2(ln)*FI2(i)*FI2(j)
           B(ijkl) = - Cijkl*ERImol(j,ik,l)
          enddo
         enddo
!--------------------------------------------------------------------
        endif
       enddo
      enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Solving the Sparse Linear System AT=B using the CG method
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICGMETHOD==1)THEN
       CALL SparseSymLinearSystem_CG(NN,NNZ,A,IROW,ICOL,B,Tijab)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Prepare for calling the subroutine F11JEF of the NAG Library
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE IF(ICGMETHOD==2)THEN
       CALL SparseSymLinearSystem_NAG(NN,NNZ,A,IROW,ICOL,B,Tijab)
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(A,IROW,ICOL,B)
      RETURN
!-----------------------------------------------------------------------
      END

! SparseSymLinearSystem_NAG
      SUBROUTINE SparseSymLinearSystem_NAG(NN,NNZ,A,IROW,ICOL,B,Tijab)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER PRECON
      CHARACTER*6 METHOD
      INTEGER,DIMENSION(NNZ) :: IROW,ICOL
      DOUBLE PRECISION,DIMENSION(NNZ) :: A
      DOUBLE PRECISION,DIMENSION(NN) :: B,Tijab
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IWORK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: WORK
!-----------------------------------------------------------------------
!     The iterative method to be used:
!     'CG'      ==> Conjugate gradient method
!     'SYMMLQ'  ==> Lanczos method (SYMMLQ).
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      METHOD = 'CG'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     The type of preconditioning used:
!     'N'       ==> no preconditioning
!     'J'       ==> Jacobi preconditioning.
!     'S'       ==> symmetric SOR preconditioning.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      PRECON = 'N'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     OMEGA ( 0.0 < OMEGA < 2.0 )
!     if PRECON = 'S' then OMEGA is the relaxation parameter to be used
!     Otherwise OMEGA need not be initialised.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      OMEGA = 1.0d0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     TOL: the tolerance required ( TOL < 1.0 )
!          The iteration is judged to have converged at step k if:
!
!               || r || <= TOL*(|| b || + || A ||*|| x ||).
!                   k                                 k
!     If TOL = 0.0 the default value of SQRT(machine precision) is used.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TOL = 1.0d-10
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     MAXITN: the maximum number of iterations allowed.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      MAXITN = 3000
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     LWORK: the dimension of the array WORK
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(METHOD=='CG')THEN
       IF(PRECON=='J'.or.PRECON=='S')THEN
        LWORK = 7*NN + 120
       ELSE
        LWORK = 6*NN + 120
       END IF
      ELSEIF(METHOD=='SYMMLQ')THEN
       IF(PRECON=='J'.or.PRECON=='S')THEN
        LWORK = 8*NN + 120
       ELSE
        LWORK = 7*NN + 120
       END IF
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!                                 AX = B
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     NN:  the order of the original sparse matrix
!     NNZ: the number of non-zero elements in the lower triangular of A
!     A: array (NNZ) that contains the non-zero elements of the lower 
!        triangular part of the original matrix, ordered by increasing
!        row index and by increasing column index within each row
!     IROW: the row indices of non-zero elements given in A
!     ICOL: the column indices of non-zero elements given in A
!     B: array (NN), the right-hand side vector
!     RNORM: the final residual norm
!     ITN: the actual number of iterations taken
!     WORK: working REAL array of dimension LWORK
!     IWORK: working INTEGER array of dimension NN+1
!
!     IFAIL (On entry must be -1, 0, or 1)
!      On exit, the following values may occur:
!       IFAIL = 0 => no error detected.
!       IFAIL = 1 => METHOD invalid, or PRECON invalid, or
!                    NN < 1, or NNZ < 1, or NNZ > N*(N+1)/2, or
!                    OMEGA not in (0,2), or TOL >= 1.0, or
!                    MAXITN < 1, or LWORK too small.
!       IFAIL = 2 => the arrays IROW and ICOL fail to satisfy:
!                    1 <= IROW(i) <= N,
!                    1 <= ICOL(i) <= IROW(i), i = 1,2,...,NNZ.
!                    IROW(i-1) < IROW(i), or
!                    IROW(i-1) = IROW(i) and ICOL(i-1) < ICOL(i)
!                    for i = 2,3,...,NNZ.
!       IFAIL = 3 => A has a zero diagonal element.
!       IFAIL = 4 => A reasonable accuracy has been obtained and
!                    further iterations could not improve the result.
!       IFAIL = 5 => Required accuracy not obtained in MAXITN
!       IFAIL = 6 => The preconditioner is not positive definite.
!       IFAIL = 7 => The matrix A is not positive definite (CG only).
!       IFAIL = 8 => A serious error has occurred in an internal call.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(WORK(LWORK),IWORK(NN+1))
      IFAIL = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      A(1) = A(1)
      IROW(1) = IROW(1)
      ICOL(1) = ICOL(1)
      B(1) = B(1)
      Tijab(1) = Tijab(1)
!nag      CALL F11JEF(METHOD,PRECON,NN,NNZ,A,IROW,ICOL,OMEGA,B,TOL,         &   
!nag                  MAXITN,Tijab,RNORM,ITN,WORK,LWORK,IWORK,IFAIL)            
      write(6,'(/,A8,E11.4,A7,I5)')' RNORM =',RNORM,', ITN =',ITN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(WORK,IWORK)
      RETURN
!-----------------------------------------------------------------------
      END

! SparseSymLinearSystem_CG      
      SUBROUTINE SparseSymLinearSystem_CG(NN,NNZ,A,IROW,ICOL,B,Tijab)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NNZ) :: IROW,ICOL
      DOUBLE PRECISION,DIMENSION(NNZ) :: A
      DOUBLE PRECISION,DIMENSION(NN) :: B,Tijab
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IIROW,IICOL
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AA,AP,R,P
!-----------------------------------------------------------------------
!     Symmetric A -> Square AA
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NNZ2 = NNZ*2
      ALLOCATE(IIROW(NNZ2),IICOL(NNZ2),AA(NNZ2))
      IIROW(1:NNZ) = IROW(1:NNZ) 
      IICOL(1:NNZ) = ICOL(1:NNZ)
      AA(1:NNZ) = A(1:NNZ)
      NZ = NNZ
      DO i=1,NNZ
       if(IIROW(i)>IICOL(i))then
        NZ = NZ + 1
        IIROW(NZ) = IICOL(i)
        IICOL(NZ) = IIROW(i)       
        AA(NZ)    = AA(i)
       end if 
      END DO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Initial Values for AP, R, P
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(AP(NN),R(NN),P(NN))
      CALL BeqProdAT(NN,NZ,IIROW,IICOL,AA,Tijab,AP)
      R(1:NN) = B(1:NN) - AP(1:NN)
      P(1:NN) = B(1:NN) - AP(1:NN)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Do Nsteps of CG method
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      Nsteps = NN
      DO i = 1,Nsteps
       CALL BeqProdAT(NN,NZ,IIROW,IICOL,AA,P,AP)
       PR  = DOT_PRODUCT(P,R)                   
       PAP = DOT_PRODUCT(P,AP)                  
       IF(PAP==0.0d0)RETURN
       Tijab(1:NN) = Tijab(1:NN) + (PR/PAP)*P(1:NN)
       R(1:NN) = R(1:NN) - (PR/PAP)*AP(1:NN)       
       RAP = DOT_PRODUCT(R,AP)                
       P(1:NN) = R(1:NN) - (RAP/PAP)*P(1:NN)  
      END DO
!-----------------------------------------------------------------------
      DEALLOCATE(IIROW,IICOL,AA,AP,R,P)
      RETURN
      END

! BeqProdAT      
      SUBROUTINE BeqProdAT(N,NZ,IROW,ICOL,A,T,B )
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NZ) :: ICOL,IROW
      DOUBLE PRECISION,DIMENSION(NZ) :: A
      DOUBLE PRECISION,DIMENSION(N) :: T,B
!-----------------------------------------------------------------------      
      B = 0.0d0
      do k = 1,NZ
       i = IROW(k)
       j = ICOL(k)
       B(i) = B(i) + A(k)*T(j)
      end do
!-----------------------------------------------------------------------
      RETURN
      END

! ORBINVE2Totalsym
      SUBROUTINE ORBINVE2Totalsym(NOCB,NOC,NVI,NN,NBF,NBFT,ERImol,      &
                                  Tijab,E2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NN) :: Tijab
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF) :: ERImol
!-----------------------------------------------------------------------
      E2 = 0.0d0
      DO k=1,nvi
       DO l=1,nvi
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
        DO i=1,nocb
         ki = (k-1)*noc + i
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                  
         DO j=1,nocb
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          E2 = E2 + Xijkl*(2.0d0*Tijab(ijkl)-Tijab(ijlk))
         ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -         
         DO j=nocb+1,noc
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          E2 = E2 + Xijkl*(Tijab(ijkl)-0.5d0*Tijab(ijlk))
         ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                  
        ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        DO i=nocb+1,noc
         ki = (k-1)*noc + i
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                  
         DO j=1,nocb        
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          E2 = E2 + Xijkl*(Tijab(ijkl)-0.5d0*Tijab(ijlk))
         ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -         
         DO j=nocb+1,noc
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          if(j/=i)E2 = E2 + Xijkl*(Tijab(ijkl)-0.5d0*Tijab(ijlk))/2.0
         ENDDO
        ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !        
!                                                                      !
!     ERIC1: FORM (PQ/RJ)                                              !
!    ERIC23: FORM (AI/RJ) for all A,I                                  !
!     ERIC4: FORM (AI/BJ) for all B                                    !
!   FOCKMOL: Form the Fock Matrix in the Molecular Basis               !
!   DENMATHFr: Calculate the density matrix (DM) using HF MOs (CHF)    !
!   FORM2JK: Calculate 2J-K in the MO basis to form the Fock matrix    ! 
!    FORMJK: Calculate J-K in the MO basis to form the Fock matrix     !
!   DENMATHF05ro: Calculate the open shell part of density matrix (DM) !
!   ELAGCOEF0: Calculate Matrix of Lagrange Multipliers if ICOEF=0     !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !        

! ERIC1
      SUBROUTINE ERIC1(ERImol,IERI,ERI,VEC,NOC,NORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)  
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
!
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
!-----------------------------------------------------------------------
      ERImol=0.0d0
      DO M=1,NINTCR
       XINT1 = ERI(M)
       XINT2 = XINT1
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IJ = I*(I-1)/2 + J
       KL = K*(K-1)/2 + L
       IF(I==J)XINT1 = XINT1 + XINT1
       IF(K==L)XINT2 = XINT2 + XINT2
       DO N=1,NOC
        ERImol(N,IJ,K) = ERImol(N,IJ,K) + XINT1*VEC(L,N)
        ERImol(N,IJ,L) = ERImol(N,IJ,L) + XINT1*VEC(K,N)
        ERImol(N,KL,I) = ERImol(N,KL,I) + XINT2*VEC(J,N)
        ERImol(N,KL,J) = ERImol(N,KL,J) + XINT2*VEC(I,N)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! ERIC23
      SUBROUTINE ERIC23(ERImol,VEC,NVI,NOC,NORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NBF),AUX2(NBF,NBF))
!-----------------------------------------------------------------------
      DO MR=1,NBF
       DO MJ=1,NOC
!       ERImol -> AUX1
        MPQ = 0
        DO MP=1,NBF
         DO MQ=1,MP
          MPQ = MPQ + 1
          AUX1(MP,MQ) = ERImol(MJ,MPQ,MR)
          AUX1(MQ,MP) = AUX1(MP,MQ)
         ENDDO
        ENDDO
!       AUX2=AUX1*C
        DO IQ=1,NBF
         DO JQ=1,NOC
          AUX2(IQ,JQ)=0.0d0
          do i=1,NBF
           AUX2(IQ,JQ)=AUX2(IQ,JQ)+AUX1(IQ,i)*VEC(i,JQ)
          enddo
         ENDDO
        ENDDO
!       AUX1=VECt*AUX2
        CALL CeqAtB(AUX1,VEC(1,NOC+1),NBF,NVI,AUX2,NOC)
!       AUX1 -> ERImol
        MAI=0
        DO MA=1,NVI
         DO MI=1,NOC
          MAI=MAI+1
          ERImol(MJ,MAI,MR) = AUX1(MA,MI)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

! ERIC4
      SUBROUTINE ERIC4(ERImol,VEC,NOC,NVI,NORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NBF),AUX2(NBF,NBF))
!-----------------------------------------------------------------------
      MAI = 0
      DO MA=1,NVI
       DO MI=1,NOC
!       ERImol -> AUX1
        MAI = MAI+1
        DO MJ=1,NOC
         DO MR=1,NBF
          AUX1(MR,MJ) = ERImol(MJ,MAI,MR)
         ENDDO
        ENDDO
!       AUX2=VEC*AUX1
        CALL CeqAtB(AUX2,VEC,NBF,NVI,AUX1,NOC)
!       AUX2 -> ERImol  
        DO MB=1,NVI
         DO MJ=1,NOC
          ERImol(MJ,MAI,MB) = AUX2(MB,MJ)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

! FOCKMOL
      SUBROUTINE FOCKMOL(NORB,COEF,VEC,ELAG,EIG,FOCKm,AHCORE,IERI,ERI,EHFL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NO1PT2/NO1PT2,NEX
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
!
      INTEGER,DIMENSION(NIJKL) :: IERI
      DOUBLE PRECISION,DIMENSION(NIJKL) :: ERI
      DOUBLE PRECISION,DIMENSION(NORB) :: EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: COEF,ELAG,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NORB) :: VEC
      DOUBLE PRECISION,DIMENSION(NORB,NORB) :: FOCKm
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: DMhf,FOCK,DMa
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: FOCKa,AUX,TVEC
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     DMhf: HF Density Matrix
!     FOCK: Fock Matrix in the atomic basis set ( FOCK = H + 2J-K )
!     EHFL = E(0) + E(1) : HF Energy with Non-HF Orbitals (COEF/=CHF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (DMhf(NBF,NBF),FOCK(NBF,NBF))
      if(MSpin==0)then               ! Singlet and Multiplet States 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL DENMATHFr(DMhf,COEF)     ! 2*COEF(M,J)*COEF(N,J)
!- - - - - - - - - - - - - - - - - - - -      
       if(NSOC>0)then
        ALLOCATE (DMa(NBF,NBF))
        CALL DENMATHF05ro(DMa,COEF)                 ! NB+1,NA       
        DMhf = DMhf + DMa
       endif         
!- - - - - - - - - - - - - - - - - - - -
       CALL FORM2JK(FOCK,DMhf,IERI,ERI)
       FOCK = AHCORE + FOCK       
       EHFL = TRACE(DMhf,AHCORE,NBF) + TRACE(DMhf,FOCK,NBF) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -             
      else if(MSpin>0)then                    ! High-Spin State
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -            
       ALLOCATE (DMa(NBF,NBF))
       CALL DENMATHFr(DMhf,COEF)              ! 1,NB
       CALL DENMATHF05ro(DMa,COEF)            ! NB+1,NA       
!- - - - - - - - - - - - - - - - - - - - -       
       CALL FORM2JK(FOCK,DMhf,IERI,ERI)    
       EHFL=2.0*TRACE(DMhf+DMa,AHCORE,NBF)+TRACE(DMhf+2.0*DMa,FOCK,NBF)
       FOCK = AHCORE + FOCK       
       IF(NSOC>1)THEN
        ALLOCATE (FOCKa(NBF,NBF))       
        CALL FORMJK(FOCKa,DMa,IERI,ERI)
        EHFL = EHFL + 2.0*TRACE(DMa,FOCKa,NBF)
        FOCK = FOCK + FOCKa
        DEALLOCATE(FOCKa)                     
       ENDIF
       DEALLOCATE(DMa)             
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -             
      end if
      DEALLOCATE(DMhf)      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     FOCKm: Fock Matrix in the molecular basis set
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (AUX(NBF,NORB),TVEC(NORB,NBF))
      AUX   = MATMUL(FOCK,VEC)
      TVEC  = TRANSPOSE(VEC)     
      FOCKm = MATMUL(TVEC,AUX)
      DEALLOCATE(FOCK,AUX,TVEC)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     EIG: Energy Eigenvalues without Core
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEIGeqELAG = 0
      IF(IEIGeqELAG==1)THEN
!- - - - - - - - - - - - - - - - - - - - 
       DO i=1,NORB
        EIG(i) = ELAG(i+NO1PT2,i+NO1PT2)
       ENDDO
!- - - - - - - - - - - - - - - - - - - - 
      ELSE
!- - - - - - - - - - - - - - - - - - - - 
!      EIG(i) -> FOCKm(i,i)
!- - - - - - - - - - - - - - - - - - - - 
       DO i=1,NORB
        EIG(i) = FOCKm(i,i)
       ENDDO
!- - - - - - - - - - - - - - - - - - - - 
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print one-particle energies (EIG) if IPRINTEIG = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IPRINTEIG = 0
      IF(IPRINTEIG==1)THEN
       write(6,'(/,A22,/)')'One-particle energies:'
       do i=1,NORB
        write(6,'(4x,I5,F20.10)')NO1PT2+i,EIG(i)
       enddo
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! DENMATHFr
      SUBROUTINE DENMATHFr(DM,CHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::DM,CHF
!----------------------------------------------------------------------
      DO M=1,NBF
       DO N=M,NBF
        DM(M,N)=0.0d0
        DO J=1,NB                                   ! NB
         DM(M,N)=DM(M,N)+ CHF(M,J)*CHF(N,J)
        ENDDO
        DM(N,M)=DM(M,N)
       ENDDO
      ENDDO
      DM=2.0d0*DM
!----------------------------------------------------------------------
      RETURN
      END
      
! FORM2JK
      SUBROUTINE FORM2JK(FM,PM,IERI,ERI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Wake up the nodes for the task
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=3
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
!-----------------------------------------------------------------------
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
!-----------------------------------------------------------------------
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
!-----------------------------------------------------------------------
!      2*J
!-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

                      F(NIJ)=F(NIJ)+P(NKL)*XJ
       IF(NIJ/=NKL)   F(NKL)=F(NKL)+P(NIJ)*XJ
!-----------------------------------------------------------------------
!      -K
!-----------------------------------------------------------------------
       XJ = 0.25*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get the pieces from slaves
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,               &
                      MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE(P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE(P,F)
#endif
!----------------------------------------------------------------------
      RETURN
      END
     
! FORMJK
      SUBROUTINE FORMJK(FM,PM,IERI,ERI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Wake up the nodes for the task
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=4
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
!----------------------------------------------------------------------
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
!----------------------------------------------------------------------
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
!-----------------------------------------------------------------------
!      J
!-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

                      F(NIJ)=F(NIJ)+0.5*P(NKL)*XJ
       IF(NIJ/=NKL)   F(NKL)=F(NKL)+0.5*P(NIJ)*XJ
!-----------------------------------------------------------------------
!      -K
!-----------------------------------------------------------------------
       XJ = 0.25*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Get the pieces from slaves
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,               &
                      MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE(P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE(P,F)
#endif
!----------------------------------------------------------------------
      RETURN
      END

! DENMATHF05ro
      SUBROUTINE DENMATHF05ro(DMa,CHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::DMa,CHF
!----------------------------------------------------------------------
      DO M=1,NBF
       DO N=M,NBF
       DMa(M,N)=0.0d0
       DO J=NB+1,NA
        DMa(M,N)=DMa(M,N)+ CHF(M,J)*CHF(N,J)
       ENDDO
       DMa(N,M)=DMa(M,N)
       ENDDO
      ENDDO
!----------------------------------------------------------------------
      RETURN
      END
                  
! ELAGCOEF0
      SUBROUTINE ELAGCOEF0(ELAG,COEF,RO,CJ12,CK12,AHCORE,               &
                           ADIPx,ADIPy,ADIPz,IERI,ERI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      INTEGER,DIMENSION(NIJKL) :: IERI
      DOUBLE PRECISION,DIMENSION(NIJKL) :: ERI
      DOUBLE PRECISION,DIMENSION(NBF5) :: RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: ELAG,COEF,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5):: CJ12,CK12
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: WJj,WKj,WF,G,AUX1
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AUX2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate AUX1: QD(j,miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,NBF5) 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (WJj(NSQ,NBF5),WKj(NSQ,NBF5),AUX1(NBF,NBF),AUX2(NSQ))
      DO j=1,NBF5
       CALL DENMATj(j,AUX1,COEF,NBF)
       CALL HSTARJ(AUX2,AUX1,IERI,ERI)
       WJj(1:NSQ,j) = AUX2(1:NSQ)
       CALL HSTARK(AUX2,AUX1,IERI,ERI)
       WKj(1:NSQ,j) = AUX2(1:NSQ)
      ENDDO
      DEALLOCATE (AUX1,AUX2)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Form F Matrix and keep it in WF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (WF(NSQ,NBF5))
      if(MSpin==0)then               ! Singlet and Multiplet States
       CALL FFJMN1rc(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)
      else if(MSpin>0)then           ! High-Spin States
       CALL FFJMN1ro(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)      
      end if      
      DEALLOCATE (WJj,WKj)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calculate G Matrix
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (G(NBF,NBF5))
      DO IQ=1,NBF5
       do i=1,nbf
        G(i,IQ) = FC(i,IQ,WF(1,IQ),COEF)
       enddo
      ENDDO
      DEALLOCATE (WF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Lagrangian Multipliers (ELAG)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ELG(ELAG,COEF,G)
      DEALLOCATE (G)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END      

!======================================================================!
!                                                                      !
!                    M C P T   S U B R O U T I N E S                   !
!                                                                      !
!                 ( J. Chem. Phys. 139, 064111, 2013 )                 !
!                                                                      !
!======================================================================!

! SC2MCPThf
      SUBROUTINE SC2MCPThf(RO,COEF,AHCORE,IERI,ERI,QK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/EHFEN/EHF,EN
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPFILE_NO1PT2/NO1PT2,NEX
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/NumLinIndOrb/NQMT
!
      INTEGER,DIMENSION(NIJKL)::IERI
      DOUBLE PRECISION,DIMENSION(NIJKL)::ERI
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QK
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,AHCORE
!
      INTEGER,ALLOCATABLE,DIMENSION(:):: IPOS,IEX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::  OCC,OCCn,QKv,EIG
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: VEC,DMhf,BBn
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: AUX,FOCK,TVEC,FOCKm
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:,:):: ERImol
!-----------------------------------------------------------------------
!     NA:  Number of HF occupied MOs (OCC=1)
!     NVI: Number of HF virtual  MOs (OCC=0)
!
!     NO1:  Number of inactive doubly occupied orbitals (OCC=1)
!     NDOC: Number of strongly occupied MOs
!     NCWO: Number of coupled weakly occupied MOs per strongly occupied
!     NCWO*NDOC: Active orbitals in the virtual subspace
!     NO0: Empty orbitals  (OCC=0)
!     NAC:  Dimension of the active natural orbital subspace
!
!           NA      |       NVI           = NBF
!       NO1 + NDOC  |  NCWO*NDOC + NO0    = NBF
!           |      NAC           |
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!                  EHFL: HF Energy with localized orbitals
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     DMhf: HF Density Matrix     ( DMhf -> FOCK = H + 2J-K )
!     FOCK: Fock Matrix in the atomic basis set
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (DMhf(NBF,NBF),FOCK(NBF,NBF))
      CALL DENMATHFr(DMhf,COEF)
      CALL FORM2JK(FOCK,DMhf,IERI,ERI)
      FOCK = AHCORE + FOCK
      EHFL = TRACE(DMhf,AHCORE,NBF) + TRACE(DMhf,FOCK,NBF)
      DEALLOCATE(DMhf)
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     Substracting core orbitals (NO1)
!     If using ECPotentials (IECP/=0): NO1=0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NOC = NA - NO1                              ! NOC = NDOC
      NVI = NQMT - NA
      NORB = NQMT - NO1
      WRITE(6,1)NO1,NOC,NVI,NQMT
      NOCNC = NOC + NCWO*NOC
      NOCNCT = NOCNC*(NOCNC+1)/2
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Check the value of NCWO if NOCNC = NOC + NCWO*NOC > NORB
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOCNC>NORB)THEN
       NCWO1 = NORB/NOC - 1 
       IF(NCWO>NCWO1)THEN
        WRITE(6,2)NCWO1
        STOP
       ENDIF
      ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     OCC,VEC: Occupations and Molecular Orbitals without Core
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(OCC(NOCNC),VEC(NBF,NORB),QKv(NOCNCT))
      DO J=1,NOCNC
       OCC(J) = RO(J+NO1)
       DO I=1,J
        IJ = I + J*(J-1)/2
        IJold = I+NO1 + (J+NO1)*(J+NO1-1)/2
        QKv(IJ) = QK(IJold)
       ENDDO
      ENDDO
      DO J=1,NORB
       DO I=1,NBF
        VEC(I,J) = COEF(I,J+NO1)
       ENDDO
      ENDDO
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     FOCKm: Fock Matrix in the molecular basis set
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ALLOCATE (FOCKm(NORB,NORB),AUX(NBF,NORB),TVEC(NORB,NBF))
      AUX   = MATMUL(FOCK,VEC)
      TVEC  = TRANSPOSE(VEC)     
      FOCKm = MATMUL(TVEC,AUX)
      DEALLOCATE(FOCK,AUX,TVEC)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     EIG = One-particle energies [E(i)=Ct(i)*FOCK*C(i)=FOCKm(i,i)]
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (EIG(NORB))
      DO i=1,NORB
       EIG(i) = FOCKm(i,i)
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print one-particle energies (EIG) if IPRINTEIG = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IPRINTEIG=0
      IF(IPRINTEIG==1)THEN
       write(6,'(/,A22,/)')'One-particle energies:'
       do i=1,NORB
        write(6,'(4x,I5,F20.10)')NO1+i,EIG(i)
       enddo
      ENDIF
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     Integral transformation ( Form <ab|rs> )
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!     Allocate <ab|rs>
      ALLOCATE(ERImol(NBF,NBF,NBF,NBF))
!     Form <al|mn> from <kl|mn>
      CALL ERIC1c(ERImol,IERI,ERI,VEC,NORB)
!     Form <ab|ms>  [ ERImol(ia,l,m,k) -> ERImol(ia,ib,is,k) ]
      CALL ERIC23c(ERImol,VEC,NORB)
!     Form <ab|rs>  [ ERImol(ia,ib,is,k) -> ERImol(ia,ib,is,ir) ]
      CALL ERIC4c(ERImol,VEC,NORB)
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!                  PNOF5(Nc)-SC2-MCPT and PNOF5(Nc)-PT2
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      IF(IPNOF==5)THEN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      BBn(i,iw) = BETA(i,iw)/SQRT(OCCi) = SQRT(OCCk)/SQRT(OCCi)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(BBn(NOC,NCWO))
       do i=1,NOC
        do iw=1,NCWO
         k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
         BBn(i,iw) = DSQRT(OCC(k)/OCC(i))
        enddo
       enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!      E0 = < 0'| H |0 > = EHFL + Ecorr   ( E1 = 0 )
!      Ecorr: Correlation Energy with respect to EHFL
!      E2x: Ec(2) correlation energy
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       Ecorr = 0.0d0
       E2x = 0.0d0
       DO i=1,NOC
        do iw=1,NCWO
         k = NOC+NCWO*(NOC-i)+iw
         ik = i + k*(k-1)/2
         BBQK = BBn(i,iw)*QKv(ik)
         Eki = 2.0d0*(EIG(k)-EIG(i))
         Ecorr = Ecorr - BBQK
         E2x = E2x - BBQK/Eki
        enddo
       ENDDO
       E0 = EHFL + Ecorr
       WRITE(6,4)EHFL+EN,Ecorr,E0+EN
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      SC2-MCPT: E2 = Sum_k=1 [  < 0'| H |k >< k'| H |0 > / (E0-Ek) ]
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       E2 = Ecorr*E2x                                                   &
          + E2HFs(NOC,NORB,EIG,FOCKm)                                   &
          + E2HFd(NOC,NORB,NBF,EIG,ERImol)                              &
          + E2F(NOC,NCWO,NORB,EIG,FOCKm,BBn)                            &
          + E2FERI(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)              &
          + E2ERIERI(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)                  &
          + E2dHF(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)                      
       IF(NOC/=1)THEN                                                    
        E2 = E2 - Ecorr*E2x/2.0d0                                       &
                + E2Ql(NOC,NCWO,NORB,NOCNCT,EIG,QKv,BBn)                &
                + E2Qd(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
       ENDIF
       IF(NEX==0)WRITE(6,5)E2,E0+E2+EN
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      PNOF5(Nc)-PT2: exclude excitations from the same spatial orbital
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       E2ex = E2HFs(NOC,NORB,EIG,FOCKm)                                 &
            + E2HFdex(NOC,NORB,NBF,EIG,ERImol)                          &
            + E2F(NOC,NCWO,NORB,EIG,FOCKm,BBn)                          &
            + E2FERIex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)          &
            + E2ERIERIex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)              &
            + E2dHFex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
       IF(NOC/=1)THEN
        E2ex = E2ex + E2Qd(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn) 
       ENDIF
       IF(NEX==0)WRITE(6,6)E2ex,E0+E2ex+EN
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
!      PNOF5(Nc)-PT2-NEX: Remove subspaces associated to NEX->E2ex-E2exi
!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       IF(NEX>0)THEN
        IF(NEX>NOC)THEN
         WRITE(6,'(/1X,A32,I5)')'STOP: NEX must be lesser than ',NOC+1
         STOP
        ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       IEX: Position of the 'NEX' minimum strongly occupation numbers
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ALLOCATE(IEX(NEX),IPOS(1),OCCn(NOC))
        IEX = -1
        WRITE(6,3)NEX
        OCCn = OCC(1:NOC)
        do i=1,nex
         IPOS = MINLOC(OCCn)
         IEX(i) = IPOS(1)
         OCCn(IEX(i)) = 1.0d0
        enddo
        E2exi = E2HFs_nex(NOC,NCWO,NORB,EIG,FOCKm,IEX,NEX)              &
              + E2HFdex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,IEX,NEX)       &
              + E2F_nex(NOC,NCWO,NORB,EIG,FOCKm,BBn,IEX,NEX)            &
              + E2FERIex_nex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn,    &
                IEX,NEX) + E2ERIERIex_nex                               &
                (NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)              &
              + E2dHFex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)    
        IF(NOC/=1)THEN                                                   
         E2exi = E2exi                                                  &
               + E2Qd_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX) 
        ENDIF
        WRITE(6,7)E2ex+E2exi,E0+E2ex+E2exi+EN
        DEALLOCATE(IEX,IPOS,OCCn)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DEALLOCATE(BBn)
      ENDIF
!-----------------------------------------------------------------------
      DEALLOCATE(OCC,VEC,QKv,EIG,FOCKm,ERImol)
      RETURN
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(//2X,'PNOF5-MCPT',/1X,12('='),//,                          &
               1X,'NUMBER OF CORE ORBITALS    (NO1) =',I5,/,            &
               1X,'NUMBER OF OCCUPIED ORBS.   (NOC) =',I5,/,            &
               1X,'NUMBER OF VIRTUAL ORBS.    (NVI) =',I5,/,            &
               1X,'NUMBER OF LIN. IND. ORBS. (NQMT) =',I5)               
    2 FORMAT(/1X,'NCWO is too large, reduce the value at least to',I5)   
    3 FORMAT(/1X,'NUMBER OF EXCLUDED COUPLES (NEX) =',I5,/)              
    4 FORMAT(/11X,'Ehf(l) =',F20.10,/,                                  &
              11X,' Ecorr =',F20.10,/,                                  &
              11X,'  E(0) =',F20.10)                                     
    5 FORMAT(/6X,'       E(2) =',F20.10,/,                              &
              6X,'E(SC2-MCPT) =',F20.10)                                 
    6 FORMAT(/5X,'        E(2) =',F20.10,/,                             &
              5X,'E(PNOF5-PT2) =',F20.10)                                
    7 FORMAT(1X,'            E(2) =',F20.10,/,                          &
             1X,'E(PNOF5-PT2-NEX) =',F20.10)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                Integral transformation ( Form <ab|rs> )              !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! ERIC1c
      SUBROUTINE ERIC1c(ERImol,IERI,ERI,VEC,NORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NIJKL/NINTMX,NIJKL,NINTCR,NSTORE
!
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
!-----------------------------------------------------------------------
      ERImol = 0.0d0
      DO M=1,NINTCR
       XINT1 = ERI(M)
       XINT2 = XINT1
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(I==J)XINT1 = XINT1 + XINT1
       IF(K==L)XINT2 = XINT2 + XINT2
       do ia=1,norb
        ERImol(ia,I,J,K) = ERImol(ia,I,J,K) + XINT1*VEC(L,ia)
        ERImol(ia,J,I,K) = ERImol(ia,I,J,K)
        ERImol(ia,I,J,L) = ERImol(ia,I,J,L) + XINT1*VEC(K,ia)
        ERImol(ia,J,I,L) = ERImol(ia,I,J,L)
        ERImol(ia,K,L,I) = ERImol(ia,K,L,I) + XINT2*VEC(J,ia)
        ERImol(ia,L,K,I) = ERImol(ia,K,L,I)
        ERImol(ia,K,L,J) = ERImol(ia,K,L,J) + XINT2*VEC(I,ia)
        ERImol(ia,L,K,J) = ERImol(ia,K,L,J)
       enddo
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! ERIC23c
      SUBROUTINE ERIC23c(ERImol,VEC,NORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NBF),AUX2(NBF,NORB))
!-----------------------------------------------------------------------
      do k=1,nbf
       do ia=1,norb
! - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       ERImol(ia,i,j,k) -> AUX1(i,j) for each (ia,k)
! - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do i=1,nbf
         do j=1,nbf
          AUX1(i,j) = ERImol(ia,i,j,k)
         enddo
        enddo
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       AUX2=AUX1*C
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        DO I=1,NBF
         do is=1,norb
          AUX2(I,is) = 0.0d0
          DO L=1,NBF
           AUX2(I,is) = AUX2(I,is) + AUX1(I,L)*VEC(L,is)
          ENDDO
         enddo
        ENDDO
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       AUX1=VECt*AUX2
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL CeqAtB(AUX1,VEC,NBF,NORB,AUX2,NORB)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       AUX1 -> ERImol(ia,ib,is,k)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do ib=1,norb
         do is=1,norb
          ERImol(ia,ib,is,k) = AUX1(ib,is)
         enddo
        enddo
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       enddo
      enddo
!-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

! ERIC4c
      SUBROUTINE ERIC4c(ERImol,VEC,NORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NORB),AUX2(NBF,NORB))
!-----------------------------------------------------------------------
      do ib=1,norb
       do is=1,norb
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       ERImol(ia,ib,is,k) -> AUX1(k,ia) for each (ib,is)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do ia=1,norb
         do k=1,nbf
          AUX1(k,ia) = ERImol(ia,ib,is,k)
         enddo
        enddo
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       AUX2 = VEC*AUX1
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL CeqAtB(AUX2,VEC,NBF,NORB,AUX1,NORB)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       AUX2 -> ERImol(ia,ib,is,ir)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do ir=1,norb
         do ia=1,norb
          ERImol(ia,ib,is,ir) = AUX2(ir,ia)
         enddo
        enddo
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       enddo
      enddo
!-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                     PNOF5(Nc)-SC2-MCPT -> E2                         !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! E2HFs
      FUNCTION E2HFs(NOC,NORB,EIG,FOCKm)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFs = 0.0d0
      DO i=1,noc
       DO l=noc+1,norb
        Eil = EIG(l) - EIG(i)
        E2HFs = E2HFs - FOCKm(i,l)*FOCKm(l,i)/Eil
       ENDDO
      ENDDO
      E2HFs = 2.0d0*E2HFs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2HFd
      FUNCTION E2HFd(NOC,NORB,NBF,EIG,ERImol)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFd = 0.0d0
      DO i=1,noc
       DO j=1,noc
        DO k=noc+1,norb
         DO l=noc+1,norb
          Xijkl = ERImol(i,j,l,k)
          Xijlk = ERImol(i,j,k,l)
          Eklij = EIG(k) + EIG(l) - EIG(i) - EIG(j)
          E2HFd = E2HFd - Xijkl*(2.0*Xijkl-Xijlk)/Eklij
         ENDDO
        ENDDO
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2F
      FUNCTION E2F(NOC,NCWO,NORB,EIG,FOCKm,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2F = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
        Eki = EIG(k) - EIG(i)
        E2F = E2F + BBn(i,iw)*FOCKm(i,k)*FOCKm(k,i)/Eki 
       enddo
      ENDDO
      E2F = 2.0d0*E2F
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2FERI
      FUNCTION E2FERI(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2FERI = 0.0d0

      DO i=1,noc
       DO l=noc+1,norb
        Eli = EIG(l) - EIG(i)
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
         Eklii = EIG(k) - EIG(i) + Eli
         Xiikl = ERImol(i,i,l,k)
         Xilkk = ERImol(i,l,k,k)
         E2FERI = E2FERI + BBn(i,iw)*                                   &
                ( FOCKm(i,l)*Xilkk/Eli + FOCKm(k,l)*Xiikl/Eklii )
        enddo
       ENDDO
      ENDDO

      DO j=1,noc
       DO i=1,noc
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
         Ekj = EIG(k) - EIG(j)
         Ekkij = 2.0d0*EIG(k) - EIG(i) - EIG(j)
         Xiijk = ERImol(i,i,k,j)
         Xijkk = ERImol(i,j,k,k)
         E2FERI = E2FERI - BBn(i,iw)*                                   &
                ( FOCKm(j,k)*Xiijk/Ekj + FOCKm(i,j)*Xijkk/Ekkij )
        enddo
       ENDDO
      ENDDO

      E2FERI = 2.0d0*E2FERI
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2ERIERI
      FUNCTION E2ERIERI(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2ERIERI = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                  ! k = (i,iw)
        DO m=1,noc
         DO j=1,noc
          Ekkmj = 2.0d0*EIG(k) - EIG(m) - EIG(j)
          Xiimj = ERImol(i,i,j,m)
          Xmjkk = ERImol(m,j,k,k)
          E2ERIERI = E2ERIERI + BBn(i,iw)*Xiimj*Xmjkk/Ekkmj
         ENDDO
        ENDDO
        DO l=noc+1,norb
         DO n=noc+1,norb
          Enlii = EIG(n) + EIG(l) - 2.0d0*EIG(i)
          Xiiln = ERImol(i,i,l,n)
          Xlnkk = ERImol(l,n,k,k)
          E2ERIERI = E2ERIERI + BBn(i,iw)*Xiiln*Xlnkk/Enlii
         ENDDO
        ENDDO
       enddo
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2dHF
      FUNCTION E2dHF(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2dHF = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
        DO j=1,noc
         DO l=noc+1,norb
          Elkij = EIG(l) + EIG(k) - EIG(i) - EIG(j)
          Xijlk = ERImol(i,j,k,l)
          Xiljk = ERImol(i,l,k,j)
          Xijkl = ERImol(i,j,l,k)
          Xilkj = ERImol(i,l,j,k)
          XXijlk = Xijlk - Xijkl
          XXiljk = Xiljk - Xilkj
          E2dHF = E2dHF - (BBn(i,iw)/Elkij) *                           &
                          ( XXijlk*Xilkj + Xijlk*Xiljk + Xijkl*XXiljk )
         ENDDO
        ENDDO
       enddo
      ENDDO
      E2dHF = 2.0d0*E2dHF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2Ql
      FUNCTION E2Ql(NOC,NCWO,NORB,NOCNCT,EIG,QKv,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOCNCT)::QKv
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2Ql = 0.0d0
      DO i=1,noc
       DO j=1,noc
        if(j/=i)then
         do iw=1,ncwo
          k = noc+ncwo*(noc-i)+iw                    ! k = (i,iw)
          jk = j + k*(k-1)/2
          do jw=1,ncwo
           l = noc+ncwo*(noc-j)+jw                   ! l = (j,jw)
           il = i + l*(l-1)/2
           Eli = EIG(l)-EIG(i)
           BB2 = BBn(i,iw)*BBn(j,jw)
           E2Ql = E2Ql - BB2*QKv(il)*QKv(jk)/Eli
          enddo
         enddo
        endif
       ENDDO
      ENDDO
      E2Ql = E2Ql/4.0d0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2Qd
      FUNCTION E2Qd(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2Qd = 0.0d0
      DO i=1,noc
       DO j=1,noc
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
         do jw=1,ncwo
          l = noc+ncwo*(noc-j)+jw                    ! l = (j,jw)
          BB2 = BBn(i,iw)*BBn(j,jw)
          if(j/=i)then
           Eklii = EIG(k) + EIG(l) - 2.0d0*EIG(i)
           Xiikl = ERImol(i,i,l,k)
           Xjjkl = ERImol(j,j,l,k)
           E2Qd = E2Qd + BB2*Xiikl*Xjjkl/Eklii
          endif
          if(l/=k)then
           Ekkij = 2.0d0*EIG(k) - EIG(i) - EIG(j)
           Xijkk = ERImol(i,j,k,k)
           Xijll = ERImol(i,j,l,l)
           E2Qd = E2Qd + BB2*Xijkk*Xijll/Ekkij
          endif
          Eklij = EIG(k) - EIG(i) + EIG(l) - EIG(j)
          Xijkl = ERImol(i,j,l,k)
          Xijlk = ERImol(i,j,k,l)
          XX = Xijkl*Xijkl - Xijkl*Xijlk + Xijlk*Xijlk
          E2Qd = E2Qd - BB2*XX/Eklij
         enddo
        enddo
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                      PNOF5(Nc)-PT2 -> E2ex                           !
!                                                                      !
!         exclude excitations from the same spatial orbital            !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! E2HFdex
      FUNCTION E2HFdex(NOC,NORB,NBF,EIG,ERImol)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     i,j (i/=j) -> k,l
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFdex = 0.0d0
      DO i=1,noc
       DO j=1,noc
        if(i/=j)then
         DO k=noc+1,norb
          DO l=noc+1,norb
           Xijkl = ERImol(i,j,l,k)
           Xijlk = ERImol(i,j,k,l)
           Eklij = EIG(k) + EIG(l) - EIG(i) - EIG(j)
           E2HFdex = E2HFdex - Xijkl*(2.0*Xijkl-Xijlk)/Eklij
          ENDDO
         ENDDO
        endif
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2FERIex
      FUNCTION E2FERIex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!-----------------------------------------------------------------------
      E2FERIex = 0.0d0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     i -> l    ( BBn(i,iw)*FOCKm(k,l)*Xiikl/Eklii is excluded )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,noc
       DO l=noc+1,norb
        Eli = EIG(l) - EIG(i)
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw               ! k = (i,iw)
         Xilkk = ERImol(i,l,k,k)
         E2FERIex = E2FERIex + BBn(i,iw)*FOCKm(i,l)*Xilkk/Eli
        enddo
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     j -> k and i/=j -> k,k
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,noc
       DO i=1,noc
        if(i/=j)then       
         do iw=1,ncwo
          k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
          Ekj = EIG(k) - EIG(j)
          Ekkij = 2.0d0*EIG(k) - EIG(i) - EIG(j)
          Xiijk = ERImol(i,i,k,j)
          Xijkk = ERImol(i,j,k,k)
          E2FERIex = E2FERIex - BBn(i,iw)*                              &
                    ( FOCKm(j,k)*Xiijk/Ekj + FOCKm(i,j)*Xijkk/Ekkij )
         enddo
        endif
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2FERIex = 2.0d0*E2FERIex
!-----------------------------------------------------------------------
      RETURN
      END

! E2ERIERIex
      FUNCTION E2ERIERIex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     j/=m -> k,k         ( BBn(i,iw)*Xiiln*Xlnkk/Enlii is excluded )
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2ERIERIex = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                  ! k = (i,iw)
        DO m=1,noc
         DO j=1,noc
          if(j/=m)then         
           Ekkmj = 2.0d0*EIG(k) - EIG(m) - EIG(j)
           Xiimj = ERImol(i,i,j,m)
           Xmjkk = ERImol(m,j,k,k)
           E2ERIERIex = E2ERIERIex + BBn(i,iw)*Xiimj*Xmjkk/Ekkmj
          endif
         ENDDO
        ENDDO
       enddo
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
      
! E2dHFex
      FUNCTION E2dHFex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     i/=j -> k,l
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2dHFex = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
        DO j=1,noc
         if(j/=i)then
          DO l=noc+1,norb
           Elkij = EIG(l) + EIG(k) - EIG(i) - EIG(j)
           Xijlk = ERImol(i,j,k,l)
           Xiljk = ERImol(i,l,k,j)
           Xijkl = ERImol(i,j,l,k)
           Xilkj = ERImol(i,l,j,k)
           XXijlk = Xijlk - Xijkl
           XXiljk = Xiljk - Xilkj
           E2dHFex = E2dHFex - (BBn(i,iw)/Elkij) *                      &
                           ( XXijlk*Xilkj + Xijlk*Xiljk + Xijkl*XXiljk )
          ENDDO
         endif
        ENDDO
       enddo
      ENDDO
      E2dHFex = 2.0d0*E2dHFex
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                     PNOF5(Nc)-PT2-NEX - > E2exi                      !
!                                                                      !
!      exclude excitations associated only to the omitted subspaces    !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

! E2HFs_nex
      FUNCTION E2HFs_nex(NOC,NCWO,NORB,EIG,FOCKm,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
!-----------------------------------------------------------------------
!     excluding ix -> lx < norb
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFs_nex = 0.0d0
      DO i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        do jxw=1,ncwo  
         lx = noc+ncwo*(noc-jx)+jxw            ! lx = (jx,jxw)
         E2HFs_nex = E2HFs_nex                                          &
                   + FOCKm(ix,lx)*FOCKm(lx,ix)/(EIG(lx)-EIG(ix))
        enddo
       enddo
      ENDDO
      E2HFs_nex = 2.0d0*E2HFs_nex
!-----------------------------------------------------------------------
      RETURN
      END

! E2HFdex_nex
      FUNCTION E2HFdex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     excluding mx,nx (mx/=nx) -> kx,lx
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFdex_nex = 0.0d0
      do m=1,nex
       mx = iex(m)
       do n=1,nex
        nx = iex(n)
        if(mx/=nx)then
         do i=1,nex
          ix = iex(i)
          do ixw=1,ncwo  
           kx = noc+ncwo*(noc-ix)+ixw            ! kx = (ix,ixw)
           do j=1,nex
            jx = iex(j)
            do jxw=1,ncwo  
             lx = noc+ncwo*(noc-jx)+jxw           ! lx = (jx,jxw)
             Xmnkl = ERImol(mx,nx,lx,kx)
             Xmnlk = ERImol(mx,nx,kx,lx)
             Eklmn = EIG(kx) + EIG(lx) - EIG(mx) - EIG(nx)
             E2HFdex_nex = E2HFdex_nex + Xmnkl*(2.0*Xmnkl-Xmnlk)/Eklmn
            enddo
           enddo
          enddo
         enddo
        endif
       enddo
      enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2F_nex
      FUNCTION E2F_nex(NOC,NCWO,NORB,EIG,FOCKm,BBn,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
!-----------------------------------------------------------------------
!     excluding ix -> kx                     
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2F_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do ixw=1,ncwo
        kx = noc+ncwo*(noc-ix)+ixw               ! kx = (ix,ixw)
        Eki = EIG(kx) - EIG(ix)
        E2F_nex = E2F_nex - BBn(ix,ixw)*FOCKm(ix,kx)*FOCKm(kx,ix)/Eki 
       enddo
      enddo
      E2F_nex = 2.0d0*E2F_nex
!-----------------------------------------------------------------------
      RETURN
      END

! E2FERIex_nex
      FUNCTION E2FERIex_nex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn,     &
                            IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!-----------------------------------------------------------------------
      E2FERIex_nex = 0.0d0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     excluding ix -> lx
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      do i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        do jxw=1,ncwo
         lx = noc+ncwo*(noc-jx)+jxw            ! lx = (jx,jxw)
         Eli = EIG(lx) - EIG(ix)
         do ixw=1,ncwo
          kx = noc+ncwo*(noc-ix)+ixw           ! kx = (ix,ixw)
          Xilkk = ERImol(ix,lx,kx,kx)
          E2FERIex_nex = E2FERIex_nex                                   &
                       - BBn(ix,ixw)*FOCKm(ix,lx)*Xilkk/Eli
         enddo
        enddo
       enddo
      enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     excluding ix,jx (ix/=jx) -> kx,kx
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,nex
       jx = iex(j)
       DO i=1,nex
        ix = iex(i)
        if(ix/=jx)then       
         do ixw=1,ncwo
          kx = noc+ncwo*(noc-ix)+ixw              ! kx = (ix,ixw)
          Ekj = EIG(kx) - EIG(jx)          
          Ekkij = 2.0d0*EIG(kx) - EIG(ix) - EIG(jx) 
          Xiijk = ERImol(ix,ix,kx,jx)          
          Xijkk = ERImol(ix,jx,kx,kx)
          E2FERIex_nex = E2FERIex_nex + BBn(ix,ixw)*                    &
                  ( FOCKm(jx,kx)*Xiijk/Ekj + FOCKm(ix,jx)*Xijkk/Ekkij )
         enddo     
        endif
       ENDDO
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2FERIex_nex = 2.0d0*E2FERIex_nex
!-----------------------------------------------------------------------
      RETURN
      END

! E2ERIERIex_nex
      FUNCTION E2ERIERIex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!-----------------------------------------------------------------------
!     excluding ix,jx -> lx,lx                        
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2ERIERIex_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        if(jx/=ix)then
         do m=1,nex
          mx=iex(m)
          do mxw=1,ncwo  
           lx = noc+ncwo*(noc-mx)+mxw            ! lx = (mx,mxw)
           Xmmij = ERImol(mx,mx,jx,ix)
           Xijll = ERImol(ix,jx,lx,lx)
           Ellij = 2.0d0*EIG(lx) - EIG(ix) - EIG(jx)
           E2ERIERIex_nex = E2ERIERIex_nex                              &
                          - BBn(mx,mxw)*Xmmij*Xijll/Ellij
          enddo
         ENDDO
        endif
       enddo
      enddo
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

! E2dHFex_nex
      FUNCTION E2dHFex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!-----------------------------------------------------------------------
!     excluding ix,jx -> kx,lx
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2dHFex_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do ixw=1,ncwo
        kx = noc+ncwo*(noc-ix)+ixw            ! kx = (ix,ixw)
        do j=1,nex
         jx = iex(j)
         if(jx/=ix)then
          do m=1,nex
           mx = iex(m)
           do mxw=1,ncwo  
            lx = noc+ncwo*(noc-mx)+mxw        ! lx = (mx,mxw)
            Elkij = EIG(lx) + EIG(kx) - EIG(ix) - EIG(jx)
            Xijlk = ERImol(ix,jx,kx,lx)
            Xiljk = ERImol(ix,lx,kx,jx)
            Xijkl = ERImol(ix,jx,lx,kx)
            Xilkj = ERImol(ix,lx,jx,kx)
            XXijlk = Xijlk - Xijkl
            XXiljk = Xiljk - Xilkj
            E2dHFex_nex = E2dHFex_nex + (BBn(ix,ixw)/Elkij) *           &
                          (XXijlk*Xilkj+Xijlk*Xiljk+Xijkl*XXiljk)
           enddo
          enddo
         endif
        enddo
       enddo
      enddo
      E2dHFex_nex = 2.0d0*E2dHFex_nex
!-----------------------------------------------------------------------
      RETURN
      END

! E2Qd_nex
      FUNCTION E2Qd_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
!-----------------------------------------------------------------------
!     excluding ix,jx -> kx,lx
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2Qd_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        if(jx/=ix)then
         do ixw=1,ncwo
          kx = noc+ncwo*(noc-ix)+ixw         ! kx = (ix,ixw)
          do jxw=1,ncwo
           lx = noc+ncwo*(noc-jx)+jxw        ! lx = (jx,jxw)
           BB2 = BBn(ix,ixw)*BBn(jx,jxw)
           Xijkl = ERImol(ix,jx,lx,kx)
           Xijlk = ERImol(ix,jx,kx,lx)
           XX = (2.0d0*Xijkl-Xijlk)*(2.0d0*Xijkl-Xijlk)
           Eklij = EIG(kx) + EIG(lx) - EIG(ix) - EIG(jx)
           E2Qd_nex = E2Qd_nex + BB2 * XX / Eklij
          enddo
         enddo
        endif
       enddo
      enddo
!-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!           N O F   G R A D I E N T   S U B R O U T I N E S            !
!                                                                      !
!             2017  Module implemented by Ion Mitxelena                !
!                                                                      !
!                ( J. Chem. Phys. 146, 014102, 2017 )                  !
!                                                                      !
! ==================================================================== !
!                                                                      !
!           Subroutines for NOF energy gradient calculations           !
!                                                                      !
!   OPTSUMSL: Optimize geometries using the CG SUMSL routine           !
!   POINTERSOPT : Define Pointers of the USER array                    !
!   CALCOPTE: Routine to compute energy needed by OPTSUMSL             !
!   CALCOPTG: Routine to compute gradients needed by OPTSUMSL          !
!                                                                      !
!   OPTCGNAG: Optimize geometries using the CG NAG routine E04DGF      !
!   ENERGYFUN: Routine to compute energy needed by OPTCGNAG            !
                                                                       !
!   OPTLBFGS: Optimize geometries with LBFGS method (mthlib.f)         !
!                                                                      !
!   PNOFGRAD:  Main driver to compute PNOF gradient at one geometry    !
!   STVDERNOF: Main driver to compute one-electron PNOF gradient       !
!   JKDERNOF:  Main driver to compute two-electron HF gradient         !
!                                                                      !
!   AOLAGRAN: Calculate PNOF lagrangian in AO basis                    !
!                                                                      !
!   SQUARETRIAN2: Put square matrix (HF density matrix) into diagonal  !
!              form without avoiding double counting of diagonal terms !                 
!   SQUARETRIAN3: Put square matrix (PNOF density matrix) to diagonal  !
!              form without avoiding double counting of diagonal terms !                                                    
!   TRACEs: Calculate the trace of lagrangian and one-electron         !
!           derivative integrals                                       !
!   VINTNOF: Gauss-Hermite quadrature for 1e derivative integrals      !
!   SETHERMITE: Roots and weights for Gauss-Hermite quadrature         !
!   DERINOF: Auxiliar computing 1e derivatives                         !
!   DVINTNOF: Gauss-Hermite quadrature for 1e derivative integrals     !
!   DTXYZNOF: Auxiliar computing 1e derivatives                        !
!   RT123NOF,ROOT4NOF,ROOT5NOF,ROOT6NOF: Auxiliars for roots           !
!   RYSASYNOF,RYSGWNOF,RYSDSNOF: Auxiliars for roots                   !
!                                                                      !
!   OEDHNDNOF: Set up pointers for 1e charge distribution              !
!   OEDRDNOF: Set pointes to the ij or kl charge distributions         !
!   JKDATMNOF: Select centers for derivatives                          !
!   JKDSHLNOF: Select indices for shell block                          !
!   JKDNDXNOF: Select indices for shell block                          !
!   DABCLUNOF: Obtain HF 2e density for one shell block                !
!   DABNOF: Obtain PNOF 2e density for one shell block, N**6           !
!   DABNOF2PRE: Contract CJ12 and CK12 with density matrix to later    !
!               use in DABNOF2                                         !
!   DABNOF2: Obtain PNOF 2e density for one shell block, N**5          !
!   DABNOF5: Obtain PNOF 2e density for one shell block, M*N**4, for   !
!      PNOF5 (DABNOF5PRE) and PNOF7 (DABNOF7PRE) by using separability !
!   JKDSPDNOF: Evaluate derivative integral                            !
!   JKDINVNOF: Process derivative gradient and add to total gradient   !
!   JKWRYSNOF: Compute roots and weights for quadrature                !
!   JKBCDFNOF: Compute coefficients for recursion formulae             !
!   JKGNMSNOF: Compute x,y,z integrals (2 centers)                     !
!   JKXYZSNOF: Compute x,y,z integrals (4 centers)                     !
!   JDXYZSNOF: Compute x,y,z integrals for derivatives                 !
!   DSPDFSNOF: Compute derivative integrals, in principle these        !
!          integrals are added to the gradient 'on the fly', but each  !
!          integral contribution can be stored just removing a 'return'!
!                                                                      !
!   VNNDERNOF: Nuclear repulsion contribution                          !
!   SDERNOF: Density force contribution                                !
!   HELFEYNOF: Hellmann-Feynmann contribution                          !
!   TVDERNOF: 1e contribution due to AO derivatives with respect to    !
!             nuclei motion                                            !
!                                                                      !
!======================================================================!

! OPTSUMSL
      SUBROUTINE OPTSUMSL(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,    &
                          NPRIMI,ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,KSTART,   &
                          KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,     &
                          ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,IRUNTYP,   &
                          GRAD,DIPS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      PARAMETER (BOHR = 0.52917724924D+00) 
      INTEGER,DIMENSION(NAT)    :: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI) :: ISH,ITYP
      INTEGER,INTENT(IN)        :: IRUNTYP
      DOUBLE PRECISION,DIMENSION(NAT)   :: ZAN,ZMASS
      DOUBLE PRECISION,DIMENSION(NPRIMI):: C1,C2,EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(3*NAT),INTENT(OUT) :: GRAD
      DOUBLE PRECISION,DIMENSION(3) :: DIPS
!      
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC_OLD,EELEC,DIF_EELEC,EELEC_MIN
      COMMON/POINTERUSER/NIU1,NIU2,NIU3,NIU4,NIU5,NIU6,NIU7,NIU8,NIU9,  &
                         NIU10,NIU11,NIU12,NIU13,NIU14,NIU15,NIU16,     &
                         NIU17,NIU18,NIU19,NIU20,NIU21,NIU22,NIU23,     &
                         NIU24,NIULAST,NU1,NU2,NU3,NU4,NU5,NU6,NU7,     &
                         NU8,NU9,NU10,NU11,NU12,NU13,NULAST
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/GEOCONV/GEOMENERGY(200)
      COMMON/USELIBRETA/ILIBRETA 
!      
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IUSER,IV
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: USER,D,V     
      EXTERNAL CALCOPTE,CALCOPTG
!-----------------------------------------------------------------------
!     Define Pointers of the USER array
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL POINTERSOPT(NAT,NSHELL,NPRIMI)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Transfer working arrays to IUSER and USER
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(IUSER(NIULAST),USER(NULAST))
!
      IUSER(NIU1)          = NINTEG
      IUSER(NIU2)          = IDONTW  
      IUSER(NIU3)          = 3
      IUSER(NIU4)          = IEMOM  
      IUSER(NIU5)          = NAT
      IUSER(NIU6)          = NBF
      IUSER(NIU7)          = NSHELL
      IUSER(NIU8)          = NPRIMI
      IUSER(NIU9 :NIU10-1) = IAN
      IUSER(NIU10:NIU11-1) = IMIN
      IUSER(NIU11:NIU12-1) = IMAX
      IUSER(NIU12:NIU13-1) = KSTART 
      IUSER(NIU13:NIU14-1) = KATOM
      IUSER(NIU14:NIU15-1) = KTYPE
      IUSER(NIU15:NIU16-1) = KLOC
      IUSER(NIU16:NIU17-1) = INTYP
      IUSER(NIU17:NIU18-1) = KNG
      IUSER(NIU18:NIU19-1) = KMIN
      IUSER(NIU19:NIU20-1) = KMAX
      IUSER(NIU20:NIU21-1) = ISH
      IUSER(NIU21:NIU22-1) = ITYP
      IUSER(NIU22)         = IRUNTYP
      IUSER(NIU23)         = 0             ! ITCG
      IUSER(NIU24)         = NBFaux      
!
      USER(NU1 :NU2-1)     = ZAN
      USER(NU2 :NU3-1)     = ZMASS 
      USER(NU3 :NU4-1)     = C1
      USER(NU4 :NU5-1)     = C2
      USER(NU5 :NU6-1)     = EX
      USER(NU6 :NU7-1)     = CS
      USER(NU7 :NU8-1)     = CP
      USER(NU8 :NU9-1)     = CD
      USER(NU9 :NU10-1)    = CF
      USER(NU10:NU11-1)    = CG
      USER(NU11:NU12-1)    = CH
      USER(NU12:NU13-1)    = CI
      USER(NU13:NULAST)    = DIPS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Initial Coordinates on File CGGRAD (Unit=11)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(11,'(/,72(1H*),/)')
      WRITE(11,*)'Initial Coordinates (Angs) for Geometry Optimization'
      WRITE(11,*)
      DO I=1,NAT
       WRITE(11,'(I5,3F15.4)')  &
             I,Cxyz(1,I)*BOHR,Cxyz(2,I)*BOHR,Cxyz(3,I)*BOHR
      ENDDO
      WRITE(11,'(/,72(1H*),/)')      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Minimization of the total energy with respect to Cxyz
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,'(/,2X,A21,/1X,23(1H=))')'GEOMETRY OPTIMIZATION'
      WRITE(6,'(/,1X,A23,7X,A19,/)')'Call in CG Optimization',          &
                                    'Total Energy (a.u.)'
      IF(MOLDEN==1)WRITE(18,'(A18)')'[GEOMETRIES] (XYZ)'
!
      NV = 3*NAT
      LIV = 60
      LV = 71+NV*(NV+15)/2
!      
      ALLOCATE( D(NV),IV(LIV),V(LV) ) 
!      
      D(1:NV) = 1.0d0      
      IV = 0
      EMINIMA = 1.0d6
!
      CALL SUMSL(NV,D,Cxyz,CALCOPTE,CALCOPTG,IV,LIV,LV,V,IUSER,USER)
!      
      ENERGIA = EELEC + EN
      IF(EMINIMA>ENERGIA)EMINIMA = ENERGIA
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Compute energy at solution to print data on the output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,'(/1X,A24,2X,F20.10,/)')'Final objective value = ',EMINIMA      
      WRITE(6,*)'New Coordinates after Conjugate Gradient Opt (Bohr)'
      WRITE(6,'(1X,51(1H-),/)')
      DO I=1,NAT
       WRITE(6,'(I5,3F15.4)')I,Cxyz(1,I),Cxyz(2,I),Cxyz(3,I)
      ENDDO
!     Update coordinates of shells if use libreta library for ERIs
      if(ILIBRETA==1)CALL UPDCOOSHELL(IUSER(NIU7),IUSER(NIU13),Cxyz,    &
                                      IUSER(NIU5))
      CALL ENERGRAD(IUSER(NIU1),IUSER(NIU2),IUSER(NIU4),IUSER(NIU5),    &
                    IUSER(NIU6),IUSER(NIU24),IUSER(NIU7),IUSER(NIU8),   &
                    USER(NU1),Cxyz,IUSER(NIU9),IUSER(NIU10),            &
                    IUSER(NIU11),IUSER(NIU12),IUSER(NIU13),IUSER(NIU14),&
                    IUSER(NIU15),IUSER(NIU16),IUSER(NIU17),IUSER(NIU18),&
                    IUSER(NIU19),IUSER(NIU20),IUSER(NIU21),USER(NU3),   &
                    USER(NU4),USER(NU5),USER(NU6),USER(NU7),USER(NU8),  &
                    USER(NU9),USER(NU10),USER(NU11),USER(NU12),GRAD,    &                    
                    IUSER(NIU22),USER(NU13),0,1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Final Coordinates on File CGGRAD (Unit=100)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(11,'(/,72(1H*),/)')
      WRITE(11,*)'New Coordinates after Conjugate Gradient Opt (Angs)'
      WRITE(11,*)
      DO I=1,NAT
       WRITE(11,'(I5,3F15.4)')                                          &
            I,Cxyz(1,I)*BOHR,Cxyz(2,I)*BOHR,Cxyz(3,I)*BOHR
      ENDDO
      CALL NUCDIST(NV,NAT,Cxyz)
      WRITE(11,'(/,72(1H*),/)')  
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write geometry energies in [GEOCONV] section of the molden file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      IF(MOLDEN==1)WRITE(18,'(A9,/,A6)')'[GEOCONV]','energy'
      if(IUSER(NIU23)<=200)then
       DO I=1,IUSER(NIU23)
        WRITE(18,'(F20.10)')GEOMENERGY(I)
       END DO
      else
       write(6,*)'Sorry, No. of calls > 200, [GEOCONV] is not possible'
      end if
!-----------------------------------------------------------------------
      DEALLOCATE(IUSER,USER,D,IV,V)
      RETURN
      END

! POINTERSOPT
      SUBROUTINE POINTERSOPT(NAT,NSHELL,NPRIMI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/POINTERUSER/NIU1,NIU2,NIU3,NIU4,NIU5,NIU6,NIU7,NIU8,NIU9,  &
                         NIU10,NIU11,NIU12,NIU13,NIU14,NIU15,NIU16,     &
                         NIU17,NIU18,NIU19,NIU20,NIU21,NIU22,NIU23,     &
                         NIU24,NIULAST,NU1,NU2,NU3,NU4,NU5,NU6,NU7,     &
                         NU8,NU9,NU10,NU11,NU12,NU13,NULAST
!-----------------------------------------------------------------------
!     Define Pointers of the USER array
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NIU1  = 1                         ! NINTEG
      NIU2  = NIU1  + 1                 ! IDONTW 
      NIU3  = NIU2  + 1                 ! Not used
      NIU4  = NIU3  + 1                 ! IEMOM  
      NIU5  = NIU4  + 1                 ! NAT
      NIU6  = NIU5  + 1                 ! NBF
      NIU7  = NIU6  + 1                 ! NSHELL
      NIU8  = NIU7  + 1                 ! NPRIMI
      NIU9  = NIU8  + 1                 ! IAN
      NIU10 = NIU9  + NAT               ! IMIN
      NIU11 = NIU10 + NAT               ! IMAX
      NIU12 = NIU11 + NAT               ! KSTART 
      NIU13 = NIU12 + NSHELL            ! KATOM
      NIU14 = NIU13 + NSHELL            ! KTYPE
      NIU15 = NIU14 + NSHELL            ! KLOC
      NIU16 = NIU15 + NSHELL            ! INTYP
      NIU17 = NIU16 + NSHELL            ! KNG
      NIU18 = NIU17 + NSHELL            ! KMIN
      NIU19 = NIU18 + NSHELL            ! KMAX 
      NIU20 = NIU19 + NSHELL            ! ISH
      NIU21 = NIU20 + NPRIMI            ! ITYP
      NIU22 = NIU21 + NPRIMI            ! IRUNTYP
      NIU23 = NIU22 + 1                 ! ITCG
      NIU24 = NIU23 + 1                 ! NBFaux
      NIULAST = NIU24 + 1               
!
      NU1  = 1                          ! ZAN
      NU2  = NU1  + NAT                 ! ZMASS
      NU3  = NU2  + NAT                 ! C1
      NU4  = NU3  + NPRIMI              ! C2
      NU5  = NU4  + NPRIMI              ! EX   
      NU6  = NU5  + NPRIMI              ! CS
      NU7  = NU6  + NPRIMI              ! CP
      NU8  = NU7  + NPRIMI              ! CD
      NU9  = NU8  + NPRIMI              ! CF
      NU10 = NU9  + NPRIMI              ! CG
      NU11 = NU10 + NPRIMI              ! CH
      NU12 = NU11 + NPRIMI              ! CI
      NU13 = NU12 + NPRIMI              ! DIPS
      NULAST = NU13 + 3
!-----------------------------------------------------------------------
      RETURN
      END      

! CALCOPTE      
      SUBROUTINE CALCOPTE(NV,Cxyz,NF,ENERGIA,IUSER,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/USELIBRETA/ILIBRETA 
      COMMON/INPNOF_MOLDEN/MOLDEN      
      COMMON/GEOCONV/GEOMENERGY(200)
      COMMON/POINTERUSER/NIU1,NIU2,NIU3,NIU4,NIU5,NIU6,NIU7,NIU8,NIU9,  &
                         NIU10,NIU11,NIU12,NIU13,NIU14,NIU15,NIU16,     &
                         NIU17,NIU18,NIU19,NIU20,NIU21,NIU22,NIU23,     &
                         NIU24,NIULAST,NU1,NU2,NU3,NU4,NU5,NU6,NU7,     &
                         NU8,NU9,NU10,NU11,NU12,NU13,NULAST
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),              &
                  KLAST(100,6),LMAX(100),LPSKIP(100),IZCORE(100)
!
      INTEGER,DIMENSION(NIULAST)         :: IUSER 
      DOUBLE PRECISION,DIMENSION(NV)     :: Cxyz
      DOUBLE PRECISION,DIMENSION(NULAST) :: USER
      PARAMETER (BOHR = 0.52917724924D+00) 
      CHARACTER*4,DIMENSION(106) :: ATMLAB
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',            &
                  'N   ','O   ','F   ','NE  ','NA  ','MG  ',            &
                  'AL  ','SI  ','P   ','S   ','CL  ','AR  ',            &
                  'K   ','CA  ','SC  ','TI  ','V   ','CR  ',            &
                  'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',            &
                  'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',            &
                  'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',            &
                  'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',            &
                  'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',            &
                  'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',            &
                  'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',            &
                  'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',            &
                  'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',            &
                  'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',            &
                  'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',            &
                  'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',            &
                  'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',            &
                  'LR  ','RF  ','X   ','BQ  '/
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: GRAD
!-----------------------------------------------------------------------
      IUSER(NIU23) = IUSER(NIU23) + 1                  ! ITCG = ITCG + 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -            
!     Update coordinates of shells if use libreta library for ERIs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(ILIBRETA==1)CALL UPDCOOSHELL(IUSER(NIU7),IUSER(NIU13),Cxyz,    &
                                      IUSER(NIU5))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(GRAD(NV))
      CALL ENERGRAD(IUSER(NIU1),IUSER(NIU2),IUSER(NIU4),IUSER(NIU5),    &
                    IUSER(NIU6),IUSER(NIU24),IUSER(NIU7),IUSER(NIU8),   &
                    USER(NU1),Cxyz,IUSER(NIU9),IUSER(NIU10),            &
                    IUSER(NIU11),IUSER(NIU12),IUSER(NIU13),IUSER(NIU14),&
                    IUSER(NIU15),IUSER(NIU16),IUSER(NIU17),IUSER(NIU18),&
                    IUSER(NIU19),IUSER(NIU20),IUSER(NIU21),USER(NU3),   &
                    USER(NU4),USER(NU5),USER(NU6),USER(NU7),USER(NU8),  &
                    USER(NU9),USER(NU10),USER(NU11),USER(NU12),GRAD,    &
                    IUSER(NIU22),USER(NU13),0,0)
      DEALLOCATE(GRAD)
!
      ENERGIA = EELEC + EN     
      WRITE(6,'(8X,I3,16X,F20.10)')NF,ENERGIA
      if(IUSER(NIU23)<=200)GEOMENERGY(nf) = ENERGIA
!
      if(MOLDEN==1)then 
       nat = IUSER(NIU5)
       write(18,'(I6)')nat
       write(18,'(I6,F20.10)')NF,ENERGIA
       do jat=1,nat
        j = (jat-1)*3
        IZNUC = INT(USER(NU1+jat-1))+IZCORE(jat)                 
        write(18,'(1X,A4,3F15.4)')ATMLAB(IZNUC),                        &
        Cxyz(1+j)*BOHR,Cxyz(2+j)*BOHR,Cxyz(3+j)*BOHR
       enddo
      endif
!-----------------------------------------------------------------------
      RETURN
      END
      
! CALCOPTG      
      SUBROUTINE CALCOPTG(NV,Cxyz,NF,GRAD,IUSER,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/USELIBRETA/ILIBRETA 

      COMMON/POINTERUSER/NIU1,NIU2,NIU3,NIU4,NIU5,NIU6,NIU7,NIU8,NIU9,  &
                         NIU10,NIU11,NIU12,NIU13,NIU14,NIU15,NIU16,     &
                         NIU17,NIU18,NIU19,NIU20,NIU21,NIU22,NIU23,     &
                         NIU24,NIULAST,NU1,NU2,NU3,NU4,NU5,NU6,NU7,     &
                         NU8,NU9,NU10,NU11,NU12,NU13,NULAST
      INTEGER,DIMENSION(NIULAST)         :: IUSER 
      DOUBLE PRECISION,DIMENSION(NV)     :: Cxyz
      DOUBLE PRECISION,DIMENSION(NV)     :: GRAD      
      DOUBLE PRECISION,DIMENSION(NULAST) :: USER
!-----------------------------------------------------------------------
!     Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NF = NF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Update coordinates of shells if use libreta library for ERIs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(ILIBRETA==1)CALL UPDCOOSHELL(IUSER(NIU7),IUSER(NIU13),Cxyz,    &
                                      IUSER(NIU5))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ENERGRAD(IUSER(NIU1),IUSER(NIU2),IUSER(NIU4),IUSER(NIU5),    &
                    IUSER(NIU6),IUSER(NIU24),IUSER(NIU7),IUSER(NIU8),   &
                    USER(NU1),Cxyz,IUSER(NIU9),IUSER(NIU10),            &
                    IUSER(NIU11),IUSER(NIU12),IUSER(NIU13),IUSER(NIU14),&
                    IUSER(NIU15),IUSER(NIU16),IUSER(NIU17),IUSER(NIU18),&
                    IUSER(NIU19),IUSER(NIU20),IUSER(NIU21),USER(NU3),   &
                    USER(NU4),USER(NU5),USER(NU6),USER(NU7),USER(NU8),  &
                    USER(NU9),USER(NU10),USER(NU11),USER(NU12),GRAD,    &                    
                    IUSER(NIU22),USER(NU13),0,0)
!-----------------------------------------------------------------------
      RETURN
      END
      
! OPTCGNAG
      SUBROUTINE OPTCGNAG(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,    &
                          NPRIMI,ZAN,Cxyz,IAN,IMIN,IMAX,ZMASS,KSTART,   &
                          KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,     &
                          ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,IRUNTYP,   &
                          GRADIENT,DIPS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      PARAMETER (BOHR = 0.52917724924D+00) 
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN,ZMASS
      INTEGER,DIMENSION(NAT):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI) :: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMI):: C1,C2,EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT):: Cxyz
      DOUBLE PRECISION,DIMENSION(3*NAT),INTENT(OUT):: GRADIENT
      INTEGER,INTENT(IN):: IRUNTYP
      DOUBLE PRECISION,DIMENSION(3):: DIPS
      COMMON/POINTERUSER/NIU1,NIU2,NIU3,NIU4,NIU5,NIU6,NIU7,NIU8,NIU9,  &
                         NIU10,NIU11,NIU12,NIU13,NIU14,NIU15,NIU16,     &
                         NIU17,NIU18,NIU19,NIU20,NIU21,NIU22,NIU23,     &
                         NIU24,NIULAST,NU1,NU2,NU3,NU4,NU5,NU6,NU7,     &
                         NU8,NU9,NU10,NU11,NU12,NU13,NULAST
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/GEOCONV/GEOMENERGY(200)
      COMMON/USELIBRETA/ILIBRETA      
!                         
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IUSER,IWORK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: USER,WORK,GRADS
      EXTERNAL ENERGYFUN
!-----------------------------------------------------------------------
!     Define Pointers of the user arrays
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL POINTERSOPT(NAT,NSHELL,NPRIMI)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Transfer working arrays to IUSER and USER
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(IUSER(NIULAST),USER(NULAST))
!
      IUSER(NIU1)          = NINTEG
      IUSER(NIU2)          = IDONTW  
      IUSER(NIU3)          = 3
      IUSER(NIU4)          = IEMOM  
      IUSER(NIU5)          = NAT
      IUSER(NIU6)          = NBF
      IUSER(NIU7)          = NSHELL
      IUSER(NIU8)          = NPRIMI
      IUSER(NIU9 :NIU10-1) = IAN
      IUSER(NIU10:NIU11-1) = IMIN
      IUSER(NIU11:NIU12-1) = IMAX
      IUSER(NIU12:NIU13-1) = KSTART 
      IUSER(NIU13:NIU14-1) = KATOM
      IUSER(NIU14:NIU15-1) = KTYPE
      IUSER(NIU15:NIU16-1) = KLOC
      IUSER(NIU16:NIU17-1) = INTYP
      IUSER(NIU17:NIU18-1) = KNG
      IUSER(NIU18:NIU19-1) = KMIN
      IUSER(NIU19:NIU20-1) = KMAX
      IUSER(NIU20:NIU21-1) = ISH
      IUSER(NIU21:NIU22-1) = ITYP
      IUSER(NIU22)         = IRUNTYP
      IUSER(NIU23)         = 0             ! ITCG
      IUSER(NIU24)         = NBFaux      
!
      USER(NU1 :NU2-1)     = ZAN
      USER(NU2 :NU3-1)     = ZMASS 
      USER(NU3 :NU4-1)     = C1
      USER(NU4 :NU5-1)     = C2
      USER(NU5 :NU6-1)     = EX
      USER(NU6 :NU7-1)     = CS
      USER(NU7 :NU8-1)     = CP
      USER(NU8 :NU9-1)     = CD
      USER(NU9 :NU10-1)    = CF
      USER(NU10:NU11-1)    = CG
      USER(NU11:NU12-1)    = CH
      USER(NU12:NU13-1)    = CI
      USER(NU13:NULAST)    = DIPS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Initial Coordinates on File CGGRAD (Unit=11)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(11,'(/,72(1H*),/)')
      WRITE(11,*)'Initial Coordinates (Angs) for Geometry Optimization'
      WRITE(11,*)
      DO I=1,NAT
       WRITE(11,'(I5,3F15.4)')  &
             I,Cxyz(1,I)*BOHR,Cxyz(2,I)*BOHR,Cxyz(3,I)*BOHR
      ENDDO
      WRITE(11,'(/,72(1H*),/)')      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Minimization of the total energy with respect to Cxyz
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,'(/,2X,A21,/1X,23(1H=))')'GEOMETRY OPTIMIZATION'
      WRITE(6,'(/,1X,A23,7X,A19,/)')'Call in CG Optimization',          &
                                    'Total Energy (a.u.)'
      IF(MOLDEN==1)WRITE(18,'(A18)')'[GEOMETRIES] (XYZ)'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Send output of E04DGF to NAG file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL X04ABF(1,2)                                           
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Est. opt. function val.
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     CALL E04DKF ('Es = ....')
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Function Precision (machine precision**0.9)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Function Precision = 1.0D-6')                
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Linesearch Tolerance (0<r<1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Linesearch Tolerance = 0.1')                 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Maximum Step Length (Default = 10**20))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Maximum Step Length  = 0.01')                
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Optimality Tolerance (relative precision**0.8)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Optimality Tolerance = 1.0D-5')              
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Verify Level (-1 = No checks, 0 = cheap test, 1 = 0 + gradients)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Verify Level = -1')                          
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Print Level (0 = No output, 1 = The final solution only)
!                 (5 = One line of summary output for each iteration)
!                 (10 = The final solution and one line for each iter.)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!nag      CALL E04DKF ('Print Level = 0')                            
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calling to NAG Library for using the CG method
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NV = 3*NAT
      IFAIL = 1
      EMINIMA = 1.0d6
      ALLOCATE(IWORK(NV+1),WORK(13*NV),GRADS(NV))
!nag      CALL E04DGF(NV,ENERGYFUN,ITER_E04DGF,ENERGIA,GRADS,Cxyz,          &  
!nag                  IWORK,WORK,IUSER,USER,IFAIL)                             
      IF(EMINIMA>ENERGIA)EMINIMA=ENERGIA
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Compute energy at solution to print data on the output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(IFAIL==0)then
       WRITE(6,'(/1X,A24,2X,F20.10,/)')'Optimal solution found !',EMINIMA
      else if(IFAIL==6)then       
       WRITE(6,'(/1X,A24,2X,F20.10,/)')'Final objective value = ',EMINIMA      
      end if
      WRITE(6,*)'New Coordinates after Conjugate Gradient Opt (Bohr)'
      WRITE(6,'(1X,51(1H-),/)')
      DO I=1,NAT
       WRITE(6,'(I5,3F15.4)')I,Cxyz(1,I),Cxyz(2,I),Cxyz(3,I)
      ENDDO
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Update coordinates of shells if use libreta library for ERIs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(ILIBRETA==1)CALL UPDCOOSHELL(IUSER(NIU7),IUSER(NIU13),Cxyz,    &
                                      IUSER(NIU5))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      CALL ENERGRAD(IUSER(NIU1),IUSER(NIU2),IUSER(NIU4),IUSER(NIU5),    &
                    IUSER(NIU6),IUSER(NIU24),IUSER(NIU7),IUSER(NIU8),   &
                    USER(NU1),Cxyz,IUSER(NIU9),IUSER(NIU10),            &
                    IUSER(NIU11),IUSER(NIU12),IUSER(NIU13),IUSER(NIU14),&
                    IUSER(NIU15),IUSER(NIU16),IUSER(NIU17),IUSER(NIU18),&
                    IUSER(NIU19),IUSER(NIU20),IUSER(NIU21),USER(NU3),   &
                    USER(NU4),USER(NU5),USER(NU6),USER(NU7),USER(NU8),  &
                    USER(NU9),USER(NU10),USER(NU11),USER(NU12),GRADS,   &
                    IUSER(NIU22),USER(NU13),0,1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Final Coordinates on File CGGRAD (Unit=100)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(11,'(/,72(1H*),/)')
      WRITE(11,*)'New Coordinates after Conjugate Gradient Opt (Angs)'
      WRITE(11,*)
      DO I=1,NAT
       WRITE(11,'(I5,3F15.4)')                                          &
            I,Cxyz(1,I)*BOHR,Cxyz(2,I)*BOHR,Cxyz(3,I)*BOHR
      ENDDO
      CALL NUCDIST(NV,NAT,Cxyz)
      WRITE(11,'(/,72(1H*),/)')      
      GRADIENT = GRADS
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write geometry energies in [GEOCONV] section of the molden file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      IF(MOLDEN==1)WRITE(18,'(A9,/,A6)')'[GEOCONV]','energy'
      if(IUSER(NIU23)<=200)then
       DO I=1,IUSER(NIU23)
        WRITE(18,'(F20.10)')GEOMENERGY(I)
       END DO
      else
       write(6,*)'Sorry, No. of calls > 200, [GEOCONV] is not possible'
      end if
!-----------------------------------------------------------------------
      DEALLOCATE(IUSER,USER,GRADS,IWORK,WORK)
      RETURN
      END
      
! ENERGYFUN
      SUBROUTINE ENERGYFUN(MODE,NV,Cxyz,ENERGIA,GRADS,NSTATE,IUSER,USER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/POINTERUSER/NIU1,NIU2,NIU3,NIU4,NIU5,NIU6,NIU7,NIU8,NIU9,  &
                         NIU10,NIU11,NIU12,NIU13,NIU14,NIU15,NIU16,     &
                         NIU17,NIU18,NIU19,NIU20,NIU21,NIU22,NIU23,     &
                         NIU24,NIULAST,NU1,NU2,NU3,NU4,NU5,NU6,NU7,     &
                         NU8,NU9,NU10,NU11,NU12,NU13,NULAST
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC_OLD,EELEC,DIF_EELEC,EELEC_MIN
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/GEOCONV/GEOMENERGY(200)
      COMMON/USELIBRETA/ILIBRETA
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),              &
                  KLAST(100,6),LMAX(100),LPSKIP(100),IZCORE(100)
!
      INTEGER,DIMENSION(*) :: IUSER
      DOUBLE PRECISION,DIMENSION(*) :: USER
      DOUBLE PRECISION,DIMENSION(NV) :: Cxyz,GRADS
      PARAMETER (BOHR = 0.52917724924D+00)
      CHARACTER*4,DIMENSION(106) :: ATMLAB
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',            &
                  'N   ','O   ','F   ','NE  ','NA  ','MG  ',            &
                  'AL  ','SI  ','P   ','S   ','CL  ','AR  ',            &
                  'K   ','CA  ','SC  ','TI  ','V   ','CR  ',            &
                  'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',            &
                  'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',            &
                  'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',            &
                  'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',            &
                  'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',            &
                  'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',            &
                  'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',            &
                  'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',            &
                  'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',            &
                  'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',            &
                  'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',            &
                  'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',            &
                  'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',            &
                  'LR  ','RF  ','X   ','BQ  '/
!-----------------------------------------------------------------------
      NSTATE = 1
      MODE = 1
      IUSER(NIU23) = IUSER(NIU23) + 1                  ! ITCG = ITCG + 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Update coordinates of shells if use libreta library for ERIs
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(ILIBRETA==1)CALL UPDCOOSHELL(IUSER(NIU7),IUSER(NIU13),Cxyz,    &
                                      IUSER(NIU5))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ENERGRAD(IUSER(NIU1),IUSER(NIU2),IUSER(NIU4),IUSER(NIU5),    &
                    IUSER(NIU6),IUSER(NIU24),IUSER(NIU7),IUSER(NIU8),   &
                    USER(NU1),Cxyz,IUSER(NIU9),IUSER(NIU10),            &
                    IUSER(NIU11),IUSER(NIU12),IUSER(NIU13),IUSER(NIU14),&
                    IUSER(NIU15),IUSER(NIU16),IUSER(NIU17),IUSER(NIU18),&
                    IUSER(NIU19),IUSER(NIU20),IUSER(NIU21),USER(NU3),   &
                    USER(NU4),USER(NU5),USER(NU6),USER(NU7),USER(NU8),  &
                    USER(NU9),USER(NU10),USER(NU11),USER(NU12),GRADS,   &
                    IUSER(NIU22),USER(NU13),0,0)
      ENERGIA = EELEC + EN     
      WRITE(6,'(8X,I3,16X,F20.10)')IUSER(NIU23),ENERGIA
      if(IUSER(NIU23)<=200)GEOMENERGY(IUSER(NIU23)) = ENERGIA
!
      if(MOLDEN==1)then 
       nat = IUSER(NIU5)
       write(18,'(I6)')nat
       write(18,'(I6,F20.10)')IUSER(NIU23),ENERGIA
       do jat=1,nat
        j = (jat-1)*3
        IZNUC = INT(USER(NU1+jat-1))+IZCORE(jat)                 
        write(18,'(1X,A4,3F15.4)')ATMLAB(IZNUC),                        &
        Cxyz(1+j)*BOHR,Cxyz(2+j)*BOHR,Cxyz(3+j)*BOHR
       enddo
      endif
!-----------------------------------------------------------------------
      RETURN
      END
      
! OPTLBFGS
      SUBROUTINE OPTLBFGS(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,    &
                          NPRIMI,ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,   &
                          KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,      &
                          C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,IRUNTYP,        &
                          GRADIENT,DIPS,NPRINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC_OLD,EELEC,DIF_EELEC,EELEC_MIN
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
      COMMON/USELIBRETA/ILIBRETA                  
!      
      PARAMETER (BOHR = 0.52917724924D+00)
      INTEGER,INTENT(IN)::NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux
      INTEGER,INTENT(IN)::NSHELL,NPRIMI,IRUNTYP,NPRINT
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      INTEGER,DIMENSION(NAT):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI) :: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMI):: C1,C2,EX,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3,NAT):: Cxyz
      DOUBLE PRECISION,DIMENSION(3*NAT),INTENT(OUT):: GRADIENT
      DOUBLE PRECISION,DIMENSION(3*NAT):: GRADS
      DOUBLE PRECISION,DIMENSION(3):: DIPS
      INTEGER,PARAMETER::MSAVE=7
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::W
      DOUBLE PRECISION X(3,NAT),G(3*NAT),DIAG(3*NAT)
      DOUBLE PRECISION::F,EPS,XTOL,GTOL,STPMIN,STPMAX,EELEC_MIN_LBFGS
      INTEGER::IFLAG,ICALL,N,M,MP,LP,NWORK
      INTEGER,DIMENSION(2)::IPRINT
      LOGICAL::DIAGCO
!     The driver for LBFGS must always declare LB2 as EXTERNAL
      EXTERNAL LB2
!-----------------------------------------------------------------------
      NWORK=3*NAT*(2*MSAVE +1)+2*MSAVE
      ALLOCATE(W(NWORK))
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Initial Coordinates on File CGGRAD (Unit=11)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(11,'(/,72(1H*),/)')
      WRITE(11,*)'Initial Coordinates (Angs) for Geometry Optimization'
      WRITE(11,*)
      DO I=1,NAT
       WRITE(11,'(I5,3F15.4)')  &
            I,Cxyz(1,I)*BOHR,Cxyz(2,I)*BOHR,Cxyz(3,I)*BOHR
      ENDDO
      WRITE(11,'(/,72(1H*),/)')      
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Minimization of the total energy with respect to Cxyz
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,'(/,2X,A21,/1X,23(1H=))')'GEOMETRY OPTIMIZATION'
      WRITE(6,'(/,1X,A23,7X,A19,/)')'Call in CG Optimization',         &
                                    'Total Energy (a.u.)'
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Calling to LBFGS SUBROUTINE
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     CHECK COMMON /LB3, MP SETS UNIT WHERE PRINTING OPTIMIZATION INFO, 
!     AND LP WHERE PRINTING INFO ABOUT ERRORS
      N=3*NAT ! NUMBER OF VARIABLES
      M=5     ! 0 <= M <= 7
      IPRINT(1)= 0
!     IPRINT(1)< 0 : no output is generated,
!     IPRINT(1)= 0 : output only at first and last iteration,
!     IPRINT(1)> 0 : output every IPRINT(1) iterations.      
      IPRINT(2)= 0
      IF(NPRINT==2) IPRINT(2)= 1
!     IPRINT(2)= 0 : iteration count, number of function 
!                     evaluations, function value, norm of the
!                     gradient, and steplength,
!     IPRINT(2)= 1 : same as IPRINT(2)=0, plus vector of
!                     variables and  gradient vector at the
!                     initial point,
!     IPRINT(2)= 2 : same as IPRINT(2)=1, plus vector of
!                     variables,
!     IPRINT(2)= 3 : same as IPRINT(2)=2, plus gradient vector.      
!
!     We do not wish to provide the diagonal matrices Hk0, and 
!     therefore set DIAGCO to FALSE.
      DIAGCO= .FALSE.
      EPS= 1.0D-10
      XTOL= 1.11D-16
      ICALL=0
      IFLAG=0
      X = Cxyz ! X(N) IS THE INITIAL ESTIMATE OF THE SOLUTION VECTOR
      DO
       ICALL=ICALL + 1
!      Update coordinates of shells if use libreta library for ERIs
       if(ILIBRETA==1)CALL UPDCOOSHELL(NSHELL,KATOM,Cxyz,NAT)
       CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,  &
                     ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,    &
                     INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX,CS,CP,CD,CF, &
                     CG,CH,CI,GRADS,IRUNTYP,DIPS,0,0)
       WRITE(6,'(8X,I3,16X,F20.10)')ICALL,EELEC+EN
                     
!      F CONTAINS THE VALUE OF THE FUNCTION AT THE POINT X
!      G CONTAINS THE COMPONENTS OF GRADIENT AT X
       IF(ICALL==1) EELEC_MIN_LBFGS = EELEC
       IF(ICALL/=1.AND.EELEC<EELEC_MIN_LBFGS) EELEC_MIN_LBFGS = EELEC
       F = EELEC + EN
       G = GRADS
       CALL LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
       Cxyz = X
       IF(IFLAG.LE.0) EXIT
!      We allow at most 1000 evaluations of F and G
       IF(ICALL.GT.1000) EXIT
      ENDDO
      DEALLOCATE(W)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -             
!     FINAL CALL TO COMPUTE ENERGY AND GRADS AT EQUIL. GEOMETRY
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
      IF(IFLAG==0.AND.EELEC<=EELEC_MIN_LBFGS) THEN
       WRITE(6,'(/1X,A24,/)')'Optimal solution found !'
      ELSEIF(IFLAG.LE.0.OR.EELEC>EELEC_MIN_LBFGS) THEN
       WRITE( 6,'(A38,/)')' !!! Cannot find optimal solution !!! '
       WRITE(11,'(A38,/)')' !!! Cannot find optimal solution !!! '
      ENDIF
      WRITE(6,*)'New Coordinates after the LBFGS Method (Bohr)'
      WRITE(6,'(45(1H-),/)')
      DO I=1,NAT
       WRITE(6,'(I5,3F20.10)')I,Cxyz(1,I),Cxyz(2,I),Cxyz(3,I)
      ENDDO
!     Update coordinates of shells if use libreta library for ERIs
      if(ILIBRETA==1)CALL UPDCOOSHELL(NSHELL,KATOM,Cxyz,NAT)
      CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NBFaux,NSHELL,NPRIMI,   &
                    ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,     &
                    INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX,CS,CP,CD,CF,  &
                    CG,CH,CI,GRADS,IRUNTYP,DIPS,0,1)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Final Coordinates on File CGGRAD (Unit=100)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(11,*)
      WRITE(11,*)'New Coordinates after the LBFGS Method (Angs)'
      WRITE(11,*)
      DO I=1,NAT
       WRITE(11,'(I5,3F20.10)')                                         &
            I,Cxyz(1,I)*BOHR,Cxyz(2,I)*BOHR,Cxyz(3,I)*BOHR
      ENDDO
      CALL NUCDIST(N,NAT,Cxyz)
      GRADIENT = GRADS
!-----------------------------------------------------------------------
      RETURN
      END

! GRADSPURIFY
      SUBROUTINE GRADSPURIFY(GRADS,NV)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::NV
      DOUBLE PRECISION,DIMENSION(NV),INTENT(INOUT)::GRADS
      DOUBLE PRECISION::GOLD
      INTEGER::I,J
      DOUBLE PRECISION,PARAMETER::THR=0.000001D+00,THR2=0.0000001D+00
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00
!-----------------------------------------------------------------------
      DO I=1,NV
        IF(DABS(GRADS(I))<=THR) THEN
          GRADS(I) = ZERO
          CYCLE
        ENDIF
        DO J=1,I-1
          IF(DABS(DABS(GRADS(I))-DABS(GRADS(J)))<THR2) THEN
            GOLD = GRADS(J)
            GRADS(J) = DABS(GRADS(I))
            IF(GOLD<ZERO) GRADS(J) = - DABS(GRADS(I))
          ENDIF
        ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! PNOFGRAD
      SUBROUTINE PNOFGRAD(COEF,QD,RO,ELAG,GRADS,ATMNAME,KATOM,KTYPE,    &
                          KLOC,KKMIN,KKMAX,KSTART,KNG,CX0,CY0,CZ0,ZNUC, &
                          EX1,CS,CP,CD,CF,CG,CJ12,CK12,XINTS,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL HighSpin
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_ORBSPACE1/NSOC,NDNS,MSpin,HighSpin
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/USELIBRETA/ILIBRETA      
!
      CHARACTER*4 ATMNAME(NATOMS)
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG
      INTEGER,INTENT(IN)::IPRINTOPT
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0,ZNUC
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::COEF
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF),INTENT(IN)::QD
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::ELAG
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5),INTENT(IN)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2),INTENT(IN)::XINTS
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT):: GRADS
!-----------------------------------------------------------------------
!     ONE-ELECTRON CONTRIBUTION TO THE GRADIENT
!-----------------------------------------------------------------------
      CALL STVDERNOF(COEF,QD,RO,ELAG,GRADS,KATOM,KTYPE,KLOC,KKMIN,KKMAX,&
                     KSTART,KNG,CX0,CY0,CZ0,ZNUC,EX1,CS,CP,CD,CF,CG)
!-----------------------------------------------------------------------
!     TWO-ELECTRON CONTRIBUTION TO THE GRADIENT
!-----------------------------------------------------------------------
      if(ILIBRETA==0)then
       IF((IPNOF==5 .or. IPNOF==7) .and. NSOC==0) THEN
        CALL JKDERNOF5(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,QD,RO,   &
                       GRADS,CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,ATMNAME,    &
                       XINTS,IPRINTOPT)
       ELSE
        CALL JKDERNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,CJ12,     &
                      CK12,QD,RO,GRADS,CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,  &
                      ATMNAME,XINTS,IPRINTOPT)
       ENDIF
      else if(ILIBRETA==1)then                    
       IF((IPNOF==5 .or. IPNOF==7) .and. NSOC==0) THEN
        CALL JKDERNOF5lib(KATOM,KTYPE,KLOC,KKMIN,KKMAX,QD,RO,GRADS,     & 
                          ATMNAME,XINTS,IPRINTOPT)                      
       ELSE                                                             
        CALL JKDERNOFlib(KATOM,KTYPE,KLOC,KKMIN,KKMAX,CJ12,CK12,        &
                         QD,RO,GRADS,ATMNAME,XINTS,IPRINTOPT)
       ENDIF
      end if
!-----------------------------------------------------------------------
      RETURN
      END      

! STVDERNOF
      SUBROUTINE STVDERNOF(COEF,QD,RO,ELAG,GRADS,KATOM,KTYPE,KLOC,      &
                           KKMIN,KKMAX,KSTART,KNG,CX0,CY0,CZ0,ZNUC,     &
                           EX1,CS,CP,CD,CF,CG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL FROZEN
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200) 
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/USELIBRETA/ILIBRETA
!      
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG  
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0,ZNUC
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::COEF
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF),INTENT(IN)::QD
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::DM2
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::ELAG
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT):: GRADS
      DOUBLE PRECISION,DIMENSION(NBFT)::LEPS
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00
!-----------------------------------------------------------------------
!     MAKE GRADIENT ZERO
      GRADS=ZERO
!-----------------------------------------------------------------------
!     Nuclear repulsion force
!-----------------------------------------------------------------------
      CALL VNNDERNOF(CX0,CY0,CZ0,ZNUC,GRADS)
!-----------------------------------------------------------------------
!     Density force contribution
!-----------------------------------------------------------------------      
!     GET LAGRANGIAN MATRIX (LEPS)    
      CALL AOLAGRAN(COEF,ELAG,LEPS,NBF,NBFT)
!     COMPUTE AND ADD OVERLAP DERIVATIVES
      if(ILIBRETA==0)then
       CALL SDERNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,            &
                    CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,LEPS,GRADS)
      else if(ILIBRETA==1)then                    
       CALL SDERNOFlib(KATOM,KLOC,KKMIN,KKMAX,LEPS,GRADS)
      end if      
!-----------------------------------------------------------------------
!     One-electron hamiltonian contribution
!-----------------------------------------------------------------------
!     CONTRACT OVER OCCUPATIONS TO OBTAIN DENSITY MATRIX
      ALLOCATE(DM2(NBF,NBF))
      DM2=ZERO
      DO J=1,NBF
       DO L=1,J
        DO I=1,NBF5
          DM2(J,L)=DM2(J,L)+QD(I,J,L)*RO(I)
        ENDDO
        DM2(L,J)=DM2(J,L)
       ENDDO
      ENDDO
      DM2=DM2+DM2
!      
!     HELLMANN-FEYNMAN FORCE      
!
      if(ILIBRETA==0)then
       CALL HELFEYNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,          &
                      CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,ZNUC,DM2,GRADS)
      else if(ILIBRETA==1)then                    
       CALL HELFEYNOFlib(KATOM,KLOC,KKMIN,KKMAX,CX0,CY0,CZ0,ZNUC,DM2,   &
                         GRADS)
      end if            
!                  
!     INTEGRAL FORCE (AO DERIVATIVE CONTRIBUTION)                  
!
      if(ILIBRETA==0)then
       CALL TVDERNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,           &
                     CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,ZNUC,DM2,GRADS)
      else if(ILIBRETA==1)then                    
       CALL TVDERNOFlib(KATOM,KLOC,KKMIN,KKMAX,CX0,CY0,CZ0,ZNUC,DM2,GRADS)
      end if
!                  
      DEALLOCATE(DM2)
!     
!     MAKE ZERO GRADIENT CORRESPONDING TO FROZEN COORDINATES
!
      IF(FROZEN) THEN
        DO I=1,200,2
         IF(IFROZEN(I)==0) EXIT
         GRADS(IFROZEN(I),IFROZEN(I+1))=ZERO
        ENDDO
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END   

!----------------------------------------------------------------------!
!                                                                      !
!                      Use HONDO for ERI calculation                   !
!                                                                      !
!----------------------------------------------------------------------!

! JKDERNOF5
      SUBROUTINE JKDERNOF5(KATOM,KTYPE,KLOC,KKMIN,KKMAX,                &
                           KSTART,KNG,QD,RO,GRADS,CX0,CY0,CZ0,          &
                           EX1,CS,CP,CD,CF,CG,ATMNAME,XINTS,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL FROZEN
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200)
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!     INPUT-OUTPUT VARIABLES OR ARGUMENTS
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF),INTENT(IN)::QD
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::P,CJAUX,CKAUX
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2),INTENT(IN)::XINTS
      CHARACTER*4 ATMNAME(NATOMS)
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::GRADS
      INTEGER,INTENT(IN)::IPRINTOPT
!     INTERMEDIATE VARIABLES
      INTEGER,DIMENSION(NBF)::IA
      INTEGER,DIMENSION(4,35)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(:,:),ALLOCATABLE::NIJG,IJKLG
      INTEGER,DIMENSION(5)::LENSHL
      INTEGER::MAXFUN,NIJGDIM,MAXVEC,MINVEC,MODTYP,LVAR,LFIX
      INTEGER::MINMEM,MAXNUM,MINXYZ,MAXXYZ
      INTEGER::IDER,JDER,KDER,LDER
      INTEGER::TOTCOUNT,INVTYP,NROOTS,NIJ,NKL,KANG,I
      INTEGER::II,JJ,KK,LL,MAXLL,ISH,JSH,KSH,LSH,IIAT,JJAT,KKAT,LLAT
      INTEGER::MINJ,MAXJ,MINK,MAXK,MINL,MAXL,MINI,MAXI,NIJ0,NKL0
      INTEGER::LIT,LJT,LKT,LLTT,NUMI,NUMJ,NUMK,NUML,IIJJ,KKLL
      LOGICAL::SKIPI,SKIPJ,SKIPK,SKIPL,SPI,SPJ,SPK,SPL,SPIJ,SPKL,SPIJKL
      LOGICAL::IIEQJJ,KKEQLL,IJEQKL,IJGTKL,IJLTKL,EXPNDI,EXPNDK
      DOUBLE PRECISION::DABMAX,DABCUT,CUTOFF,CUTOFF2,GMAX
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::DCHRG
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::DAB,GINT,FINT
      DOUBLE PRECISION,DIMENSION(84)::PNRM
      DOUBLE PRECISION::FI
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
      DOUBLE PRECISION,PARAMETER::SQRT3=1.73205080756888D+00
      DOUBLE PRECISION,PARAMETER::SQRT5=2.23606797749979D+00
      DOUBLE PRECISION,PARAMETER::SQRT7=2.64575131106459D+00
      DOUBLE PRECISION,PARAMETER::TEN=10.0D+00,TENM9=1.0D-09,TENM11=1.0D-11
      DATA LENSHL /1,4,10,20,35/
!-----------------------------------------------------------------------
!     ROUTINE BASCHK DO:
      KANG=0
      DO N=1,NSHELL
        IF(KTYPE(N).GT.KANG) KANG = KTYPE(N)
      ENDDO
      MINXYZ=(4*KANG -2 + 1)/2
      MODTYP=KANG+1
      MAXVEC= 255/3
!     ROUTINE IGETGRDVECLEN DO:
      MINVEC= MAXVEC*3+1
!
!     NOT IMPLEMENTED FOR SHELLS LARGER THAN G      
      IF(KANG.GT.5) THEN
        WRITE(6,*) "G IS THE MAXIMUM SHELL FOR GRADIENTS"
        STOP
      ENDIF      
!
!     SET NORMALIZATION CONSTANTS
!     MAXFUN=NUMBER OF FUNCTIONS WITH ANGULAR MOMENTUM EQUAL TO MAXTYP
      MAXFUN=LENSHL(KANG)
      DO I=1,MAXFUN
        PNRM(I)=ONE
      ENDDO
      SQRT53=SQRT5/SQRT3
      FI=ZERO
      DO I=1,MAXFUN
        IF (I.EQ.1.OR.I.EQ.2.OR.I.EQ.5.OR.I.EQ.11.OR.I.EQ.21) THEN
           FI = ONE
        ELSE IF (I.EQ.8.OR.I.EQ.20.OR.I.EQ.33) THEN
           FI=FI*SQRT3
        ELSE IF (I.EQ.14) THEN
           FI=FI*SQRT5
        ELSE IF (I.EQ.24) THEN
           FI=FI*SQRT7
        ELSE IF (I.EQ.30) THEN
           FI=FI*SQRT53
        END IF
        PNRM(I)=FI
      ENDDO
!
!     SET STARTING PARAMETERS
!
!     CUTOFF IS THE SCHWARZ SCREENING CUT OFF 
      CUTOFF=TENM9/TEN
      CUTOFF2=CUTOFF*0.5D+00
      ZBIG = 0.0D+00
      DO ISH=1,NSHELL
         I1=KSTART(ISH)
         I2=I1+KNG(ISH)-1
         DO IG=I1,I2
            IF(EX1(IG).GT.ZBIG) ZBIG = EX1(IG)           
         ENDDO
      ENDDO
!     DABCUT IS THE TWO PARTICLE DENSITY CUT OFF      
      DABCUT=1.0D-11
      IF(ZBIG.GT.1.0D+06) DABCUT = DABCUT/10.0D+00
      IF(ZBIG.GT.1.0D+07) DABCUT = DABCUT/10.0D+00
!     SET POINTERS FOR PARTITIONING MEMORY
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
!           
      NIJGDIM=0
!     CALCULATE THE LARGEST SHELL TYPE      
      DO N=1,NSHELL
!       GET NUMBER OF PRIMITIVE CHARGE DISTRIBUTIONS        
        DO NN2=1,N
          NIJGDIM=NIJGDIM+KNG(N)*KNG(NN2)
        ENDDO
      ENDDO
!      
!     MAXNUM=NUMBER OF FUNCTIONS WITH ANGULAR MOMENTUM EQUAL TO MAXTYP
      MAXNUM=((KANG)*(KANG+1))/2
!     DO AT LEAST AN L SHELL      
      IF(MAXNUM.LT.4) MAXNUM=4
      MAXNUM=(MAXNUM**4)
!      
      LVAR=     ( MODTYP**2       * MODTYP**2       )*3                 
      LVAR=LVAR+( MODTYP**2       *(MODTYP+MODTYP-1))*3                 
      LVAR=LVAR+((MODTYP+MODTYP-1)*(MODTYP+MODTYP-1))*3                 
      LVAR=LVAR+( MODTYP**2                         )*3                 
      LVAR=LVAR+((MODTYP+MODTYP-1)                  )*3                 
      LVAR=LVAR+((MODTYP+MODTYP-1)* 3               )*3                 
      LVAR=LVAR+(  3                                )*3                 
      LVAR=LVAR+(  9                                )                   
      LVAR=LVAR+(  4                                )                   
      LVAR=LVAR+(  5                                )                   
      LVAR=LVAR+( 18                                )                   
      LVAR=LVAR+(  2                                )                   
      LVAR=LVAR+(  4                                )*3                 
      LVAR=LVAR+( MODTYP**2       * MODTYP**2       )*3*14
      LFIX=(NBF*NBF + NBF)/2
      LFIX=LFIX  +(NSHELL*(NSHELL+1))/2
      LFIX=LFIX+( (NSHELL*(NSHELL+1))/2 )*2
      LFIX=LFIX+MAXNUM* 4
      LFIX=LFIX+MAXNUM
      LFIX=LFIX+NIJGDIM*15
!
!     CHECK OUT NEEDED MEMORY
!     MAXXYZ=MAXIMUM NUMBER OF PRIMITIVE INTEGRALS THAT CAN BE HANDLED IN ONE VECTOR
      MAXXYZ=MAXVEC
      MINMEM=(MINXYZ*LVAR)+1+LFIX
      IF(MAXXYZ.LT.MINXYZ) THEN
        WRITE(6,3) MINMEM
        STOP
      ENDIF                                
!
      ALLOCATE(IJKLG(4,MAXNUM))
      ALLOCATE(NIJG(2,(NSHELL*(NSHELL+1))/2))
      ALLOCATE(DCHRG(15,NIJGDIM))
      ALLOCATE(DAB(MAXNUM))
      ALLOCATE(GINT(MAXNUM))
      ALLOCATE(FINT(MAXNUM))
!     SET UP 1e CHARGE DISTRIBUTION
      CALL OEDHNDNOF(DCHRG,NIJGDIM,NIJG,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG, &
                  KATOM,IA,CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG)          
      ALLOCATE(P(NBF,NBFT))  
      CALL SQUARETRIAN3(QD,P,NBF,NBFT)
      P=P*0.5D+00
      ALLOCATE(CJAUX(NBFT,NBFT))
      ALLOCATE(CKAUX(NBFT,NBFT))
      IF(IPNOF==5) CALL DABNOF5PRE(RO,P,CJAUX,CKAUX)
      IF(IPNOF==7) CALL DABNOF7PRE(RO,P,CJAUX,CKAUX)
      DEALLOCATE(P)
!
      TOTCOUNT=1
!
!----I SHELL
!
      DO II=1,NSHELL
!      
!-----J SHELL
!
       DO JJ=1,II
        IIJJ=IA(MAX0(II,JJ))+MIN0(II,JJ)
!       SET POINTERS TO THE IJ CHARGE DISTRIBUTION        
        CALL OEDRDNOF(NIJG,NIJ,NIJ0,IIJJ)
        IF(NIJ.EQ.0) CYCLE
!        
!-----K SHELL
!
        DO KK=1,II
!        
!-----L SHELL
!
        MAXLL=KK
        IF(KK.EQ.II) MAXLL=JJ
         DO LL=1,MAXLL
!
!         IMPLEMENT INTEGRAL SCREENING HERE USING EXCHANGE INTEGRALS
!                                                                       
          IJIJ=IA(MAX0(II,JJ))+MIN0(II,JJ)                          
          KLKL=IA(MAX0(KK,LL))+MIN0(KK,LL)                          
          GMAX=(XINTS(IJIJ)*XINTS(KLKL))
!
!         COARSE SCREENING, ON JUST THE INTEGRAL VALUE         
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF (GMAX.LT.CUTOFF.AND.NATOMS>5) CYCLE
!
          ISH=II
          JSH=JJ
          KSH=KK
          LSH=LL
          KKLL=IA(MAX0(KK,LL))+MIN0(KK,LL)
!         SET POINTERS TO THE KL CHARGE DISTRIBUTION                  
          CALL OEDRDNOF(NIJG,NKL,NKL0,KKLL)
          IF(NKL.EQ.0) CYCLE
!          
!         SELECT CENTERS FOR DERIVATIVES
!
          CALL JKDATMNOF(ISH,JSH,KSH,LSH,SKIPI,SKIPJ,SKIPK,SKIPL,INVTYP,&
                         KATOM,IIAT,JJAT,KKAT,LLAT)                      
          IF(SKIPI.AND.SKIPJ.AND.SKIPK.AND.SKIPL) CYCLE
!          
!         SELECT INDICES FOR SHELL BLOCK
!
          CALL JKDSHLNOF(ISH,JSH,KSH,LSH,KTYPE,KLOC,KKMIN,KKMAX,        &
                         SPI,SPJ,SPK,SPL,SPIJ,SPKL,SPIJKL,EXPNDI,EXPNDK,&
                         MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,       &
                         IIEQJJ,KKEQLL,IJEQKL,IJGTKL,IJLTKL,            &
                         LIT,LJT,LKT,LLTT,NUMI,NUMJ,NUMK,NUML)                      
          CALL JKDNDXNOF(LIT,LJT,LKT,LLTT,NUMJ,NUMK,NUML,               &
                         SKIPI,SKIPJ,SKIPK,SKIPL,MINI,MAXI,             &
                         MINJ,MAXJ,MINK,MAXK,MINL,MAXL,NROOTS,          &
                         IGXYZ,JGXYZ,KGXYZ,LGXYZ,                       &
                         IIEQJJ,KKEQLL,IJEQKL,IJKLG,MAXNUM,             &
                         IDER,JDER,KDER,LDER)          
!                      
!         OBTAIN 2e DENSITY FOR THIS SHELL BLOCK                      
!
          CALL DABNOF5(ISH,JSH,KSH,LSH,PNRM,KKMIN,KKMAX,KLOC,           &
                       IGXYZ,JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,    &
                       IA,DAB,MAXNUM,DABMAX,CJAUX,CKAUX)
!
!         FINE SCREENING, ON INTEGRAL VALUE TIMES DENSITY FACTOR
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF(DABMAX*GMAX.LT.CUTOFF2.AND.NATOMS>5) CYCLE
!
!         EVALUATE DERIVATIVE INTEGRAL AND ADD TO THE GRADIENT
!
          CALL JKDSPDNOF(TOTCOUNT,GINT,FINT,DAB,DCHRG,NIJGDIM,MINI,MAXI,&
                         MINJ,MAXJ,MINK,MAXK,MINL,MAXL,IIEQJJ,KKEQLL,   &
                         IJEQKL,EXPNDI,EXPNDK,SKIPI,SKIPJ,SKIPK,SKIPL,  &
                         SPI,SPJ,SPK,SPL,SPIJKL,IJKLG,MAXNUM,INVTYP,    &
                         NROOTS,MINVEC,MODTYP,MAXXYZ,NKL,NIJ,IIAT,JJAT, &
                         KKAT,LLAT,GRADS,DABMAX,DABCUT,NKL0,NIJ0,LIT,   &
                         LJT,LKT,LLTT,IDER,JDER,KDER,LDER)               
!      
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      DEALLOCATE(IJKLG,NIJG,DCHRG,DAB,GINT,FINT,CJAUX,CKAUX)
!     
!     MAKE ZERO GRADIENT CORRESPONDING TO FROZEN COORDINATES
!
      IF(FROZEN) THEN
        DO I=1,200,2
         IF(IFROZEN(I).EQ.0) EXIT
         GRADS(IFROZEN(I),IFROZEN(I+1))=ZERO
        ENDDO
      ENDIF      
!
!     PRINT OUT TOTAL PNOF ENERGY GRADIENT
!
      IF(IPRINTOPT==1)THEN
       WRITE(6,1)
       DO I=1,NATOMS
        WRITE(6,2)I,ATMNAME(I),GRADS(1,I),GRADS(2,I),GRADS(3,I)
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT( /1X,'----------------',                                  &
              /1X,' Total Gradient ',                                  &
              /1X,'----------------',                                  &
              //9X,'Atom',7X,'Ex',10X,'Ey',10X,'Ez' )
    2 FORMAT(/1X,I4,5X,A4,F10.4,2X,F10.4,2X,F10.4)
    3 FORMAT(/,' THE MINIMUM MEMORY REQUIRED IS ',I10,' WORDS.')
!-----------------------------------------------------------------------
      RETURN
      END      

! JKDERNOF
      SUBROUTINE JKDERNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,CJ12, &
                          CK12,QD,RO,GRADS,CX0,CY0,CZ0,EX1,CS,CP,CD,CF, &
                          CG,ATMNAME,XINTS,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL FROZEN
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200)      
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!     INPUT-OUTPUT VARIABLES OR ARGUMENTS
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5),INTENT(IN)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF),INTENT(IN)::QD
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::P,DAAUX,DAAUX2
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2),INTENT(IN)::XINTS
      CHARACTER*4 ATMNAME(NATOMS)
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::GRADS
      INTEGER,INTENT(IN)::IPRINTOPT
!     INTERMEDIATE VARIABLES 
      INTEGER,DIMENSION(NBF)::IA
      INTEGER,DIMENSION(4,35)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(:,:),ALLOCATABLE::NIJG,IJKLG
      INTEGER,DIMENSION(5)::LENSHL
      INTEGER::MAXFUN,NIJGDIM,MAXVEC,MINVEC,MODTYP,LVAR,LFIX
      INTEGER::MINMEM,MAXNUM,MINXYZ,MAXXYZ
      INTEGER::IDER,JDER,KDER,LDER
      INTEGER::TOTCOUNT,INVTYP,NROOTS,NIJ,NKL,KANG,I
      INTEGER::II,JJ,KK,LL,MAXLL,ISH,JSH,KSH,LSH,IIAT,JJAT,KKAT,LLAT
      INTEGER::MINJ,MAXJ,MINK,MAXK,MINL,MAXL,MINI,MAXI,NIJ0,NKL0
      INTEGER::LIT,LJT,LKT,LLTT,NUMI,NUMJ,NUMK,NUML,IIJJ,KKLL
      LOGICAL::SKIPI,SKIPJ,SKIPK,SKIPL,SPI,SPJ,SPK,SPL,SPIJ,SPKL,SPIJKL
      LOGICAL::IIEQJJ,KKEQLL,IJEQKL,IJGTKL,IJLTKL,EXPNDI,EXPNDK
      DOUBLE PRECISION::DABMAX,DABCUT,CUTOFF,CUTOFF2,GMAX
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::DCHRG
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::DAB,GINT,FINT
      DOUBLE PRECISION,DIMENSION(84)::PNRM
      DOUBLE PRECISION::FI
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
      DOUBLE PRECISION,PARAMETER::SQRT3=1.73205080756888D+00
      DOUBLE PRECISION,PARAMETER::SQRT5=2.23606797749979D+00
      DOUBLE PRECISION,PARAMETER::SQRT7=2.64575131106459D+00
      DOUBLE PRECISION,PARAMETER::TEN=10.0D+00,TENM9=1.0D-09,TENM11=1.0D-11
      DATA LENSHL /1,4,10,20,35/
!-----------------------------------------------------------------------
!     ROUTINE BASCHK DO:
      KANG=0
      DO N=1,NSHELL
        IF(KTYPE(N).GT.KANG) KANG = KTYPE(N)
      ENDDO
      MINXYZ=(4*KANG -2 + 1)/2
      MODTYP=KANG+1
      MAXVEC= 255/3
!     ROUTINE IGETGRDVECLEN DO:
      MINVEC= MAXVEC*3+1
!
!     NOT IMPLEMENTED FOR SHELLS LARGER THAN G      
      IF(KANG.GT.5) THEN
        WRITE(6,*) "G IS THE MAXIMUM SHELL FOR GRADIENTS"
        STOP
      ENDIF      
!
!     SET NORMALIZATION CONSTANTS
!     MAXFUN=NUMBER OF FUNCTIONS WITH ANGULAR MOMENTUM EQUAL TO MAXTYP
      MAXFUN=LENSHL(KANG)
      DO I=1,MAXFUN
        PNRM(I)=ONE
      ENDDO
      SQRT53=SQRT5/SQRT3
      FI=ZERO
      DO I=1,MAXFUN
        IF (I.EQ.1.OR.I.EQ.2.OR.I.EQ.5.OR.I.EQ.11.OR.I.EQ.21) THEN
           FI = ONE
        ELSE IF (I.EQ.8.OR.I.EQ.20.OR.I.EQ.33) THEN
           FI=FI*SQRT3
        ELSE IF (I.EQ.14) THEN
           FI=FI*SQRT5
        ELSE IF (I.EQ.24) THEN
           FI=FI*SQRT7
        ELSE IF (I.EQ.30) THEN
           FI=FI*SQRT53
        END IF
        PNRM(I)=FI
      ENDDO
!
!     SET STARTING PARAMETERS
!
!     CUTOFF IS THE SCHWARZ SCREENING CUT OFF 
      CUTOFF=TENM9/TEN
      CUTOFF2=CUTOFF*0.5D+00
      ZBIG = 0.0D+00
      DO ISH=1,NSHELL
         I1=KSTART(ISH)
         I2=I1+KNG(ISH)-1
         DO IG=I1,I2
            IF(EX1(IG).GT.ZBIG) ZBIG = EX1(IG)           
         ENDDO
      ENDDO
!     DABCUT IS THE TWO PARTICLE DENSITY CUT OFF      
      DABCUT=1.0D-11
      IF(ZBIG.GT.1.0D+06) DABCUT = DABCUT/10.0D+00
      IF(ZBIG.GT.1.0D+07) DABCUT = DABCUT/10.0D+00
!     SET POINTERS FOR PARTITIONING MEMORY
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
!           
      NIJGDIM=0
!     CALCULATE THE LARGEST SHELL TYPE      
      DO N=1,NSHELL
!       GET NUMBER OF PRIMITIVE CHARGE DISTRIBUTIONS        
        DO NN2=1,N
          NIJGDIM=NIJGDIM+KNG(N)*KNG(NN2)
        ENDDO
      ENDDO
!      
!     MAXNUM=NUMBER OF FUNCTIONS WITH ANGULAR MOMENTUM EQUAL TO MAXTYP
      MAXNUM=((KANG)*(KANG+1))/2
!     DO AT LEAST AN L SHELL      
      IF(MAXNUM.LT.4) MAXNUM=4
      MAXNUM=(MAXNUM**4)
!      
      LVAR=     ( MODTYP**2       * MODTYP**2       )*3                 
      LVAR=LVAR+( MODTYP**2       *(MODTYP+MODTYP-1))*3                 
      LVAR=LVAR+((MODTYP+MODTYP-1)*(MODTYP+MODTYP-1))*3                 
      LVAR=LVAR+( MODTYP**2                         )*3                 
      LVAR=LVAR+((MODTYP+MODTYP-1)                  )*3                 
      LVAR=LVAR+((MODTYP+MODTYP-1)* 3               )*3                 
      LVAR=LVAR+(  3                                )*3                 
      LVAR=LVAR+(  9                                )                   
      LVAR=LVAR+(  4                                )                   
      LVAR=LVAR+(  5                                )                   
      LVAR=LVAR+( 18                                )                   
      LVAR=LVAR+(  2                                )                   
      LVAR=LVAR+(  4                                )*3                 
      LVAR=LVAR+( MODTYP**2       * MODTYP**2       )*3*14
      LFIX=(NBF*NBF + NBF)/2
      LFIX=LFIX  +(NSHELL*(NSHELL+1))/2
      LFIX=LFIX+( (NSHELL*(NSHELL+1))/2 )*2
      LFIX=LFIX+MAXNUM* 4                                               
      LFIX=LFIX+MAXNUM                                                  
      LFIX=LFIX+NIJGDIM*15
!
!     CHECK OUT NEEDED MEMORY
!     MAXXYZ=MAXIMUM NUMBER OF PRIMITIVE INTEGRALS THAT CAN BE HANDLED IN ONE VECTOR
      MAXXYZ=MAXVEC
      MINMEM=(MINXYZ*LVAR)+1+LFIX
      IF(MAXXYZ.LT.MINXYZ) THEN
        WRITE(6,3) MINMEM
        STOP
      ENDIF                                
!
      ALLOCATE(IJKLG(4,MAXNUM))
      ALLOCATE(NIJG(2,(NSHELL*(NSHELL+1))/2))
      ALLOCATE(DCHRG(15,NIJGDIM))
      ALLOCATE(DAB(MAXNUM))
      ALLOCATE(GINT(MAXNUM))
      ALLOCATE(FINT(MAXNUM))
!     SET UP 1e CHARGE DISTRIBUTION
      CALL OEDHNDNOF(DCHRG,NIJGDIM,NIJG,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG, &
                  KATOM,IA,CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG)          
      ALLOCATE(P(NBF,NBFT))
      CALL SQUARETRIAN3(QD,P,NBF,NBFT)
      P=P*0.5D+00
      ALLOCATE(DAAUX(NBF,NBFT))
      ALLOCATE(DAAUX2(NBF,NBFT))
      CALL DABNOF2PRE(CJ12,CK12,RO,P,DAAUX,DAAUX2)
!
      TOTCOUNT=1
!
!----I SHELL
!
      DO II=1,NSHELL
!      
!-----J SHELL
!
       DO JJ=1,II
        IIJJ=IA(MAX0(II,JJ))+MIN0(II,JJ)
!       SET POINTERS TO THE IJ CHARGE DISTRIBUTION        
        CALL OEDRDNOF(NIJG,NIJ,NIJ0,IIJJ)
        IF(NIJ.EQ.0) CYCLE
!        
!-----K SHELL
!
        DO KK=1,II
!        
!-----L SHELL
!
        MAXLL=KK
        IF(KK.EQ.II) MAXLL=JJ
         DO LL=1,MAXLL
!
!         IMPLEMENT INTEGRAL SCREENING HERE USING EXCHANGE INTEGRALS
!                                                                       
          IJIJ=IA(MAX0(II,JJ))+MIN0(II,JJ)                          
          KLKL=IA(MAX0(KK,LL))+MIN0(KK,LL)                          
          GMAX=(XINTS(IJIJ)*XINTS(KLKL))
!
!         COARSE SCREENING, ON JUST THE INTEGRAL VALUE         
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF (GMAX.LT.CUTOFF.AND.NATOMS>5) CYCLE
!
          ISH=II
          JSH=JJ
          KSH=KK
          LSH=LL
          KKLL=IA(MAX0(KK,LL))+MIN0(KK,LL)
!         SET POINTERS TO THE KL CHARGE DISTRIBUTION                  
          CALL OEDRDNOF(NIJG,NKL,NKL0,KKLL)
          IF(NKL.EQ.0) CYCLE
!          
!         SELECT CENTERS FOR DERIVATIVES
!
          CALL JKDATMNOF(ISH,JSH,KSH,LSH,SKIPI,SKIPJ,SKIPK,SKIPL,      &
                         INVTYP,KATOM,IIAT,JJAT,KKAT,LLAT)                      
          IF(SKIPI.AND.SKIPJ.AND.SKIPK.AND.SKIPL) CYCLE
!          
!         SELECT INDICES FOR SHELL BLOCK
!
          CALL JKDSHLNOF(ISH,JSH,KSH,LSH,KTYPE,KLOC,KKMIN,KKMAX,        &
                         SPI,SPJ,SPK,SPL,SPIJ,SPKL,SPIJKL,EXPNDI,EXPNDK,&
                         MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,       &
                         IIEQJJ,KKEQLL,IJEQKL,IJGTKL,IJLTKL,            &
                         LIT,LJT,LKT,LLTT,NUMI,NUMJ,NUMK,NUML)                      
          CALL JKDNDXNOF(LIT,LJT,LKT,LLTT,NUMJ,NUMK,NUML,               &
                         SKIPI,SKIPJ,SKIPK,SKIPL,MINI,MAXI,             &
                         MINJ,MAXJ,MINK,MAXK,MINL,MAXL,NROOTS,          &
                         IGXYZ,JGXYZ,KGXYZ,LGXYZ,                       &
                         IIEQJJ,KKEQLL,IJEQKL,IJKLG,MAXNUM,             &
                         IDER,JDER,KDER,LDER)          
!                      
!         OBTAIN 2e DENSITY FOR THIS SHELL BLOCK                      
!
          CALL DABNOF2(ISH,JSH,KSH,LSH,PNRM,KKMIN,KKMAX,KLOC,           &
                       IGXYZ,JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,    &
                       IA,P,DAB,MAXNUM,DABMAX,DAAUX,DAAUX2)
!
!         FINE SCREENING, ON INTEGRAL VALUE TIMES DENSITY FACTOR
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF(DABMAX*GMAX.LT.CUTOFF2.AND.NATOMS>5) CYCLE
!
!         EVALUATE DERIVATIVE INTEGRAL AND ADD TO THE GRADIENT
!
          CALL JKDSPDNOF(TOTCOUNT,GINT,FINT,DAB,DCHRG,NIJGDIM,          &
                         MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,       &
                         IIEQJJ,KKEQLL,IJEQKL,EXPNDI,EXPNDK,SKIPI,      &
                         SKIPJ,SKIPK,SKIPL,SPI,SPJ,SPK,SPL,SPIJKL,      &
                         IJKLG,MAXNUM,INVTYP,NROOTS,MINVEC,MODTYP,      &
                         MAXXYZ,NKL,NIJ,IIAT,JJAT,KKAT,LLAT,GRADS,      &
                         DABMAX,DABCUT,NKL0,NIJ0,LIT,LJT,LKT,LLTT,      &
                         IDER,JDER,KDER,LDER)               
!      
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      DEALLOCATE(P,IJKLG,NIJG,DCHRG,DAB,GINT,FINT,DAAUX,DAAUX2)
!     
!     MAKE ZERO GRADIENT CORRESPONDING TO FROZEN COORDINATES
!
      IF(FROZEN) THEN
        DO I=1,200,2
         IF(IFROZEN(I).EQ.0) EXIT
         GRADS(IFROZEN(I),IFROZEN(I+1))=ZERO
        ENDDO
      ENDIF      
!
!     PRINT OUT TOTAL PNOF ENERGY GRADIENT
!
      IF(IPRINTOPT==1)THEN
       WRITE(6,1)
       DO I=1,NATOMS
        WRITE(6,2)I,ATMNAME(I),GRADS(1,I),GRADS(2,I),GRADS(3,I)
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT( /1X,'----------------',                                  &
              /1X,' Total Gradient ',                                  &
              /1X,'----------------',                                  &
              //9X,'Atom',7X,'Ex',10X,'Ey',10X,'Ez' )
    2 FORMAT(/1X,I4,5X,A4,F10.4,2X,F10.4,2X,F10.4)
    3 FORMAT(/,' THE MINIMUM MEMORY REQUIRED IS ',I10,' WORDS.')
!-----------------------------------------------------------------------
      RETURN
      END

! AOLAGRAN
      SUBROUTINE AOLAGRAN(C,EE,LEPS,N,NL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(N,N),INTENT(IN) :: C,EE
      DOUBLE PRECISION,DIMENSION(NL),INTENT(OUT) :: LEPS
      DOUBLE PRECISION,DIMENSION(N,N) :: AUXELG,AELG
      DOUBLE PRECISION :: AUX
      DOUBLE PRECISION,PARAMETER :: PT5=0.5D+00,ZERO=0.0D+00
!-----------------------------------------------------------------------
!     GET THE LAGRANGIAN MATRIX FOR PNOF (COEF*LAMBDA*COEF)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      LEPS=ZERO
!     SIMETRIZATION OF LAMBDA MATRIX      
      DO I=1,NBF
       DO J=1,I
        AUXELG(I,J)=EE(I,J)
        AUXELG(J,I)=AUXELG(I,J)
       ENDDO
      ENDDO
!     SCALING AS N**3 CALCULATION, FIRST CONTRACTING OVER A SINGLE COEF
      AELG=ZERO
      DO L=1,N
       DO M=1,NBF
        DO NM=1,NBF
          AELG(M,L)=AELG(M,L)+AUXELG(M,NM)*C(L,NM)
        ENDDO
       ENDDO
      ENDDO
      KL=0
      DO K=1,N
       DO L=1,K
        KL=KL+1
        AUX=ZERO
        DO M=1,NBF
          AUX = AUX - AELG(M,L)*C(K,M)
        ENDDO
        LEPS(KL) = AUX + AUX
       ENDDO
!     DOUBLE COUNTING OF DIAGONAL IS AVOIDED IN TRACEs              
      ENDDO
      LEPS = LEPS + LEPS
!-----------------------------------------------------------------------
      RETURN
      END

! OEDHNDNOF      
      SUBROUTINE OEDHNDNOF(DCHRG,NIJGDIM,NIJG,KTYPE,KLOC,KKMIN,KKMAX,   &
                        KSTART,KNG,KATOM,IA,CX0,CY0,CZ0,EX1,CS,CP,    &
                        CD,CF,CG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(2,(NSHELL*(NSHELL+1))/2),INTENT(OUT)::NIJG
      DOUBLE PRECISION,DIMENSION(15,NIJGDIM),INTENT(OUT)::DCHRG
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG,KATOM
      INTEGER,DIMENSION(NBF),INTENT(IN)::IA
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
!
      NIJ0=0
      DO II=1,NSHELL
        DO JJ=1,II
          ISHI=II
          JSHJ=JJ
          CALL OEDSHLNOF(ISHI,JSHJ,DCHRG,NIJGDIM,NIJ,KTYPE,KLOC,KKMIN, &
                      KKMAX,KSTART,KNG,KATOM,CX0,CY0,CZ0,EX1,      &
                      CS,CP,CD,CF,CG,NIJ0)
          IIJJ=IA(MAX0(II,JJ))+MIN0(II,JJ)
          NIJG(1,IIJJ)=NIJ0
          NIJG(2,IIJJ)=NIJ
          NIJ0=NIJ0+NIJ
        ENDDO
      ENDDO
!      
      RETURN
      END

! OEDSHLNOF
      SUBROUTINE OEDSHLNOF(ISH,JSH,DCHRG,NIJGDIM,NIJ,KTYPE,KLOC,KKMIN,  &
                        KKMAX,KSTART,KNG,KATOM,CX,CY,CZ,EX1,       &
                        CS,CP,CD,CF,CG,NIJ0)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
!
      DOUBLE PRECISION::RTOL,DTOL
      INTEGER,INTENT(IN)::ISH,JSH,NIJ0
      INTEGER,INTENT(OUT)::NIJ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG,KATOM
      DOUBLE PRECISION,DIMENSION(15,NIJGDIM),INTENT(OUT)::DCHRG
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX,CY,CZ
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
!     NOTE THAT THIS IS LIMITED TO G SHELL
      DOUBLE PRECISION,PARAMETER::ONE=1.0D+00
      DOUBLE PRECISION,DIMENSION(30)::GA,CCA,CCAS,GB,CCB,CCBS
      DOUBLE PRECISION,DIMENSION(NPRIMI,5)::CSPDFG
      LOGICAL::IIEQJJ,SPI,SPJ,EXPNDI
!      
      IIEQJJ=ISH.EQ.JSH
      RTOL=20*2.30258D+00
      DTOL=(10.0D+00)**(-20)
      CSPDFG(:,1)=CS(:)
      CSPDFG(:,2)=CP(:)
      CSPDFG(:,3)=CD(:)
      CSPDFG(:,4)=CF(:)
      CSPDFG(:,5)=CG(:)
!
!     ----- ISHELL -----
!
      I=KATOM(ISH)
      XI=CX(I)
      YI=CY(I)
      ZI=CZ(I)
      I1=KSTART(ISH)
      I2=I1+KNG(ISH)-1
      LIT=KTYPE(ISH)
      MINI=KKMIN(ISH)
      MAXI=KKMAX(ISH)
      NUMI=MAXI-MINI+1
      LOCI=KLOC(ISH)-MINI
      SPI=LIT.EQ.2.AND.MINI.EQ.1
      NGA=0
      DO I=I1,I2
        NGA=NGA+1
        GA(NGA)=EX1(I)
        CCA(NGA)=CSPDFG(I,LIT)
        IF(SPI) CCAS(NGA)=CSPDFG(I,1)/CSPDFG(I,2)
      ENDDO
!
!     ----- JSHELL -----
!
      J=KATOM(JSH)
      XJ=CX(J)
      YJ=CY(J)
      ZJ=CZ(J)
      J1=KSTART(JSH)
      J2=J1+KNG(JSH)-1
      LJT=KTYPE(JSH)
      MINJ=KKMIN(JSH)
      MAXJ=KKMAX(JSH)
      NUMJ=MAXJ-MINJ+1
      LOCJ=KLOC(JSH)-MINJ
      SPJ=LJT.EQ.2.AND.MINJ.EQ.1
      NGB=0
      DO J=J1,J2
        NGB=NGB+1
        GB(NGB)=EX1(J)
        CCB(NGB)=CSPDFG(J,LJT)
        IF(SPJ) CCBS(NGB)=CSPDFG(J,1)/CSPDFG(J,2)
      ENDDO
      RRI=((XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2)
      EXPNDI=LIT.GE.LJT
!
!     ----- -IJ- CHARGE DISTRIBUTION -----
!
      XC=XI
      YC=YI
      ZC=ZI
      DXIJ=XI-XJ
      DYIJ=YI-YJ
      DZIJ=ZI-ZJ
      IF(.NOT.EXPNDI) THEN
       XC=XJ
       YC=YJ
       ZC=ZJ
       DXIJ=XJ-XI
       DYIJ=YJ-YI
       DZIJ=ZJ-ZI
      ENDIF
!
!     ----- - I- PRIMITIVE           -----
!
      NIJ=0
      DO IA=1,NGA
        AI=GA(IA)
        ARRI=AI*RRI
        AXI=AI*XI
        AYI=AI*YI
        AZI=AI*ZI
        CCI=CCA(IA)
!
!     ----- - J- PRIMITIVE           -----
!
        DO JB=1,NGB
          AJ=GB(JB)
          AA=AI+AJ
          AA1=ONE/AA
          DUM=AJ*ARRI*AA1
          IF(DUM.GT.RTOL) CYCLE
          DAEXPA=CCI*CCB(JB)* EXP(-DUM)*AA1
          DUM=  ABS(DAEXPA)
          IF(DUM.LE.DTOL) CYCLE
!
          NIJ=NIJ+1
          DCHRG( 1,NIJ+NIJ0)= DAEXPA
          DCHRG( 2,NIJ+NIJ0)= AA
          DCHRG( 3,NIJ+NIJ0)=(AXI+AJ*XJ)*AA1
          DCHRG( 4,NIJ+NIJ0)=(AYI+AJ*YJ)*AA1
          DCHRG( 5,NIJ+NIJ0)=(AZI+AJ*ZJ)*AA1
          DCHRG( 6,NIJ+NIJ0)= XC
          DCHRG( 7,NIJ+NIJ0)= YC
          DCHRG( 8,NIJ+NIJ0)= ZC
          DCHRG( 9,NIJ+NIJ0)= DXIJ
          DCHRG(10,NIJ+NIJ0)= DYIJ
          DCHRG(11,NIJ+NIJ0)= DZIJ
          DCHRG(12,NIJ+NIJ0)= AI+AI
          DCHRG(13,NIJ+NIJ0)= AJ+AJ
          IF(SPI) DCHRG(14,NIJ+NIJ0)=CCAS(IA)
          IF(SPJ) DCHRG(15,NIJ+NIJ0)=CCBS(JB)
        ENDDO
      ENDDO     
      RETURN
      END      

! OEDRDNOF      
      SUBROUTINE OEDRDNOF(NIJG,NIJ,NIJ0,IIJJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
!
      INTEGER,INTENT(IN)::IIJJ
      INTEGER,DIMENSION(2,(NSHELL*(NSHELL+1))/2),INTENT(IN)::NIJG
      INTEGER,INTENT(OUT)::NIJ0,NIJ
!
      NIJ0=NIJG(1,IIJJ)
      NIJ =NIJG(2,IIJJ)
      RETURN
      END      

! JKDATMNOF
      SUBROUTINE JKDATMNOF(II,JJ,KK,LL,SKIPI,SKIPJ,SKIPK,SKIPL,INVTYP,  &
                        KATOM,IIAT,JJAT,KKAT,LLAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM
      INTEGER,INTENT(IN)::II,JJ,KK,LL
      INTEGER,INTENT(OUT)::INVTYP,IIAT,JJAT,KKAT,LLAT
      LOGICAL,INTENT(OUT)::SKIPI,SKIPJ,SKIPK,SKIPL
      LOGICAL::IANDJ,IANDK,IANDL,JANDK,JANDL,KANDL
!-----------------------------------------------------------------------      
      SKIPI=.TRUE.
      SKIPJ=.TRUE.
      SKIPK=.TRUE.
      SKIPL=.TRUE.
      IIAT=KATOM(II)
      JJAT=KATOM(JJ)
      KKAT=KATOM(KK)
      LLAT=KATOM(LL)
      IANDJ=IIAT.EQ.JJAT
      IANDK=IIAT.EQ.KKAT
      IANDL=IIAT.EQ.LLAT
      JANDK=JJAT.EQ.KKAT
      JANDL=JJAT.EQ.LLAT
      KANDL=KKAT.EQ.LLAT
      IF(.NOT.IANDJ) GO TO 500
      IF(.NOT.IANDK) GO TO 200
      IF(.NOT.IANDL) GO TO 100
!     ----- IAT = JAT = KAT = LAT ----- (IAT,IAT/IAT,IAT) -----
      INVTYP=1
      GO TO 1500
  100 CONTINUE
!     ----- IAT = JAT = KAT ; LAT ----- (IAT,IAT/IAT,LAT) -----
      SKIPL=.FALSE.
      INVTYP=2
      GO TO 1500
  200 IF(.NOT.IANDL) GO TO 300
!     ----- IAT = JAT = LAT ; KAT ----- (IAT,IAT/KAT,IAT) -----
      SKIPK=.FALSE.
      INVTYP=3
      GO TO 1500
  300 IF(.NOT.KANDL) GO TO 400
!     ----- IAT = JAT ; KAT = LAT ----- (IAT,IAT/KAT,KAT) -----
      SKIPK=.FALSE.
      SKIPL=.FALSE.
      INVTYP=4
      GO TO 1500
  400 CONTINUE
!     ----- IAT = JAT ; KAT ; LAT ----- (IAT,IAT/KAT,LAT) -----
      SKIPK=.FALSE.
      SKIPL=.FALSE.
      INVTYP=5
      GO TO 1500
  500 IF(.NOT.IANDK) GO TO 800
      IF(.NOT.IANDL) GO TO 600
!     ----- IAT = KAT = LAT ; JAT ----- (IAT,JAT/IAT,IAT) -----
      SKIPJ=.FALSE.
      INVTYP=6
      GO TO 1500
  600 IF(.NOT.JANDL) GO TO 700
!     ----- IAT = KAT ; JAT = LAT ----- (IAT,JAT/IAT,JAT) -----
      SKIPJ=.FALSE.
      SKIPL=.FALSE.
      INVTYP=7
      GO TO 1500
  700 CONTINUE
!     ----- IAT = KAT ; JAT ; LAT ----- (IAT,JAT/IAT,LAT) -----
      SKIPJ=.FALSE.
      SKIPL=.FALSE.
      INVTYP=8
      GO TO 1500
  800 IF(.NOT.IANDL) GO TO 1000
      IF(.NOT.JANDK) GO TO 900
!     ----- IAT = LAT ; JAT = KAT ----- (IAT,JAT/JAT,IAT) -----
      SKIPJ=.FALSE.
      SKIPK=.FALSE.
      INVTYP=9
      GO TO 1500
  900 CONTINUE
!     ----- IAT = LAT ; JAT , KAT ----- (IAT,JAT/KAT,IAT) -----
      SKIPJ=.FALSE.
      SKIPK=.FALSE.
      INVTYP=10
      GO TO 1500
 1000 IF(.NOT.JANDK) GO TO 1200
      IF(.NOT.JANDL) GO TO 1100
!     ----- IAT ; JAT = JAT = JAT ----- (IAT,JAT/JAT,JAT) -----
      SKIPI=.FALSE.
      INVTYP=11
      GO TO 1500
 1100 CONTINUE
!     ----- IAT ; JAT = KAT ; LAT ----- (IAT,JAT/JAT,LAT) -----
      SKIPI=.FALSE.
      SKIPL=.FALSE.
      INVTYP=12
      GO TO 1500
 1200 IF(.NOT.JANDL) GO TO 1300
!     ----- JAT = LAT ; IAT ; KAT ----- (IAT,JAT/KAT,JAT) -----
      SKIPI=.FALSE.
      SKIPK=.FALSE.
      INVTYP=13
      GO TO 1500
 1300 IF(.NOT.KANDL) GO TO 1400
!     ----- KAT = LAT ; IAT ; JAT ----- (IAT,JAT/KAT,KAT) -----
      SKIPI=.FALSE.
      SKIPJ=.FALSE.
      INVTYP=14
      GO TO 1500
 1400 CONTINUE
!     ----- IAT ; JAT ; KAT ; LAT ----- (IAT,JAT/KAT,LAT) -----
      SKIPI=.FALSE.
      SKIPJ=.FALSE.
      SKIPK=.FALSE.
      INVTYP=15
 1500 CONTINUE      
!-----------------------------------------------------------------------
      RETURN
      END

! JKDSHLNOF
      SUBROUTINE JKDSHLNOF(ISH,JSH,KSH,LSH,KTYPE,KLOC,KKMIN,KKMAX,      &
                        SPI,SPJ,SPK,SPL,SPIJ,SPKL,SPIJKL,EXPNDI,EXPNDK, &
                        MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,        &
                        IIEQJJ,KKEQLL,IJEQKL,IJGTKL,IJLTKL,             &
                        LIT,LJT,LKT,LLTT,NUMI,NUMJ,NUMK,NUML)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::ISH,JSH,KSH,LSH
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,INTENT(OUT)::MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL
      INTEGER,INTENT(OUT)::LIT,LJT,LKT,LLTT
!     USE LLTT INSTEAD OF LLT BECAUSE LLT IS INTRINSIC FUNCTION      
      INTEGER,INTENT(OUT)::NUMI,NUMJ,NUMK,NUML
      LOGICAL,INTENT(OUT)::SPI,SPJ,SPK,SPL,SPIJ,SPKL,SPIJKL      
      LOGICAL,INTENT(OUT)::IIEQJJ,KKEQLL,IJEQKL,IJGTKL,IJLTKL
      LOGICAL,INTENT(OUT)::EXPNDI,EXPNDK      
!-----------------------------------------------------------------------
      IIEQJJ=ISH.EQ.JSH
      KKEQLL=KSH.EQ.LSH
      IJEQKL=ISH.EQ.KSH.AND.JSH.EQ.LSH
      IJGTKL=MAX0(ISH,JSH).GT.MAX0(KSH,LSH)
      IJLTKL=MAX0(ISH,JSH).LT.MAX0(KSH,LSH)
!     ----- ISHELL -----
      LIT=KTYPE(ISH)
      MINI=KKMIN(ISH)
      MAXI=KKMAX(ISH)
      NUMI=MAXI-MINI+1
      LOCI=KLOC(ISH)-MINI
      SPI=LIT.EQ.2.AND.MINI.EQ.1
!     ----- JSHELL -----
      LJT=KTYPE(JSH)
      MINJ=KKMIN(JSH)
      MAXJ=KKMAX(JSH)
      NUMJ=MAXJ-MINJ+1
      LOCJ=KLOC(JSH)-MINJ
      SPJ=LJT.EQ.2.AND.MINJ.EQ.1
      SPIJ=SPI.OR.SPJ
      EXPNDI=LIT.GE.LJT
!     ----- KSHELL -----
      LKT=KTYPE(KSH)
      MINK=KKMIN(KSH)
      MAXK=KKMAX(KSH)
      NUMK=MAXK-MINK+1
      LOCK=KLOC(KSH)-MINK
      SPK=LKT.EQ.2.AND.MINK.EQ.1
!     ----- LSHELL -----
      LLTT=KTYPE(LSH)
      MINL=KKMIN(LSH)
      MAXL=KKMAX(LSH)
      NUML=MAXL-MINL+1
      LOCL=KLOC(LSH)-MINL
      SPL=LLTT.EQ.2.AND.MINL.EQ.1
      SPKL=SPK.OR.SPL
      SPIJKL=SPIJ.OR.SPKL
      EXPNDK=LKT.GE.LLTT
!-----------------------------------------------------------------------
      RETURN
      END

! JKDNDXNOF
      SUBROUTINE JKDNDXNOF(LIT,LJT,LKT,LLTT,NUMJ,NUMK,NUML,             &
                        SKIPI,SKIPJ,SKIPK,SKIPL,MINI,MAXI,       &
                        MINJ,MAXJ,MINK,MAXK,MINL,MAXL,NROOTS,    &
                        IGXYZ,JGXYZ,KGXYZ,LGXYZ,                 &
                        IIEQJJ,KKEQLL,IJEQKL,IJKLG,MAXNUM,       &
                        IDER,JDER,KDER,LDER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(4,MAXNUM)::IJKLG
      INTEGER,INTENT(IN)::LIT,LJT,LKT,LLTT,NUMJ,NUMK,NUML
      INTEGER,INTENT(IN)::MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL
      INTEGER,INTENT(OUT)::NROOTS,IDER,JDER,KDER,LDER
      INTEGER,DIMENSION(4,35),INTENT(OUT)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      LOGICAL,INTENT(IN)::SKIPI,SKIPJ,SKIPK,SKIPL
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      INTEGER,DIMENSION(35)::IJKLX,IJKLY,IJKLZ
      INTEGER,DIMENSION(5)::IJKLN
      DATA IJKLN /   1,  4, 10, 20, 35/
      DATA IJKLX /   0,  1,  0,  0,  2,  0,  0,  1,  1,  0,      &
                     3,  0,  0,  2,  2,  1,  0,  1,  0,  1,      &
                     4,  0,  0,  3,  3,  1,  0,  1,  0,  2,      &
                     2,  0,  2,  1,  1/
      DATA IJKLY /   0,  0,  1,  0,  0,  2,  0,  1,  0,  1,      &
                     0,  3,  0,  1,  0,  2,  2,  0,  1,  1,      &
                     0,  4,  0,  1,  0,  3,  3,  0,  1,  2,      &
                     0,  2,  1,  2,  1/
      DATA IJKLZ /   0,  0,  0,  1,  0,  0,  2,  0,  1,  1,      &
                     0,  0,  3,  0,  1,  0,  1,  2,  2,  1,      &
                     0,  0,  4,  0,  1,  0,  1,  3,  3,  0,      &
                     2,  2,  1,  1,  2/
!-----------------------------------------------------------------------
      IDER=1
      JDER=1
      KDER=1
      LDER=1
      IF(SKIPI) IDER=0
      IF(SKIPJ) JDER=0
      IF(SKIPK) KDER=0
      IF(SKIPL) LDER=0
      LJTMOD=LJT + JDER
      LKTMOD=LKT + KDER
      LLTMOD=LLTT + LDER
!     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS -----
      NI=NUML*NUMK*NUMJ
      DO I=MINI,MAXI
        IGXYZ(1,I)=NI*(I-MINI)+1
      ENDDO
      LLKJT=LLTMOD*LKTMOD*LJTMOD
      DO I=1,IJKLN(LIT)
        IGXYZ(2,I)=IJKLX(I)*LLKJT+1
        IGXYZ(3,I)=IJKLY(I)*LLKJT+1
        IGXYZ(4,I)=IJKLZ(I)*LLKJT+1
      ENDDO
      NJ=NUML*NUMK
      DO J=MINJ,MAXJ
        JGXYZ(1,J)=NJ*(J-MINJ)
      ENDDO
      LLKT=LLTMOD*LKTMOD
      DO J=1,IJKLN(LJT)
        JGXYZ(2,J)=IJKLX(J)*LLKT
        JGXYZ(3,J)=IJKLY(J)*LLKT
        JGXYZ(4,J)=IJKLZ(J)*LLKT
      ENDDO
!     ----- PREPARE INDICES FOR PAIRS OF (K,L) FUNCTIONS -----
      NK=NUML
      DO K=MINK,MAXK
        KGXYZ(1,K)=NK*(K-MINK)
      ENDDO
      DO K=1,IJKLN(LKT)
        KGXYZ(2,K)=IJKLX(K)*LLTMOD
        KGXYZ(3,K)=IJKLY(K)*LLTMOD
        KGXYZ(4,K)=IJKLZ(K)*LLTMOD
      ENDDO
      NL=1
      DO L=MINL,MAXL
         LGXYZ(1,L)=NL*(L-MINL)
      ENDDO
      DO L=1,IJKLN(LLTT)
         LGXYZ(2,L)=IJKLX(L)
         LGXYZ(3,L)=IJKLY(L)
         LGXYZ(4,L)=IJKLZ(L)
      ENDDO
!     ----- PREPARE INDICES FOR (IJ/KL) -----
      IJKL=0
      DO I=MINI,MAXI
        JMAX=MAXJ
        IF(IIEQJJ) JMAX=I
        DO J=MINJ,JMAX
          KMAX=MAXK
          IF(IJEQKL) KMAX=I
          DO K=MINK,KMAX
            LMAX=MAXL
            IF(KKEQLL           ) LMAX=K
            IF(IJEQKL.AND.K.EQ.I) LMAX=J
            DO L=MINL,LMAX
              IJKL=IJKL+1
              NN=((IGXYZ(1,I)+JGXYZ(1,J))+KGXYZ(1,K))+LGXYZ(1,L)
              NX=((IGXYZ(2,I)+JGXYZ(2,J))+KGXYZ(2,K))+LGXYZ(2,L)
              NY=((IGXYZ(3,I)+JGXYZ(3,J))+KGXYZ(3,K))+LGXYZ(3,L)
              NZ=((IGXYZ(4,I)+JGXYZ(4,J))+KGXYZ(4,K))+LGXYZ(4,L)
              IJKLG(1,IJKL)=   NN
              IJKLG(2,IJKL)=3*(NX-1)+1
              IJKLG(3,IJKL)=3*(NY-1)+2
              IJKLG(4,IJKL)=3*(NZ-1)+3
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!     ----- SET NUMBER OF QUADRATURE POINTS -----
      NROOTS=(LIT+LJT+LKT+LLTT-2 + 1 )/2
!-----------------------------------------------------------------------
      RETURN
      END

! JKDSPDNOF
      SUBROUTINE JKDSPDNOF(TOTCOUNT,GINT,FINT,DAB,DCHRG,NIJGDIM,        &
                           MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,     &
                           IIEQJJ,KKEQLL,IJEQKL,EXPNDI,EXPNDK,          &
                           SKIPI,SKIPJ,SKIPK,SKIPL,SPI,SPJ,SPK,SPL,     &
                           SPIJKL,IJKLG,MAXNUM,INVTYP,NROOTS,MINVEC,    &
                           MODTYP,MAXXYZ,NKL,NIJ,IIAT,JJAT,KKAT,LLAT,   &
                           GRADS,DABMAX,DABCUT,NKL0,NIJ0,               &
                           LIT,LJT,LKT,LLTT,IDER,JDER,KDER,LDER)          
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::MAXNUM
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(IN)::DAB
      DOUBLE PRECISION,DIMENSION(15,NIJGDIM),INTENT(IN)::DCHRG
      DOUBLE PRECISION,INTENT(IN)::DABMAX,DABCUT
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL,EXPNDI,EXPNDK
      LOGICAL,INTENT(IN)::SKIPI,SKIPJ,SKIPK,SKIPL,SPI,SPJ,SPK,SPL,SPIJKL
      INTEGER,INTENT(IN)::MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL
      INTEGER,INTENT(IN)::INVTYP,NKL,NIJ,MAXXYZ,IIAT,JJAT,KKAT,LLAT
      INTEGER,INTENT(IN)::NKL0,NIJ0
      INTEGER,INTENT(IN)::LIT,LJT,LKT,LLTT,IDER,JDER,KDER,LDER
      INTEGER,INTENT(IN)::NROOTS,MINVEC
      INTEGER,INTENT(INOUT)::TOTCOUNT
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::GRADS
      DOUBLE PRECISION,DIMENSION(12)::FD
      DOUBLE PRECISION::XC,YC,ZC,DXIJ,DYIJ,DZIJ
      INTEGER,DIMENSION(4,MAXNUM),INTENT(IN)::IJKLG
!      
      LOGICAL::NMAXS,NMAXP,MMAXS,MMAXP
      INTEGER::NIMAX,NJMAX,NKMAX,NLMAX,NMAX,MMAX
!     ZERO AND FIRST DERIVATIVE INTEGRALS      
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(INOUT)::GINT,FINT
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::GNM,GNKL,GIJKL,FI,FJ,FK,FL,DIJ,DKL
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::AAI,AAJ,BBK,BBL,DIJSI,DKLSK,DKLSL,DIJSJ
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::C00,D00,F00,B00,B01,B10,RWV,ABV,CV
!
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,PI252=34.986836655250D+00
      LOGICAL::FIRST,LAST
!-----------------------------------------------------------------------            
      ALLOCATE(GNM((MODTYP+MODTYP-1)*(MODTYP+MODTYP-1)*MAXXYZ*3))
      ALLOCATE(GNKL(MODTYP**2*(MODTYP+MODTYP-1)*MAXXYZ*3))
      ALLOCATE(GIJKL(MODTYP**2*MODTYP**2*MAXXYZ*3))
      ALLOCATE(FI(MODTYP**2*MODTYP**2*MAXXYZ*3),FJ(MODTYP**2*MODTYP**2*MAXXYZ*3))
      ALLOCATE(FK(MODTYP**2*MODTYP**2*MAXXYZ*3),FL(MODTYP**2*MODTYP**2*MAXXYZ*3))
      ALLOCATE(DIJ((MODTYP**2)*MAXXYZ*3),DKL((MODTYP+MODTYP-1)*MAXXYZ*3))
      ALLOCATE(AAI(MAXXYZ*3),AAJ(MAXXYZ*3),BBK(MAXXYZ*3),BBL(MAXXYZ*3))
      ALLOCATE(DIJSI(MAXXYZ),DKLSK(MAXXYZ),DKLSL(MAXXYZ),DIJSJ(MAXXYZ))
      ALLOCATE(C00(MAXXYZ,3),D00(MAXXYZ,3),F00(MAXXYZ,3),RWV(2,MAXXYZ),ABV(5,MAXXYZ),CV(18,MAXXYZ))
      ALLOCATE(B00((MODTYP+MODTYP-1)*MAXXYZ,3),B01((MODTYP+MODTYP-1)*MAXXYZ,3),B10((MODTYP+MODTYP-1)*MAXXYZ,3))      
!     
      NIMAX=LIT + IDER
      NJMAX=LJT + JDER
      NKMAX=LKT + KDER
      NLMAX=LLTT + LDER
      NMAX=LIT+LJT-1 + MIN0(IDER+JDER,1)
      MMAX=LKT+LLTT-1 + MIN0(KDER+LDER,1)
      NMAXS=NMAX.EQ.1
      NMAXP=NMAX.LE.2
      MMAXS=MMAX.EQ.1
      MMAXP=MMAX.LE.2
!
      DTOL=(10.0D+00)**(-20)
      DTOL=DTOL*DTOL
      Q4=PI252
      MAXG=MAXXYZ/NROOTS      
!
!     ----- PAIR OF K,L PRIMITIVES -----
!      
      FIRST=.TRUE.
      NG=0
      KLG=0
  100  KLG=KLG+1
       IF(KLG.GT.NKL) GO TO 300
       DB=DCHRG( 1,KLG+NKL0)
       BB=DCHRG( 2,KLG+NKL0)
       XB=DCHRG( 3,KLG+NKL0)
       YB=DCHRG( 4,KLG+NKL0)
       ZB=DCHRG( 5,KLG+NKL0)
       XD=DCHRG( 6,KLG+NKL0)
       YD=DCHRG( 7,KLG+NKL0)
       ZD=DCHRG( 8,KLG+NKL0)
       DXKL=DCHRG( 9,KLG+NKL0)
       DYKL=DCHRG(10,KLG+NKL0)
       DZKL=DCHRG(11,KLG+NKL0)
       Q4DB=Q4*DB
!
!     ----- PAIR OF I,J PRIMITIVES -----
!       
       IJG=0
  200  IJG=IJG+1
       IF(IJG.GT.NIJ) GO TO 100
       DA=DCHRG( 1,IJG+NIJ0)
       AA=DCHRG( 2,IJG+NIJ0)
       XA=DCHRG( 3,IJG+NIJ0)
       YA=DCHRG( 4,IJG+NIJ0)
       ZA=DCHRG( 5,IJG+NIJ0)
       Q4DBDA=Q4DB*DA
       AANDB1=(1.0D+00)/(AA+BB)        
       DUM=Q4DBDA*Q4DBDA*AANDB1
       IF(DUM.LE.DTOL) GO TO 200
       Q4DBDA=Q4DBDA*SQRT(AANDB1)
       IF(ABS(Q4DBDA*DABMAX).LT.DABCUT) GO TO 200
       RHO   =AA*BB*AANDB1
       XX=RHO*((XA-XB)**2+(YA-YB)**2+(ZA-ZB)**2)
!
       NG=NG+1
       ABV(1,NG)=AA
       ABV(2,NG)=BB
       ABV(3,NG)=RHO
       ABV(4,NG)=Q4DBDA
       ABV(5,NG)=XX
!
       XC=DCHRG( 6,IJG+NIJ0)
       YC=DCHRG( 7,IJG+NIJ0)
       ZC=DCHRG( 8,IJG+NIJ0)
       DXIJ=DCHRG( 9,IJG+NIJ0)
       DYIJ=DCHRG(10,IJG+NIJ0)
       DZIJ=DCHRG(11,IJG+NIJ0)
!
       AAI(NG)=DCHRG(12,IJG+NIJ0)
       AAJ(NG)=DCHRG(13,IJG+NIJ0)
       BBK(NG)=DCHRG(12,KLG+NKL0)
       BBL(NG)=DCHRG(13,KLG+NKL0)        
!
       IF(.NOT.MMAXS) THEN
        CV( 1,NG)=AA*(XA-XD)
        CV( 2,NG)=BB*(XB-XD)
        CV( 3,NG)=AA*(YA-YD)
        CV( 4,NG)=BB*(YB-YD)
        CV( 5,NG)=AA*(ZA-ZD)
        CV( 6,NG)=BB*(ZB-ZD)
       ENDIF
       IF(.NOT.NMAXS) THEN
        CV( 7,NG)=AA*(XA-XC)
        CV( 8,NG)=BB*(XB-XC)
        CV( 9,NG)=AA*(YA-YC)
        CV(10,NG)=BB*(YB-YC)
        CV(11,NG)=AA*(ZA-ZC)
        CV(12,NG)=BB*(ZB-ZC)
       ENDIF
       CV(13,NG)=DXIJ
       CV(14,NG)=DYIJ
       CV(15,NG)=DZIJ
       CV(16,NG)=DXKL
       CV(17,NG)=DYKL
       CV(18,NG)=DZKL
       IF(SPI) DIJSI(NG)=DCHRG(14,IJG+NIJ0)
       IF(SPJ) DIJSJ(NG)=DCHRG(15,IJG+NIJ0)
       IF(SPK) DKLSK(NG)=DCHRG(14,KLG+NKL0)
       IF(SPL) DKLSL(NG)=DCHRG(15,KLG+NKL0)        
!
       IF(NG.LT.MAXG) GO TO 200
       LAST=.FALSE.
       GO TO 310
!       
  300  CONTINUE
       LAST=.TRUE.
  310  CONTINUE
       NUMG=NG
       IF(NUMG.EQ.0) GO TO 998
!       
       IF(NROOTS.EQ.1) GO TO 480
       IF (SPI) THEN
           DO IROOT=2,NROOTS
           DO IG=1,NUMG
               DIJSI(IG+NUMG*(IROOT-1))=DIJSI(IG)
           ENDDO
           ENDDO
       ENDIF
       IF (SPJ) THEN
          DO IROOT=2,NROOTS
          DO IG=1,NUMG
             DIJSJ(IG+NUMG*(IROOT-1))=DIJSJ(IG)
          ENDDO
          ENDDO
       ENDIF
       IF (SPK) THEN
          DO IROOT=2,NROOTS
          DO IG=1,NUMG
             DKLSK(IG+NUMG*(IROOT-1))=DKLSK(IG)
          ENDDO
          ENDDO
       ENDIF
       IF (SPL) THEN
          DO IROOT=2,NROOTS
          DO IG=1,NUMG
             DKLSL(IG+NUMG*(IROOT-1))=DKLSL(IG)
          ENDDO
          ENDDO
       ENDIF      
!
  480 IF(.NOT.SKIPI) THEN
       DO IRXYZ=2,NROOTS*3
       DO IG=1,NUMG
       AAI(IG+NUMG*(IRXYZ-1))=AAI(IG)
       ENDDO
       ENDDO
      ENDIF
      IF(.NOT.SKIPJ) THEN
       DO IRXYZ=2,NROOTS*3
       DO IG=1,NUMG
       AAJ(IG+NUMG*(IRXYZ-1))=AAJ(IG)
       ENDDO
       ENDDO
      ENDIF
      IF(.NOT.SKIPK) THEN
       DO IRXYZ=2,NROOTS*3
       DO IG=1,NUMG
       BBK(IG+NUMG*(IRXYZ-1))=BBK(IG)
       ENDDO
       ENDDO
      ENDIF
      IF(.NOT.SKIPL) THEN
       DO IRXYZ=2,NROOTS*3
       DO IG=1,NUMG
       BBL(IG+NUMG*(IRXYZ-1))=BBL(IG)
       ENDDO
       ENDDO
      ENDIF
!
!     ----- COMPUTE ROOTS AND WEIGHTS FOR QUADRATURE -----
!
      CALL JKWRYSNOF(RWV,ABV,NUMG,NROOTS,NKL,NIJ)
!
!     ----- COMPUTE COEFFICIENTS FOR RECURSION FORMULAE -----
!
      CALL JKBCDFNOF(B00,B01,B10,C00,D00,F00,DIJ,DKL,                   &
                     ABV,CV,RWV,NUMG,NROOTS,NKL,NIJ,                    &
                     NMAXS,MMAXS)
!
!     ----- COMPUTE -X- , -Y- , -Z- INTEGRALS ( 2 CENTERS, 2-D ) -----
!
      IF(NUMG*NROOTS*3.LT.MINVEC) THEN
         CALL JKGNMSNOF(GNM,NUMG*NROOTS*3,NMAX,MMAX,                    &
                        B00,B01,B10,C00,D00,F00,                        &
                        NMAXS,NMAXP,MMAXS,MMAXP)
      ELSE
         WRITE(6,*) 'SCALAR MACHINES SHOULD NOT CALL -JKGNMV-'
         WRITE(6,*) 'ERROR IN SUBROUTINE JKDSPD'
         STOP
      END IF
!
!     ----- COMPUTE -X- , -Y- , -Z- INTEGRALS ( 4 CENTERS, 2-D ) -----
!
      IF(NUMG*NROOTS*3.LT.MINVEC) THEN
         CALL JKXYZSNOF(GIJKL,GIJKL,GNKL,GNKL,GNKL,GNM,                 &
                        NUMG*NROOTS*3,NMAX,MMAX,NIMAX,NJMAX,            &
                        NKMAX,NLMAX,DIJ,DKL,EXPNDI,EXPNDK)
      ELSE
         WRITE(6,*) 'SCALAR MACHINES SHOULD NOT CALL -JKXYZV-'
         WRITE(6,*) 'ERROR IN SUBROUTINE JKDSPD'
         STOP
      END IF
!
!     ----- COMPUTE -X- , -Y- , -Z- INTEGRALS FOR DERIVATIVES -----
!
      IF(NUMG*NROOTS*3.LT.MINVEC) THEN
         CALL JDXYZSNOF(GIJKL,GIJKL,GIJKL,GIJKL,                        &
                        NUMG*NROOTS*3,NIMAX,NJMAX,NKMAX,NLMAX,          &
                        LIT,LJT,LKT,LLTT,AAI,AAJ,BBK,BBL,FI,FJ,FK,FL,   &
                        SKIPI,SKIPJ,SKIPK,SKIPL) 
      ELSE
         WRITE(6,*) 'SCALAR MACHINES SHOULD NOT CALL -JDXYZV-'
         WRITE(6,*) 'ERROR IN SUBROUTINE JKDSPD'
         STOP
      END IF      
!        
!       ZERO OUT FIRST TIME AROUND 
        IF(FIRST) THEN
         FD=ZERO
         FIRST=.FALSE.
        ENDIF
!
!     ----- COMPUTE DERIVATIVE INTEGRALS -----
!
      IF(NUMG*NROOTS.LT.MINVEC) THEN
       IGIJKL=MODTYP**2*MODTYP**2*MAXXYZ*3
       CALL DSPDFSNOF(TOTCOUNT,NUMG,NROOTS,IJKLG,GINT,FINT,GIJKL,       &
                      FI,FJ,FK,FL,DIJSI,DIJSJ,DKLSK,DKLSL,              &
                      DAB,SKIPI,SKIPJ,SKIPK,SKIPL,                      &
                      MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          &
                      MAXNUM,MAXXYZ,IIEQJJ,KKEQLL,IJEQKL,               &
                      SPI,SPJ,SPK,SPL,SPIJKL,FD,IGIJKL)
      ELSE
         WRITE(6,*) 'SCALAR MACHINES SHOULD NOT CALL -DSPDFV-'
         WRITE(6,*) 'ERROR IN SUBROUTINE JKDSPD'
         STOP
      END IF
!
      IF(LAST) GO TO 998
      NG=0  
      GO TO 200
  998 CONTINUE
      IF(NUMG.EQ.0.AND.FIRST) RETURN
!      
!     ADD TO THE GRADIENT VECTOR ACCORDING TO SYMMETRY(INVTYP)
!
      CALL JKDINVNOF(INVTYP,FD,GRADS,IIAT,JJAT,KKAT,LLAT)
      DEALLOCATE(GNM,GNKL,GIJKL,FI,FJ,FK,FL,DIJ,DKL)
      DEALLOCATE(AAI,AAJ,BBK,BBL,DIJSI,DKLSK,DKLSL,DIJSJ)
      DEALLOCATE(C00,D00,F00,B00,B01,B10,RWV,ABV,CV)
!-----------------------------------------------------------------------
      RETURN
      END

! JKDINVNOF
      SUBROUTINE JKDINVNOF(INVTYP,FD,GRADS,II,JJ,KK,LL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::INVTYP,II,JJ,KK,LL
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::GRADS
      DOUBLE PRECISION,DIMENSION(3,4)::FD
!     ----- TRANSLATIONAL INVARIANCE FOR GRADIENT ELEMENTS -----
      IF (INVTYP.EQ.2) THEN
        DO IXYZ=1,3
          FD(IXYZ,1)=- FD(IXYZ,4)
        ENDDO
      ELSE IF (INVTYP.EQ.3) THEN
        DO IXYZ=1,3
          FD(IXYZ,1)=- FD(IXYZ,3)
        ENDDO
      ELSE IF (INVTYP.EQ.4.OR.INVTYP.EQ.5) THEN
        DO IXYZ=1,3
          FD(IXYZ,1)=-(FD(IXYZ,3)+FD(IXYZ,4))
        ENDDO
      ELSE IF (INVTYP.EQ.6) THEN
        DO IXYZ=1,3
          FD(IXYZ,1)=- FD(IXYZ,2)
        ENDDO
      ELSE IF (INVTYP.EQ.7) THEN
        DO IXYZ=1,3
          FD(IXYZ,1)=-(FD(IXYZ,2)+FD(IXYZ,4))
        ENDDO
      ELSE IF (INVTYP.EQ.8) THEN
        DO IXYZ=1,3
          FD(IXYZ,1)=-(FD(IXYZ,2)+FD(IXYZ,4))
        ENDDO
      ELSE IF (INVTYP.EQ.9.OR.INVTYP.EQ.10) THEN
        DO IXYZ=1,3
          FD(IXYZ,1)=-(FD(IXYZ,2)+FD(IXYZ,3))
        ENDDO
      ELSE IF (INVTYP.EQ.11) THEN
        DO IXYZ=1,3
          FD(IXYZ,2)=- FD(IXYZ,1)
        ENDDO
      ELSE IF (INVTYP.EQ.12) THEN
        DO IXYZ=1,3
          FD(IXYZ,2)=-(FD(IXYZ,1)+FD(IXYZ,4))
        ENDDO
      ELSE IF (INVTYP.EQ.13) THEN
        DO IXYZ=1,3
          FD(IXYZ,2)=-(FD(IXYZ,1)+FD(IXYZ,3))
        ENDDO
      ELSE IF (INVTYP.EQ.14) THEN
        DO IXYZ=1,3
          FD(IXYZ,3)=-(FD(IXYZ,1)+FD(IXYZ,2))
        ENDDO
      ELSE IF (INVTYP.EQ.15) THEN
        DO IXYZ=1,3
          FD(IXYZ,4)=-(FD(IXYZ,1)+FD(IXYZ,2)+FD(IXYZ,3))
        ENDDO
      ENDIF
      DO IXYZ=1,3
        GRADS(IXYZ,II)=GRADS(IXYZ,II)+FD(IXYZ,1)
        GRADS(IXYZ,JJ)=GRADS(IXYZ,JJ)+FD(IXYZ,2)
        GRADS(IXYZ,KK)=GRADS(IXYZ,KK)+FD(IXYZ,3)
        GRADS(IXYZ,LL)=GRADS(IXYZ,LL)+FD(IXYZ,4)
      ENDDO   
!-----------------------------------------------------------------------
      RETURN
      END

! DABCLUNOF
      SUBROUTINE DABCLUNOF(II,JJ,KK,LL,PNRM,KKMIN,KKMAX,KLOC,IGXYZ,     &
                           JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,      &
                           IA,DA,DAB,MAXNUM,DABMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::II,JJ,KK,LL
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(4,35),INTENT(IN)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(NBF),INTENT(IN)::IA
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      DOUBLE PRECISION,DIMENSION(NBFT),INTENT(IN)::DA  
      DOUBLE PRECISION,INTENT(OUT)::DABMAX
      DOUBLE PRECISION,DIMENSION(84),INTENT(IN)::PNRM
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(OUT)::DAB
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00,PT5=0.5D+00,F04=4.0D+00
!-----------------------------------------------------------------------
      DABMAX=ZER
!      
      MINI= KKMIN(II)
      MINJ= KKMIN(JJ)
      MINK= KKMIN(KK)
      MINL= KKMIN(LL)
      LOCI= KLOC(II)-MINI
      LOCJ= KLOC(JJ)-MINJ
      LOCK= KLOC(KK)-MINK
      LOCL= KLOC(LL)-MINL
      MAXI= KKMAX(II)
      MAXJ= KKMAX(JJ)
      MAXK= KKMAX(KK)
      MAXL= KKMAX(LL)
         DO I=MINI,MAXI
            P1I = PNRM(I)
            JMAX= MAXJ
            IF(IIEQJJ) JMAX= I
            DO J=MINJ,JMAX
               P2J = P1I*PNRM(J)
               IAJ= MAX0(LOCI+I,LOCJ+J)
               IIJ= MIN0(LOCI+I,LOCJ+J)
               KMMAX=MAXK
               IF(IJEQKL) KMMAX= I
               DO K=MINK,KMMAX
                  P3K = P2J*PNRM(K)
                  LMAX= MAXL
                  IF(KKEQLL) LMAX= K
                  IF(IJEQKL .AND. K.EQ.I) LMAX= J
                  DO L=MINL,LMAX
                     P4L= P3K*PNRM(L)
                     KAL= MAX0(LOCK+K,LOCL+L)
                     KIL= MIN0(LOCK+K,LOCL+L)
                     IN = IAJ
                     JN = IIJ
                     KN = KAL
                     LN = KIL
                     IF(IN.LT.KN .OR.(IN.EQ.KN .AND. JN.LT.LN)) THEN
                        IN = KAL
                        JN = KIL
                        KN = IAJ
                        LN = IIJ
                     ENDIF
                     IJ = IA(IN)+JN
                     IK = IA(IN)+KN
                     IL = IA(IN)+LN
                     JK = IA(MAX0(JN,KN))+MIN0(JN,KN)
                     JL = IA(JN)+LN
                     IF(JN.LT.KN) JL = IA(MAX0(JN,LN))+MIN0(JN,LN)
                     KL = IA(KN)+LN
! THE DENSITY IS BUILT ACCORDING TO THE PAPER OF DUPUIS (1978)                     
                     DF1= DA(IJ)*DA(KL)
                     DQ1= DA(IK)*DA(JL)+DA(IL)*DA(JK)
                     DF1= DF1*F04-DQ1
! AVOID DOUBLE COUNTING OF DIAGONAL TERMS NOT DONE IN SQUARETRIAN2                     
                     IF(JN.EQ.IN               ) DF1= DF1*PT5
                     IF(LN.EQ.KN               ) DF1= DF1*PT5
                     IF(KN.EQ.IN .AND. LN.EQ.JN) DF1= DF1*PT5
                     IF(DABMAX.LT. ABS(DF1)) DABMAX= ABS(DF1)
! IGXYZ AND J, K, AND L ARE SET UP IN JKDNDX
                     IJKL=IGXYZ(1,I)+JGXYZ(1,J)+KGXYZ(1,K)+LGXYZ(1,L)
                     DAB(IJKL)= DF1*P4L
                  ENDDO
               ENDDO
            ENDDO
         ENDDO   
!-----------------------------------------------------------------------
      RETURN
      END

! VNNDERNOF
      SUBROUTINE VNNDERNOF(CX0,CY0,CZ0,ZNUC,DE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0,ZNUC
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::DE
      DOUBLE PRECISION,DIMENSION(3,NATOMS)::C
      DOUBLE PRECISION,DIMENSION(NATOMS,NATOMS)::DRG
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
!      
      C(1,:)=CX0
      C(2,:)=CY0
      C(3,:)=CZ0
!
!     ----- FORM DISTANCE MATRIX -----
!
      DRG(1,1) = ZERO
      DO K = 2,NATOMS
         DRG(K,K) = ZERO
         K1 = K-1
         DO L = 1,K1
            RKL = ZERO
            DO I = 1,3
               RKL = RKL+(C(I,K)-C(I,L))**2
            ENDDO
            DRG(K,L) = -ONE/RKL
            DRG(L,K) = SQRT(RKL)
         ENDDO
      ENDDO
!
!     ----- NUCLEAR REPULSION CONTRIBUTION TO GRADIENT -----
!
      DO KK = 1,3
         DO K = 2,NATOMS
            ZAK = ZNUC(K)
            KM1 = K-1
            DO L = 1,KM1
               ZAL = ZNUC(L)
               PKL = (C(KK,K)-C(KK,L))/DRG(L,K)
               DE(KK,K) = DE(KK,K)+PKL*DRG(K,L)*ZAK*ZAL
            ENDDO
         ENDDO
!
         NAT1 = NATOMS-1
         DO K = 1,NAT1
            ZAK = ZNUC(K)
            KP1 = K+1
            DO L = KP1,NATOMS
               ZAL = ZNUC(L)
               PKL = (C(KK,K)-C(KK,L))/DRG(K,L)
               DE(KK,K) = DE(KK,K)+PKL*DRG(L,K)*ZAK*ZAL
            ENDDO
         ENDDO
      ENDDO
!-----------------------------------------------------------------------  
      RETURN
      END

! SDERNOF
      SUBROUTINE SDERNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,       &
                      CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,EPS,DE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION(NBFT),INTENT(IN)::EPS
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::DE
!      
      INTEGER,DIMENSION(NBF)::IA
      INTEGER,DIMENSION(35)::IJX,IJY,IJZ
      DOUBLE PRECISION,DIMENSION(5,5)::DXS,DYS,DZS
      DOUBLE PRECISION,DIMENSION(6,5)::XS,YS,ZS
      DOUBLE PRECISION,DIMENSION(225)::DIJ
      DOUBLE PRECISION::TOL
!
      DOUBLE PRECISION,PARAMETER::SQRT3=1.73205080756888D+00
      DOUBLE PRECISION,PARAMETER::SQRT5=2.23606797749979D+00
      DOUBLE PRECISION,PARAMETER::SQRT7=2.64575131106459D+00
      DOUBLE PRECISION,PARAMETER::ONE=1.0D+00,RLN10=2.30258D+00
!
      DATA IJX / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,                          &
                 4, 1, 1, 3, 3, 2, 1, 2, 1, 2,                          &
                 5, 1, 1, 4, 4, 2, 1, 2, 1, 3,                          &
                 3, 1, 3, 2, 2/                                         
      DATA IJY / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,                          &
                 1, 4, 1, 2, 1, 3, 3, 1, 2, 2,                          &
                 1, 5, 1, 2, 1, 4, 4, 1, 2, 3,                          &
                 1, 3, 2, 3, 2/                                         
      DATA IJZ / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,                          &
                 1, 1, 4, 1, 2, 1, 2, 3, 3, 2,                          &
                 1, 1, 5, 1, 2, 1, 2, 4, 4, 1,                          &
                 3, 3, 2, 2, 3/      
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
      TOL = RLN10*20
!
!     ----- I SHELL
!
      DO II = 1,NSHELL
!
      IAT = KATOM(II)
      XI = CX0(IAT)
      YI = CY0(IAT)
      ZI = CZ0(IAT)
      I1 = KSTART(II)
      I2 = I1+KNG(II)-1
      LIT = KTYPE(II)
      MINI = KKMIN(II)
      MAXI = KKMAX(II)
      LOCI = KLOC(II)-MINI
      LITDER = LIT+1     
!
!     ----- J SHELL
!
      DO JJ = 1,II
!
      JAT = KATOM(JJ)
      XJ = CX0(JAT)
      YJ = CY0(JAT)
      ZJ = CZ0(JAT)
      J1 = KSTART(JJ)
      J2 = J1+KNG(JJ)-1
      LJT = KTYPE(JJ)
      MINJ = KKMIN(JJ)
      MAXJ = KKMAX(JJ)
      LOCJ = KLOC(JJ)-MINJ
      RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
      IF(II.EQ.JJ) CYCLE
!
!     ----- I PRIMITIVE
!
      DO IG = I1,I2
        AI = EX1(IG)
        ARRI = AI*RR
        AXI = AI*XI
        AYI = AI*YI
        AZI = AI*ZI
        CSI=CS(IG)
        CPI=CP(IG)
        CDI=CD(IG)
        CFI=CF(IG)
        CGI=CG(IG)
!
!     ----- J PRIMITIVE
!
        DO JG = J1,J2
          AJ = EX1(JG)
          AA = AI+AJ
          AA1 = ONE/AA
          DUM = AJ*ARRI*AA1
          IF(DUM .GT. TOL) CYCLE
          FAC = EXP(-DUM)
          CSJ = CS(JG)
          CPJ = CP(JG)
          CDJ = CD(JG)
          CFJ = CF(JG)
          CGJ = CG(JG)
          AX = (AXI+AJ*XJ)*AA1
          AY = (AYI+AJ*YJ)*AA1
          AZ = (AZI+AJ*ZJ)*AA1      
!
!     ----- DENSITY FACTOR
!
          IJ = 0
          DO I = MINI,MAXI
            IF(I.EQ.1) DUM1=CSI*FAC
            IF(I.EQ.2) DUM1=CPI*FAC
            IF(I.EQ.5) DUM1=CDI*FAC
            IF(I.EQ.8) DUM1=DUM1*SQRT3
            IF(I.EQ.11) DUM1=CFI*FAC
            IF(I.EQ.14) DUM1=DUM1*SQRT5
            IF(I.EQ.20) DUM1=DUM1*SQRT3
            IF(I.EQ.21) DUM1=CGI*FAC
            IF(I.EQ.24) DUM1=DUM1*SQRT7
            IF(I.EQ.30) DUM1=DUM1*SQRT5/SQRT3
            IF(I.EQ.33) DUM1=DUM1*SQRT3
            DO J = MINJ,MAXJ
              IF(J.EQ.1) DUM2=DUM1*CSJ
              IF(J.EQ.2) DUM2=DUM1*CPJ
              IF(J.EQ.5) DUM2=DUM1*CDJ
              IF(J.EQ.8) DUM2=DUM2*SQRT3
              IF(J.EQ.11) DUM2=DUM1*CFJ
              IF(J.EQ.14) DUM2=DUM2*SQRT5
              IF(J.EQ.20) DUM2=DUM2*SQRT3
              IF(J.EQ.21) DUM2=DUM1*CGJ
              IF(J.EQ.24) DUM2=DUM2*SQRT7
              IF(J.EQ.30) DUM2=DUM2*SQRT5/SQRT3
              IF(J.EQ.33) DUM2=DUM2*SQRT3
              IJ=IJ+1
              NN=IA(LOCI+I)+(LOCJ+J)
              DEN = EPS(NN)
              DIJ(IJ) = DUM2*DEN
            ENDDO
          ENDDO
!
!     ----- OVERLAP
!
      T = SQRT(AA1)
      X0 = AX
      Y0 = AY
      Z0 = AZ
      DO J = 1,LJT
        NJ = J
        DO I = 1,LITDER
          NI = I
          CALL VINTNOF(NI,NJ,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ &
                        ,XINT,YINT,ZINT)
          XS(I,J)=XINT*T
          YS(I,J)=YINT*T
          ZS(I,J)=ZINT*T
        ENDDO
      ENDDO
!
      CALL DERINOF(DXS,DYS,DZS,XS,YS,ZS,LIT,LJT,AI)
!
      IJ=0
      DO I=MINI,MAXI
        IX=IJX(I)
        IY=IJY(I)
        IZ=IJZ(I)
        DO J=MINJ,MAXJ
          JX=IJX(J)
          JY=IJY(J)
          JZ=IJZ(J)
          DUMX=DXS(IX,JX)* YS(IY,JY)* ZS(IZ,JZ)
          DUMY= XS(IX,JX)*DYS(IY,JY)* ZS(IZ,JZ)
          DUMZ= XS(IX,JX)* YS(IY,JY)*DZS(IZ,JZ)
          IJ=IJ+1
          DE(1,IAT)=DE(1,IAT)+(DUMX*DIJ(IJ))
          DE(2,IAT)=DE(2,IAT)+(DUMY*DIJ(IJ))
          DE(3,IAT)=DE(3,IAT)+(DUMZ*DIJ(IJ))
          DE(1,JAT)=DE(1,JAT)-(DUMX*DIJ(IJ))
          DE(2,JAT)=DE(2,JAT)-(DUMY*DIJ(IJ))
          DE(3,JAT)=DE(3,JAT)-(DUMZ*DIJ(IJ))
        ENDDO
      ENDDO
!
      ENDDO
      ENDDO
!
!     ----- END OF PRIMITIVE LOOPS -----
!
      ENDDO
      ENDDO
!
!     ----- END OF SHELL LOOPS -----
!  
!-----------------------------------------------------------------------      
      RETURN
      END

! HELFEYNOF
      SUBROUTINE HELFEYNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,     &
                           CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,ZAN,PM,DE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0,ZAN
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::PM
      DOUBLE PRECISION,DIMENSION(NBFT)::P
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::DE
!
      LOGICAL::IANDJ,DOUBLETE
      INTEGER::NROOTS
      INTEGER,DIMENSION(NBF)::IA
      INTEGER,DIMENSION(35)::IJX,IJY,IJZ
      DOUBLE PRECISION,DIMENSION(225)::DIJ
      DOUBLE PRECISION,DIMENSION(5,5,5,2)::XIN,YIN,ZIN
      DOUBLE PRECISION,DIMENSION(13)::UROOT,WROOT
      DOUBLE PRECISION::TOL,XX,ZNUCC      
!
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00, ONE=1.0D+00
      DOUBLE PRECISION,PARAMETER::RLN10=2.30258D+00,PI212=1.1283791670955D+00
      DOUBLE PRECISION,PARAMETER::SQRT3=1.73205080756888D+00
      DOUBLE PRECISION,PARAMETER::SQRT5=2.23606797749979D+00
      DOUBLE PRECISION,PARAMETER::SQRT7=2.64575131106459D+00
!
!  THE IJX, IJY, AND IJZ ARRAYS CONTAIN THE POWERS OF THE CARTESIAN
!  GAUSSIANS PLUS 1 IN EVERY PLACE.
!
      DATA IJX/ 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,   &
                4, 1, 1, 3, 3, 2, 1, 2, 1, 2,   &
                5, 1, 1, 4, 4, 2, 1, 2, 1, 3,   &
                3, 1, 3, 2, 2/
      DATA IJY/ 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,   &
                1, 4, 1, 2, 1, 3, 3, 1, 2, 2,   &
                1, 5, 1, 2, 1, 4, 4, 1, 2, 3,   &
                1, 3, 2, 3, 2/
      DATA IJZ/ 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,   &
                1, 1, 4, 1, 2, 1, 2, 3, 3, 2,   &
                1, 1, 5, 1, 2, 1, 2, 4, 4, 1,   &
                3, 3, 2, 2, 3/      
!
!     ----- HELMANN-FEYNMAN GRADIENT TERM -----
!     INTEGRAL TYPE IS <II/H'/JJ> = <II/V'/JJ>
!                     
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
      TOL = RLN10*20
      CALL SQUARETRIAN2(PM,P,NBF,NBFT)
      P=P*0.5D+00
!
!     ----- I SHELL
!
      DO II = 1,NSHELL
!
      I = KATOM(II)
      XI = CX0(I)
      YI = CY0(I)
      ZI = CZ0(I)
      I1 = KSTART(II)
      I2 = I1+KNG(II)-1
      LIT = KTYPE(II)
      MINI = KKMIN(II)
      MAXI = KKMAX(II)
      LOCI = KLOC(II)-MINI
!
!     ----- J SHELL
!
      DO JJ = 1,II
!
        J = KATOM(JJ)
        XJ = CX0(J)
        YJ = CY0(J)
        ZJ = CZ0(J)
        J1 = KSTART(JJ)
        J2 = J1+KNG(JJ)-1
        LJT = KTYPE(JJ)
        MINJ = KKMIN(JJ)
        MAXJ = KKMAX(JJ)
        LOCJ = KLOC(JJ)-MINJ
        NROOTS = (LIT+LJT+1-2)/2 + 1
        RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
        IANDJ = II .EQ. JJ
!
!     ----- I PRIMITIVE
!
        DO IG = I1,I2
        AI = EX1(IG)
        ARRI = AI*RR
        AXI = AI*XI
        AYI = AI*YI
        AZI = AI*ZI
        CSI = CS(IG)
        CPI = CP(IG)
        CDI = CD(IG)
        CFI = CF(IG)
        CGI = CG(IG)
!
!     ----- J PRIMITIVE
!
        JGMAX = J2
        IF(IANDJ) JGMAX = IG
        DO JG = J1,JGMAX
          AJ = EX1(JG)
          AA = AI+AJ
          AA1 = ONE/AA
          DUM = AJ*ARRI*AA1
          IF(DUM .GT. TOL) CYCLE
          FAC = EXP(-DUM)
          CSJ = CS(JG)
          CPJ = CP(JG)
          CDJ = CD(JG)
          CFJ = CF(JG)
          CGJ = CG(JG)
          AX = (AXI+AJ*XJ)*AA1
          AY = (AYI+AJ*YJ)*AA1
          AZ = (AZI+AJ*ZJ)*AA1       
!
!     ----- DENSITY FACTOR
!
          DOUBLETE=IANDJ.AND.IG.NE.JG
          JMAX = MAXJ
          NN = 0
          DUM1 = ZERO
          DUM2 = DUM1
          DO I = MINI,MAXI
            IF(I.EQ.1) DUM1=CSI*FAC
            IF(I.EQ.2) DUM1=CPI*FAC
            IF(I.EQ.5) DUM1=CDI*FAC
            IF(I.EQ.8) DUM1=DUM1*SQRT3
            IF(I.EQ.11) DUM1=CFI*FAC
            IF(I.EQ.14) DUM1=DUM1*SQRT5
            IF(I.EQ.20) DUM1=DUM1*SQRT3
            IF(I.EQ.21) DUM1=CGI*FAC
            IF(I.EQ.24) DUM1=DUM1*SQRT7
            IF(I.EQ.30) DUM1=DUM1*SQRT5/SQRT3
            IF(I.EQ.33) DUM1=DUM1*SQRT3
!
            IF(IANDJ) JMAX = I
            DO J = MINJ,JMAX
              IF(J.EQ.1) THEN
                DUM2=DUM1*CSJ
                IF( .NOT. DOUBLETE) GO TO 350
                IF(I .GT. 1) THEN
                 DUM2 = DUM2+CSI*CPJ*FAC
                ELSE
                 DUM2 = DUM2+DUM2
                END IF
              ELSE IF(J.EQ.2) THEN
                DUM2=DUM1*CPJ
                IF(DOUBLETE) DUM2 = DUM2+DUM2
              ELSE IF(J.EQ.5) THEN
                DUM2=DUM1*CDJ
                IF(DOUBLETE) DUM2 = DUM2+DUM2
              ELSE IF(J.EQ.8) THEN
                DUM2 = DUM2*SQRT3
              ELSE IF(J.EQ.11) THEN
                DUM2=DUM1*CFJ
                IF(DOUBLETE) DUM2=DUM2+DUM2
              ELSE IF(J.EQ.14) THEN
                DUM2=DUM2*SQRT5
              ELSE IF(J.EQ.20) THEN
                DUM2=DUM2*SQRT3
              ELSE IF(J.EQ.21) THEN
                DUM2=DUM1*CGJ
                IF(DOUBLETE) DUM2=DUM2+DUM2
              ELSE IF(J.EQ.24) THEN
                DUM2=DUM2*SQRT7
              ELSE IF(J.EQ.30) THEN
                DUM2=DUM2*SQRT5/SQRT3
              ELSE IF(J.EQ.33) THEN
                DUM2=DUM2*SQRT3
              END IF
!
  350         NN = NN+1
!  
              NDUM = IA(LOCI+I)+(LOCJ+J)
              DEN = P(NDUM)
              IF(IANDJ.AND.I.EQ.J) DEN=DEN*0.5D+00
              DIJ(NN)=DUM2*DEN*PI212*AA1  
            ENDDO
          ENDDO
!
!     ..... HELLMANN-FEYNMAN TERM .....
!
          AAX = AA*AX
          AAY = AA*AY
          AAZ = AA*AZ
          DO IC = 1,NATOMS
            ZNUCC = -ZAN(IC)
            CX = CX0(IC)
            CY = CY0(IC)
            CZ = CZ0(IC)
            XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
            IF(NROOTS.LE.3) CALL RT123NOF(XX,NROOTS,UROOT,WROOT)
            IF(NROOTS.EQ.4) CALL ROOT4NOF(XX,UROOT,WROOT)
            IF(NROOTS.EQ.5) CALL ROOT5NOF(XX,UROOT,WROOT)
            DO K = 1,NROOTS
              UU = AA*UROOT(K)
              WW = WROOT(K)*ZNUCC
              WW=WW*(UU+UU)
              TT = ONE/(AA+UU)
              T = SQRT(TT)
              X0 = (AAX+UU*CX)*TT
              Y0 = (AAY+UU*CY)*TT
              Z0 = (AAZ+UU*CZ)*TT
              DO J = 1,LJT
                NJ = J
                DO I = 1,LIT
                  NI = I
                  CALL VINTNOF(NI,NJ,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ &
                            ,XINT,YINT,ZINT)
                  XIN(I,J,K,1) = XINT
                  YIN(I,J,K,1) = YINT
                  ZIN(I,J,K,1) = ZINT*WW
                  CALL DVINTNOF(NI,NJ,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ &
                             ,CX,CY,CZ,XINT,YINT,ZINT)
                  XIN(I,J,K,2) = XINT
                  YIN(I,J,K,2) = YINT
                  ZIN(I,J,K,2) = ZINT*WW
                ENDDO
              ENDDO  
            ENDDO
           IJ=0
           DO I=MINI,MAXI
            IX=IJX(I)
            IY=IJY(I)
            IZ=IJZ(I)
            JMAX=MAXJ
            IF(IANDJ) JMAX=I
            DO J=MINJ,JMAX
             JX=IJX(J)
             JY=IJY(J)
             JZ=IJZ(J)
             DUMX = ZERO
             DUMY = ZERO
             DUMZ = ZERO
             DO K = 1,NROOTS
              DUMX = DUMX+XIN(IX,JX,K,2)*YIN(IY,JY,K,1)*ZIN(IZ,JZ,K,1)
              DUMY = DUMY+XIN(IX,JX,K,1)*YIN(IY,JY,K,2)*ZIN(IZ,JZ,K,1)
              DUMZ = DUMZ+XIN(IX,JX,K,1)*YIN(IY,JY,K,1)*ZIN(IZ,JZ,K,2)
             ENDDO
             IJ=IJ+1  
             DUM=DIJ(IJ)
             DE(1,IC) = DE(1,IC)+DUM*DUMX
             DE(2,IC) = DE(2,IC)+DUM*DUMY
             DE(3,IC) = DE(3,IC)+DUM*DUMZ
            ENDDO
           ENDDO
          ENDDO
      ENDDO
      ENDDO
!
!     ----- END OF *PRIMITIVE* LOOPS -----
!
      ENDDO
      ENDDO
!
!     ----- END OF *SHELL* LOOPS -----
!             
!-----------------------------------------------------------------------
      RETURN
      END      

! TVDERNOF
      SUBROUTINE TVDERNOF(KATOM,KTYPE,KLOC,KKMIN,KKMAX,KSTART,KNG,      &
                      CX0,CY0,CZ0,EX1,CS,CP,CD,CF,CG,ZAN,PM,DE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KSTART,KNG
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0,ZAN
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::EX1,CS,CP,CD,CF,CG
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::PM
      DOUBLE PRECISION,DIMENSION(NBFT)::P
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::DE
!      
      INTEGER::NROOTS
      INTEGER,DIMENSION(NBF)::IA
      INTEGER,DIMENSION(35)::IJX,IJY,IJZ
      DOUBLE PRECISION,DIMENSION(5,5)::DXS,DYS,DZS,DXT,DYT,DZT
      DOUBLE PRECISION,DIMENSION(6,7)::XS,YS,ZS
      DOUBLE PRECISION,DIMENSION(6,5)::XT,YT,ZT
      DOUBLE PRECISION,DIMENSION(6,5,5)::XV,YV,ZV
      DOUBLE PRECISION,DIMENSION(5,5,5)::DXV,DYV,DZV
      DOUBLE PRECISION,DIMENSION(225)::DIJ
      DOUBLE PRECISION,DIMENSION(13)::UROOT,WROOT
      DOUBLE PRECISION::TOL
      DOUBLE PRECISION::ZNUCC
      DOUBLE PRECISION::XX
!
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00, ONE=1.0D+00,TWO=2.0D+00
      DOUBLE PRECISION,PARAMETER::RLN10=2.30258D+00,PI212=1.1283791670955D+00
      DOUBLE PRECISION,PARAMETER::SQRT3=1.73205080756888D+00
      DOUBLE PRECISION,PARAMETER::SQRT5=2.23606797749979D+00
      DOUBLE PRECISION,PARAMETER::SQRT7=2.64575131106459D+00
!
      DATA IJX / 1, 2, 1, 1, 3, 1, 1, 2, 2, 1,   &
                 4, 1, 1, 3, 3, 2, 1, 2, 1, 2,   &
                 5, 1, 1, 4, 4, 2, 1, 2, 1, 3,   &
                 3, 1, 3, 2, 2/
      DATA IJY / 1, 1, 2, 1, 1, 3, 1, 2, 1, 2,   &
                 1, 4, 1, 2, 1, 3, 3, 1, 2, 2,   &
                 1, 5, 1, 2, 1, 4, 4, 1, 2, 3,   &
                 1, 3, 2, 3, 2/
      DATA IJZ / 1, 1, 1, 2, 1, 1, 3, 1, 2, 2,   &
                 1, 1, 4, 1, 2, 1, 2, 3, 3, 2,   &
                 1, 1, 5, 1, 2, 1, 2, 4, 4, 1,   &
                 3, 3, 2, 2, 3/
!-----------------------------------------------------------------------
!
!     ----- BASIS FUNCTION DERIVATIVE CONTRIBUTIONS TO GRADIENT -----
!     INTEGRALS ARE OF TYPE <II'/H/JJ> = <II'/T+V/JJ>
!
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO
      IAZ=0
      TOL = RLN10*20
      CALL SQUARETRIAN2(PM,P,NBF,NBFT)
      P=P*0.5D+00      
!
!     ----- I SHELL
!
      DO II = 1,NSHELL
!      
        IAT = KATOM(II)
        XI = CX0(IAT)
        YI = CY0(IAT)
        ZI = CZ0(IAT)
        I1 = KSTART(II)
        I2 = I1+KNG(II)-1
        LIT = KTYPE(II)
        MINI = KKMIN(II)
        MAXI = KKMAX(II)
        LOCI = KLOC(II)-MINI
        LITDER = LIT + 1      
!
!     ----- J SHELL
!
        DO JJ = 1,NSHELL
!
          JAT = KATOM(JJ)
          XJ = CX0(JAT)
          YJ = CY0(JAT)
          ZJ = CZ0(JAT)
          J1 = KSTART(JJ)
          J2 = J1+KNG(JJ)-1
          LJT = KTYPE(JJ)
          MINJ = KKMIN(JJ)
          MAXJ = KKMAX(JJ)
          LOCJ = KLOC(JJ)-MINJ
          LJTMOD = LJT+2
          NROOTS = (LIT+LJT-1)/2 + 1
          RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2       
!
!     ----- I PRIMITIVE
!
        DO IG = I1,I2
          AI = EX1(IG)
          ARRI = AI*RR
          AXI = AI*XI
          AYI = AI*YI
          AZI = AI*ZI
          CSI=CS(IG)
          CPI=CP(IG)
          CDI=CD(IG)
          CFI=CF(IG)
          CGI=CG(IG)   
!
!     ----- J PRIMITIVE
!
          DO JG = J1,J2
            AJ = EX1(JG)
            AA = AI+AJ
            AA1 = ONE/AA
            DUM = AJ*ARRI*AA1
            IF(DUM .GT. TOL) CYCLE
            FAC = EXP(-DUM)
            CSJ = CS(JG)
            CPJ = CP(JG)
            CDJ = CD(JG)
            CFJ = CF(JG)
            CGJ = CG(JG)
            AX = (AXI+AJ*XJ)*AA1
            AY = (AYI+AJ*YJ)*AA1
            AZ = (AZI+AJ*ZJ)*AA1
!
!     ----- DENSITY FACTOR
!
            IJ = 0
            DUM1 = ZERO
            DUM2 = DUM1
            DO I=MINI,MAXI
              IF(I.EQ.1) DUM1=CSI*FAC
              IF(I.EQ.2) DUM1=CPI*FAC
              IF(I.EQ.5) DUM1=CDI*FAC
              IF(I.EQ.8) DUM1=DUM1*SQRT3
              IF(I.EQ.11) DUM1=CFI*FAC
              IF(I.EQ.14) DUM1=DUM1*SQRT5
              IF(I.EQ.20) DUM1=DUM1*SQRT3
              IF(I.EQ.21) DUM1=CGI*FAC
              IF(I.EQ.24) DUM1=DUM1*SQRT7
              IF(I.EQ.30) DUM1=DUM1*SQRT5/SQRT3
              IF(I.EQ.33) DUM1=DUM1*SQRT3
!
              DO J = MINJ,MAXJ
                IF(J.EQ.1) DUM2=DUM1*CSJ
                IF(J.EQ.2) DUM2=DUM1*CPJ
                IF(J.EQ.5) DUM2=DUM1*CDJ
                IF(J.EQ.8) DUM2=DUM2*SQRT3
                IF(J.EQ.11) DUM2=DUM1*CFJ
                IF(J.EQ.14) DUM2=DUM2*SQRT5
                IF(J.EQ.20) DUM2=DUM2*SQRT3
                IF(J.EQ.21) DUM2=DUM1*CGJ
                IF(J.EQ.24) DUM2=DUM2*SQRT7
                IF(J.EQ.30) DUM2=DUM2*SQRT5/SQRT3
                IF(J.EQ.33) DUM2=DUM2*SQRT3
!
                IJ=IJ+1            
                NN = IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
                DEN = P(NN)
                DIJ(IJ)=DUM2*DEN
              ENDDO
            ENDDO
!     
!     -----  KINETIC ENERGY
!
      T = SQRT(AA1)
      X0 = AX
      Y0 = AY
      Z0 = AZ
      DO J = 1,LJTMOD
        NJ =J
        DO I = 1,LITDER
          NI = I
          CALL VINTNOF(NI,NJ,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ   &
                        ,XINT,YINT,ZINT)
          XS(I,J)=XINT*T
          YS(I,J)=YINT*T
          ZS(I,J)=ZINT*T
        ENDDO
      ENDDO
      CALL DTXYZNOF(XT,YT,ZT,XS,YS,ZS,LITDER,LJT,AJ)
      CALL DERINOF(DXS,DYS,DZS,XS,YS,ZS,LIT,LJT,AI)
      CALL DERINOF(DXT,DYT,DZT,XT,YT,ZT,LIT,LJT,AI)
      IJ=0
      DO I=MINI,MAXI
        IX=IJX(I)
        IY=IJY(I)
        IZ=IJZ(I)
        DO J=MINJ,MAXJ
          JX=IJX(J)
          JY=IJY(J)
          JZ=IJZ(J)
          DUMX=DXT(IX,JX)* YS(IY,JY)* ZS(IZ,JZ)    &
              +DXS(IX,JX)* YT(IY,JY)* ZS(IZ,JZ)    &
              +DXS(IX,JX)* YS(IY,JY)* ZT(IZ,JZ)
          DUMY= XT(IX,JX)*DYS(IY,JY)* ZS(IZ,JZ)    &
              + XS(IX,JX)*DYT(IY,JY)* ZS(IZ,JZ)    &
              + XS(IX,JX)*DYS(IY,JY)* ZT(IZ,JZ)
          DUMZ= XT(IX,JX)* YS(IY,JY)*DZS(IZ,JZ)    &
              + XS(IX,JX)* YT(IY,JY)*DZS(IZ,JZ)    &
              + XS(IX,JX)* YS(IY,JY)*DZT(IZ,JZ)
          IJ=IJ+1
          DE(1,IAT)=DE(1,IAT)+ DUMX*DIJ(IJ)
          DE(2,IAT)=DE(2,IAT)+ DUMY*DIJ(IJ)
          DE(3,IAT)=DE(3,IAT)+ DUMZ*DIJ(IJ)          
        ENDDO
      ENDDO
!
!     ..... NUCLEAR ATTRACTION
!
      AAX = AA*AX
      AAY = AA*AY
      AAZ = AA*AZ
!
      DO IC = 1,NATOMS
            IF(IC.LE.NATOMS) THEN
               ZNUCC = -ZAN(IC)
               CX = CX0(IC)
               CY = CY0(IC)
               CZ = CZ0(IC)
            ENDIF
         XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
         IF(NROOTS.LE.3) CALL RT123NOF(XX,NROOTS,UROOT,WROOT)
         IF(NROOTS.EQ.4) CALL ROOT4NOF(XX,UROOT,WROOT)
         IF(NROOTS.EQ.5) CALL ROOT5NOF(XX,UROOT,WROOT)
         DO K = 1,NROOTS
            UU = AA*UROOT(K)
            WW = WROOT(K)*ZNUCC
            TT = ONE/(AA+UU)
            T = SQRT(TT)
            X0 = (AAX+UU*CX)*TT
            Y0 = (AAY+UU*CY)*TT
            Z0 = (AAZ+UU*CZ)*TT
            DO J = 1,LJT
               NJ = J
               DO I = 1,LITDER
                  NI = I
                  CALL VINTNOF(NI,NJ,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ &
                        ,XINT,YINT,ZINT)
                  XV(I,J,K) = XINT
                  YV(I,J,K) = YINT
                  ZV(I,J,K) = ZINT*WW
               ENDDO
            ENDDO
            CALL DERINOF(DXV(1,1,K),DYV(1,1,K),DZV(1,1,K),    &
                      XV(1,1,K), YV(1,1,K), ZV(1,1,K),LIT,LJT,AI)
         ENDDO
         IJ=0
         DO I=MINI,MAXI
           IX=IJX(I)
           IY=IJY(I)
           IZ=IJZ(I)
           DO J=MINJ,MAXJ
             JX=IJX(J)
             JY=IJY(J)
             JZ=IJZ(J)
             DUMX=ZERO
             DUMY=ZERO
             DUMZ=ZERO
             DO K=1,NROOTS
               DUMX=DUMX+DXV(IX,JX,K)* YV(IY,JY,K)* ZV(IZ,JZ,K)
               DUMY=DUMY+ XV(IX,JX,K)*DYV(IY,JY,K)* ZV(IZ,JZ,K)
               DUMZ=DUMZ+ XV(IX,JX,K)* YV(IY,JY,K)*DZV(IZ,JZ,K)
             ENDDO
             IJ=IJ+1
             IF((IC.GT.NATOMS).AND.(IAT.EQ.IAZ)) CYCLE
             DUMINT=DIJ(IJ)*AA1*PI212
             DE(1,IAT)=DE(1,IAT)+DUMX*DUMINT
             DE(2,IAT)=DE(2,IAT)+DUMY*DUMINT
             DE(3,IAT)=DE(3,IAT)+DUMZ*DUMINT
           ENDDO
         ENDDO
      ENDDO
!
      ENDDO
      ENDDO
!
!     ----- END OF PRIMITIVE LOOPS -----
!
      ENDDO
      ENDDO
!
!     ----- END OF SHELL LOOPS -----
!
!-----------------------------------------------------------------------
      RETURN
      END

! JKWRYSNOF
      SUBROUTINE JKWRYSNOF(RWV,ABV,NUMG,NROOTS,NKL,NIJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
      INTEGER,INTENT(IN)::NUMG,NROOTS,NKL,NIJ
      DOUBLE PRECISION,DIMENSION(5,NKL*NIJ),INTENT(IN)::ABV
      DOUBLE PRECISION,DIMENSION(2,NUMG,NROOTS),INTENT(OUT)::RWV
      DOUBLE PRECISION,DIMENSION(13)::UROOT,WROOT
!
      DO NG=1,NUMG
         XX=ABV(5,NG)
         IF(NROOTS.LE.3) CALL RT123NOF(XX,NROOTS,UROOT,WROOT)
         IF(NROOTS.EQ.4) CALL ROOT4NOF(XX,UROOT,WROOT)
         IF(NROOTS.EQ.5) CALL ROOT5NOF(XX,UROOT,WROOT)
         IF(NROOTS.GE.6) CALL ROOT6NOF(XX,NROOTS,UROOT,WROOT)
         DO NR=1,NROOTS
           RWV(1,NG,NR)=UROOT(NR)
           RWV(2,NG,NR)=WROOT(NR)
         ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! JKBCDFNOF
      SUBROUTINE JKBCDFNOF(B00,B01,B10,C00,D00,F00,DIJ,DKL,             &
                        ABV,CV,RWV,NUMG,NROOTS,NKL,NIJ,   &
                        NMAXS,MMAXS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!      
      LOGICAL,INTENT(IN)::NMAXS,MMAXS
      INTEGER,INTENT(IN)::NUMG,NROOTS,NKL,NIJ
      DOUBLE PRECISION,DIMENSION(5,NKL*NIJ),INTENT(IN)::ABV
      DOUBLE PRECISION,DIMENSION(18,NKL*NIJ),INTENT(IN)::CV
      DOUBLE PRECISION,DIMENSION(2,NUMG,NROOTS),INTENT(IN)::RWV
      DOUBLE PRECISION,DIMENSION(NUMG,NROOTS,3),INTENT(OUT)::B00,B01,B10,C00,D00
      DOUBLE PRECISION,DIMENSION(NUMG,NROOTS,3),INTENT(OUT)::F00,DIJ,DKL
      DOUBLE PRECISION,PARAMETER::PT5=0.5D+00, ONE=1.0D+00
!
      DO NR=1,NROOTS
        DO NG=1,NUMG
          AA =ABV(1,NG)
          BB =ABV(2,NG)
          RHO=ABV(3,NG)
          QAB=ABV(4,NG)
          UU =RHO*RWV(1,NG,NR)
          WW =    RWV(2,NG,NR)
          AAUU=AA+UU
          BBUU=BB+UU
          F00(NG,NR,1)=WW*QAB
          F00(NG,NR,2)=ONE
          F00(NG,NR,3)=ONE
          RHO0  = AA*BB/(AA+BB)
          DUM2=PT5/(AA*BB+UU*(AA+BB))
          AUDUM=AAUU*DUM2
          BUDUM=BBUU*DUM2
           UDUM=  UU*DUM2
           B00(NG,NR,1)= UDUM
           B00(NG,NR,2)= UDUM
           B00(NG,NR,3)= UDUM
           B01(NG,NR,1)=AUDUM
           B01(NG,NR,2)=AUDUM
           B01(NG,NR,3)=AUDUM
           B10(NG,NR,1)=BUDUM
           B10(NG,NR,2)=BUDUM
           B10(NG,NR,3)=BUDUM
           UDUM= UDUM+ UDUM
           IF(.NOT.MMAXS) THEN
            AUDUM=AUDUM+AUDUM
            D00(NG,NR,1)= UDUM*CV( 1,NG) + AUDUM*CV( 2,NG)
            D00(NG,NR,2)= UDUM*CV( 3,NG) + AUDUM*CV( 4,NG)
            D00(NG,NR,3)= UDUM*CV( 5,NG) + AUDUM*CV( 6,NG)
           ENDIF
           IF(.NOT.NMAXS) THEN
            BUDUM=BUDUM+BUDUM
            C00(NG,NR,1)= UDUM*CV( 8,NG) + BUDUM*CV( 7,NG)
            C00(NG,NR,2)= UDUM*CV(10,NG) + BUDUM*CV( 9,NG)
            C00(NG,NR,3)= UDUM*CV(12,NG) + BUDUM*CV(11,NG)
           ENDIF
!
        ENDDO
      ENDDO
!
      DO NR=1,NROOTS
        DO NG=1,NUMG
          DIJ(NG,NR,1)=CV(13,NG)
          DIJ(NG,NR,2)=CV(14,NG)
          DIJ(NG,NR,3)=CV(15,NG)
          DKL(NG,NR,1)=CV(16,NG)
          DKL(NG,NR,2)=CV(17,NG)
          DKL(NG,NR,3)=CV(18,NG)
        ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! JKGNMSNOF
      SUBROUTINE JKGNMSNOF(GNM,NG,NMAX,MMAX,B002,B012,B102,C00,D00,     &
                           F00,NMAXS,NMAXP,MMAXS,MMAXP)
!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
      LOGICAL,INTENT(IN)::NMAXS,NMAXP,MMAXS,MMAXP
      INTEGER,INTENT(IN)::NG,NMAX,MMAX
      DOUBLE PRECISION,DIMENSION(NG),INTENT(IN)::C00,D00,F00
      DOUBLE PRECISION,DIMENSION(NG),INTENT(INOUT)::B002,B012,B102
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::B00
      DOUBLE PRECISION,DIMENSION(NG,NMAX-1)::B10
      DOUBLE PRECISION,DIMENSION(NG,MMAX-1)::B01
      DOUBLE PRECISION,DIMENSION(NG,NMAX,MMAX),INTENT(OUT)::GNM
!
!     ----- G(0,0) -----
!
      DO IG=1,NG
        GNM(IG,1,1)=F00(IG)
      ENDDO
      IF(NMAXS.AND.MMAXS) RETURN
      IF(NMAXS) GO TO 30
!
!     ----- G(1,0) = C00 * G(0,0) -----
!
      DO IG=1,NG
        GNM(IG,2,1)=C00(IG)*GNM(IG,1,1)
      ENDDO
!
   30 IF(MMAXS) GO TO 60
!
!     ----- G(0,1) = D00 * G(0,0) -----
!
      DO IG=1,NG
        GNM(IG,1,2)=D00(IG)*GNM(IG,1,1)
      ENDDO
      IF(NMAXS) GO TO 60
!
!     ----- G(1,1) = B00 * G(0,0) + D00 * G(1,0) -----
!
      DO IG=1,NG
        GNM(IG,2,2)=B002(IG)*GNM(IG,1,1)+D00(IG)*GNM(IG,2,1)
      ENDDO
!
   60 MAX60=MAX0(NMAX-1,MMAX-1)
      ALLOCATE(B00(NG,MAX60))
      B00(:,1)=B002(:)
      DO M=2,MAX60
        DO IG=1,NG
          B00(IG,M)=B00(IG,M-1)+B00(IG,1)
        ENDDO
      ENDDO
!
      IF(NMAXP) GO TO 120
!
!     ----- G(N+1,0) = N * B10 * G(N-1,0) + C00 * G(N,0) -----
!
      B10(:,1)=B102(:)
      DO N=2,NMAX-1
        DO IG=1,NG
          B10(IG,N)=B10(IG,N-1)+B10(IG,1)
        ENDDO
      ENDDO
      DO N=2,NMAX-1
        DO IG=1,NG
          GNM(IG,N+1,1)=B10(IG,N-1)*GNM(IG,N-1,1)+C00(IG)*GNM(IG,N,1)
        ENDDO
      ENDDO
      IF(MMAXS) GO TO 120
!
!     ----- G(N,1) = N * B00 * G(N-1,0) + D00 * G(N,0) -----
!
      DO N=2,NMAX-1
        DO IG=1,NG
          GNM(IG,N+1,2)=B00(IG,N)*GNM(IG,N,1)+D00(IG)*GNM(IG,N+1,1)
        ENDDO
      ENDDO
!
  120 IF(MMAXP) GO TO 170
!
!     ----- G(0,M+1) = M * B01 * G(0,M-1) + D00 * G(O,M) -----
!
      B01(:,1)=B012(:)
      DO M=2,MMAX-1
        DO IG=1,NG
          B01(IG,M)=B01(IG,M-1)+B01(IG,1)
        ENDDO
      ENDDO
      DO M=2,MMAX-1
        DO IG=1,NG
          GNM(IG,1,M+1)=B01(IG,M-1)*GNM(IG,1,M-1)+D00(IG)*GNM(IG,1,M)
        ENDDO
      ENDDO
      IF(NMAXS) GO TO 170
!
!     ----- G(1,M) = M * B00 * G(0,M-1) + C00 * G(0,M) -----
!
      DO M=2,MMAX-1
        DO IG=1,NG
          GNM(IG,2,M+1)=B00(IG,M)*GNM(IG,1,M)+C00(IG)*GNM(IG,1,M+1)
        ENDDO
      ENDDO
!
  170 IF(NMAXP.OR.MMAXP) THEN
        DEALLOCATE(B00)
!        DEALLOCATE(B10)
        RETURN
      ENDIF
!
!     ----- G(N+1,M) = N * B10 * G(N-1,M  ) -----
!                    +     C00 * G(N  ,M  )
!                    + M * B00 * G(N  ,M-1)
!
      DO M=2,MMAX-1
        DO N=2,NMAX-1
          DO IG=1,NG
            GNM(IG,N+1,M+1)=B10(IG,N-1)*GNM(IG,N-1,M+1)+  &
                      C00(IG    )*GNM(IG,N  ,M+1)+        &
                      B00(IG,M  )*GNM(IG,N  ,M  )
          ENDDO
        ENDDO
      ENDDO
!-----------------------------------------------------------------------
      DEALLOCATE(B00)
      RETURN
      END

! JKXYZSNOF
      SUBROUTINE JKXYZSNOF(GIJKL,HIJKL,GNKL,HNKL,FNKL,GNM,              &
       NG,NMAX,MMAX,NIMAX,NJMAX,NKMAX,NLMAX,DIJ,DKL,EXPNDI,EXPNDK)
!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL,INTENT(IN)::EXPNDI,EXPNDK
      INTEGER,INTENT(IN)::NG,NMAX,MMAX,NIMAX,NJMAX,NKMAX,NLMAX
      DOUBLE PRECISION,DIMENSION(NG*NLMAX*NKMAX,NJMAX,NIMAX),INTENT(OUT)::GIJKL
      DOUBLE PRECISION,DIMENSION(NG*NLMAX*NKMAX*NJMAX,NIMAX),INTENT(OUT)::HIJKL
      DOUBLE PRECISION,DIMENSION(NG,NLMAX,NKMAX,NMAX),INTENT(OUT)::GNKL
      DOUBLE PRECISION,DIMENSION(NG*NLMAX*NKMAX,NMAX),INTENT(IN)::HNKL
      DOUBLE PRECISION,DIMENSION(NG*NLMAX*NKMAX*NMAX),INTENT(IN)::FNKL
      DOUBLE PRECISION,DIMENSION(NG,NMAX,MMAX),INTENT(INOUT)::GNM
      DOUBLE PRECISION,DIMENSION(NG),INTENT(IN)::DIJ,DKL
!
!     ----- G(N,K,L) -----
!
      IF (.NOT.EXPNDK) THEN
!
        DO NK=1,NKMAX
          DO NL=1,NLMAX
            DO  N=1,NMAX
              DO IG=1,NG
                GNKL(IG,NL,NK,N)=GNM(IG,N,NL)
              ENDDO
            ENDDO
          ENDDO
          IF(NK.EQ.NKMAX) EXIT
          MAXXXX=MMAX-NK
          DO M=1,MAXXXX
            DO N=1,NMAX
             DO IG=1,NG
              GNM(IG,N,M)=DKL(IG)*GNM(IG,N,M)+GNM(IG,N,M+1)
             ENDDO
            ENDDO
          ENDDO
        ENDDO
!
      ELSE
!
        DO NL=1,NLMAX
          DO  NK=1,NKMAX
            DO   N=1,NMAX
              DO  IG=1,NG
                GNKL(IG,NL,NK,N)=GNM(IG,N,NK)
              ENDDO
            ENDDO
          ENDDO
          IF(NL.EQ.NLMAX) EXIT
          MAXXXX=MMAX-NL
          DO  M=1,MAXXXX
            DO  N=1,NMAX
              DO IG=1,NG
                GNM(IG,N,M)=DKL(IG)*GNM(IG,N,M)+GNM(IG,N,M+1)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
!
      ENDIF
!
!     ----- G(I,J,K,L) -----
!
      IF (.NOT.EXPNDI) THEN
!
        DO NI=1,NIMAX
          DO IGLKJ=1,NG*NLMAX*NKMAX*NJMAX
            HIJKL(IGLKJ,NI)=FNKL(IGLKJ)
          ENDDO
          IF(NI.EQ.NIMAX) EXIT
          MAXXXX=NMAX-NI
          DO N=1,MAXXXX
            DO NK=1,NKMAX
              DO NL=1,NLMAX
                DO IG=1,NG
                  GNKL(IG,NL,NK,N)=DIJ(IG)*GNKL(IG,NL,NK,N)+  &
                                   GNKL(IG,NL,NK,N+1)
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
!
      ELSE
!
        DO NJ=1,NJMAX
          DO NI=1,NIMAX
            DO IGLK=1,NG*NLMAX*NKMAX
              GIJKL(IGLK,NJ,NI)=HNKL(IGLK,NI)
            ENDDO
          ENDDO
          IF(NJ.EQ.NJMAX) EXIT
          MAXXXX=NMAX-NJ
          DO N=1,MAXXXX
            DO NK=1,NKMAX
              DO NL=1,NLMAX
                DO IG=1,NG
                  GNKL(IG,NL,NK,N)=DIJ(IG)*GNKL(IG,NL,NK,N)+  &
                                   GNKL(IG,NL,NK,N+1)
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDIF
!-----------------------------------------------------------------------
      RETURN
      END

! JDXYZSNOF
      SUBROUTINE JDXYZSNOF(GI,GIJ,GIJK,GIJKL,                           &
       NG,NIMAX,NJMAX,NKMAX,NLMAX,NI,NJ,NK,NL,AAI,AAJ,AAK,AAL,         &
       FI,FJ,FK,FL,SKIPI,SKIPJ,SKIPK,SKIPL)
!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER,INTENT(IN)::NG,NIMAX,NJMAX,NKMAX,NLMAX,NI,NJ,NK,NL
      LOGICAL,INTENT(IN)::SKIPI,SKIPJ,SKIPK,SKIPL
      LOGICAL::IS,JS,KS,LS
      DOUBLE PRECISION,DIMENSION(NG,NLMAX,NKMAX*NJMAX*NIMAX),INTENT(IN)::GIJKL
      DOUBLE PRECISION,DIMENSION(NG,NLMAX,NKMAX,NJMAX*NIMAX),INTENT(IN)::GIJK
      DOUBLE PRECISION,DIMENSION(NG,NLMAX*NKMAX,NJMAX,NIMAX),INTENT(IN)::GIJ
      DOUBLE PRECISION,DIMENSION(NG,NLMAX*NKMAX*NJMAX,NIMAX),INTENT(IN)::GI
      DOUBLE PRECISION,DIMENSION(NG),INTENT(IN)::AAI,AAJ,AAK,AAL
      DOUBLE PRECISION,DIMENSION(NG,NLMAX*NKMAX*NJMAX,NIMAX),INTENT(OUT)::FI
      DOUBLE PRECISION,DIMENSION(NG,NLMAX*NKMAX,NJMAX,NIMAX),INTENT(OUT)::FJ
      DOUBLE PRECISION,DIMENSION(NG,NLMAX,NKMAX,NJMAX*NIMAX),INTENT(OUT)::FK
      DOUBLE PRECISION,DIMENSION(NG,NLMAX,NKMAX*NJMAX*NIMAX),INTENT(OUT)::FL
!
      IS=NI.EQ.1
      JS=NJ.EQ.1
      KS=NK.EQ.1
      LS=NL.EQ.1
!
!     ----- FIRST DERIVATIVES ONLY -----
!
      IF(SKIPI) GO TO 1030
!
!     ----- -FI- ONLY -----
!
      DO LKJ=1,NLMAX*NKMAX*NJMAX
        DO IG =1,NG
           FI(IG,LKJ,1)=  GI(IG,LKJ,2)*AAI(IG)
        ENDDO
      ENDDO
      IF(IS) GO TO 1030
      DO I  =2,NI
        DO LKJ=1,NLMAX*NKMAX*NJMAX
          DO IG =1,NG
             FI(IG,LKJ,I)= GI(IG,LKJ,I+1)*AAI(IG)  &
                          -GI(IG,LKJ,I-1)*(I-1)
          ENDDO
        ENDDO
      ENDDO
!
 1030 IF(SKIPJ) GO TO 1130
!
!     ----- -FJ- ONLY -----
!
      DO I =1,NIMAX
        DO LK=1,NLMAX*NKMAX
          DO IG=1,NG
             FJ(IG,LK,1,I)=  GIJ(IG,LK,2,I)*AAJ(IG)
          ENDDO
        ENDDO
      ENDDO
      IF(JS) GO TO 1130
      DO I =1,NIMAX
        DO J =2,NJ
          DO LK=1,NLMAX*NKMAX
            DO IG=1,NG
               FJ(IG,LK,J,I)= GIJ(IG,LK,J+1,I)*AAJ(IG) &
                             -GIJ(IG,LK,J-1,I)*(J-1)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
 1130 IF(SKIPK) GO TO 1230
!
!     ----- -FK- ONLY -----
!
      DO JI=1,NJMAX*NIMAX
        DO L =1,NLMAX
          DO IG=1,NG
             FK(IG,L,1,JI)=  GIJK(IG,L,2,JI)*AAK(IG)
          ENDDO
        ENDDO
      ENDDO
      IF(KS) GO TO 1230
      DO JI=1,NJMAX*NIMAX
        DO K =2,NK
          DO L =1,NLMAX
            DO IG=1,NG
               FK(IG,L,K,JI)= GIJK(IG,L,K+1,JI)*AAK(IG)  &
                             -GIJK(IG,L,K-1,JI)*(K-1)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
 1230 IF(SKIPL) GO TO 1330
!
!     ----- -FL- AND -SLL- -----
!
      DO KJI=1,NKMAX*NJMAX*NIMAX
        DO IG =1,NG
           FL(IG,1,KJI)=  GIJKL(IG,2,KJI)*AAL(IG)
        ENDDO
      ENDDO
      IF(LS) GO TO 1330
      DO KJI=1,NKMAX*NJMAX*NIMAX
        DO L  =2,NL
          DO IG =1,NG
             FL(IG,L,KJI)= GIJKL(IG,L+1,KJI)*AAL(IG)   &
                          -GIJKL(IG,L-1,KJI)*(L-1)
          ENDDO
        ENDDO
      ENDDO
!
 1330 CONTINUE
!----------------------------------------------------------------------- 
      RETURN
      END

! DSPDFSNOF
      SUBROUTINE DSPDFSNOF(IIFINT,NG,NR,IJKLG,GIJKL,FIJKL,XYZ,FIXYZ,    &
                           FJXYZ,FKXYZ,FLXYZ,DIJSI,DIJSJ,DKLSK,DKLSL,   &
                           DAB,SKIPI,SKIPJ,SKIPK,SKIPL,MINI,MINJ,MINK,  &
                           MINL,MAXI,MAXJ,MAXK,MAXL,MAXNUM,MAXXYZ,      &
                           IIEQJJ,KKEQLL,IJEQKL,SPI,SPJ,SPK,SPL,SPIJKL, &
                           FD,IFI)
!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL::IS,JS,KS,LS
      LOGICAL::IJS,IJKS,IJKLS
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      LOGICAL,INTENT(IN)::SPI,SPJ,SPK,SPL,SPIJKL
      LOGICAL,INTENT(IN)::SKIPI,SKIPJ,SKIPK,SKIPL
      INTEGER,INTENT(IN)::MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL
      INTEGER,INTENT(IN)::NG,NR,MAXNUM,MAXXYZ,IFI
      INTEGER,INTENT(INOUT)::IIFINT
      INTEGER,DIMENSION(4,MAXNUM),INTENT(IN)::IJKLG
      DOUBLE PRECISION,DIMENSION(12),INTENT(INOUT)::FD
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(IN)::DAB
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(OUT)::GIJKL
      DOUBLE PRECISION,DIMENSION(12,MAXNUM/4),INTENT(OUT)::FIJKL
!     CAUTION, XYZ WHEN CALLING IS GIJKL, BUT HERE GIJKL STORES INTEGRALS
      DOUBLE PRECISION,DIMENSION(NG*NR,IFI-NG*NR),INTENT(IN)::XYZ
      DOUBLE PRECISION,DIMENSION(NG*NR,IFI-NG*NR),INTENT(IN)::FIXYZ,FJXYZ,FKXYZ,FLXYZ
      DOUBLE PRECISION,DIMENSION(MAXXYZ),INTENT(IN)::DIJSI,DIJSJ,DKLSK,DKLSL
      DOUBLE PRECISION,DIMENSION(NG*NR)::XY,XZ,YZ,SJ,SK,SL
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00
!
      IF(SPIJKL) GO TO 1000
!
!     ----- NO SHARED EXPONENTS ; SUM UP ( IX * IY * IZ ) -----
!
!
!     ----- GRADIENT -----
!
      IJKLN=0
      DO I=MINI,MAXI
        JMAX=MAXJ
        IF(IIEQJJ) JMAX=I
        DO J=MINJ,JMAX
          KMAX=MAXK
          IF(IJEQKL) KMAX=I
          DO K=MINK,KMAX
            LMAX=MAXL
            IF(KKEQLL           ) LMAX=K
            IF(IJEQKL.AND.K.EQ.I) LMAX=J
            DO L=MINL,LMAX
              IJKLN=IJKLN+1
              NN=IJKLG(1,IJKLN)
              NX=IJKLG(2,IJKLN)
              NY=IJKLG(3,IJKLN)
              NZ=IJKLG(4,IJKLN)
!
              DO IGR=1,NG*NR
                XY(IGR)=XYZ(IGR,NX)*XYZ(IGR,NY)
                XZ(IGR)=XYZ(IGR,NX)*XYZ(IGR,NZ)
                YZ(IGR)=XYZ(IGR,NY)*XYZ(IGR,NZ)
              ENDDO
!
              IF(SKIPI) GO TO 530
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FIXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FIXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FIXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!
              IIFINT=IIFINT+3
              FD( 1)=FD( 1)+DAB(NN)*DUMFX
              FD( 2)=FD( 2)+DAB(NN)*DUMFY
              FD( 3)=FD( 3)+DAB(NN)*DUMFZ
  530         IF(SKIPJ) GO TO 550
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FJXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FJXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FJXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!
              IIFINT=IIFINT+3 
              FD( 4)=FD( 4)+DAB(NN)*DUMFX
              FD( 5)=FD( 5)+DAB(NN)*DUMFY
              FD( 6)=FD( 6)+DAB(NN)*DUMFZ
  550         IF(SKIPK) GO TO 570
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FKXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FKXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FKXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!
              IIFINT=IIFINT+3
              FD( 7)=FD( 7)+DAB(NN)*DUMFX
              FD( 8)=FD( 8)+DAB(NN)*DUMFY
              FD( 9)=FD( 9)+DAB(NN)*DUMFZ
  570         IF(SKIPL) GO TO 600
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FLXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FLXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FLXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!
              IIFINT=IIFINT+3
              FD(10)=FD(10)+DAB(NN)*DUMFX
              FD(11)=FD(11)+DAB(NN)*DUMFY
              FD(12)=FD(12)+DAB(NN)*DUMFZ
  600         CONTINUE
!
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
!     ----- ZEROTH AND FIRST DERIVATIVE INTEGRALS -----
!
!     REMOVE NEXT RETURN FOR STORING EACH INTEGRAL CONTRIBUTION
      RETURN
!
      IJKLN=0
      DO 940 I=MINI,MAXI
        JMAX=MAXJ
        IF(IIEQJJ) JMAX=I
        DO 930 J=MINJ,JMAX
          KMAX=MAXK
          IF(IJEQKL) KMAX=I
          DO 920 K=MINK,KMAX
            LMAX=MAXL
            IF(KKEQLL           ) LMAX=K
            IF(IJEQKL.AND.K.EQ.I) LMAX=J
            DO 910 L=MINL,LMAX
            IJKLN=IJKLN+1
            NN=IJKLG(1,IJKLN)
            NX=IJKLG(2,IJKLN)
            NY=IJKLG(3,IJKLN)
            NZ=IJKLG(4,IJKLN)
!
            DO IGR=1,NG*NR
              XY(IGR)=XYZ(IGR,NX)*XYZ(IGR,NY)
              XZ(IGR)=XYZ(IGR,NX)*XYZ(IGR,NZ)
              YZ(IGR)=XYZ(IGR,NY)*XYZ(IGR,NZ)
            ENDDO
            DUM=ZERO
            DO IGR=1,NG*NR
              DUM=DUM+XYZ(IGR,NX)*YZ(IGR)
            ENDDO
            GIJKL(NN)=GIJKL(NN)+DUM
!
            IF(SKIPI) GO TO 830
            DUMFX =ZERO
            DUMFY =ZERO
            DUMFZ =ZERO
            DO IGR=1,NG*NR
              DUMFX =DUMFX + FIXYZ(IGR,NX)*YZ(IGR)
              DUMFY =DUMFY + FIXYZ(IGR,NY)*XZ(IGR)
              DUMFZ =DUMFZ + FIXYZ(IGR,NZ)*XY(IGR)
            ENDDO
            FIJKL( 1,NN)=FIJKL( 1,NN)+DUMFX
            FIJKL( 2,NN)=FIJKL( 2,NN)+DUMFY
            FIJKL( 3,NN)=FIJKL( 3,NN)+DUMFZ
  830       IF(SKIPJ) GO TO 850
            DUMFX =ZERO
            DUMFY =ZERO
            DUMFZ =ZERO
            DO IGR=1,NG*NR
              DUMFX =DUMFX + FJXYZ(IGR,NX)*YZ(IGR)
              DUMFY =DUMFY + FJXYZ(IGR,NY)*XZ(IGR)
              DUMFZ =DUMFZ + FJXYZ(IGR,NZ)*XY(IGR)
            ENDDO
            FIJKL( 4,NN)=FIJKL( 4,NN)+DUMFX
            FIJKL( 5,NN)=FIJKL( 5,NN)+DUMFY
            FIJKL( 6,NN)=FIJKL( 6,NN)+DUMFZ
  850       IF(SKIPK) GO TO 870
            DUMFX =ZERO
            DUMFY =ZERO
            DUMFZ =ZERO
            DO IGR=1,NG*NR
              DUMFX =DUMFX + FKXYZ(IGR,NX)*YZ(IGR)
              DUMFY =DUMFY + FKXYZ(IGR,NY)*XZ(IGR)
              DUMFZ =DUMFZ + FKXYZ(IGR,NZ)*XY(IGR)
            ENDDO
            FIJKL( 7,NN)=FIJKL( 7,NN)+DUMFX
            FIJKL( 8,NN)=FIJKL( 8,NN)+DUMFY
            FIJKL( 9,NN)=FIJKL( 9,NN)+DUMFZ
  870       IF(SKIPL) GO TO 900
            DUMFX =ZERO
            DUMFY =ZERO
            DUMFZ =ZERO
            DO IGR=1,NG*NR
              DUMFX =DUMFX + FLXYZ(IGR,NX)*YZ(IGR)
              DUMFY =DUMFY + FLXYZ(IGR,NY)*XZ(IGR)
              DUMFZ =DUMFZ + FLXYZ(IGR,NZ)*XY(IGR)
            ENDDO
            FIJKL(10,NN)=FIJKL(10,NN)+DUMFX
            FIJKL(11,NN)=FIJKL(11,NN)+DUMFY
            FIJKL(12,NN)=FIJKL(12,NN)+DUMFZ
  900       CONTINUE
!
  910       CONTINUE
  920     CONTINUE
  930   CONTINUE
  940 CONTINUE
!
      RETURN
!
!     ----- SHARED EXPONENTS ; FORM ( IX * IY * IZ ) -----
!
 1000 CONTINUE
!
!     ----- GRADIENT -----
!
      IJKLN=0
      DO 2640 I=MINI,MAXI
        IS=SPI.AND.I.EQ.1
!
        JMAX=MAXJ
        IF(IIEQJJ) JMAX=I
        DO 2630 J=MINJ,JMAX
          JS=SPJ.AND.J.EQ.1
!
          IF(JS) THEN
             IF(IS) THEN
                DO IGR=1,NG*NR
                  SJ(IGR)=DIJSJ(IGR)*DIJSI(IGR)
                ENDDO
             ELSE
                DO IGR=1,NG*NR
                  SJ(IGR)=DIJSJ(IGR)
                ENDDO
             ENDIF
          ELSE
             IF(IS) THEN
                DO IGR=1,NG*NR
                  SJ(IGR)=DIJSI(IGR)
                ENDDO
             ENDIF
          ENDIF
          IJS=IS.OR.JS
!
          KMAX=MAXK
          IF(IJEQKL) KMAX=I
          DO 2620 K=MINK,KMAX
            KS=SPK.AND.K.EQ.1
!
            IF(KS) THEN
               IF(IJS) THEN
                  DO IGR=1,NG*NR
                    SK(IGR)=DKLSK(IGR)*SJ(IGR)
                  ENDDO
               ELSE
                  DO IGR=1,NG*NR
                    SK(IGR)=DKLSK(IGR)
                  ENDDO
               ENDIF
            ELSE
               IF(IJS) THEN
                  DO IGR=1,NG*NR
                    SK(IGR)=SJ(IGR)
                  ENDDO
               ENDIF
            ENDIF
            IJKS=IJS.OR.KS
!
            LMAX=MAXL
            IF(KKEQLL           ) LMAX=K
            IF(IJEQKL.AND.K.EQ.I) LMAX=J
            DO 2610 L=MINL,LMAX
              LS=SPL.AND.L.EQ.1
!
              IF(LS) THEN
                 IF(IJKS) THEN
                    DO IGR=1,NG*NR
                      SL(IGR)=DKLSL(IGR)*SK(IGR)
                    ENDDO
                 ELSE
                    DO IGR=1,NG*NR
                      SL(IGR)=DKLSL(IGR)
                    ENDDO
                 ENDIF
              ELSE
                 IF(IJKS) THEN
                    DO IGR=1,NG*NR
                      SL(IGR)=SK(IGR)
                    ENDDO
                 ENDIF
              ENDIF
              IJKLS=IJKS.OR.LS
!
              IJKLN=IJKLN+1
              NN=IJKLG(1,IJKLN)
              NX=IJKLG(2,IJKLN)
              NY=IJKLG(3,IJKLN)
              NZ=IJKLG(4,IJKLN)
!
              IF(IJKLS) THEN
                 DO IGR=1,NG*NR
                   XY(IGR)=XYZ(IGR,NX)*XYZ(IGR,NY)*SL(IGR)
                   XZ(IGR)=XYZ(IGR,NX)*XYZ(IGR,NZ)*SL(IGR)
                   YZ(IGR)=XYZ(IGR,NY)*XYZ(IGR,NZ)*SL(IGR)
                 ENDDO
              ELSE
                 DO IGR=1,NG*NR
                   XY(IGR)=XYZ(IGR,NX)*XYZ(IGR,NY)
                   XZ(IGR)=XYZ(IGR,NX)*XYZ(IGR,NZ)
                   YZ(IGR)=XYZ(IGR,NY)*XYZ(IGR,NZ)
                 ENDDO
              ENDIF
!
              IF(SKIPI) GO TO 2530
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FIXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FIXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FIXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!
              IIFINT=IIFINT+3
              FD( 1)=FD( 1)+DAB(NN)*DUMFX
              FD( 2)=FD( 2)+DAB(NN)*DUMFY
              FD( 3)=FD( 3)+DAB(NN)*DUMFZ
 2530         IF(SKIPJ) GO TO 2550
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FJXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FJXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FJXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!
              IIFINT=IIFINT+3 
              FD( 4)=FD( 4)+DAB(NN)*DUMFX
              FD( 5)=FD( 5)+DAB(NN)*DUMFY
              FD( 6)=FD( 6)+DAB(NN)*DUMFZ
 2550         IF(SKIPK) GO TO 2570
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FKXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FKXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FKXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!
              IIFINT=IIFINT+3
              FD( 7)=FD( 7)+DAB(NN)*DUMFX
              FD( 8)=FD( 8)+DAB(NN)*DUMFY
              FD( 9)=FD( 9)+DAB(NN)*DUMFZ
 2570         IF(SKIPL) GO TO 2600
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FLXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FLXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FLXYZ(IGR,NZ)*XY(IGR)
              ENDDO
!  
              IIFINT=IIFINT+3
              FD(10)=FD(10)+DAB(NN)*DUMFX
              FD(11)=FD(11)+DAB(NN)*DUMFY
              FD(12)=FD(12)+DAB(NN)*DUMFZ
 2600         CONTINUE
!
 2610       CONTINUE
 2620     CONTINUE
 2630   CONTINUE
 2640 CONTINUE
!
!     ----- ZEROTH AND FIRST DERIVATIVE INTEGRALS -----
!
!     REMOVE NEXT RETURN FOR STORING EACH INTEGRAL CONTRIBUTION
      RETURN
!
      IJKLN=0
      DO 3640 I=MINI,MAXI
        IS=SPI.AND.I.EQ.1
!
        JMAX=MAXJ
        IF(IIEQJJ) JMAX=I
        DO 3630 J=MINJ,JMAX
          JS=SPJ.AND.J.EQ.1
!
          IF(JS) THEN
             IF(IS) THEN
                DO IGR=1,NG*NR
                  SJ(IGR)=DIJSJ(IGR)*DIJSI(IGR)
                ENDDO
             ELSE
                DO IGR=1,NG*NR
                  SJ(IGR)=DIJSJ(IGR)
                ENDDO
             ENDIF
          ELSE
             IF(IS) THEN
                DO IGR=1,NG*NR
                  SJ(IGR)=DIJSI(IGR)
                ENDDO
             ENDIF
          ENDIF
          IJS=IS.OR.JS
!
          KMAX=MAXK
          IF(IJEQKL) KMAX=I
          DO 3620 K=MINK,KMAX
            KS=SPK.AND.K.EQ.1
!
            IF(KS) THEN
               IF(IJS) THEN
                  DO IGR=1,NG*NR
                    SK(IGR)=DKLSK(IGR)*SJ(IGR)
                  ENDDO
               ELSE
                  DO IGR=1,NG*NR
                    SK(IGR)=DKLSK(IGR)
                  ENDDO
               ENDIF
            ELSE
               IF(IJS) THEN
                  DO IGR=1,NG*NR
                    SK(IGR)=SJ(IGR)
                  ENDDO
               ENDIF
            ENDIF
            IJKS=IJS.OR.KS
!
            LMAX=MAXL
            IF(KKEQLL           ) LMAX=K
            IF(IJEQKL.AND.K.EQ.I) LMAX=J
            DO 3610 L=MINL,LMAX
              LS=SPL.AND.L.EQ.1
!
              IF(LS) THEN
                 IF(IJKS) THEN
                    DO IGR=1,NG*NR
                      SL(IGR)=DKLSL(IGR)*SK(IGR)
                    ENDDO
                 ELSE
                    DO IGR=1,NG*NR
                      SL(IGR)=DKLSL(IGR)
                    ENDDO
                 ENDIF
              ELSE
                 IF(IJKS) THEN
                    DO IGR=1,NG*NR
                      SL(IGR)=SK(IGR)
                    ENDDO
                 ENDIF
              ENDIF
              IJKLS=IJKS.OR.LS
!
              IJKLN=IJKLN+1
              NN=IJKLG(1,IJKLN)
              NX=IJKLG(2,IJKLN)
              NY=IJKLG(3,IJKLN)
              NZ=IJKLG(4,IJKLN)
!
              IF(IJKLS) THEN
                 DO IGR=1,NG*NR
                   XY(IGR)=XYZ(IGR,NX)*XYZ(IGR,NY)*SL(IGR)
                   XZ(IGR)=XYZ(IGR,NX)*XYZ(IGR,NZ)*SL(IGR)
                   YZ(IGR)=XYZ(IGR,NY)*XYZ(IGR,NZ)*SL(IGR)
                 ENDDO
              ELSE
                 DO IGR=1,NG*NR
                   XY(IGR)=XYZ(IGR,NX)*XYZ(IGR,NY)
                   XZ(IGR)=XYZ(IGR,NX)*XYZ(IGR,NZ)
                   YZ(IGR)=XYZ(IGR,NY)*XYZ(IGR,NZ)
                 ENDDO
              ENDIF
!
              DUM=ZERO
              DO IGR=1,NG*NR
                DUM=DUM+XYZ(IGR,NX)*YZ(IGR)
              ENDDO
              GIJKL(NN)=GIJKL(NN)+DUM
!
              IF(SKIPI) GO TO 3530
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FIXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FIXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FIXYZ(IGR,NZ)*XY(IGR)
              ENDDO
              FIJKL( 1,NN)=FIJKL( 1,NN)+DUMFX
              FIJKL( 2,NN)=FIJKL( 2,NN)+DUMFY
              FIJKL( 3,NN)=FIJKL( 3,NN)+DUMFZ
 3530         IF(SKIPJ) GO TO 3550
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FJXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FJXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FJXYZ(IGR,NZ)*XY(IGR)
              ENDDO
              FIJKL( 4,NN)=FIJKL( 4,NN)+DUMFX
              FIJKL( 5,NN)=FIJKL( 5,NN)+DUMFY
              FIJKL( 6,NN)=FIJKL( 6,NN)+DUMFZ
 3550         IF(SKIPK) GO TO 3570
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FKXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FKXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FKXYZ(IGR,NZ)*XY(IGR)
              ENDDO
              FIJKL( 7,NN)=FIJKL( 7,NN)+DUMFX
              FIJKL( 8,NN)=FIJKL( 8,NN)+DUMFY
              FIJKL( 9,NN)=FIJKL( 9,NN)+DUMFZ
 3570         IF(SKIPL) GO TO 3600
              DUMFX =ZERO
              DUMFY =ZERO
              DUMFZ =ZERO
              DO IGR=1,NG*NR
                DUMFX =DUMFX + FLXYZ(IGR,NX)*YZ(IGR)
                DUMFY =DUMFY + FLXYZ(IGR,NY)*XZ(IGR)
                DUMFZ =DUMFZ + FLXYZ(IGR,NZ)*XY(IGR)
              ENDDO
              FIJKL(10,NN)=FIJKL(10,NN)+DUMFX
              FIJKL(11,NN)=FIJKL(11,NN)+DUMFY
              FIJKL(12,NN)=FIJKL(12,NN)+DUMFZ
 3600         CONTINUE
!
 3610       CONTINUE
 3620     CONTINUE
 3630   CONTINUE
 3640 CONTINUE
!-----------------------------------------------------------------------
      RETURN
      END

! DABNOF2
      SUBROUTINE DABNOF2(II,JJ,KK,LL,PNRM,KKMIN,KKMAX,KLOC,             &
                        IGXYZ,JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,  &
                        IA,DA,DAB,MAXNUM,DABMAX,DAAUX,DAAUX2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      INTEGER,INTENT(IN)::II,JJ,KK,LL
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(4,35),INTENT(IN)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(NBF),INTENT(IN)::IA
      INTEGER,INTENT(IN)::MAXNUM
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(IN)::DA
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(IN)::DAAUX,DAAUX2
      DOUBLE PRECISION,INTENT(OUT)::DABMAX
      DOUBLE PRECISION,DIMENSION(84),INTENT(IN)::PNRM
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(OUT)::DAB
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00,PT5=0.5D+00
!-----------------------------------------------------------------------
      DABMAX=ZER         
!
!     GET 2e DENSITY FOR THIS SHELL BLOCK
!
      MINI= KKMIN(II)
      MINJ= KKMIN(JJ)
      MINK= KKMIN(KK)
      MINL= KKMIN(LL)
      LOCI= KLOC(II)-MINI
      LOCJ= KLOC(JJ)-MINJ
      LOCK= KLOC(KK)-MINK
      LOCL= KLOC(LL)-MINL
      MAXI= KKMAX(II)
      MAXJ= KKMAX(JJ)
      MAXK= KKMAX(KK)
      MAXL= KKMAX(LL)
         DO I=MINI,MAXI
            P1I = PNRM(I)
            JMAX= MAXJ
            IF(IIEQJJ) JMAX= I
            DO J=MINJ,JMAX
               P2J = P1I*PNRM(J)
               IAJ= MAX0(LOCI+I,LOCJ+J)
               IIJ= MIN0(LOCI+I,LOCJ+J)
               KMMAX=MAXK
               IF(IJEQKL) KMMAX= I
               DO K=MINK,KMMAX
                  P3K = P2J*PNRM(K)
                  LMAX= MAXL
                  IF(KKEQLL) LMAX= K
                  IF(IJEQKL .AND. K.EQ.I) LMAX= J
                  DO L=MINL,LMAX
                     P4L= P3K*PNRM(L)
                     KAL= MAX0(LOCK+K,LOCL+L)
                     KIL= MIN0(LOCK+K,LOCL+L)
                     IN = IAJ
                     JN = IIJ
                     KN = KAL
                     LN = KIL
                     IF(IN.LT.KN .OR.(IN.EQ.KN .AND. JN.LT.LN)) THEN
                        IN = KAL
                        JN = KIL
                        KN = IAJ
                        LN = IIJ
                     ENDIF
                     IJ = IA(IN)+JN
                     IK = IA(IN)+KN
                     IL = IA(IN)+LN
                     JK = IA(MAX0(JN,KN))+MIN0(JN,KN)
                     JL = IA(JN)+LN
                     IF(JN.LT.KN) JL = IA(MAX0(JN,LN))+MIN0(JN,LN)
                     KL = IA(KN)+LN
!                    CONTRACT OVER THE 2nd NO COEFFICIENT
                     DF1=ZER
                     DQ1=ZER
                     DO LQ=1,NBF5
                      DF1 = DF1 + DAAUX(LQ,KL)*DA(LQ,IJ)
                      DQ1 = DQ1 + DAAUX2(LQ,JK)*DA(LQ,IL)
                      DQ1 = DQ1 + DAAUX2(LQ,JL)*DA(LQ,IK)
                     ENDDO
!                    BUILD THE DENSITY TERM SUMMING COULOMB-LIKE
!                    AND EXCHANGE-LIKE PARTS
                     DF1 = DF1 + DF1 - DQ1
!                    AVOID DOUBLE COUNTING OF DIAGONAL TERMS                     
                     IF(JN.EQ.IN               ) DF1= DF1*PT5
                     IF(LN.EQ.KN               ) DF1= DF1*PT5
                     IF(KN.EQ.IN .AND. LN.EQ.JN) DF1= DF1*PT5
                     IF(DABMAX.LT. ABS(DF1)) DABMAX= ABS(DF1)
! IGXYZ AND J, K, AND L ARE SET UP IN JKDNDX
                     IJKL=IGXYZ(1,I)+JGXYZ(1,J)+KGXYZ(1,K)+LGXYZ(1,L)
                     DAB(IJKL)= DF1*P4L
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
!-----------------------------------------------------------------------
      RETURN
      END        

! DABNOF2PRE
      SUBROUTINE DABNOF2PRE(CJ12,CK12,RO,DA,DAAUX,DAAUX2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5),INTENT(IN)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(IN)::DA
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(OUT)::DAAUX,DAAUX2
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00
!-----------------------------------------------------------------------
!      
!     FIRST CONTRACT OVER ONE NATURAL ORBITAL COEFFICIENT
!
      DAAUX=ZER
      DAAUX2=ZER
       DO IJ=1,NBFT
        DO LP=1,NBF5
          DAAUX(LP,IJ) = DAAUX(LP,IJ) + RO(LP)*DA(LP,IJ)
          DO LQ=1,LP-1
            DAAUX(LQ,IJ) = DAAUX(LQ,IJ) + CJ12(LP,LQ)*DA(LP,IJ)
            DAAUX2(LQ,IJ) = DAAUX2(LQ,IJ) + CK12(LP,LQ)*DA(LP,IJ)
          ENDDO
          DO LQ=LP+1,NBF5
            DAAUX(LQ,IJ) = DAAUX(LQ,IJ) + CJ12(LP,LQ)*DA(LP,IJ)
            DAAUX2(LQ,IJ) = DAAUX2(LQ,IJ) + CK12(LP,LQ)*DA(LP,IJ)
          ENDDO
        ENDDO
       ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! DABNOF5PRE
      SUBROUTINE DABNOF5PRE(RO,DA,CJAUX,CKAUX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Extended (Nc>1): NBF5 = NBF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(NBF5)::BETA
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(IN)::DA
      DOUBLE PRECISION,DIMENSION(NBFT)::DENS5
      DOUBLE PRECISION,DIMENSION(NDOC,NBFT)::DAAUX2
      DOUBLE PRECISION,DIMENSION(NCO,NBFT)::DAAUX
      DOUBLE PRECISION,DIMENSION(NBFT,NBFT),INTENT(OUT)::CJAUX,CKAUX
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,NBF5
        BETA(i)=DSQRT(RO(i))
      ENDDO
!     DENS5 AND DAAUX ARE RELATED WITH (NN-DELTA)
!     DAAUX2 IS RELATED TO PI MATRIX
      DENS5=ZER
      DAAUX=ZER
      DAAUX2=ZER
      CJAUX = ZER
      CKAUX = ZER
      DO IJ=1,NBFT
!     ADD HF-LIKE TERMS FROM FROZEN COEFFICIENTS      
       DO LP=1,NO1
          DENS5(IJ) = DENS5(IJ) + RO(LP)*DA(LP,IJ)
          DAAUX(LP,IJ) = DAAUX(LP,IJ) + RO(LP)*DA(LP,IJ)
       ENDDO
       DO j=1,NDOC
        jn = NO1+j
        DENS5(IJ)=DENS5(IJ)+RO(jn)*DA(jn,IJ)
        DAAUX(jn,IJ)=DAAUX(jn,IJ)+RO(jn)*DA(jn,IJ)
        DAAUX2(j,IJ)=DAAUX2(j,IJ)-BETA(jn)*DA(jn,IJ)
        DO i=NDOC+NCWO*(NDOC-j)+1,NDOC+NCWO*(NDOC-j+1)
          in = NO1+i
          DENS5(IJ)=DENS5(IJ)+RO(in)*DA(in,IJ)
          DAAUX(jn,IJ)=DAAUX(jn,IJ)+RO(in)*DA(in,IJ)
          DAAUX2(j,IJ)=DAAUX2(j,IJ)+BETA(in)*DA(in,IJ)
        ENDDO
       ENDDO
!       
       DO KL=1,IJ
        CJAUX(IJ,KL) = DENS5(IJ)*DENS5(KL)
        DO IG=1,NDOC
         IGG = IG + NO1
         CJAUX(IJ,KL) = CJAUX(IJ,KL) - DAAUX(IGG,IJ)*DAAUX(IGG,KL)
         CKAUX(IJ,KL) = CKAUX(IJ,KL) + DAAUX2(IG,IJ)*DAAUX2(IG,KL)
        ENDDO
! AACOMP        
        CKAUX(IJ,KL) = CJAUX(IJ,KL) - CKAUX(IJ,KL)
        CJAUX(IJ,KL) = CJAUX(IJ,KL) + CJAUX(IJ,KL)
! SYMMETRY IN AO INDICES         
        CKAUX(KL,IJ) = CKAUX(IJ,KL)
        CJAUX(KL,IJ) = CJAUX(IJ,KL)
       ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! DABNOF7PRE
      SUBROUTINE DABNOF7PRE(RO,DA,CJAUX,CKAUX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPNOF_STATIC/Ista
      COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Extended (Nc>1): NBF5 = NBF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(NBF5)::BETA
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(IN)::DA
      DOUBLE PRECISION,DIMENSION(NBFT)::DENS5,DENS7
      DOUBLE PRECISION,DIMENSION(NDOC,NBFT)::DAAUX2,DAAUX3
      DOUBLE PRECISION,DIMENSION(NCO,NBFT)::DAAUX
      DOUBLE PRECISION,DIMENSION(NBFT,NBFT),INTENT(OUT)::CJAUX,CKAUX
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::FIs
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,NBF5
        BETA(i)=DSQRT(RO(i))
      ENDDO
      ALLOCATE(FIs(NBF5))
      FIs = 0.0d0      
      if(Ista==0)then
       DO j=NO1+1,NBF5
        FIs(j) = DSQRT( RO(j)*(1.0d0-RO(j)) )
       ENDDO
      else if(Ista==1)then
       DO j=NO1+1,NBF5
        FIs(j) = 2.0d0*RO(j)*(1.0d0-RO(j))
       ENDDO
      end if
!
      DENS5=ZER
      DENS7=ZER
      DAAUX=ZER
      DAAUX2=ZER
      DAAUX3=ZER
      CJAUX = ZER
      CKAUX = ZER
      DO IJ=1,NBFT
       DO LP=1,NO1
          DENS5(IJ) = DENS5(IJ) + RO(LP)*DA(LP,IJ)
          DAAUX(LP,IJ) = DAAUX(LP,IJ) + RO(LP)*DA(LP,IJ)
       ENDDO
       DO j=1,NDOC
        jn = NO1+j
        DENS5(IJ)=DENS5(IJ)+RO(jn)*DA(jn,IJ)
        DENS7(IJ)=DENS7(IJ)+FIs(jn)*DA(jn,IJ)
        DAAUX(jn,IJ)=DAAUX(jn,IJ)+RO(jn)*DA(jn,IJ)
        DAAUX2(j,IJ)=DAAUX2(j,IJ)-BETA(jn)*DA(jn,IJ)
        DAAUX3(j,IJ)=DAAUX3(j,IJ)+FIs(jn)*DA(jn,IJ)
        DO i=NDOC+NCWO*(NDOC-j)+1,NDOC+NCWO*(NDOC-j+1)
          in = NO1+i
          DENS5(IJ)=DENS5(IJ)+RO(in)*DA(in,IJ)
          DENS7(IJ)=DENS7(IJ)+FIs(in)*DA(in,IJ)
          DAAUX(jn,IJ)=DAAUX(jn,IJ)+RO(in)*DA(in,IJ)
          DAAUX2(j,IJ)=DAAUX2(j,IJ)+BETA(in)*DA(in,IJ)
          DAAUX3(j,IJ)=DAAUX3(j,IJ)+FIs(in)*DA(in,IJ)
        ENDDO
       ENDDO
!       
       DO KL=1,IJ
        CJAUX(IJ,KL) = DENS5(IJ)*DENS5(KL)
        CKAUX(IJ,KL) = - DENS7(IJ)*DENS7(KL)
        DO IG=1,NDOC
         IGG = IG + NO1
         CJAUX(IJ,KL) = CJAUX(IJ,KL) - DAAUX(IGG,IJ)*DAAUX(IGG,KL)
         CKAUX(IJ,KL) = CKAUX(IJ,KL) + DAAUX2(IG,IJ)*DAAUX2(IG,KL)
         CKAUX(IJ,KL) = CKAUX(IJ,KL) + DAAUX3(IG,IJ)*DAAUX3(IG,KL)
        ENDDO
! AACOMP
        CKAUX(IJ,KL) = CJAUX(IJ,KL) - CKAUX(IJ,KL)
        CJAUX(IJ,KL) = CJAUX(IJ,KL) + CJAUX(IJ,KL)
! SYMMETRY IN AO INDICES
        CKAUX(KL,IJ) = CKAUX(IJ,KL)
        CJAUX(KL,IJ) = CJAUX(IJ,KL)
       ENDDO
      ENDDO
      DEALLOCATE(FIs)
!-----------------------------------------------------------------------
      RETURN
      END

! DABNOF5
      SUBROUTINE DABNOF5(II,JJ,KK,LL,PNRM,KKMIN,KKMAX,KLOC,             &
                        IGXYZ,JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,  &
                        IA,DAB,MAXNUM,DABMAX,CJAUX,CKAUX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::II,JJ,KK,LL
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(4,35),INTENT(IN)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(NBF),INTENT(IN)::IA
      INTEGER,INTENT(IN)::MAXNUM
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      DOUBLE PRECISION,DIMENSION(NBFT,NBFT),INTENT(IN)::CJAUX,CKAUX
      DOUBLE PRECISION,INTENT(OUT)::DABMAX
      DOUBLE PRECISION,DIMENSION(84),INTENT(IN)::PNRM
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(OUT)::DAB
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00,PT5=0.5D+00
!-----------------------------------------------------------------------
      DABMAX=ZER         
!
!     GET 2e DENSITY FOR THIS SHELL BLOCK
!
      MINI= KKMIN(II)
      MINJ= KKMIN(JJ)
      MINK= KKMIN(KK)
      MINL= KKMIN(LL)
      LOCI= KLOC(II)-MINI
      LOCJ= KLOC(JJ)-MINJ
      LOCK= KLOC(KK)-MINK
      LOCL= KLOC(LL)-MINL
      MAXI= KKMAX(II)
      MAXJ= KKMAX(JJ)
      MAXK= KKMAX(KK)
      MAXL= KKMAX(LL)
         DO I=MINI,MAXI
            P1I = PNRM(I)
            JMAX= MAXJ
            IF(IIEQJJ) JMAX= I
            DO J=MINJ,JMAX
               P2J = P1I*PNRM(J)
               IAJ= MAX0(LOCI+I,LOCJ+J)
               IIJ= MIN0(LOCI+I,LOCJ+J)
               KMMAX=MAXK
               IF(IJEQKL) KMMAX= I
               DO K=MINK,KMMAX
                  P3K = P2J*PNRM(K)
                  LMAX= MAXL
                  IF(KKEQLL) LMAX= K
                  IF(IJEQKL .AND. K.EQ.I) LMAX= J
                  DO L=MINL,LMAX
                     P4L= P3K*PNRM(L)
                     KAL= MAX0(LOCK+K,LOCL+L)
                     KIL= MIN0(LOCK+K,LOCL+L)
                     IN = IAJ
                     JN = IIJ
                     KN = KAL
                     LN = KIL
                     IF(IN.LT.KN .OR.(IN.EQ.KN .AND. JN.LT.LN)) THEN
                        IN = KAL
                        JN = KIL
                        KN = IAJ
                        LN = IIJ
                     ENDIF
                     IJ = IA(IN)+JN
                     IK = IA(IN)+KN
                     IL = IA(IN)+LN
                     JK = IA(MAX0(JN,KN))+MIN0(JN,KN)
                     JL = IA(JN)+LN
                     IF(JN.LT.KN) JL = IA(MAX0(JN,LN))+MIN0(JN,LN)
                     KL = IA(KN)+LN
                     DF1 = ZER
                     DQ1 = ZER
                     DF1 = CJAUX(IJ,KL)
                     DQ1 = CKAUX(JK,IL) + CKAUX(JL,IK)
                     DF1 = DF1 + DF1 - DQ1
!                    AVOID DOUBLE COUNTING OF DIAGONAL TERMS                     
                     IF(JN.EQ.IN               ) DF1= DF1*PT5
                     IF(LN.EQ.KN               ) DF1= DF1*PT5
                     IF(KN.EQ.IN .AND. LN.EQ.JN) DF1= DF1*PT5
                     IF(DABMAX.LT. ABS(DF1)) DABMAX= ABS(DF1)
! IGXYZ AND J, K, AND L ARE SET UP IN JKDNDX
                     IJKL=IGXYZ(1,I)+JGXYZ(1,J)+KGXYZ(1,K)+LGXYZ(1,L)
                     DAB(IJKL)= DF1*P4L
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
!-----------------------------------------------------------------------
      RETURN
      END      

! SQUARETRIAN2
      SUBROUTINE SQUARETRIAN2(FM,F,N,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::FM
      DOUBLE PRECISION,DIMENSION(NT)::F
!-----------------------------------------------------------------------
!     PUT SQUARE FM IN TRIANGULAR FORM F
!-----------------------------------------------------------------------
      NZ=0
      DO I=1,N
       DO J=1,I
        NZ=NZ+1
        F(NZ)=FM(I,J)+FM(I,J)
       ENDDO
!      DOUBLE COUNTING OF DIAGONAL TERMS IS SKIPPED IN DABCLU
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! SQUARETRIAN3
      SUBROUTINE SQUARETRIAN3(FM,F,N,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N,N)::FM
      DOUBLE PRECISION,DIMENSION(N,NT)::F
      NZ=0
      DO I=1,N
       DO J=1,I
        NZ=NZ+1
        F(:,NZ)=FM(:,I,J)+FM(:,J,I)
       ENDDO
!      AVOIDING DOUBLE DIAGONAL COUNTING IN DABNOF       
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END      

! TRACEs
      SUBROUTINE TRACEs(E,AA,EEPS,N,NL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N),INTENT(IN)::AA
      DOUBLE PRECISION,DIMENSION(NL),INTENT(IN)::EEPS
      DOUBLE PRECISION,INTENT(OUT)::E
      E = 0.0D+0
      KL = 0
      DO K=1,N
       DO L=1,K
        KL = KL + 1
        E = E + AA(K,L)*EEPS(KL)
       ENDDO
       E = E - AA(K,K)*EEPS(KL)*0.5d0
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! VINTNOF
      SUBROUTINE VINTNOF(NI,NJ,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ,            &
                         XINT,YINT,ZINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER,INTENT(IN)::NI,NJ
      DOUBLE PRECISION,INTENT(IN)::T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ
      DOUBLE PRECISION,INTENT(OUT)::XINT,YINT,ZINT
      INTEGER,DIMENSION(7)::IIMIN,IIMAX
      DOUBLE PRECISION,DIMENSION(55)::HTOTAL,WTOTAL
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00
!
      DATA IIMIN /1,2,4,7,11,16,22/
      DATA IIMAX /1,3,6,10,15,21,28/
!
!     ----- GAUSS-HERMITE QUADRATURE USING MINIMUM POINT FORMULA -----
!
      CALL SETHERMITE(HTOTAL,WTOTAL)
      XINT = ZERO
      YINT = ZERO
      ZINT = ZERO
      NPTS = (NI+NJ-2)/2+1
      IMIN = IIMIN(NPTS)
      IMAX = IIMAX(NPTS)
      DO I = IMIN,IMAX
         DUM = WTOTAL(I)
         PX = DUM
         PY = DUM
         PZ = DUM
         DUM = HTOTAL(I)*T
         PTX = DUM+X0
         PTY = DUM+Y0
         PTZ = DUM+Z0
         AX = PTX-XI
         AY = PTY-YI
         AZ = PTZ-ZI
         BX = PTX-XJ
         BY = PTY-YJ
         BZ = PTZ-ZJ
         IF(PX+AX .EQ. PX) AX = ZERO
         IF(PY+AY .EQ. PY) AY = ZERO
         IF(PZ+AZ .EQ. PZ) AZ = ZERO
         IF(PX+BX .EQ. PX) BX = ZERO
         IF(PY+BY .EQ. PY) BY = ZERO
         IF(PZ+BZ .EQ. PZ) BZ = ZERO
         GO TO (180,164, 162, 160,140,120,100),NI
!
  100    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  120    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  140    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  160    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  162    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  164    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  180    GO TO (320,310,300,280,260,240,220,200),NJ
!
  200    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  220    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  240    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  260    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  280    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  300    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  310    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  320    CONTINUE
         XINT = XINT+PX
         YINT = YINT+PY
         ZINT = ZINT+PZ
      ENDDO
!-----------------------------------------------------------------------  
      RETURN
      END

! DERINOF
      SUBROUTINE DERINOF(DXDI,DYDI,DZDI,X,Y,Z,LIT,LJT,AI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(5,1),INTENT(OUT)::DXDI,DYDI,DZDI
      DOUBLE PRECISION,DIMENSION(6,5),INTENT(IN)::X,Y,Z
      DOUBLE PRECISION,INTENT(IN)::AI
      INTEGER,INTENT(IN)::LIT,LJT
!
!     ----- DXDI ... -----
!
      DO J=1,LJT
        DXDI(1,J)=X(2,J)*(AI+AI)
        DYDI(1,J)=Y(2,J)*(AI+AI)
        DZDI(1,J)=Z(2,J)*(AI+AI)
      ENDDO
!
      IF(LIT.EQ.1) RETURN
!
      DO I=2,LIT
        DO J=1,LJT
          DXDI(I,J)=X(I+1,J)*(AI+AI) - X(I-1,J)*(I-1)
          DYDI(I,J)=Y(I+1,J)*(AI+AI) - Y(I-1,J)*(I-1)
          DZDI(I,J)=Z(I+1,J)*(AI+AI) - Z(I-1,J)*(I-1)
        ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! DVINTNOF
      SUBROUTINE DVINTNOF(NI,NJ,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ,           &
                          CX,CY,CZ,XINT,YINT,ZINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER,INTENT(IN)::NI,NJ
      DOUBLE PRECISION,INTENT(IN)::T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ,CX,CY,CZ
      DOUBLE PRECISION,INTENT(OUT)::XINT,YINT,ZINT
      INTEGER,DIMENSION(7)::IIMIN,IIMAX
      DOUBLE PRECISION,DIMENSION(55)::HTOTAL,WTOTAL
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00
!
      DATA IIMIN /1,2,4,7,11,16,22/
      DATA IIMAX /1,3,6,10,15,21,28/
!
!     ----- GAUSS-HERMITE QUADRATURE USING MINIMUM POINT FORMULA -----
!
      CALL SETHERMITE(HTOTAL,WTOTAL)      
      XINT = ZERO
      YINT = ZERO
      ZINT = ZERO
      NPTS = (NI+NJ+1-2)/2+1
      IMIN = IIMIN(NPTS)
      IMAX = IIMAX(NPTS)
      DO I = IMIN,IMAX
         DUM = HTOTAL(I)*T
         PTX = DUM+X0
         PTY = DUM+Y0
         PTZ = DUM+Z0
         PX = PTX-CX
         PY = PTY-CY
         PZ = PTZ-CZ
         AX = PTX-XI
         AY = PTY-YI
         AZ = PTZ-ZI
         BX = PTX-XJ
         BY = PTY-YJ
         BZ = PTZ-ZJ
         GO TO (180,170,160,140,120,100),NI
!
  100    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  120    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  140    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  160    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  170    PX = PX*AX
         PY = PY*AY
         PZ = PZ*AZ
  180    GO TO (320,300,280,260,240,220,200),NJ
!
  200    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  220    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  240    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  260    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  280    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  300    PX = PX*BX
         PY = PY*BY
         PZ = PZ*BZ
  320    DUM = WTOTAL(I)
         XINT = XINT+DUM*PX
         YINT = YINT+DUM*PY
         ZINT = ZINT+DUM*PZ
      ENDDO
!-----------------------------------------------------------------------  
      RETURN
      END      

! DTXYZNOF
      SUBROUTINE DTXYZNOF(XT,YT,ZT,XS,YS,ZS,NI,NJ,AJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,INTENT(IN)::NI,NJ
      DOUBLE PRECISION,INTENT(IN)::AJ
      DOUBLE PRECISION,DIMENSION(6,5),INTENT(OUT)::XT,YT,ZT
      DOUBLE PRECISION,DIMENSION(6,7),INTENT(IN)::XS,YS,ZS
      DOUBLE PRECISION,PARAMETER::THREE=3.0D+00
!
      DO I=1,NI
        XT(I,1)=(XS(I,1  )       - XS(I,3  )*(AJ+AJ))*AJ
        YT(I,1)=(YS(I,1  )       - YS(I,3  )*(AJ+AJ))*AJ
        ZT(I,1)=(ZS(I,1  )       - ZS(I,3  )*(AJ+AJ))*AJ
      ENDDO
!
      IF(NJ.EQ.1) RETURN
!
      DO I=1,NI
        XT(I,2)=(XS(I,2  )*THREE - XS(I,4  )*(AJ+AJ))*AJ
        YT(I,2)=(YS(I,2  )*THREE - YS(I,4  )*(AJ+AJ))*AJ
        ZT(I,2)=(ZS(I,2  )*THREE - ZS(I,4  )*(AJ+AJ))*AJ
      ENDDO
!
      IF(NJ.EQ.2) RETURN
!
      DO J=3,NJ
        FACT1 = J+J-1
        FACT2 = (J-1)*(J-2)
        FACT2 = FACT2/2
        DO I=1,NI
          XT(I,J)=(XS(I,J  )*FACT1 - XS(I,J+2)*(AJ+AJ))*AJ   &
                                   - XS(I,J-2)*FACT2
          YT(I,J)=(YS(I,J  )*FACT1 - YS(I,J+2)*(AJ+AJ))*AJ   &
                                   - YS(I,J-2)*FACT2
          ZT(I,J)=(ZS(I,J  )*FACT1 - ZS(I,J+2)*(AJ+AJ))*AJ   &
                                   - ZS(I,J-2)*FACT2
        ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! RT123NOF
      SUBROUTINE RT123NOF(X,NROOTS,UAUX,WAUX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION,INTENT(IN)::X
      INTEGER,INTENT(IN)::NROOTS
      DOUBLE PRECISION,DIMENSION(13),INTENT(OUT)::UAUX,WAUX
      DOUBLE PRECISION,DIMENSION(13)::U,W
!      
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
!
      DATA R12,PIE4/2.75255128608411D-01, 7.85398163397448D-01/
      DATA R22,W22/ 2.72474487139158D+00, 9.17517095361369D-02/
      DATA R13/     1.90163509193487D-01/
      DATA R23,W23/ 1.78449274854325D+00, 1.77231492083829D-01/
      DATA R33,W33/ 5.52534374226326D+00, 5.11156880411248D-03/
!-----------------------------------------------------------------------     
!      
      IF (X .GT. 5.0D+00) GO TO 400
      IF (X .GT. 1.0D+00) GO TO 280
      IF (X .GT. 3.0D-07) GO TO 180
!     X IS APPROXIMATELY ZERO.         NROOTS=1,2, OR 3
      IF (NROOTS-2) 120,140,160
  120 RT1 = 0.5D+00 -X/5.0D+00
      WW1 = 1.0D+00 -X/3.0D+00
      UAUX=U
      WAUX=W
      RETURN
  140 RT1 = 1.30693606237085D-01 -2.90430236082028D-02 *X
      RT2 = 2.86930639376291D+00 -6.37623643058102D-01 *X
      WW1 = 6.52145154862545D-01 -1.22713621927067D-01 *X
      WW2 = 3.47854845137453D-01 -2.10619711404725D-01 *X
      UAUX=U
      WAUX=W
      RETURN
  160 RT1 = 6.03769246832797D-02 -9.28875764357368D-03 *X
      RT2 = 7.76823355931043D-01 -1.19511285527878D-01 *X
      RT3 = 6.66279971938567D+00 -1.02504611068957D+00 *X
      WW1 = 4.67913934572691D-01 -5.64876917232519D-02 *X
      WW2 = 3.60761573048137D-01 -1.49077186455208D-01 *X
      WW3 = 1.71324492379169D-01 -1.27768455150979D-01 *X
      UAUX=U
      WAUX=W
      RETURN
!     X = 0.0 TO 1.0                   NROOTS=1,2, OR 3
  180 IF (NROOTS .EQ. 3) GO TO 220
      F1 = ((((((((-8.36313918003957D-08*X+1.21222603512827D-06 )*X-    &
          1.15662609053481D-05 )*X+9.25197374512647D-05 )*X-            &
          6.40994113129432D-04 )*X+3.78787044215009D-03 )*X-            &
          1.85185172458485D-02 )*X+7.14285713298222D-02 )*X-            &
          1.99999999997023D-01 )*X+3.33333333333318D-01                 
      WW1 = (X+X)*F1+EXP(-X)                                            
      IF (NROOTS .EQ. 2) GO TO 200                                      
      RT1 = F1/(WW1-F1)                                                 
      UAUX=U                                                            
      WAUX=W                                                            
      RETURN                                                            
  200 RT1 = (((((((-2.35234358048491D-09*X+2.49173650389842D-08)*X-     &
          4.558315364581D-08)*X-2.447252174587D-06)*X+                  &
          4.743292959463D-05)*X-5.33184749432408D-04 )*X+               &
          4.44654947116579D-03 )*X-2.90430236084697D-02 )*X+            &
          1.30693606237085D-01                                          
      RT2 = (((((((-2.47404902329170D-08*X+2.36809910635906D-07)*X+     &
          1.835367736310D-06)*X-2.066168802076D-05)*X-                  &
          1.345693393936D-04)*X-5.88154362858038D-05 )*X+               &
          5.32735082098139D-02 )*X-6.37623643056745D-01 )*X+            &
          2.86930639376289D+00
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      UAUX=U
      WAUX=W
      RETURN
  220 RT1 = ((((((-5.10186691538870D-10*X+2.40134415703450D-08)*X-      &
          5.01081057744427D-07 )*X+7.58291285499256D-06 )*X-            &
          9.55085533670919D-05 )*X+1.02893039315878D-03 )*X-            &
          9.28875764374337D-03 )*X+6.03769246832810D-02                 
      RT2 = ((((((-1.29646524960555D-08*X+7.74602292865683D-08)*X+      &
          1.56022811158727D-06 )*X-1.58051990661661D-05 )*X-            &
          3.30447806384059D-04 )*X+9.74266885190267D-03 )*X-            &
          1.19511285526388D-01 )*X+7.76823355931033D-01                 
      RT3 = ((((((-9.28536484109606D-09*X-3.02786290067014D-07)*X-      &
         2.50734477064200D-06 )*X-7.32728109752881D-06 )*X+             &
         2.44217481700129D-04 )*X+4.94758452357327D-02 )*X-             &
         1.02504611065774D+00 )*X+6.66279971938553D+00             
      F2 = ((((((((-7.60911486098850D-08*X+1.09552870123182D-06 )*X-    &
          1.03463270693454D-05 )*X+8.16324851790106D-05 )*X-            &
          5.55526624875562D-04 )*X+3.20512054753924D-03 )*X-            &
          1.51515139838540D-02 )*X+5.55555554649585D-02 )*X-            &
          1.42857142854412D-01 )*X+1.99999999999986D-01
  240 E = EXP(-X)
      F1 = ((X+X)*F2+E)/3.0D+00
      WW1 = (X+X)*F1+E
  260 T1 = RT1/(RT1+1.0D+00)
      T2 = RT2/(RT2+1.0D+00)
      T3 = RT3/(RT3+1.0D+00)
      A2 = F2-T1*F1
      A1 = F1-T1*WW1
      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1))
      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1))
      WW1 = WW1-WW2-WW3
      UAUX=U
      WAUX=W
      RETURN
  280 IF (X .GT. 3.0D+00) GO TO 340
!     X = 1.0 TO 3.0                   NROOTS=1,2, OR 3
      Y = X-2.0D+00
      IF (NROOTS .EQ. 3) GO TO 320
      F1 = ((((((((((-1.61702782425558D-10*Y+1.96215250865776D-09 )*Y-  &
           2.14234468198419D-08 )*Y+2.17216556336318D-07 )*Y-           &
           1.98850171329371D-06 )*Y+1.62429321438911D-05 )*Y-           &
           1.16740298039895D-04 )*Y+7.24888732052332D-04 )*Y-           &
           3.79490003707156D-03 )*Y+1.61723488664661D-02 )*Y-           &
           5.29428148329736D-02 )*Y+1.15702180856167D-01              
      WW1 = (X+X)*F1+EXP(-X)                                           
      IF (NROOTS .EQ. 2) GO TO 300                                     
      RT1 = F1/(WW1-F1)
      UAUX=U
      WAUX=W
      RETURN
  300 RT1 = (((((((((-6.36859636616415D-12*Y+8.47417064776270D-11)*Y-   &
           5.152207846962D-10)*Y-3.846389873308D-10)*Y+                 &
           8.472253388380D-08)*Y-1.85306035634293D-06 )*Y+              &
           2.47191693238413D-05 )*Y-2.49018321709815D-04 )*Y+           &
           2.19173220020161D-03 )*Y-1.63329339286794D-02 )*Y+           &
           8.68085688285261D-02                                         
      RT2 = ((((((((( 1.45331350488343D-10*Y+2.07111465297976D-09)*Y-   &
           1.878920917404D-08)*Y-1.725838516261D-07)*Y+                 &
           2.247389642339D-06)*Y+9.76783813082564D-06 )*Y-              &
           1.93160765581969D-04 )*Y-1.58064140671893D-03 )*Y+           &
           4.85928174507904D-02 )*Y-4.30761584997596D-01 )*Y+           &
           1.80400974537950D+00                                       
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      UAUX=U
      WAUX=W
      RETURN
  320 RT1 = (((((((( 1.44687969563318D-12*Y+4.85300143926755D-12)*Y-    &
           6.55098264095516D-10 )*Y+1.56592951656828D-08 )*Y-           &
           2.60122498274734D-07 )*Y+3.86118485517386D-06 )*Y-           &
           5.13430986707889D-05 )*Y+6.03194524398109D-04 )*Y-           &
           6.11219349825090D-03 )*Y+4.52578254679079D-02                
      RT2 = ((((((( 6.95964248788138D-10*Y-5.35281831445517D-09)*Y-     &
           6.745205954533D-08)*Y+1.502366784525D-06)*Y+                 &
           9.923326947376D-07)*Y-3.89147469249594D-04 )*Y+              &
           7.51549330892401D-03 )*Y-8.48778120363400D-02 )*Y+           &
           5.73928229597613D-01                                         
      RT3 = ((((((((-2.81496588401439D-10*Y+3.61058041895031D-09)*Y+    &
           4.53631789436255D-08 )*Y-1.40971837780847D-07 )*Y-           &
           6.05865557561067D-06 )*Y-5.15964042227127D-05 )*Y+           &
           3.34761560498171D-05 )*Y+5.04871005319119D-02 )*Y-           &
           8.24708946991557D-01 )*Y+4.81234667357205D+00                
      F2 = ((((((((((-1.48044231072140D-10*Y+1.78157031325097D-09 )*Y-  &
           1.92514145088973D-08 )*Y+1.92804632038796D-07 )*Y-           &
           1.73806555021045D-06 )*Y+1.39195169625425D-05 )*Y-           &
           9.74574633246452D-05 )*Y+5.83701488646511D-04 )*Y-           &
           2.89955494844975D-03 )*Y+1.13847001113810D-02 )*Y-           &
           3.23446977320647D-02 )*Y+5.29428148329709D-02               
      GO TO 240                                                        
!     X = 3.0 TO 5.0                   NROOTS =1,2, OR 3               
  340 Y = X-4.0D+00
      IF (NROOTS .EQ. 3) GO TO 380
      F1 = ((((((((((-2.62453564772299D-11*Y+3.24031041623823D-10 )*Y-  &
           3.614965656163D-09)*Y+3.760256799971D-08)*Y-                 &
           3.553558319675D-07)*Y+3.022556449731D-06)*Y-                 &
           2.290098979647D-05)*Y+1.526537461148D-04)*Y-                 &
           8.81947375894379D-04 )*Y+4.33207949514611D-03 )*Y-           &
           1.75257821619926D-02 )*Y+5.28406320615584D-02                
      WW1 = (X+X)*F1+EXP(-X)                                             
      IF (NROOTS .EQ. 2) GO TO 360                                       
      RT1 = F1/(WW1-F1)                                                 
      UAUX=U                                                            
      WAUX=W                                                            
      RETURN                                                            
  360 RT1 = ((((((((-4.11560117487296D-12*Y+7.10910223886747D-11)*Y-    &
              1.73508862390291D-09 )*Y+5.93066856324744D-08 )*Y-        &
              9.76085576741771D-07 )*Y+1.08484384385679D-05 )*Y-        &
              1.12608004981982D-04 )*Y+1.16210907653515D-03 )*Y-        &
              9.89572595720351D-03 )*Y+6.12589701086408D-02             
      RT2 = (((((((((-1.80555625241001D-10*Y+5.44072475994123D-10)*Y+   &
           1.603498045240D-08)*Y-1.497986283037D-07)*Y-                 &
           7.017002532106D-07)*Y+1.85882653064034D-05 )*Y-              &
           2.04685420150802D-05 )*Y-2.49327728643089D-03 )*Y+           &
           3.56550690684281D-02 )*Y-2.60417417692375D-01 )*Y+           &
           1.12155283108289D+00                                        
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                   
      WW1 = WW1-WW2                                                     
      UAUX=U
      WAUX=W
      RETURN
  380 RT1 = ((((((( 1.44265709189601D-11*Y-4.66622033006074D-10)*Y+     &
          7.649155832025D-09)*Y-1.229940017368D-07)*Y+                  &
          2.026002142457D-06)*Y-2.87048671521677D-05 )*Y+               &
          3.70326938096287D-04 )*Y-4.21006346373634D-03 )*Y+            &
          3.50898470729044D-02
      RT2 = ((((((((-2.65526039155651D-11*Y+1.97549041402552D-10)*Y+    &
           2.15971131403034D-09 )*Y-7.95045680685193D-08 )*Y+           &
           5.15021914287057D-07 )*Y+1.11788717230514D-05 )*Y-           &
           3.33739312603632D-04 )*Y+5.30601428208358D-03 )*Y-           &
           5.93483267268959D-02 )*Y+4.31180523260239D-01
      RT3 = ((((((((-3.92833750584041D-10*Y-4.16423229782280D-09)*Y+    &
           4.42413039572867D-08 )*Y+6.40574545989551D-07 )*Y-           &
           3.05512456576552D-06 )*Y-1.05296443527943D-04 )*Y-           &
           6.14120969315617D-04 )*Y+4.89665802767005D-02 )*Y-           &
           6.24498381002855D-01 )*Y+3.36412312243724D+00
      F2 = ((((((((((-2.36788772599074D-11*Y+2.89147476459092D-10 )*Y-  &
           3.18111322308846D-09 )*Y+3.25336816562485D-08 )*Y-           &
           3.00873821471489D-07 )*Y+2.48749160874431D-06 )*Y-           &
           1.81353179793672D-05 )*Y+1.14504948737066D-04 )*Y-           &
           6.10614987696677D-04 )*Y+2.64584212770942D-03 )*Y-           &
           8.66415899015349D-03 )*Y+1.75257821619922D-02                
      GO TO 240                                                         
  400 IF (X .GT. 15.0D+00) GO TO 560                                    
      E = EXP(-X)
      IF (X .GT. 10.0D+00) GO TO 480
!     X = 5.0 TO 10.0                  NROOTS =1,2, OR 3
      WW1 = (((((( 4.6897511375022D-01/X-6.9955602298985D-01)/X +       &
          5.3689283271887D-01)/X-3.2883030418398D-01)/X +               &
          2.4645596956002D-01)/X-4.9984072848436D-01)/X -               &
          3.1501078774085D-06)*E + SQRT(PIE4/X)                        
      F1 = (WW1-E)/(X+X)
      IF (NROOTS-2) 420,440,460
  420 RT1 = F1/(WW1-F1)
      UAUX=U
      WAUX=W
      RETURN
  440 Y = X-7.5D+00
      RT1 = (((((((((((((-1.43632730148572D-16*Y+2.38198922570405D-16)* &
             Y+1.358319618800D-14)*Y-7.064522786879D-14)*Y-             &
             7.719300212748D-13)*Y+7.802544789997D-12)*Y+               &
             6.628721099436D-11)*Y-1.775564159743D-09)*Y+               &
             1.713828823990D-08)*Y-1.497500187053D-07)*Y+               &
             2.283485114279D-06)*Y-3.76953869614706D-05 )*Y+            &
             4.74791204651451D-04 )*Y-4.60448960876139D-03 )*Y+         &
             3.72458587837249D-02                                      
      RT2 = (((((((((((( 2.48791622798900D-14*Y-1.36113510175724D-13)*Y-&
            2.224334349799D-12)*Y+4.190559455515D-11)*Y-                &
            2.222722579924D-10)*Y-2.624183464275D-09)*Y+                &
            6.128153450169D-08)*Y-4.383376014528D-07)*Y-                &
            2.49952200232910D-06 )*Y+1.03236647888320D-04 )*Y-          &
            1.44614664924989D-03 )*Y+1.35094294917224D-02 )*Y-          &
            9.53478510453887D-02 )*Y+5.44765245686790D-01               
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)                    
      WW1 = WW1-WW2
      UAUX=U
      WAUX=W
      RETURN
  460 F2 = (F1+F1+F1-E)/(X+X)
      Y = X-7.5D+00
      RT1 = ((((((((((( 5.74429401360115D-16*Y+7.11884203790984D-16)*Y- &
           6.736701449826D-14)*Y-6.264613873998D-13)*Y+                 &
           1.315418927040D-11)*Y-4.23879635610964D-11 )*Y+              &
           1.39032379769474D-09 )*Y-4.65449552856856D-08 )*Y+           &
           7.34609900170759D-07 )*Y-1.08656008854077D-05 )*Y+           &
           1.77930381549953D-04 )*Y-2.39864911618015D-03 )*Y+           &
           2.39112249488821D-02                                          
      RT2 = ((((((((((( 1.13464096209120D-14*Y+6.99375313934242D-15)*Y- &
          8.595618132088D-13)*Y-5.293620408757D-12)*Y-                  &
          2.492175211635D-11)*Y+2.73681574882729D-09 )*Y-               &
          1.06656985608482D-08 )*Y-4.40252529648056D-07 )*Y+            &
          9.68100917793911D-06 )*Y-1.68211091755327D-04 )*Y+            &
          2.69443611274173D-03 )*Y-3.23845035189063D-02 )*Y+            &
          2.75969447451882D-01
      RT3 = (((((((((((( 6.66339416996191D-15*Y+1.84955640200794D-13)*Y-&
           1.985141104444D-12)*Y-2.309293727603D-11)*Y+                 &
           3.917984522103D-10)*Y+1.663165279876D-09)*Y-                 &
           6.205591993923D-08)*Y+8.769581622041D-09)*Y+                 &
           8.97224398620038D-06 )*Y-3.14232666170796D-05 )*Y-           &
           1.83917335649633D-03 )*Y+3.51246831672571D-02 )*Y-           &
           3.22335051270860D-01 )*Y+1.73582831755430D+00                 
      GO TO 260                                                          
!     X = 10.0 TO 15.0                 NROOTS=1,2, OR 3
  480 WW1 = (((-1.8784686463512D-01/X+2.2991849164985D-01)/X -          &
            4.9893752514047D-01)/X-2.1916512131607D-05)*E + SQRT(PIE4/X)
      F1 = (WW1-E)/(X+X)
      IF (NROOTS-2) 500,520,540
  500 RT1 = F1/(WW1-F1)
      UAUX=U
      WAUX=W
      RETURN
  520 RT1 = ((((-1.01041157064226D-05*X+1.19483054115173D-03)*X -       &
           6.73760231824074D-02)*X+1.25705571069895D+00)*X + (((-       &
           8.57609422987199D+03/X+5.91005939591842D+03)/X -             &
           1.70807677109425D+03)/X+2.64536689959503D+02)/X -            &
           2.38570496490846D+01)*E + R12/(X-R12)
      RT2 = ((( 3.39024225137123D-04*X-9.34976436343509D-02)*X -        &
           4.22216483306320D+00)*X + (((-2.08457050986847D+03/X -       &
           1.04999071905664D+03)/X+3.39891508992661D+02)/X -            &
           1.56184800325063D+02)/X+8.00839033297501D+00)*E + R22/(X-R22) 
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      UAUX=U
      WAUX=W
      RETURN
  540 F2 = (F1+F1+F1-E)/(X+X)
      Y = X-12.5D+00
      RT1 = ((((((((((( 4.42133001283090D-16*Y-2.77189767070441D-15)*Y- &
           4.084026087887D-14)*Y+5.379885121517D-13)*Y+                 &
           1.882093066702D-12)*Y-8.67286219861085D-11 )*Y+              &
           7.11372337079797D-10 )*Y-3.55578027040563D-09 )*Y+           &
           1.29454702851936D-07 )*Y-4.14222202791434D-06 )*Y+           &
           8.04427643593792D-05 )*Y-1.18587782909876D-03 )*Y+           &
           1.53435577063174D-02                                         
      RT2 = ((((((((((( 6.85146742119357D-15*Y-1.08257654410279D-14)*Y- &
          8.579165965128D-13)*Y+6.642452485783D-12)*Y+                  &
          4.798806828724D-11)*Y-1.13413908163831D-09 )*Y+               &
          7.08558457182751D-09 )*Y-5.59678576054633D-08 )*Y+            &
          2.51020389884249D-06 )*Y-6.63678914608681D-05 )*Y+            &
          1.11888323089714D-03 )*Y-1.45361636398178D-02 )*Y+            &
          1.65077877454402D-01
      RT3 = (((((((((((( 3.20622388697743D-15*Y-2.73458804864628D-14)*Y-&
           3.157134329361D-13)*Y+8.654129268056D-12)*Y-                 &
           5.625235879301D-11)*Y-7.718080513708D-10)*Y+                 &
           2.064664199164D-08)*Y-1.567725007761D-07)*Y-                 &
           1.57938204115055D-06 )*Y+6.27436306915967D-05 )*Y-           &
           1.01308723606946D-03 )*Y+1.13901881430697D-02 )*Y-           &
           1.01449652899450D-01 )*Y+7.77203937334739D-01                 
      GO TO 260                                                          
  560 IF (X .GT. 33.0D+00) GO TO 660
!     X = 15.0 TO 33.0                 NROOTS=1,2, OR 3
      E = EXP(-X)
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -           &
            6.0156581186481D-05)*E + SQRT(PIE4/X)
      F1 = (WW1-E)/(X+X)
      IF (NROOTS-2) 580,600,620
  580 RT1 = F1/(WW1-F1)
      UAUX=U
      WAUX=W
      RETURN
  600 RT1 = ((((-1.14906395546354D-06*X+1.76003409708332D-04)*X -       &
           1.71984023644904D-02)*X-1.37292644149838D-01)*X + (-         &
           4.75742064274859D+01/X+9.21005186542857D+00)/X -             &
           2.31080873898939D-02)*E + R12/(X-R12)                        
      RT2 = ((( 3.64921633404158D-04*X-9.71850973831558D-02)*X -        &
           4.02886174850252D+00)*X + (-1.35831002139173D+02/X -         &
           8.66891724287962D+01)/X+2.98011277766958D+00)*E + R22/(X-R22)
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      UAUX=U
      WAUX=W
      RETURN
  620 F2 = (F1+F1+F1-E)/(X+X)
      IF (X .GT. 20.0D+00) GO TO 640
      RT1 = ((((((-2.43270989903742D-06*X+3.57901398988359D-04)*X -     &
           2.34112415981143D-02)*X+7.81425144913975D-01)*X -            &
           1.73209218219175D+01)*X+2.43517435690398D+02)*X + (-         &
           1.97611541576986D+04/X+9.82441363463929D+03)/X -             &
           2.07970687843258D+03)*E + R13/(X-R13)                        
      RT2 = (((((-2.62627010965435D-04*X+3.49187925428138D-02)*X -      &
          3.09337618731880D+00)*X+1.07037141010778D+02)*X -             &
          2.36659637247087D+03)*X + ((-2.91669113681020D+06/X +         &
          1.41129505262758D+06)/X-2.91532335433779D+05)/X +             &
          3.35202872835409D+04)*E + R23/(X-R23)                         
      RT3 = ((((( 9.31856404738601D-05*X-2.87029400759565D-02)*X -      &
          7.83503697918455D-01)*X-1.84338896480695D+01)*X +             &
          4.04996712650414D+02)*X + (-1.89829509315154D+05/X +          &
          5.11498390849158D+04)/X-6.88145821789955D+03)*E + R33/(X-R33)
      GO TO 260
  640 RT1 = ((((-4.97561537069643D-04*X-5.00929599665316D-02)*X +       &
           1.31099142238996D+00)*X-1.88336409225481D+01)*X -            &
           6.60344754467191D+02 /X+1.64931462413877D+02)*E + R13/(X-R13)
      RT2 = ((((-4.48218898474906D-03*X-5.17373211334924D-01)*X +       &
           1.13691058739678D+01)*X-1.65426392885291D+02)*X -            &
           6.30909125686731D+03 /X+1.52231757709236D+03)*E + R23/(X-R23)
      RT3 = ((((-1.38368602394293D-02*X-1.77293428863008D+00)*X +       &
         1.73639054044562D+01)*X-3.57615122086961D+02)*X -              &
         1.45734701095912D+04 /X+2.69831813951849D+03)*E + R33/(X-R33)
      GO TO 260
!     X = 33.0 TO INFINITY             NROOTS=1,2, OR 3
  660 WW1 = SQRT(PIE4/X)
      IF (NROOTS-2) 680,700,720
  680 RT1 = 0.5D+00/(X-0.5D+00)
      UAUX=U
      WAUX=W
      RETURN
  700 IF (X .GT. 40.0D+00) GO TO 740
      E = EXP(-X)
      RT1 = (-8.78947307498880D-01*X+1.09243702330261D+01)*E + R12/(X-  &
           R12)                                                         
      RT2 = (-9.28903924275977D+00*X+8.10642367843811D+01)*E + R22/(X-  &
           R22)                                                        
      WW2 = ( 4.46857389308400D+00*X-7.79250653461045D+01)*E + W22*WW1 
      WW1 = WW1-WW2                                                    
      UAUX=U
      WAUX=W
      RETURN
  720 IF (X .GT. 47.0D+00) GO TO 760
      E = EXP(-X)
      RT1 = ((-7.39058467995275D+00*X+3.21318352526305D+02)*X -         &
          3.99433696473658D+03)*E + R13/(X-R13)                         
      RT2 = ((-7.38726243906513D+01*X+3.13569966333873D+03)*X -         &
          3.86862867311321D+04)*E + R23/(X-R23)                         
      RT3 = ((-2.63750565461336D+02*X+1.04412168692352D+04)*X -         &
          1.28094577915394D+05)*E + R33/(X-R33)                         
      WW3 = ((( 1.52258947224714D-01*X-8.30661900042651D+00)*X +        &
          1.92977367967984D+02)*X-1.67787926005344D+03)*E + W33*WW1      
      WW2 = (( 6.15072615497811D+01*X-2.91980647450269D+03)*X +         &
           3.80794303087338D+04)*E + W23*WW1                         
      WW1 = WW1-WW2-WW3
      UAUX=U
      WAUX=W
      RETURN
  740 RT1 = R12/(X-R12)
      RT2 = R22/(X-R22)
      WW2 = W22*WW1
      WW1 = WW1-WW2
      UAUX=U
      WAUX=W
      RETURN
  760 RT1 = R13/(X-R13)
      RT2 = R23/(X-R23)
      RT3 = R33/(X-R33)
      WW2 = W23*WW1
      WW3 = W33*WW1
      WW1 = WW1-WW2-WW3
!-----------------------------------------------------------------------  
      UAUX=U
      WAUX=W
      RETURN
      END
      
! ROOT4NOF
      SUBROUTINE ROOT4NOF(X,UAUX,WAUX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION,INTENT(IN)::X
      DOUBLE PRECISION,DIMENSION(13),INTENT(OUT)::UAUX,WAUX
      DOUBLE PRECISION,DIMENSION(13)::U,W
!
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
!
      DATA R14,PIE4/1.45303521503316D-01, 7.85398163397448D-01/
      DATA R24,W24/ 1.33909728812636D+00, 2.34479815323517D-01/
      DATA R34,W34/ 3.92696350135829D+00, 1.92704402415764D-02/
      DATA R44,W44/ 8.58863568901199D+00, 2.25229076750736D-04/      
!-----------------------------------------------------------------------
      IF (X .GT. 15.0D+00) GO TO 180
      IF (X .GT. 5.0D+00) GO TO 140
      IF (X .GT. 1.0D+00) GO TO 120
      IF (X .GT. 3.0D-07) GO TO 100
!     X IS APPROXIMATELY ZERO.                   NROOTS = 4
      RT1 = 3.48198973061471D-02 -4.09645850660395D-03 *X
      RT2 = 3.81567185080042D-01 -4.48902570656719D-02 *X
      RT3 = 1.73730726945891D+00 -2.04389090547327D-01 *X
      RT4 = 1.18463056481549D+01 -1.39368301742312D+00 *X
      WW1 = 3.62683783378362D-01 -3.13844305713928D-02 *X
      WW2 = 3.13706645877886D-01 -8.98046242557724D-02 *X
      WW3 = 2.22381034453372D-01 -1.29314370958973D-01 *X
      WW4 = 1.01228536290376D-01 -8.28299075414321D-02 *X
      UAUX=U
      WAUX=W
      RETURN
!
!     X=0.0 TO 1.0                               NROOTS = 4
  100 RT1 = ((((((-1.95309614628539D-10*X+5.19765728707592D-09)*X-      &
              1.01756452250573D-07 )*X+1.72365935872131D-06 )*X-        &
              2.61203523522184D-05 )*X+3.52921308769880D-04 )*X-        &
              4.09645850658433D-03 )*X+3.48198973061469D-02             
      RT2 = (((((-1.89554881382342D-08*X+3.07583114342365D-07)*X+       &
             1.270981734393D-06)*X-1.417298563884D-04)*X+               &
             3.226979163176D-03)*X-4.48902570678178D-02 )*X+            &
             3.81567185080039D-01                                       
      RT3 = (((((( 1.77280535300416D-09*X+3.36524958870615D-08)*X-      &
             2.58341529013893D-07 )*X-1.13644895662320D-05 )*X-         &
             7.91549618884063D-05 )*X+1.03825827346828D-02 )*X-         &
             2.04389090525137D-01 )*X+1.73730726945889D+00              
      RT4 = (((((-5.61188882415248D-08*X-2.49480733072460D-07)*X+       &
             3.428685057114D-06)*X+1.679007454539D-04)*X+               &
             4.722855585715D-02)*X-1.39368301737828D+00 )*X+            &
             1.18463056481543D+01                                       
      WW1 = ((((((-1.14649303201279D-08*X+1.88015570196787D-07)*X-      &
            2.33305875372323D-06 )*X+2.68880044371597D-05 )*X-          &
            2.94268428977387D-04 )*X+3.06548909776613D-03 )*X-          &
            3.13844305680096D-02 )*X+3.62683783378335D-01
      WW2 = ((((((((-4.11720483772634D-09*X+6.54963481852134D-08)*X-    &
             7.20045285129626D-07 )*X+6.93779646721723D-06 )*X-         &
             6.05367572016373D-05 )*X+4.74241566251899D-04 )*X-         &
             3.26956188125316D-03 )*X+1.91883866626681D-02 )*X-         &
             8.98046242565811D-02 )*X+3.13706645877886D-01              
      WW3 = ((((((((-3.41688436990215D-08*X+5.07238960340773D-07)*X-    &
             5.01675628408220D-06 )*X+4.20363420922845D-05 )*X-         &
             3.08040221166823D-04 )*X+1.94431864731239D-03 )*X-         &
             1.02477820460278D-02 )*X+4.28670143840073D-02 )*X-         &
             1.29314370962569D-01 )*X+2.22381034453369D-01
      WW4 = ((((((((( 4.99660550769508D-09*X-7.94585963310120D-08)*X+   &
             8.359072409485D-07)*X-7.422369210610D-06)*X+               &
             5.763374308160D-05)*X-3.86645606718233D-04 )*X+            &
             2.18417516259781D-03 )*X-9.99791027771119D-03 )*X+         &
             3.48791097377370D-02 )*X-8.28299075413889D-02 )*X+         &
             1.01228536290376D-01                                    
      UAUX=U
      WAUX=W
      RETURN
!
!     X= 1.0 TO 5.0                              NROOTS = 4
  120 Y = X-3.0D+00
      RT1 = (((((((((-1.48570633747284D-15*Y-1.33273068108777D-13)*Y+   &
            4.068543696670D-12)*Y-9.163164161821D-11)*Y+                &
            2.046819017845D-09)*Y-4.03076426299031D-08 )*Y+             &
            7.29407420660149D-07 )*Y-1.23118059980833D-05 )*Y+          &
            1.88796581246938D-04 )*Y-2.53262912046853D-03 )*Y+          &
            2.51198234505021D-02                                        
      RT2 = ((((((((( 1.35830583483312D-13*Y-2.29772605964836D-12)*Y-   &
            3.821500128045D-12)*Y+6.844424214735D-10)*Y-                &
            1.048063352259D-08)*Y+1.50083186233363D-08 )*Y+             &
            3.48848942324454D-06 )*Y-1.08694174399193D-04 )*Y+          &
            2.08048885251999D-03 )*Y-2.91205805373793D-02 )*Y+          &
            2.72276489515713D-01                                        
      RT3 = ((((((((( 5.02799392850289D-13*Y+1.07461812944084D-11)*Y-   &
            1.482277886411D-10)*Y-2.153585661215D-09)*Y+                &
            3.654087802817D-08)*Y+5.15929575830120D-07 )*Y-             &
            9.52388379435709D-06 )*Y-2.16552440036426D-04 )*Y+          &
            9.03551469568320D-03 )*Y-1.45505469175613D-01 )*Y+          &
            1.21449092319186D+00                                        
      RT4 = (((((((((-1.08510370291979D-12*Y+6.41492397277798D-11)*Y+   &
            7.542387436125D-10)*Y-2.213111836647D-09)*Y-                &
            1.448228963549D-07)*Y-1.95670833237101D-06 )*Y-             &
            1.07481314670844D-05 )*Y+1.49335941252765D-04 )*Y+          &
            4.87791531990593D-02 )*Y-1.10559909038653D+00 )*Y+          &
            8.09502028611780D+00                                       
      WW1 = ((((((((((-4.65801912689961D-14*Y+7.58669507106800D-13)*Y-  &
            1.186387548048D-11)*Y+1.862334710665D-10)*Y-                &
            2.799399389539D-09)*Y+4.148972684255D-08)*Y-                &
            5.933568079600D-07)*Y+8.168349266115D-06)*Y-                &
            1.08989176177409D-04 )*Y+1.41357961729531D-03 )*Y-          &
            1.87588361833659D-02 )*Y+2.89898651436026D-01               
      WW2 = ((((((((((((-1.46345073267549D-14*Y+2.25644205432182D-13)*Y-&
            3.116258693847D-12)*Y+4.321908756610D-11)*Y-                &
            5.673270062669D-10)*Y+7.006295962960D-09)*Y-                &
            8.120186517000D-08)*Y+8.775294645770D-07)*Y-                &
            8.77829235749024D-06 )*Y+8.04372147732379D-05 )*Y-          &
            6.64149238804153D-04 )*Y+4.81181506827225D-03 )*Y-          &
            2.88982669486183D-02 )*Y+1.56247249979288D-01
      WW3 = ((((((((((((( 9.06812118895365D-15*Y-1.40541322766087D-13)* &
            Y+1.919270015269D-12)*Y-2.605135739010D-11)*Y+              &
            3.299685839012D-10)*Y-3.86354139348735D-09 )*Y+             &
            4.16265847927498D-08 )*Y-4.09462835471470D-07 )*Y+          &
            3.64018881086111D-06 )*Y-2.88665153269386D-05 )*Y+          &
            2.00515819789028D-04 )*Y-1.18791896897934D-03 )*Y+          &
            5.75223633388589D-03 )*Y-2.09400418772687D-02 )*Y+          &
            4.85368861938873D-02                                          
      WW4 = ((((((((((((((-9.74835552342257D-16*Y+1.57857099317175D-14)*&
            Y-2.249993780112D-13)*Y+3.173422008953D-12)*Y-              &
            4.161159459680D-11)*Y+5.021343560166D-10)*Y-                &
            5.545047534808D-09)*Y+5.554146993491D-08)*Y-                &
            4.99048696190133D-07 )*Y+3.96650392371311D-06 )*Y-          &
            2.73816413291214D-05 )*Y+1.60106988333186D-04 )*Y-          &
            7.64560567879592D-04 )*Y+2.81330044426892D-03 )*Y-          &
            7.16227030134947D-03 )*Y+9.66077262223353D-03                 
      UAUX=U
      WAUX=W
      RETURN                                                             
!
  140 IF (X .GT. 10.0D+00) GO TO 160
!     X=5.0 TO 10.0                              NROOTS = 4
      Y = X-7.5D+00
      RT1 = ((((((((( 4.64217329776215D-15*Y-6.27892383644164D-15)*Y+   &
            3.462236347446D-13)*Y-2.927229355350D-11)*Y+                &
            5.090355371676D-10)*Y-9.97272656345253D-09 )*Y+             &
            2.37835295639281D-07 )*Y-4.60301761310921D-06 )*Y+          &
            8.42824204233222D-05 )*Y-1.37983082233081D-03 )*Y+          &
            1.66630865869375D-02                                        
      RT2 = ((((((((( 2.93981127919047D-14*Y+8.47635639065744D-13)*Y-   &
            1.446314544774D-11)*Y-6.149155555753D-12)*Y+                &
            8.484275604612D-10)*Y-6.10898827887652D-08 )*Y+             &
            2.39156093611106D-06 )*Y-5.35837089462592D-05 )*Y+          &
            1.00967602595557D-03 )*Y-1.57769317127372D-02 )*Y+          &
            1.74853819464285D-01                                        
      RT3 = (((((((((( 2.93523563363000D-14*Y-6.40041776667020D-14)*Y-  &
            2.695740446312D-12)*Y+1.027082960169D-10)*Y-                &
            5.822038656780D-10)*Y-3.159991002539D-08)*Y+                &
            4.327249251331D-07)*Y+4.856768455119D-06)*Y-                &
            2.54617989427762D-04 )*Y+5.54843378106589D-03 )*Y-          &
            7.95013029486684D-02 )*Y+7.20206142703162D-01               
      RT4 = (((((((((((-1.62212382394553D-14*Y+7.68943641360593D-13)*Y+ &
            5.764015756615D-12)*Y-1.380635298784D-10)*Y-                &
            1.476849808675D-09)*Y+1.84347052385605D-08 )*Y+             &
            3.34382940759405D-07 )*Y-1.39428366421645D-06 )*Y-          &
            7.50249313713996D-05 )*Y-6.26495899187507D-04 )*Y+          &
            4.69716410901162D-02 )*Y-6.66871297428209D-01 )*Y+          &
            4.11207530217806D+00
      WW1 = ((((((((((-1.65995045235997D-15*Y+6.91838935879598D-14)*Y-  &
            9.131223418888D-13)*Y+1.403341829454D-11)*Y-                &
            3.672235069444D-10)*Y+6.366962546990D-09)*Y-                &
            1.039220021671D-07)*Y+1.959098751715D-06)*Y-                &
            3.33474893152939D-05 )*Y+5.72164211151013D-04 )*Y-          &
            1.05583210553392D-02 )*Y+2.26696066029591D-01               
      WW2 = ((((((((((((-3.57248951192047D-16*Y+6.25708409149331D-15)*Y-&
            9.657033089714D-14)*Y+1.507864898748D-12)*Y-                &
            2.332522256110D-11)*Y+3.428545616603D-10)*Y-                &
            4.698730937661D-09)*Y+6.219977635130D-08)*Y-                &
            7.83008889613661D-07 )*Y+9.08621687041567D-06 )*Y-          &
            9.86368311253873D-05 )*Y+9.69632496710088D-04 )*Y-          &
            8.14594214284187D-03 )*Y+8.50218447733457D-02
      WW3 = ((((((((((((( 1.64742458534277D-16*Y-2.68512265928410D-15)* &
            Y+3.788890667676D-14)*Y-5.508918529823D-13)*Y+              &
            7.555896810069D-12)*Y-9.69039768312637D-11 )*Y+             &
            1.16034263529672D-09 )*Y-1.28771698573873D-08 )*Y+          &
            1.31949431805798D-07 )*Y-1.23673915616005D-06 )*Y+          &
            1.04189803544936D-05 )*Y-7.79566003744742D-05 )*Y+          &
            5.03162624754434D-04 )*Y-2.55138844587555D-03 )*Y+          &
            1.13250730954014D-02                                        
      WW4 = ((((((((((((((-1.55714130075679D-17*Y+2.57193722698891D-16)*&
            Y-3.626606654097D-15)*Y+5.234734676175D-14)*Y-              &
            7.067105402134D-13)*Y+8.793512664890D-12)*Y-                &
            1.006088923498D-10)*Y+1.050565098393D-09)*Y-                &
            9.91517881772662D-09 )*Y+8.35835975882941D-08 )*Y-          &
            6.19785782240693D-07 )*Y+3.95841149373135D-06 )*Y-          &
            2.11366761402403D-05 )*Y+9.00474771229507D-05 )*Y-          &
            2.78777909813289D-04 )*Y+5.26543779837487D-04               
      UAUX=U
      WAUX=W
      RETURN
!
!     X=10.0 TO 15.0                             NROOTS = 4
  160 Y = X-12.5D+00
      RT1 = ((((((((((( 4.94869622744119D-17*Y+8.03568805739160D-16)*Y- &
            5.599125915431D-15)*Y-1.378685560217D-13)*Y+                &
            7.006511663249D-13)*Y+1.30391406991118D-11 )*Y+             &
            8.06987313467541D-11 )*Y-5.20644072732933D-09 )*Y+          &
            7.72794187755457D-08 )*Y-1.61512612564194D-06 )*Y+          &
            4.15083811185831D-05 )*Y-7.87855975560199D-04 )*Y+          &
            1.14189319050009D-02                                         
      RT2 = ((((((((((( 4.89224285522336D-16*Y+1.06390248099712D-14)*Y- &
            5.446260182933D-14)*Y-1.613630106295D-12)*Y+                &
            3.910179118937D-12)*Y+1.90712434258806D-10 )*Y+             &
            8.78470199094761D-10 )*Y-5.97332993206797D-08 )*Y+          &
            9.25750831481589D-07 )*Y-2.02362185197088D-05 )*Y+          &
            4.92341968336776D-04 )*Y-8.68438439874703D-03 )*Y+          &
            1.15825965127958D-01                                         
      RT3 = (((((((((( 6.12419396208408D-14*Y+1.12328861406073D-13)*Y-  &
           9.051094103059D-12)*Y-4.781797525341D-11)*Y+                 &
           1.660828868694D-09)*Y+4.499058798868D-10)*Y-                 &
           2.519549641933D-07)*Y+4.977444040180D-06)*Y-                 &
           1.25858350034589D-04 )*Y+2.70279176970044D-03 )*Y-           &
           3.99327850801083D-02 )*Y+4.33467200855434D-01                
      RT4 = ((((((((((( 4.63414725924048D-14*Y-4.72757262693062D-14)*Y- &
            1.001926833832D-11)*Y+6.074107718414D-11)*Y+                &
            1.576976911942D-09)*Y-2.01186401974027D-08 )*Y-             &
            1.84530195217118D-07 )*Y+5.02333087806827D-06 )*Y+          &
            9.66961790843006D-06 )*Y-1.58522208889528D-03 )*Y+          &
            2.80539673938339D-02 )*Y-2.78953904330072D-01 )*Y+          &
            1.82835655238235D+00                                         
      WW4 = ((((((((((((( 2.90401781000996D-18*Y-4.63389683098251D-17)* &
            Y+6.274018198326D-16)*Y-8.936002188168D-15)*Y+              &
            1.194719074934D-13)*Y-1.45501321259466D-12 )*Y+             &
            1.64090830181013D-11 )*Y-1.71987745310181D-10 )*Y+          &
            1.63738403295718D-09 )*Y-1.39237504892842D-08 )*Y+          &
            1.06527318142151D-07 )*Y-7.27634957230524D-07 )*Y+          &
            4.12159381310339D-06 )*Y-1.74648169719173D-05 )*Y+          &
            8.50290130067818D-05                                         
      WW3 = ((((((((((((-4.19569145459480D-17*Y+5.94344180261644D-16)*Y-&
            1.148797566469D-14)*Y+1.881303962576D-13)*Y-                &
            2.413554618391D-12)*Y+3.372127423047D-11)*Y-                &
            4.933988617784D-10)*Y+6.116545396281D-09)*Y-                &
            6.69965691739299D-08 )*Y+7.52380085447161D-07 )*Y-          &
            8.08708393262321D-06 )*Y+6.88603417296672D-05 )*Y-          &
            4.67067112993427D-04 )*Y+5.42313365864597D-03                
      WW2 = ((((((((((-6.22272689880615D-15*Y+1.04126809657554D-13)*Y-  &
            6.842418230913D-13)*Y+1.576841731919D-11)*Y-                &
            4.203948834175D-10)*Y+6.287255934781D-09)*Y-                &
            8.307159819228D-08)*Y+1.356478091922D-06)*Y-                &
            2.08065576105639D-05 )*Y+2.52396730332340D-04 )*Y-          &
            2.94484050194539D-03 )*Y+6.01396183129168D-02                
      WW1 = (((-1.8784686463512D-01/X+2.2991849164985D-01)/X -          &
            4.9893752514047D-01)/X-2.1916512131607D-05)*EXP(-X) +       &
            SQRT(PIE4/X)-WW4-WW3-WW2                                     
      UAUX=U
      WAUX=W
      RETURN                                                            
!
  180 WW1 = SQRT(PIE4/X)
      IF (X .GT. 35.0D+00) GO TO 220
      IF (X .GT. 20.0D+00) GO TO 200
!     X=15.0 TO 20.0                             NROOTS = 4
      Y = X-17.5D+00
      RT1 = ((((((((((( 4.36701759531398D-17*Y-1.12860600219889D-16)*Y- &
            6.149849164164D-15)*Y+5.820231579541D-14)*Y+                &
            4.396602872143D-13)*Y-1.24330365320172D-11 )*Y+             &
            6.71083474044549D-11 )*Y+2.43865205376067D-10 )*Y+          &
            1.67559587099969D-08 )*Y-9.32738632357572D-07 )*Y+          &
            2.39030487004977D-05 )*Y-4.68648206591515D-04 )*Y+          &
            8.34977776583956D-03                                        
      RT2 = ((((((((((( 4.98913142288158D-16*Y-2.60732537093612D-16)*Y- &
            7.775156445127D-14)*Y+5.766105220086D-13)*Y+                &
            6.432696729600D-12)*Y-1.39571683725792D-10 )*Y+             &
            5.95451479522191D-10 )*Y+2.42471442836205D-09 )*Y+          &
            2.47485710143120D-07 )*Y-1.14710398652091D-05 )*Y+          &
            2.71252453754519D-04 )*Y-4.96812745851408D-03 )*Y+          &
            8.26020602026780D-02                                        
      RT3 = ((((((((((( 1.91498302509009D-15*Y+1.48840394311115D-14)*Y- &
           4.316925145767D-13)*Y+1.186495793471D-12)*Y+                 &
           4.615806713055D-11)*Y-5.54336148667141D-10 )*Y+              &
           3.48789978951367D-10 )*Y-2.79188977451042D-09 )*Y+           &
           2.09563208958551D-06 )*Y-6.76512715080324D-05 )*Y+           &
           1.32129867629062D-03 )*Y-2.05062147771513D-02 )*Y+           &
           2.88068671894324D-01
      RT4 = (((((((((((-5.43697691672942D-15*Y-1.12483395714468D-13)*Y+ &
            2.826607936174D-12)*Y-1.266734493280D-11)*Y-                &
            4.258722866437D-10)*Y+9.45486578503261D-09 )*Y-             &
            5.86635622821309D-08 )*Y-1.28835028104639D-06 )*Y+          &
            4.41413815691885D-05 )*Y-7.61738385590776D-04 )*Y+          &
            9.66090902985550D-03 )*Y-1.01410568057649D-01 )*Y+          &
            9.54714798156712D-01                                        
      WW4 = ((((((((((((-7.56882223582704D-19*Y+7.53541779268175D-18)*Y-&
            1.157318032236D-16)*Y+2.411195002314D-15)*Y-                &
            3.601794386996D-14)*Y+4.082150659615D-13)*Y-                &
            4.289542980767D-12)*Y+5.086829642731D-11)*Y-                &
            6.35435561050807D-10 )*Y+6.82309323251123D-09 )*Y-          &
            5.63374555753167D-08 )*Y+3.57005361100431D-07 )*Y-          &
            2.40050045173721D-06 )*Y+4.94171300536397D-05               
      WW3 = (((((((((((-5.54451040921657D-17*Y+2.68748367250999D-16)*Y+ &
            1.349020069254D-14)*Y-2.507452792892D-13)*Y+                &
            1.944339743818D-12)*Y-1.29816917658823D-11 )*Y+             &
            3.49977768819641D-10 )*Y-8.67270669346398D-09 )*Y+          &
            1.31381116840118D-07 )*Y-1.36790720600822D-06 )*Y+          &
            1.19210697673160D-05 )*Y-1.42181943986587D-04 )*Y+          &
            4.12615396191829D-03
      WW2 = (((((((((((-1.86506057729700D-16*Y+1.16661114435809D-15)*Y+ &
            2.563712856363D-14)*Y-4.498350984631D-13)*Y+                &
            1.765194089338D-12)*Y+9.04483676345625D-12 )*Y+             &
            4.98930345609785D-10 )*Y-2.11964170928181D-08 )*Y+          &
            3.98295476005614D-07 )*Y-5.49390160829409D-06 )*Y+          &
            7.74065155353262D-05 )*Y-1.48201933009105D-03 )*Y+          &
            4.97836392625268D-02                                        
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -           &
            6.0156581186481D-05)*EXP(-X)+WW1-WW2-WW3-WW4
      UAUX=U
      WAUX=W
      RETURN
!
!     X=20.0 TO 35.0                             NROOTS = 4
  200 E = EXP(-X)
      RT1 = ((((((-4.45711399441838D-05*X+1.27267770241379D-03)*X -     &
            2.36954961381262D-01)*X+1.54330657903756D+01)*X -           &
            5.22799159267808D+02)*X+1.05951216669313D+04)*X + (-        &
            2.51177235556236D+06/X+8.72975373557709D+05)/X -            &
            1.29194382386499D+05)*E + R14/(X-R14)                       
      RT2 = (((((-7.85617372254488D-02*X+6.35653573484868D+00)*X -      &
            3.38296938763990D+02)*X+1.25120495802096D+04)*X -           &
            3.16847570511637D+05)*X + ((-1.02427466127427D+09/X +       &
            3.70104713293016D+08)/X-5.87119005093822D+07)/X +           &
            5.38614211391604D+06)*E + R24/(X-R24)
      RT3 = (((((-2.37900485051067D-01*X+1.84122184400896D+01)*X -      &
             1.00200731304146D+03)*X+3.75151841595736D+04)*X -          &
             9.50626663390130D+05)*X + ((-2.88139014651985D+09/X +      &
             1.06625915044526D+09)/X-1.72465289687396D+08)/X +          &
             1.60419390230055D+07)*E + R34/(X-R34)
      RT4 = ((((((-6.00691586407385D-04*X-3.64479545338439D-01)*X +     &
            1.57496131755179D+01)*X-6.54944248734901D+02)*X +           &
            1.70830039597097D+04)*X-2.90517939780207D+05)*X + (+        &
            3.49059698304732D+07/X-1.64944522586065D+07)/X +            &
            2.96817940164703D+06)*E + R44/(X-R44)                       
      IF (X .LE. 25.0D+00) WW4 = ((((((( 2.33766206773151D-07*X-        &
           3.81542906607063D-05)*X +3.51416601267000D-03)*X-            &
           1.66538571864728D-01)*X +4.80006136831847D+00)*X-            &
           8.73165934223603D+01)*X +9.77683627474638D+02)*X +           &
           1.66000945117640D+04/X -6.14479071209961D+03)*E + W44*WW1
      IF (X .GT. 25.0D+00) WW4 = (((((( 5.74245945342286D-06*X-         &
            7.58735928102351D-05)*X +2.35072857922892D-04)*X-           &
            3.78812134013125D-03)*X +3.09871652785805D-01)*X-           &
            7.11108633061306D+00)*X +5.55297573149528D+01)*E + W44*WW1  
      WW3 = (((((( 2.36392855180768D-04*X-9.16785337967013D-03)*X +     &
            4.62186525041313D-01)*X-1.96943786006540D+01)*X +           &
            4.99169195295559D+02)*X-6.21419845845090D+03)*X + ((+       &
            5.21445053212414D+07/X-1.34113464389309D+07)/X +            &
            1.13673298305631D+06)/X-2.81501182042707D+03)*E + W34*WW1   
      WW2 = (((((( 7.29841848989391D-04*X-3.53899555749875D-02)*X +     &
            2.07797425718513D+00)*X-1.00464709786287D+02)*X +           &
            3.15206108877819D+03)*X-6.27054715090012D+04)*X + (+        &
            1.54721246264919D+07/X-5.26074391316381D+06)/X +            &
            7.67135400969617D+05)*E + W24*WW1                           
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -           &
            6.0156581186481D-05)*E + WW1-WW2-WW3-WW4                   
      UAUX=U
      WAUX=W
      RETURN                                                          
!                                                                     
  220 IF (X .GT. 53.0D+00) GO TO 240
!     X=35.0 TO 53.0                             NROOTS = 4
      E = EXP(-X)*(X*X)**2
      RT4 = ((-2.19135070169653D-03*X-1.19108256987623D-01)*X -         &
           7.50238795695573D-01)*E + R44/(X-R44)                        
      RT3 = ((-9.65842534508637D-04*X-4.49822013469279D-02)*X +         &
           6.08784033347757D-01)*E + R34/(X-R34)                        
      RT2 = ((-3.62569791162153D-04*X-9.09231717268466D-03)*X +         &
           1.84336760556262D-01)*E + R24/(X-R24)                        
      RT1 = ((-4.07557525914600D-05*X-6.88846864931685D-04)*X +         &
           1.74725309199384D-02)*E + R14/(X-R14)                        
      WW4 = (( 5.76631982000990D-06*X-7.89187283804890D-05)*X +         &
           3.28297971853126D-04)*E + W44*WW1                            
      WW3 = (( 2.08294969857230D-04*X-3.77489954837361D-03)*X +         &
           2.09857151617436D-02)*E + W34*WW1                            
      WW2 = (( 6.16374517326469D-04*X-1.26711744680092D-02)*X +         &
           8.14504890732155D-02)*E + W24*WW1
      WW1 = WW1-WW2-WW3-WW4
      UAUX=U
      WAUX=W
      RETURN
!
!     X=47.0 TO INFINITY                         NROOTS = 4
  240 RT1 = R14/(X-R14)
      RT2 = R24/(X-R24)
      RT3 = R34/(X-R34)
      RT4 = R44/(X-R44)
      WW4 = W44*WW1
      WW3 = W34*WW1
      WW2 = W24*WW1
      WW1 = WW1-WW2-WW3-WW4
!-----------------------------------------------------------------------  
      UAUX=U
      WAUX=W
      RETURN
      END   
      
! ROOT5NOF
      SUBROUTINE ROOT5NOF(X,UAUX,WAUX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION,INTENT(IN)::X
      DOUBLE PRECISION,DIMENSION(13),INTENT(OUT)::UAUX,WAUX
      DOUBLE PRECISION,DIMENSION(13)::U,W
!
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
!
      DATA R15,PIE4/1.17581320211778D-01, 7.85398163397448D-01/
      DATA R25,W25/ 1.07456201243690D+00, 2.70967405960535D-01/
      DATA R35,W35/ 3.08593744371754D+00, 3.82231610015404D-02/
      DATA R45,W45/ 6.41472973366203D+00, 1.51614186862443D-03/
      DATA R55,W55/ 1.18071894899717D+01, 8.62130526143657D-06/
!-----------------------------------------------------------------------
      IF (X .GT. 15.0D+00) GO TO 180
      IF (X .GT. 5.0D+00) GO TO 140
      IF (X .GT. 1.0D+00) GO TO 120
      IF (X .GT. 3.0D-07) GO TO 100
!     X IS APPROXIMATELY ZERO.                   NROOTS = 5
      RT1 = 2.26659266316985D-02 -2.15865967920897D-03 *X
      RT2 = 2.31271692140903D-01 -2.20258754389745D-02 *X
      RT3 = 8.57346024118836D-01 -8.16520023025515D-02 *X
      RT4 = 2.97353038120346D+00 -2.83193369647137D-01 *X
      RT5 = 1.84151859759051D+01 -1.75382723579439D+00 *X
      WW1 = 2.95524224714752D-01 -1.96867576909777D-02 *X
      WW2 = 2.69266719309995D-01 -5.61737590184721D-02 *X
      WW3 = 2.19086362515981D-01 -9.71152726793658D-02 *X
      WW4 = 1.49451349150580D-01 -1.02979262193565D-01 *X
      WW5 = 6.66713443086877D-02 -5.73782817488315D-02 *X
      UAUX=U
      WAUX=W
      RETURN
!
!     X=0.0 TO 1.0                               NROOTS = 5
  100 RT1 = ((((((-4.46679165328413D-11*X+1.21879111988031D-09)*X-      &
           2.62975022612104D-08 )*X+5.15106194905897D-07 )*X-           &
           9.27933625824749D-06 )*X+1.51794097682482D-04 )*X-           &
           2.15865967920301D-03 )*X+2.26659266316985D-02                
      RT2 = (((((( 1.93117331714174D-10*X-4.57267589660699D-09)*X+      &
           2.48339908218932D-08 )*X+1.50716729438474D-06 )*X-           &
           6.07268757707381D-05 )*X+1.37506939145643D-03 )*X-           &
           2.20258754419939D-02 )*X+2.31271692140905D-01                
      RT3 = ((((( 4.84989776180094D-09*X+1.31538893944284D-07)*X-       &
           2.766753852879D-06)*X-7.651163510626D-05)*X+                 &
           4.033058545972D-03)*X-8.16520022916145D-02 )*X+              &
           8.57346024118779D-01                                         
      RT4 = ((((-2.48581772214623D-07*X-4.34482635782585D-06)*X-        &
           7.46018257987630D-07 )*X+1.01210776517279D-02 )*X-           &
           2.83193369640005D-01 )*X+2.97353038120345D+00                
      RT5 = (((((-8.92432153868554D-09*X+1.77288899268988D-08)*X+       &
           3.040754680666D-06)*X+1.058229325071D-04)*X+                 &
           4.596379534985D-02)*X-1.75382723579114D+00 )*X+              &
           1.84151859759049D+01                                         
      WW1 = ((((((-2.03822632771791D-09*X+3.89110229133810D-08)*X-      &
            5.84914787904823D-07 )*X+8.30316168666696D-06 )*X-          &
            1.13218402310546D-04 )*X+1.49128888586790D-03 )*X-          &
            1.96867576904816D-02 )*X+2.95524224714749D-01               
      WW2 = ((((((( 8.62848118397570D-09*X-1.38975551148989D-07)*X+     &
           1.602894068228D-06)*X-1.646364300836D-05)*X+                 &
           1.538445806778D-04)*X-1.28848868034502D-03 )*X+              &
           9.38866933338584D-03 )*X-5.61737590178812D-02 )*X+           &
           2.69266719309991D-01                                         
      WW3 = ((((((((-9.41953204205665D-09*X+1.47452251067755D-07)*X-    &
           1.57456991199322D-06 )*X+1.45098401798393D-05 )*X-           &
           1.18858834181513D-04 )*X+8.53697675984210D-04 )*X-           &
           5.22877807397165D-03 )*X+2.60854524809786D-02 )*X-           &
           9.71152726809059D-02 )*X+2.19086362515979D-01                
      WW4 = ((((((((-3.84961617022042D-08*X+5.66595396544470D-07)*X-    &
           5.52351805403748D-06 )*X+4.53160377546073D-05 )*X-           &
           3.22542784865557D-04 )*X+1.95682017370967D-03 )*X-           &
           9.77232537679229D-03 )*X+3.79455945268632D-02 )*X-           &
           1.02979262192227D-01 )*X+1.49451349150573D-01                
      WW5 = ((((((((( 4.09594812521430D-09*X-6.47097874264417D-08)*X+   &
           6.743541482689D-07)*X-5.917993920224D-06)*X+                 &
           4.531969237381D-05)*X-2.99102856679638D-04 )*X+              &
           1.65695765202643D-03 )*X-7.40671222520653D-03 )*X+           &
           2.50889946832192D-02 )*X-5.73782817487958D-02 )*X+           &
           6.66713443086877D-02                                      
      UAUX=U
      WAUX=W
      RETURN                                                          
!
!     X=1.0 TO 5.0                               NROOTS = 5
  120 Y = X-3.0D+00
      RT1 = ((((((((-2.58163897135138D-14*Y+8.14127461488273D-13)*Y-    &
           2.11414838976129D-11 )*Y+5.09822003260014D-10 )*Y-           &
           1.16002134438663D-08 )*Y+2.46810694414540D-07 )*Y-           &
           4.92556826124502D-06 )*Y+9.02580687971053D-05 )*Y-           &
           1.45190025120726D-03 )*Y+1.73416786387475D-02                
      RT2 = ((((((((( 1.04525287289788D-14*Y+5.44611782010773D-14)*Y-   &
           4.831059411392D-12)*Y+1.136643908832D-10)*Y-                 &
           1.104373076913D-09)*Y-2.35346740649916D-08 )*Y+              &
           1.43772622028764D-06 )*Y-4.23405023015273D-05 )*Y+           &
           9.12034574793379D-04 )*Y-1.52479441718739D-02 )*Y+           &
           1.76055265928744D-01                                         
      RT3 = (((((((((-6.89693150857911D-14*Y+5.92064260918861D-13)*Y+   &
           1.847170956043D-11)*Y-3.390752744265D-10)*Y-                 &
           2.995532064116D-09)*Y+1.57456141058535D-07 )*Y-              &
           3.95859409711346D-07 )*Y-9.58924580919747D-05 )*Y+           &
           3.23551502557785D-03 )*Y-5.97587007636479D-02 )*Y+           &
           6.46432853383057D-01                                         
      RT4 = ((((((((-3.61293809667763D-12*Y-2.70803518291085D-11)*Y+    &
           8.83758848468769D-10 )*Y+1.59166632851267D-08 )*Y-           &
           1.32581997983422D-07 )*Y-7.60223407443995D-06 )*Y-           &
           7.41019244900952D-05 )*Y+9.81432631743423D-03 )*Y-           &
           2.23055570487771D-01 )*Y+2.21460798080643D+00                
      RT5 = ((((((((( 7.12332088345321D-13*Y+3.16578501501894D-12)*Y-   &
           8.776668218053D-11)*Y-2.342817613343D-09)*Y-                 &
           3.496962018025D-08)*Y-3.03172870136802D-07 )*Y+              &
           1.50511293969805D-06 )*Y+1.37704919387696D-04 )*Y+           &
           4.70723869619745D-02 )*Y-1.47486623003693D+00 )*Y+           &
           1.35704792175847D+01                                         
      WW1 = ((((((((( 1.04348658616398D-13*Y-1.94147461891055D-12)*Y+   &
           3.485512360993D-11)*Y-6.277497362235D-10)*Y+                 &
           1.100758247388D-08)*Y-1.88329804969573D-07 )*Y+              &
           3.12338120839468D-06 )*Y-5.04404167403568D-05 )*Y+           &
           8.00338056610995D-04 )*Y-1.30892406559521D-02 )*Y+           &
           2.47383140241103D-01                                        
      WW2 = ((((((((((( 3.23496149760478D-14*Y-5.24314473469311D-13)*Y+ &
           7.743219385056D-12)*Y-1.146022750992D-10)*Y+                 &
           1.615238462197D-09)*Y-2.15479017572233D-08 )*Y+              &
           2.70933462557631D-07 )*Y-3.18750295288531D-06 )*Y+           &
           3.47425221210099D-05 )*Y-3.45558237388223D-04 )*Y+           &
           3.05779768191621D-03 )*Y-2.29118251223003D-02 )*Y+           &
           1.59834227924213D-01
      WW3 = ((((((((((((-3.42790561802876D-14*Y+5.26475736681542D-13)*Y-&
           7.184330797139D-12)*Y+9.763932908544D-11)*Y-                 &
           1.244014559219D-09)*Y+1.472744068942D-08)*Y-                 &
           1.611749975234D-07)*Y+1.616487851917D-06)*Y-                 &
           1.46852359124154D-05 )*Y+1.18900349101069D-04 )*Y-           &
           8.37562373221756D-04 )*Y+4.93752683045845D-03 )*Y-           &
           2.25514728915673D-02 )*Y+6.95211812453929D-02
      WW4 = ((((((((((((( 1.04072340345039D-14*Y-1.60808044529211D-13)* &
           Y+2.183534866798D-12)*Y-2.939403008391D-11)*Y+               &
           3.679254029085D-10)*Y-4.23775673047899D-09 )*Y+              &
           4.46559231067006D-08 )*Y-4.26488836563267D-07 )*Y+           &
           3.64721335274973D-06 )*Y-2.74868382777722D-05 )*Y+           &
           1.78586118867488D-04 )*Y-9.68428981886534D-04 )*Y+           &
           4.16002324339929D-03 )*Y-1.28290192663141D-02 )*Y+           &
           2.22353727685016D-02                                         
      WW5 = ((((((((((((((-8.16770412525963D-16*Y+1.31376515047977D-14)*&
           Y-1.856950818865D-13)*Y+2.596836515749D-12)*Y-               &
           3.372639523006D-11)*Y+4.025371849467D-10)*Y-                 &
           4.389453269417D-09)*Y+4.332753856271D-08)*Y-                 &
           3.82673275931962D-07 )*Y+2.98006900751543D-06 )*Y-           &
           2.00718990300052D-05 )*Y+1.13876001386361D-04 )*Y-           &
           5.23627942443563D-04 )*Y+1.83524565118203D-03 )*Y-           &
           4.37785737450783D-03 )*Y+5.36963805223095D-03
      UAUX=U
      WAUX=W
      RETURN
!
  140 IF (X .GT. 10.0D+00) GO TO 160
!     X=5.0 TO 10.0                              NROOTS = 5
      Y = X-7.5D+00
      RT1 = ((((((((-1.13825201010775D-14*Y+1.89737681670375D-13)*Y-    &
           4.81561201185876D-12 )*Y+1.56666512163407D-10 )*Y-           &
           3.73782213255083D-09 )*Y+9.15858355075147D-08 )*Y-           &
           2.13775073585629D-06 )*Y+4.56547356365536D-05 )*Y-           &
           8.68003909323740D-04 )*Y+1.22703754069176D-02             
      RT2 = (((((((((-3.67160504428358D-15*Y+1.27876280158297D-14)*Y-   &
           1.296476623788D-12)*Y+1.477175434354D-11)*Y+                 &
           5.464102147892D-10)*Y-2.42538340602723D-08 )*Y+              &
           8.20460740637617D-07 )*Y-2.20379304598661D-05 )*Y+           &
           4.90295372978785D-04 )*Y-9.14294111576119D-03 )*Y+           &
           1.22590403403690D-01                                         
      RT3 = ((((((((( 1.39017367502123D-14*Y-6.96391385426890D-13)*Y+   &
           1.176946020731D-12)*Y+1.725627235645D-10)*Y-                 &
           3.686383856300D-09)*Y+2.87495324207095D-08 )*Y+              &
           1.71307311000282D-06 )*Y-7.94273603184629D-05 )*Y+           &
           2.00938064965897D-03 )*Y-3.63329491677178D-02 )*Y+           &
           4.34393683888443D-01                                         
      RT4 = ((((((((((-1.27815158195209D-14*Y+1.99910415869821D-14)*Y+  &
           3.753542914426D-12)*Y-2.708018219579D-11)*Y-                 &
           1.190574776587D-09)*Y+1.106696436509D-08)*Y+                 &
           3.954955671326D-07)*Y-4.398596059588D-06)*Y-                 &
           2.01087998907735D-04 )*Y+7.89092425542937D-03 )*Y-           &
           1.42056749162695D-01 )*Y+1.39964149420683D+00                
      RT5 = ((((((((((-1.19442341030461D-13*Y-2.34074833275956D-12)*Y+  &
           6.861649627426D-12)*Y+6.082671496226D-10)*Y+                 &
           5.381160105420D-09)*Y-6.253297138700D-08)*Y-                 &
           2.135966835050D-06)*Y-2.373394341886D-05)*Y+                 &
           2.88711171412814D-06 )*Y+4.85221195290753D-02 )*Y-           &
           1.04346091985269D+00 )*Y+7.89901551676692D+00                
      WW1 = ((((((((( 7.95526040108997D-15*Y-2.48593096128045D-13)*Y+   &
           4.761246208720D-12)*Y-9.535763686605D-11)*Y+                 &
           2.225273630974D-09)*Y-4.49796778054865D-08 )*Y+              &
           9.17812870287386D-07 )*Y-1.86764236490502D-05 )*Y+           &
           3.76807779068053D-04 )*Y-8.10456360143408D-03 )*Y+           &
           2.01097936411496D-01                                        
      WW2 = ((((((((((( 1.25678686624734D-15*Y-2.34266248891173D-14)*Y+ &
           3.973252415832D-13)*Y-6.830539401049D-12)*Y+                 &
           1.140771033372D-10)*Y-1.82546185762009D-09 )*Y+              &
           2.77209637550134D-08 )*Y-4.01726946190383D-07 )*Y+           &
           5.48227244014763D-06 )*Y-6.95676245982121D-05 )*Y+           &
           8.05193921815776D-04 )*Y-8.15528438784469D-03 )*Y+           &
           9.71769901268114D-02                                        
      WW3 = ((((((((((((-8.20929494859896D-16*Y+1.37356038393016D-14)*Y-&
           2.022863065220D-13)*Y+3.058055403795D-12)*Y-                 &
           4.387890955243D-11)*Y+5.923946274445D-10)*Y-                 &
           7.503659964159D-09)*Y+8.851599803902D-08)*Y-                 &
           9.65561998415038D-07 )*Y+9.60884622778092D-06 )*Y-           &
           8.56551787594404D-05 )*Y+6.66057194311179D-04 )*Y-           &
           4.17753183902198D-03 )*Y+2.25443826852447D-02
      WW4 = ((((((((((((((-1.08764612488790D-17*Y+1.85299909689937D-16)*&
           Y-2.730195628655D-15)*Y+4.127368817265D-14)*Y-               &
           5.881379088074D-13)*Y+7.805245193391D-12)*Y-                 &
           9.632707991704D-11)*Y+1.099047050624D-09)*Y-                 &
           1.15042731790748D-08 )*Y+1.09415155268932D-07 )*Y-           &
           9.33687124875935D-07 )*Y+7.02338477986218D-06 )*Y-           &
           4.53759748787756D-05 )*Y+2.41722511389146D-04 )*Y-           &
           9.75935943447037D-04 )*Y+2.57520532789644D-03                
      WW5 = ((((((((((((((( 7.28996979748849D-19*Y-1.26518146195173D-17)&
            *Y+1.886145834486D-16)*Y-2.876728287383D-15)*Y+             &
           4.114588668138D-14)*Y-5.44436631413933D-13 )*Y+              &
           6.64976446790959D-12 )*Y-7.44560069974940D-11 )*Y+           &
           7.57553198166848D-10 )*Y-6.92956101109829D-09 )*Y+           &
           5.62222859033624D-08 )*Y-3.97500114084351D-07 )*Y+           &
           2.39039126138140D-06 )*Y-1.18023950002105D-05 )*Y+           &
           4.52254031046244D-05 )*Y-1.21113782150370D-04 )*Y+           &
           1.75013126731224D-04                                        
      UAUX=U
      WAUX=W
      RETURN                                                           
!
!     X=10.0 TO 15.0                             NROOTS = 5
  160 Y = X-12.5D+00
      RT1 = ((((((((((-4.16387977337393D-17*Y+7.20872997373860D-16)*Y+  &
           1.395993802064D-14)*Y+3.660484641252D-14)*Y-                 &
           4.154857548139D-12)*Y+2.301379846544D-11)*Y-                 &
           1.033307012866D-09)*Y+3.997777641049D-08)*Y-                 &
           9.35118186333939D-07 )*Y+2.38589932752937D-05 )*Y-           &
           5.35185183652937D-04 )*Y+8.85218988709735D-03                
      RT2 = ((((((((((-4.56279214732217D-16*Y+6.24941647247927D-15)*Y+  &
           1.737896339191D-13)*Y+8.964205979517D-14)*Y-                 &
           3.538906780633D-11)*Y+9.561341254948D-11)*Y-                 &
           9.772831891310D-09)*Y+4.240340194620D-07)*Y-                 &
           1.02384302866534D-05 )*Y+2.57987709704822D-04 )*Y-           &
           5.54735977651677D-03 )*Y+8.68245143991948D-02                
      RT3 = ((((((((((-2.52879337929239D-15*Y+2.13925810087833D-14)*Y+  &
           7.884307667104D-13)*Y-9.023398159510D-13)*Y-                 &
           5.814101544957D-11)*Y-1.333480437968D-09)*Y-                 &
           2.217064940373D-08)*Y+1.643290788086D-06)*Y-                 &
           4.39602147345028D-05 )*Y+1.08648982748911D-03 )*Y-           &
           2.13014521653498D-02 )*Y+2.94150684465425D-01                
      RT4 = ((((((((((-6.42391438038888D-15*Y+5.37848223438815D-15)*Y+  &
           8.960828117859D-13)*Y+5.214153461337D-11)*Y-                 &
           1.106601744067D-10)*Y-2.007890743962D-08)*Y+                 &
           1.543764346501D-07)*Y+4.520749076914D-06)*Y-                 &
           1.88893338587047D-04 )*Y+4.73264487389288D-03 )*Y-           &
           7.91197893350253D-02 )*Y+8.60057928514554D-01              
      RT5 = (((((((((((-2.24366166957225D-14*Y+4.87224967526081D-14)*Y+ &
           5.587369053655D-12)*Y-3.045253104617D-12)*Y-                 &
           1.223983883080D-09)*Y-2.05603889396319D-09 )*Y+              &
           2.58604071603561D-07 )*Y+1.34240904266268D-06 )*Y-           &
           5.72877569731162D-05 )*Y-9.56275105032191D-04 )*Y+           &
           4.23367010370921D-02 )*Y-5.76800927133412D-01 )*Y+           &
           3.87328263873381D+00
      WW1 = ((((((((( 8.98007931950169D-15*Y+7.25673623859497D-14)*Y+   &
           5.851494250405D-14)*Y-4.234204823846D-11)*Y+                 &
           3.911507312679D-10)*Y-9.65094802088511D-09 )*Y+              &
           3.42197444235714D-07 )*Y-7.51821178144509D-06 )*Y+           &
           1.94218051498662D-04 )*Y-5.38533819142287D-03 )*Y+           &
           1.68122596736809D-01                                       
      WW2 = ((((((((((-1.05490525395105D-15*Y+1.96855386549388D-14)*Y-  &
           5.500330153548D-13)*Y+1.003849567976D-11)*Y-                 &
           1.720997242621D-10)*Y+3.533277061402D-09)*Y-                 &
           6.389171736029D-08)*Y+1.046236652393D-06)*Y-                 &
           1.73148206795827D-05 )*Y+2.57820531617185D-04 )*Y-           &
           3.46188265338350D-03 )*Y+7.03302497508176D-02              
      WW3 = ((((((((((( 3.60020423754545D-16*Y-6.24245825017148D-15)*Y+ &
           9.945311467434D-14)*Y-1.749051512721D-12)*Y+                 &
           2.768503957853D-11)*Y-4.08688551136506D-10 )*Y+              &
           6.04189063303610D-09 )*Y-8.23540111024147D-08 )*Y+           &
           1.01503783870262D-06 )*Y-1.20490761741576D-05 )*Y+           &
           1.26928442448148D-04 )*Y-1.05539461930597D-03 )*Y+           &
           1.15543698537013D-02
      WW4 = ((((((((((((( 2.51163533058925D-18*Y-4.31723745510697D-17)* &
           Y+6.557620865832D-16)*Y-1.016528519495D-14)*Y+               &
           1.491302084832D-13)*Y-2.06638666222265D-12 )*Y+              &
           2.67958697789258D-11 )*Y-3.23322654638336D-10 )*Y+           &
           3.63722952167779D-09 )*Y-3.75484943783021D-08 )*Y+           &
           3.49164261987184D-07 )*Y-2.92658670674908D-06 )*Y+           &
           2.12937256719543D-05 )*Y-1.19434130620929D-04 )*Y+           &
           6.45524336158384D-04                                         
      WW5 = ((((((((((((((-1.29043630202811D-19*Y+2.16234952241296D-18)*&
           Y-3.107631557965D-17)*Y+4.570804313173D-16)*Y-               &
           6.301348858104D-15)*Y+8.031304476153D-14)*Y-                 &
           9.446196472547D-13)*Y+1.018245804339D-11)*Y-                 &
           9.96995451348129D-11 )*Y+8.77489010276305D-10 )*Y-           &
           6.84655877575364D-09 )*Y+4.64460857084983D-08 )*Y-           &
           2.66924538268397D-07 )*Y+1.24621276265907D-06 )*Y-           &
           4.30868944351523D-06 )*Y+9.94307982432868D-06
      UAUX=U
      WAUX=W
      RETURN
!
  180 IF (X .GT. 25.0D+00) GO TO 220
      IF (X .GT. 20.0D+00) GO TO 200
!     X=15.0 TO 20.0                             NROOTS = 5
      Y = X-17.5D+00
      RT1 = (((((((((( 1.91875764545740D-16*Y+7.8357401095707D-16)*Y-   &
           3.260875931644D-14)*Y-1.186752035569D-13)*Y+                 &
           4.275180095653D-12)*Y+3.357056136731D-11)*Y-                 &
           1.123776903884D-09)*Y+1.231203269887D-08)*Y-                 &
           3.99851421361031D-07 )*Y+1.45418822817771D-05 )*Y-           &
           3.49912254976317D-04 )*Y+6.67768703938812D-03              
      RT2 = (((((((((( 2.02778478673555D-15*Y+1.01640716785099D-14)*Y-  &
           3.385363492036D-13)*Y-1.615655871159D-12)*Y+                 &
           4.527419140333D-11)*Y+3.853670706486D-10)*Y-                 &
           1.184607130107D-08)*Y+1.347873288827D-07)*Y-                 &
           4.47788241748377D-06 )*Y+1.54942754358273D-04 )*Y-           &
           3.55524254280266D-03 )*Y+6.44912219301603D-02               
      RT3 = (((((((((( 7.79850771456444D-15*Y+6.00464406395001D-14)*Y-  &
           1.249779730869D-12)*Y-1.020720636353D-11)*Y+                 &
           1.814709816693D-10)*Y+1.766397336977D-09)*Y-                 &
           4.603559449010D-08)*Y+5.863956443581D-07)*Y-                 &
           2.03797212506691D-05 )*Y+6.31405161185185D-04 )*Y-           &
           1.30102750145071D-02 )*Y+2.10244289044705D-01              
      RT4 = (((((((((((-2.92397030777912D-15*Y+1.94152129078465D-14)*Y+ &
           4.859447665850D-13)*Y-3.217227223463D-12)*Y-                 &
           7.484522135512D-11)*Y+7.19101516047753D-10 )*Y+              &
           6.88409355245582D-09 )*Y-1.44374545515769D-07 )*Y+           &
           2.74941013315834D-06 )*Y-1.02790452049013D-04 )*Y+           &
           2.59924221372643D-03 )*Y-4.35712368303551D-02 )*Y+           &
           5.62170709585029D-01
      RT5 = ((((((((((( 1.17976126840060D-14*Y+1.24156229350669D-13)*Y- &
           3.892741622280D-12)*Y-7.755793199043D-12)*Y+                 &
           9.492190032313D-10)*Y-4.98680128123353D-09 )*Y-              &
           1.81502268782664D-07 )*Y+2.69463269394888D-06 )*Y+           &
           2.50032154421640D-05 )*Y-1.33684303917681D-03 )*Y+           &
           2.29121951862538D-02 )*Y-2.45653725061323D-01 )*Y+           &
           1.89999883453047D+00
      WW1 = (((((((((( 1.74841995087592D-15*Y-6.95671892641256D-16)*Y-  &
          3.000659497257D-13)*Y+2.021279817961D-13)*Y+                  &
          3.853596935400D-11)*Y+1.461418533652D-10)*Y-                  &
          1.014517563435D-08)*Y+1.132736008979D-07)*Y-                  &
          2.86605475073259D-06 )*Y+1.21958354908768D-04 )*Y-            &
          3.86293751153466D-03 )*Y+1.45298342081522D-01               
      WW2 = ((((((((((-1.11199320525573D-15*Y+1.85007587796671D-15)*Y+  &
          1.220613939709D-13)*Y+1.275068098526D-12)*Y-                  &
          5.341838883262D-11)*Y+6.161037256669D-10)*Y-                  &
          1.009147879750D-08)*Y+2.907862965346D-07)*Y-                  &
          6.12300038720919D-06 )*Y+1.00104454489518D-04 )*Y-            &
          1.80677298502757D-03 )*Y+5.78009914536630D-02               
      WW3 = ((((((((((-9.49816486853687D-16*Y+6.67922080354234D-15)*Y+  &
          2.606163540537D-15)*Y+1.983799950150D-12)*Y-                  &
          5.400548574357D-11)*Y+6.638043374114D-10)*Y-                  &
          8.799518866802D-09)*Y+1.791418482685D-07)*Y-                  &
          2.96075397351101D-06 )*Y+3.38028206156144D-05 )*Y-            &
          3.58426847857878D-04 )*Y+8.39213709428516D-03                
      WW4 = ((((((((((( 1.33829971060180D-17*Y-3.44841877844140D-16)*Y+ &
          4.745009557656D-15)*Y-6.033814209875D-14)*Y+                  &
          1.049256040808D-12)*Y-1.70859789556117D-11 )*Y+               &
          2.15219425727959D-10 )*Y-2.52746574206884D-09 )*Y+            &
          3.27761714422960D-08 )*Y-3.90387662925193D-07 )*Y+            &
          3.46340204593870D-06 )*Y-2.43236345136782D-05 )*Y+            &
          3.54846978585226D-04                                        
      WW5 = ((((((((((((( 2.69412277020887D-20*Y-4.24837886165685D-19)* &
          Y+6.030500065438D-18)*Y-9.069722758289D-17)*Y+                &
          1.246599177672D-15)*Y-1.56872999797549D-14 )*Y+               &
          1.87305099552692D-13 )*Y-2.09498886675861D-12 )*Y+            &
          2.11630022068394D-11 )*Y-1.92566242323525D-10 )*Y+            &
          1.62012436344069D-09 )*Y-1.23621614171556D-08 )*Y+            &
          7.72165684563049D-08 )*Y-3.59858901591047D-07 )*Y+            &
          2.43682618601000D-06                                        
      UAUX=U
      WAUX=W
      RETURN                                                           
!
!     X=20.0 TO 25.0                             NROOTS = 5
  200 Y = X-22.5D+00
      RT1 = (((((((((-1.13927848238726D-15*Y+7.39404133595713D-15)*Y+   &
            1.445982921243D-13)*Y-2.676703245252D-12)*Y+                &
            5.823521627177D-12)*Y+2.17264723874381D-10 )*Y+             &
            3.56242145897468D-09 )*Y-3.03763737404491D-07 )*Y+          &
            9.46859114120901D-06 )*Y-2.30896753853196D-04 )*Y+          &
            5.24663913001114D-03                                        
      RT2 = (((((((((( 2.89872355524581D-16*Y-1.22296292045864D-14)*Y+  &
           6.184065097200D-14)*Y+1.649846591230D-12)*Y-                 &
           2.729713905266D-11)*Y+3.709913790650D-11)*Y+                 &
           2.216486288382D-09)*Y+4.616160236414D-08)*Y-                 &
           3.32380270861364D-06 )*Y+9.84635072633776D-05 )*Y-           &
           2.30092118015697D-03 )*Y+5.00845183695073D-02                
      RT3 = (((((((((( 1.97068646590923D-15*Y-4.89419270626800D-14)*Y+  &
           1.136466605916D-13)*Y+7.546203883874D-12)*Y-                 &
           9.635646767455D-11)*Y-8.295965491209D-11)*Y+                 &
           7.534109114453D-09)*Y+2.699970652707D-07)*Y-                 &
           1.42982334217081D-05 )*Y+3.78290946669264D-04 )*Y-           &
           8.03133015084373D-03 )*Y+1.58689469640791D-01                
      RT4 = (((((((((( 1.33642069941389D-14*Y-1.55850612605745D-13)*Y-  &
           7.522712577474D-13)*Y+3.209520801187D-11)*Y-                 &
           2.075594313618D-10)*Y-2.070575894402D-09)*Y+                 &
           7.323046997451D-09)*Y+1.851491550417D-06)*Y-                 &
           6.37524802411383D-05 )*Y+1.36795464918785D-03 )*Y-           &
           2.42051126993146D-02 )*Y+3.97847167557815D-01                
      RT5 = ((((((((((-6.07053986130526D-14*Y+1.04447493138843D-12)*Y-  &
           4.286617818951D-13)*Y-2.632066100073D-10)*Y+                 &
           4.804518986559D-09)*Y-1.835675889421D-08)*Y-                 &
           1.068175391334D-06)*Y+3.292234974141D-05)*Y-                 &
           5.94805357558251D-04 )*Y+8.29382168612791D-03 )*Y-           &
           9.93122509049447D-02 )*Y+1.09857804755042D+00                
      WW1 = (((((((((-9.10338640266542D-15*Y+1.00438927627833D-13)*Y+   &
           7.817349237071D-13)*Y-2.547619474232D-11)*Y+                 &
           1.479321506529D-10)*Y+1.52314028857627D-09 )*Y+              &
           9.20072040917242D-09 )*Y-2.19427111221848D-06 )*Y+           &
           8.65797782880311D-05 )*Y-2.82718629312875D-03 )*Y+           &
           1.28718310443295D-01                                         
      WW2 = ((((((((( 5.52380927618760D-15*Y-6.43424400204124D-14)*Y-   &
           2.358734508092D-13)*Y+8.261326648131D-12)*Y+                 &
           9.229645304956D-11)*Y-5.68108973828949D-09 )*Y+              &
           1.22477891136278D-07 )*Y-2.11919643127927D-06 )*Y+           &
           4.23605032368922D-05 )*Y-1.14423444576221D-03 )*Y+           &
           5.06607252890186D-02                                         
      WW3 = ((((((((( 3.99457454087556D-15*Y-5.11826702824182D-14)*Y-   &
           4.157593182747D-14)*Y+4.214670817758D-12)*Y+                 &
           6.705582751532D-11)*Y-3.36086411698418D-09 )*Y+              &
           6.07453633298986D-08 )*Y-7.40736211041247D-07 )*Y+           &
           8.84176371665149D-06 )*Y-1.72559275066834D-04 )*Y+           &
           7.16639814253567D-03                                        
      WW4 = (((((((((((-2.14649508112234D-18*Y-2.45525846412281D-18)*Y+ &
           6.126212599772D-16)*Y-8.526651626939D-15)*Y+                 &
           4.826636065733D-14)*Y-3.39554163649740D-13 )*Y+              &
           1.67070784862985D-11 )*Y-4.42671979311163D-10 )*Y+           &
           6.77368055908400D-09 )*Y-7.03520999708859D-08 )*Y+           &
           6.04993294708874D-07 )*Y-7.80555094280483D-06 )*Y+           &
           2.85954806605017D-04
      WW5 = ((((((((((((-5.63938733073804D-21*Y+6.92182516324628D-20)*Y-&
           1.586937691507D-18)*Y+3.357639744582D-17)*Y-                 &
           4.810285046442D-16)*Y+5.386312669975D-15)*Y-                 &
           6.117895297439D-14)*Y+8.441808227634D-13)*Y-                 &
           1.18527596836592D-11 )*Y+1.36296870441445D-10 )*Y-           &
           1.17842611094141D-09 )*Y+7.80430641995926D-09 )*Y-           &
           5.97767417400540D-08 )*Y+1.65186146094969D-06
      UAUX=U
      WAUX=W
      RETURN
!
  220 WW1 = SQRT(PIE4/X)
      IF (X .GT. 40.0D+00) GO TO 240
!     X=25.0 TO 40.0                             NROOTS = 5
      E = EXP(-X)
      RT1 = ((((((((-1.73363958895356D-06*X+1.19921331441483D-04)*X -   &
           1.59437614121125D-02)*X+1.13467897349442D+00)*X -            &
           4.47216460864586D+01)*X+1.06251216612604D+03)*X -            &
           1.52073917378512D+04)*X+1.20662887111273D+05)*X -            &
           4.07186366852475D+05)*E + R15/(X-R15)                      
      RT2 = ((((((((-1.60102542621710D-05*X+1.10331262112395D-03)*X -   &
           1.50043662589017D-01)*X+1.05563640866077D+01)*X -            &
           4.10468817024806D+02)*X+9.62604416506819D+03)*X -            &
           1.35888069838270D+05)*X+1.06107577038340D+06)*X -            &
           3.51190792816119D+06)*E + R25/(X-R25)
      RT3 = ((((((((-4.48880032128422D-05*X+2.69025112122177D-03)*X -   &
           4.01048115525954D-01)*X+2.78360021977405D+01)*X -            &
           1.04891729356965D+03)*X+2.36985942687423D+04)*X -            &
           3.19504627257548D+05)*X+2.34879693563358D+06)*X -            &
           7.16341568174085D+06)*E + R35/(X-R35)                       
      RT4 = ((((((((-6.38526371092582D-05*X-2.29263585792626D-03)*X -   &
           7.65735935499627D-02)*X+9.12692349152792D+00)*X -            &
           2.32077034386717D+02)*X+2.81839578728845D+02)*X +            &
           9.59529683876419D+04)*X-1.77638956809518D+06)*X +            &
           1.02489759645410D+07)*E + R45/(X-R45)
      RT5 = ((((((((-3.59049364231569D-05*X-2.25963977930044D-02)*X +   &
           1.12594870794668D+00)*X-4.56752462103909D+01)*X +            &
           1.05804526830637D+03)*X-1.16003199605875D+04)*X -            &
           4.07297627297272D+04)*X+2.22215528319857D+06)*X -            &
           1.61196455032613D+07)*E + R55/(X-R55)                       
      WW5 = (((((((((-4.61100906133970D-10*X+1.43069932644286D-07)*X -  &
           1.63960915431080D-05)*X+1.15791154612838D-03)*X -            &
           5.30573476742071D-02)*X+1.61156533367153D+00)*X -            &
           3.23248143316007D+01)*X+4.12007318109157D+02)*X -            &
           3.02260070158372D+03)*X+9.71575094154768D+03)*E + W55*WW1
      WW4 = (((((((((-2.40799435809950D-08*X+8.12621667601546D-06)*X -  &
           9.04491430884113D-04)*X+6.37686375770059D-02)*X -            &
           2.96135703135647D+00)*X+9.15142356996330D+01)*X -            &
           1.86971865249111D+03)*X+2.42945528916947D+04)*X -            &
           1.81852473229081D+05)*X+5.96854758661427D+05)*E + W45*WW1   
      WW3 = (((((((( 1.83574464457207D-05*X-1.54837969489927D-03)*X +   &
           1.18520453711586D-01)*X-6.69649981309161D+00)*X +            &
           2.44789386487321D+02)*X-5.68832664556359D+03)*X +            &
           8.14507604229357D+04)*X-6.55181056671474D+05)*X +            &
           2.26410896607237D+06)*E + W35*WW1
      WW2 = (((((((( 2.77778345870650D-05*X-2.22835017655890D-03)*X +   &
           1.61077633475573D-01)*X-8.96743743396132D+00)*X +            &
           3.28062687293374D+02)*X-7.65722701219557D+03)*X +            &
           1.10255055017664D+05)*X-8.92528122219324D+05)*X +            &
           3.10638627744347D+06)*E + W25*WW1                          
      WW1 = WW1-0.01962D+00*E-WW2-WW3-WW4-WW5                         
      UAUX=U
      WAUX=W
      RETURN
!
  240 IF (X .GT. 59.0D+00) GO TO 260
!     X=40.0 TO 59.0                             NROOTS = 5
      XXX = X**3
      E = XXX*EXP(-X)
      RT1 = (((-2.43758528330205D-02*X+2.07301567989771D+00)*X -        &
           6.45964225381113D+01)*X+7.14160088655470D+02)*E + R15/(X-R15)
      RT2 = (((-2.28861955413636D-01*X+1.93190784733691D+01)*X -        &
           5.99774730340912D+02)*X+6.61844165304871D+03)*E + R25/(X-R25)
      RT3 = (((-6.95053039285586D-01*X+5.76874090316016D+01)*X -        &
           1.77704143225520D+03)*X+1.95366082947811D+04)*E + R35/(X-R35)
      RT4 = (((-1.58072809087018D+00*X+1.27050801091948D+02)*X -        &
           3.86687350914280D+03)*X+4.23024828121420D+04)*E + R45/(X-R45)
      RT5 = (((-3.33963830405396D+00*X+2.51830424600204D+02)*X -        &
           7.57728527654961D+03)*X+8.21966816595690D+04)*E + R55/(X-R55)
      E = XXX*E
      WW5 = (( 1.35482430510942D-08*X-3.27722199212781D-07)*X +         &
           2.41522703684296D-06)*E + W55*WW1
      WW4 = (( 1.23464092261605D-06*X-3.55224564275590D-05)*X +         &
           3.03274662192286D-04)*E + W45*WW1
      WW3 = (( 1.34547929260279D-05*X-4.19389884772726D-04)*X +         &
           3.87706687610809D-03)*E + W35*WW1
      WW2 = (( 2.09539509123135D-05*X-6.87646614786982D-04)*X +         &
           6.68743788585688D-03)*E + W25*WW1
      WW1 = WW1-WW2-WW3-WW4-WW5
      UAUX=U
      WAUX=W
      RETURN
!
!     X=59.0 TO INFINITY                         NROOTS = 5
  260 RT1 = R15/(X-R15)
      RT2 = R25/(X-R25)
      RT3 = R35/(X-R35)
      RT4 = R45/(X-R45)
      RT5 = R55/(X-R55)
      WW2 = W25*WW1
      WW3 = W35*WW1
      WW4 = W45*WW1
      WW5 = W55*WW1
      WW1 = WW1-WW2-WW3-WW4-WW5
!-----------------------------------------------------------------------  
      UAUX=U
      WAUX=W
      RETURN
      END 
      
! ROOT6NOF
      SUBROUTINE ROOT6NOF(XX,NROOTS,UF,WF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
      INTEGER,PARAMETER::MR=13,MXAUX=55
      DOUBLE PRECISION,PARAMETER::ONE=1.0D+00
!
      DOUBLE PRECISION,INTENT(IN)::XX
      INTEGER,INTENT(IN)::NROOTS
      DOUBLE PRECISION,DIMENSION(13),INTENT(OUT)::UF,WF
!
      DOUBLE PRECISION,DIMENSION(0:MR-1)::ALPHA,BETA
      DOUBLE PRECISION,DIMENSION(MR)::RTS,WTS,WRK
      DOUBLE PRECISION,DIMENSION(MR)::XASYMP
      DOUBLE PRECISION,DIMENSION(MR,MR)::RTSASY,WTSASY
      DOUBLE PRECISION,DIMENSION(55,8)::RTSAUX,WTSAUX
      DOUBLE PRECISION,DIMENSION(MXAUX)::RGRID,WGRID,P0,P1,P2
      INTEGER,DIMENSION(MR)::NAUXS,MAPRYS
!
!           GENERAL CASE (NROOTS=1 TO 13) OF RYS ROOTS/WEIGHTS
!
      EPS=1.0D-14
!
      CALL SETRYSNOF(XASYMP,RTSASY,WTSASY,RTSAUX,WTSAUX,NAUXS,MAPRYS)
!
      IF(XX.GE.XASYMP(NROOTS)) THEN
         CALL RYSASYNOF(NROOTS,XX,RTSASY,WTSASY,RTS,WTS)
!
      ELSE
         NAUX=NAUXS(NROOTS)
         MAP=MAPRYS(NROOTS)
         DO I=1,NAUX
            T2 = RTSAUX(I,MAP)*RTSAUX(I,MAP)
            RGRID(I) = T2
            WGRID(I) = WTSAUX(I,MAP)*EXP(-XX*T2)
         ENDDO
         CALL RYSDSNOF(NROOTS,NAUX,RGRID,WGRID,ALPHA,BETA,IERR,P0,P1,P2)
         IF (IERR.NE.0) THEN
            WRITE(6,*)"ERROR IN SUBROUTINE RYSDS, USED IN ROOT6,grad.f90"
            STOP
         ENDIF         
         CALL RYSGWNOF(NROOTS,ALPHA,BETA,EPS,RTS,WTS,IERR,WRK)
         IF (IERR.NE.0) THEN
            WRITE(6,*)"ERROR IN SUBROUTINE RYSGW, USED IN ROOT6,grad.f90"
            STOP
         ENDIF
      END IF
!
      DO K=1,NROOTS
         DUM  =RTS(K)
         UF(K)=DUM/(ONE-DUM)
         WF(K)=WTS(K)
      ENDDO
!-----------------------------------------------------------------------      
      RETURN
      END
      
! RYSASYNOF
      SUBROUTINE RYSASYNOF(NROOTS,XX,RTSASY,WTSASY,RTS,WTS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!      
      INTEGER,INTENT(IN)::NROOTS
      DOUBLE PRECISION,INTENT(IN)::XX
      DOUBLE PRECISION,DIMENSION(13,13),INTENT(IN)::RTSASY,WTSASY
      DOUBLE PRECISION,DIMENSION(NROOTS),INTENT(OUT)::RTS,WTS
!
      DOUBLE PRECISION,PARAMETER::ONE=1.0D+00
!
!     THE ROOTS AND WEIGHTS FOR XX = BIG ARE GIVEN BY:
!       T*T = S*S/XX    W = V/SQRT(XX)
!     WHERE S AND V ARE THE ROOTS AND WEIGHTS OF THE
!     HERMITE POLYNOMIALS, OF ORDER 2*NROOTS.
!
      FACTR = ONE/XX
      FACTW = SQRT(FACTR)
      DO I=1,NROOTS
         RTS(I)= FACTR * RTSASY(I,NROOTS)
         WTS(I)= FACTW * WTSASY(I,NROOTS)
      ENDDO
!-----------------------------------------------------------------------      
      RETURN
      END
      
! SETRYSNOF
      SUBROUTINE SETRYSNOF(XASYMP,RTSASY,WTSASY,RTSAUX,WTSAUX,NAUXS,    &
                           MAPRYS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!      
      INTEGER,PARAMETER::MR=13, MAUX=55
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,FOUR=4.0D+00
      DOUBLE PRECISION,DIMENSION(MAUX)::RTS,WTS,WRK
      DOUBLE PRECISION,DIMENSION(0:MAUX-1)::ALPHA,BETA
!
      DOUBLE PRECISION,DIMENSION(MR),INTENT(OUT)::XASYMP
      DOUBLE PRECISION,DIMENSION(MR,MR),INTENT(OUT)::RTSASY,WTSASY
      DOUBLE PRECISION,DIMENSION(55,8),INTENT(OUT)::RTSAUX,WTSAUX
      INTEGER,DIMENSION(MR),INTENT(OUT)::NAUXS,MAPRYS
!
!     ----- INITIALIZE THE RYS QUADRATURE PROCEDURE -----
!
      QUART = ONE/FOUR
      PI    = 3.141592653589793238D+00
      EPS   = 1.0D-14
!
!     SET UP ASYMPTOTIC ROOT COMPUTATION, BY GENERATING
!     THE ROOTS OF THE HERMITE POLYNOMIALS OF ORDER 2N.
!
      XASYMP( 1)=29.0D+00
      XASYMP( 2)=37.0D+00
      XASYMP( 3)=43.0D+00
      XASYMP( 4)=49.0D+00
      XASYMP( 5)=55.0D+00
      XASYMP( 6)=60.0D+00
      XASYMP( 7)=65.0D+00
      XASYMP( 8)=71.0D+00
      XASYMP( 9)=76.0D+00
      XASYMP(10)=81.0D+00
      XASYMP(11)=86.0D+00
      XASYMP(12)=91.0D+00
      XASYMP(13)=96.0D+00
!
      DO I=1,MR
!            NOTE THAT MAUX MUST BE AT LEAST TWICE MR, FROM NEXT LINE
         N=2*I
         DO J=0,N-1
            ALPHA(J) = ZERO
         ENDDO
         BETA(0)=SQRT(PI)
         DO J=1,N-1
            BETA(J) = J/TWO
         END DO
         CALL RYSGWNOF(N,ALPHA,BETA,EPS,RTS,WTS,IERR,WRK)
         DO J=1,I
            RTSASY(J,I) = RTS(I+J)*RTS(I+J)
            WTSASY(J,I) = WTS(I+J)
         ENDDO
      ENDDO
!
!        GENERATE AUXILIARY GRIDS, AT 8 DISTINCT POINT DENSITIES
!
      NAUXS( 1)=20
      NAUXS( 2)=25
      NAUXS( 3)=30
      NAUXS( 4)=30
      NAUXS( 5)=35
      NAUXS( 6)=40
      NAUXS( 7)=40
      NAUXS( 8)=40
      NAUXS( 9)=45
      NAUXS(10)=50
      NAUXS(11)=50
      NAUXS(12)=55
      NAUXS(13)=55
!
      MAPRYS( 1)=1
      MAPRYS( 2)=2
      MAPRYS( 3)=3
      MAPRYS( 4)=3
      MAPRYS( 5)=4
      MAPRYS( 6)=5
      MAPRYS( 7)=5
      MAPRYS( 8)=5
      MAPRYS( 9)=6
      MAPRYS(10)=7
      MAPRYS(11)=7
      MAPRYS(12)=8
      MAPRYS(13)=8
!
!        THE AUXILIARY QUADRATURE IS TAKEN TO BE "SHIFTED LEGENDRE"
!
      NAUXSV=0
      IGRID=0
      DO M=1,MR
         NAUX=NAUXS(M)
         IF(NAUX.EQ.NAUXSV) CYCLE
         IGRID=IGRID+1
         NAUXSV=NAUX
         DO I=0,NAUX-1
            ALPHA(I) = ONE/TWO
         ENDDO
         BETA(0)= ONE
         DO I=1,NAUX-1
            BETA(I) = QUART/(FOUR-(ONE/(I*I)))
         END DO
         CALL RYSGWNOF(NAUX,ALPHA,BETA,EPS,RTS,WTS,IERR,WRK)
         DO I=1,NAUX
            RTSAUX(I,IGRID) = RTS(I)
            WTSAUX(I,IGRID) = WTS(I)
         ENDDO
      ENDDO
!-----------------------------------------------------------------------  
      RETURN
      END
      
! RYSGWNOF
      SUBROUTINE RYSGWNOF(N,ALPHA,BETA,EPS,ROOTS,WEIGHT,IERR,WRK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER,INTENT(IN)::N
      DOUBLE PRECISION,DIMENSION(N),INTENT(IN)::ALPHA,BETA
      DOUBLE PRECISION,INTENT(IN)::EPS
      DOUBLE PRECISION,DIMENSION(N),INTENT(OUT)::ROOTS,WEIGHT,WRK
      INTEGER,INTENT(OUT)::IERR
!
!        INPUT:  N - - THE NUMBER OF POINTS IN THE GAUSSIAN QUADRATURE
!                      FORMULA; TYPE INTEGER
!                ALPHA,BETA - - ARRAYS OF DIMENSION  N  TO BE FILLED
!                      WITH THE VALUES OF  ALPHA(K-1), BETA(K-1), K=1,2,
!                      ...,N
!                EPS - THE RELATIVE ACCURACY DESIRED IN THE NODES
!                      AND WEIGHTS
!
!        OUTPUT: ROOTS- ARRAY OF DIMENSION  N  CONTAINING THE GAUSSIAN
!                      NODES (IN INCREASING ORDER)  ROOTS(K)=X(K),
!                       K=1,2,...,N
!                WEIGHT - ARRAY OF DIMENSION  N  CONTAINING THE
!                      GAUSSIAN WEIGHTS  WEIGHT(K)=W(K), K=1,2,...,N
!                IERR- AN ERROR FLAG EQUAL TO  0  ON NORMAL RETURN,
!                      EQUAL TO  I  IF THE QR ALGORITHM DOES NOT
!                      CONVERGE WITHIN 30 ITERATIONS ON EVALUATING THE
!                      I-TH EIGENVALUE, EQUAL TO  -1  IF  N  IS NOT IN
!                      RANGE, AND EQUAL TO  -2  IF ONE OF THE BETA'S IS
!                      NEGATIVE.
!
! THE ARRAY  WRK  IS NEEDED FOR WORKING SPACE.
!
      IF(N.LT.1) THEN
        IERR=-1
        RETURN
      END IF
!
      IERR=0
      ROOTS(1)=ALPHA(1)
      IF(BETA(1).LT.0.0D+00) THEN
        IERR=-2
        RETURN
      END IF
      WEIGHT(1)=BETA(1)
      IF (N.EQ.1) RETURN
!
      WEIGHT(1)=1.0D+00
      WRK(N)=0.0D+00
      DO K=2,N
        ROOTS(K)=ALPHA(K)
        IF(BETA(K).LT.0.0D+00) THEN
          IERR=-2
          RETURN
        END IF
        WRK(K-1)=SQRT(BETA(K))
        WEIGHT(K)=0.0D+00
      ENDDO
!
      DO L=1,N
        J=0
!
! LOOK FOR A SMALL SUBDIAGONAL ELEMENT.
!
  105   DO M=L,N
          IF(M.EQ.N) EXIT
          IF(ABS(WRK(M)).LE.EPS*(ABS(ROOTS(M))+ABS(ROOTS(M+1)))) &
                   EXIT
        ENDDO
        DP=ROOTS(L)
        IF(M.EQ.L) CYCLE
        IF(J.EQ.30) GO TO 400
        J=J+1
!
! FORM SHIFT.
!
        DG=(ROOTS(L+1)-DP)/(2.0D+00*WRK(L))
        DR=SQRT(DG*DG+1.0D+00)
        DG=ROOTS(M)-DP+WRK(L)/(DG+SIGN(DR,DG))
        DS=1.0D+00
        DC=1.0D+00
        DP=0.0D+00
        MML=M-L
!
! FOR I=M-1 STEP -1 UNTIL L DO ...
!
        DO II=1,MML
          I=M-II
          DF=DS*WRK(I)
          DB=DC*WRK(I)
          IF(ABS(DF).LT.ABS(DG)) GO TO 150
          DC=DG/DF
          DR=SQRT(DC*DC+1.0D+00)
          WRK(I+1)=DF*DR
          DS=1.0D+00/DR
          DC=DC*DS
          GO TO 160
  150     DS=DF/DG
          DR=SQRT(DS*DS+1.0D+00)
          WRK(I+1)=DG*DR
          DC=1.0D+00/DR
          DS=DS*DC
  160     DG=ROOTS(I+1)-DP
          DR=(ROOTS(I)-DG)*DS+2.0D+00*DC*DB
          DP=DS*DR
          ROOTS(I+1)=DG+DP
          DG=DC*DR-DB
!
! FORM FIRST COMPONENT OF VECTOR.
!
          DF=WEIGHT(I+1)
          WEIGHT(I+1)=DS*WEIGHT(I)+DC*DF
          WEIGHT(I)=DC*WEIGHT(I)-DS*DF
        ENDDO
        ROOTS(L)=ROOTS(L)-DP
        WRK(L)=DG
        WRK(M)=0.0D+00
        GO TO 105
      ENDDO
!
! ORDER EIGENVALUES AND EIGENVECTORS.
!
      DO II=2,N
        I=II-1
        K=I
        DP=ROOTS(I)
        DO J=II,N
          IF(ROOTS(J).GE.DP) CYCLE
          K=J
          DP=ROOTS(J)
        ENDDO
        IF(K.EQ.I) CYCLE
        ROOTS(K)=ROOTS(I)
        ROOTS(I)=DP
        DP=WEIGHT(I)
        WEIGHT(I)=WEIGHT(K)
        WEIGHT(K)=DP
      ENDDO
      DO K=1,N
        WEIGHT(K)=BETA(1)*WEIGHT(K)*WEIGHT(K)
      ENDDO
      RETURN
!
! SET ERROR - NO CONVERGENCE TO AN EIGENVALUE AFTER 30 ITERATIONS.
!
  400 IERR=L
!-----------------------------------------------------------------------  
      RETURN
      END
      
! RYSDSNOF
      SUBROUTINE RYSDSNOF(N,NCAP,X,W,ALPHA,BETA,IERR,P0,P1,P2)      
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!
      INTEGER,INTENT(IN)::N,NCAP
      INTEGER,INTENT(OUT)::IERR
      DOUBLE PRECISION,DIMENSION(NCAP),INTENT(IN)::X,W
      DOUBLE PRECISION,DIMENSION(N),INTENT(OUT)::ALPHA,BETA
      DOUBLE PRECISION,DIMENSION(NCAP),INTENT(OUT)::P0,P1,P2
!
!      ACM TRANSACTIONS ON MATHEMATICAL SOFTWARE, 20, 21-62(1994)
!
! (CF. SECTION 2.1 OF W. GAUTSCHI, 'ON GENERATING ORTHOGONAL  SCI.
! POLYNOMIALS', SIAM J. STATIST. COMPUT. 3, 1982, 289-317)
!
!     (F,G)=SUM OVER K FROM 1 TO NCAP OF W(K)*F(X(K))*G(X(K)).
!
      TINYY = 1.0D-40
      HUGEE = 1.0D+40
!
      IERR=0
      IF(N.LE.0 .OR. N.GT.NCAP) THEN
        IERR=1
        RETURN
      END IF
      NM1=N-1
!
! COMPUTE THE FIRST ALPHA- AND BETA-COEFFICIENT.
!
      SUM0=0.0D+00
      SUM1=0.0D+00
      DO M=1,NCAP
        SUM0=SUM0+W(M)
        SUM1=SUM1+W(M)*X(M)
      ENDDO
      ALPHA(1)=SUM1/SUM0
      BETA(1)=SUM0
     IF(N.EQ.1) RETURN
!
! COMPUTE THE REMAINING ALPHA- AND BETA-COEFFICIENTS.
!
     DO M=1,NCAP
        P1(M)=0.0D+00
        P2(M)=1.0D+00
     ENDDO
      DO K=1,NM1
        SUM1=0.0D+00
        SUM2=0.0D+00
        DO M=1,NCAP
!
! THE FOLLOWING STATEMENT IS DESIGNED TO AVOID AN OVERFLOW CONDITION
! IN THE COMPUTATION OF  P2(M)  WHEN THE WEIGHTS  W(M)  GO TO ZERO
! FASTER (AND UNDERFLOW) THAN THE  P2(M)  GROW.
!
          IF(W(M).EQ.0.0D+00) CYCLE
          P0(M)=P1(M)
          P1(M)=P2(M)
          P2(M)=(X(M)-ALPHA(K))*P1(M)-BETA(K)*P0(M)
!
! CHECK FOR IMPENDING OVERFLOW.
!
          IF(ABS(P2(M)).GT.HUGEE .OR. ABS(SUM2).GT.HUGEE) THEN
            IERR=K
            RETURN
          END IF
          T=W(M)*P2(M)*P2(M)
          SUM1=SUM1+T
          SUM2=SUM2+T*X(M)
        ENDDO
!
! CHECK FOR IMPENDING UNDERFLOW.
!
        IF(ABS(SUM1).LT.TINYY) THEN
          IERR=-K
          RETURN
        END IF
        ALPHA(K+1)=SUM2/SUM1
        BETA(K+1)=SUM1/SUM0
        SUM0=SUM1
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END
      
!----------------------------------------------------------------------!
!                                                                      !
!       2020 Use Libreta open source library for ERI calculation       !
!                                                                      !
!  implemented by Juan Felipe Huan Lew Yee and Jorge Martin del Campo  ! 
!                                                                      !
!----------------------------------------------------------------------!

! SDERNOFlib
      SUBROUTINE SDERNOFlib(KATOM,KLOC,KKMIN,KKMAX,EPS,DE)
      USE ISO_C_BINDING            
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KLOC,KKMIN,KKMAX
      DOUBLE PRECISION,DIMENSION(NBFT),INTENT(IN)::EPS
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::DE
!      
      INTEGER,DIMENSION(NBF)::IA
!
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      DOUBLE PRECISION,DIMENSION(2352)::SBLKDERIV
!
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
!
!     ----- I SHELL
!
      DO II = 1,NSHELL
!
        IAT = KATOM(II)
        MINI = KKMIN(II)
        MAXI = KKMAX(II)
        LOCI = KLOC(II)-MINI
!
!     ----- J SHELL
!
        DO JJ = 1,II
!
          JAT = KATOM(JJ)
          MINJ = KKMIN(JJ)
          MAXJ = KKMAX(JJ)
          LOCJ = KLOC(JJ)-MINJ
          IF(II.EQ.JJ) CYCLE

!lib          CALL svalderiv(BASLIB,II,JJ,SBLKDERIV)

          IJ=0
          DO I=MINI,MAXI
            DO J=MINJ,MAXJ
              NN=IA(LOCI+I)+(LOCJ+J)
              DEN = EPS(NN)

              DE(1,IAT)=DE(1,IAT)+(SBLKDERIV(IJ+1)*DEN)
              DE(2,IAT)=DE(2,IAT)+(SBLKDERIV(IJ+2)*DEN)
              DE(3,IAT)=DE(3,IAT)+(SBLKDERIV(IJ+3)*DEN)
              DE(1,JAT)=DE(1,JAT)-(SBLKDERIV(IJ+1)*DEN)
              DE(2,JAT)=DE(2,JAT)-(SBLKDERIV(IJ+2)*DEN)
              DE(3,JAT)=DE(3,JAT)-(SBLKDERIV(IJ+3)*DEN)
              IJ = IJ + 3
            END DO
          END DO
        ENDDO
      ENDDO

!
!     ----- END OF SHELL LOOPS -----
!  
!-----------------------------------------------------------------------      
      RETURN
      END

! HELFEYNOFlib
      SUBROUTINE HELFEYNOFlib(KATOM,KLOC,KKMIN,KKMAX,CX0,CY0,CZ0,       &
                              ZAN,PM,DE)
      USE ISO_C_BINDING                                          
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KLOC,KKMIN,KKMAX
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0,ZAN
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::PM
      DOUBLE PRECISION,DIMENSION(NBFT)::P
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::DE
! 
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      DOUBLE PRECISION,DIMENSION(2352)::VBLKDERIV
!
      LOGICAL::IANDJ
      INTEGER,DIMENSION(NBF)::IA
!
!     ----- HELMANN-FEYNMAN GRADIENT TERM -----
!     INTEGRAL TYPE IS <II/H'/JJ> = <II/V'/JJ>
!                     

      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
      CALL SQUARETRIAN2(PM,P,NBF,NBFT)
      P=P*0.5D+00
!
!     ----- I SHELL
!
      DO II = 1,NSHELL
!
        I = KATOM(II)
        MINI = KKMIN(II)
        MAXI = KKMAX(II)
        LOCI = KLOC(II)-MINI
!
!     ----- J SHELL
!
        DO JJ = 1,II
!
          J = KATOM(JJ)
          MINJ = KKMIN(JJ)
          MAXJ = KKMAX(JJ)
          LOCJ = KLOC(JJ)-MINJ
          IANDJ = II .EQ. JJ
          DO IC = 1,NATOMS
            ZNUCC = -ZAN(IC)
            CX = CX0(IC)
            CY = CY0(IC)
            CZ = CZ0(IC)

!lib            CALL helfeyvalderiv(BASLIB,II,JJ,VBLKDERIV,CX,CY,CZ,ZAN(IC))

            IJ=0
            DO I=MINI,MAXI
              JMAX=MAXJ
              IF(IANDJ) JMAX=I
              DO J=MINJ,JMAX
                NDUM = IA(LOCI+I)+(LOCJ+J)
                DEN = P(NDUM)
                IF(IANDJ.AND.I.EQ.J) DEN=DEN*0.5D+00
                DE(1,IC) = DE(1,IC)+VBLKDERIV(IJ+1)*DEN
                DE(2,IC) = DE(2,IC)+VBLKDERIV(IJ+2)*DEN
                DE(3,IC) = DE(3,IC)+VBLKDERIV(IJ+3)*DEN
                IJ = IJ + 3
              ENDDO
            ENDDO

          ENDDO
!
!     ----- END OF *ATOMS* LOOPS -----
!
        ENDDO
      ENDDO

!
!     ----- END OF *SHELL* LOOPS -----
!             
!-----------------------------------------------------------------------
      RETURN
      END      

! TVDERNOFlib
      SUBROUTINE TVDERNOFlib(KATOM,KLOC,KKMIN,KKMAX,CX0,CY0,CZ0,        &
                             ZAN,PM,DE)
      USE ISO_C_BINDING                                          
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KLOC,KKMIN,KKMAX
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN)::CX0,CY0,CZ0,ZAN
      DOUBLE PRECISION,DIMENSION(NBF,NBF),INTENT(IN)::PM
      DOUBLE PRECISION,DIMENSION(NBFT)::P
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::DE
!      
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      DOUBLE PRECISION,DIMENSION(2352)::TBLKDERIV      
      DOUBLE PRECISION,DIMENSION(2352)::VBLKDERIV
!
      INTEGER,DIMENSION(NBF)::IA
      DOUBLE PRECISION::ZNUCC
!-----------------------------------------------------------------------
!
!     ----- BASIS FUNCTION DERIVATIVE CONTRIBUTIONS TO GRADIENT -----
!     INTEGRALS ARE OF TYPE <II'/H/JJ> = <II'/T+V/JJ>
!
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO
      IAZ=0
      CALL SQUARETRIAN2(PM,P,NBF,NBFT)
      P=P*0.5D+00  
!
!     ----- I SHELL
!
      DO II = 1,NSHELL
!      
        IAT = KATOM(II)
        MINI = KKMIN(II)
        MAXI = KKMAX(II)
        LOCI = KLOC(II)-MINI
!
!     ----- J SHELL
!
        DO JJ = 1,NSHELL
!
          JAT = KATOM(JJ)
          MINJ = KKMIN(JJ)
          MAXJ = KKMAX(JJ)
          LOCJ = KLOC(JJ)-MINJ

!lib          CALL tvalderiv(BASLIB,II,JJ,TBLKDERIV)

          IJ = 0
          DO I=MINI,MAXI
            DO J=MINJ,MAXJ
              NN = IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
              DEN = P(NN)
              DE(1,IAT)=DE(1,IAT) + TBLKDERIV(IJ+1)*DEN
              DE(2,IAT)=DE(2,IAT) + TBLKDERIV(IJ+2)*DEN
              DE(3,IAT)=DE(3,IAT) + TBLKDERIV(IJ+3)*DEN
              IJ = IJ + 3
            ENDDO
          ENDDO
!
!     ..... NUCLEAR ATTRACTION
!
          DO IC = 1,NATOMS
            IF(IC.LE.NATOMS) THEN
              ZNUCC = -ZAN(IC)
              CX = CX0(IC)
              CY = CY0(IC)
              CZ = CZ0(IC)
            ENDIF
!
!lib            CALL vvalderiv(BASLIB,II,JJ,VBLKDERIV,CX,CY,CZ,ZAN(IC))
!
            IJ=0
            DO I=MINI,MAXI
              DO J=MINJ,MAXJ
                IF((IC.GT.NATOMS).AND.(IAT.EQ.IAZ)) CYCLE
                NN = IA(MAX0(LOCI+I,LOCJ+J))+MIN0(LOCI+I,LOCJ+J)
                DEN = P(NN)
                DE(1,IAT)=DE(1,IAT)+VBLKDERIV(IJ+1)*DEN
                DE(2,IAT)=DE(2,IAT)+VBLKDERIV(IJ+2)*DEN
                DE(3,IAT)=DE(3,IAT)+VBLKDERIV(IJ+3)*DEN
                IJ = IJ + 3
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
!     ----- END OF SHELL LOOPS -----
!
!-----------------------------------------------------------------------
      RETURN
      END

! JKDERNOF5lib
      SUBROUTINE JKDERNOF5lib(KATOM,KTYPE,KLOC,KKMIN,KKMAX,QD,RO,GRADS, &
                              ATMNAME,XINTS,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      LOGICAL FROZEN
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200) 
      COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!     INPUT-OUTPUT VARIABLES OR ARGUMENTS
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF),INTENT(IN)::QD
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::P,CJAUX,CKAUX
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2),INTENT(IN)::XINTS
      CHARACTER*4 ATMNAME(NATOMS)
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::GRADS
      INTEGER,INTENT(IN)::IPRINTOPT
!     INTERMEDIATE VARIABLES
      INTEGER,DIMENSION(NBF)::IA
      INTEGER,DIMENSION(35)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(:),ALLOCATABLE::IJKLG
      INTEGER::TOTCOUNT,INVTYP,KANG,I
      INTEGER::II,JJ,KK,LL,MAXLL,ISH,JSH,KSH,LSH,IIAT,JJAT,KKAT,LLAT
      INTEGER::MINJ,MAXJ,MINK,MAXK,MINL,MAXL,MINI,MAXI
      INTEGER::NUMI,NUMJ,NUMK,NUML
      LOGICAL::SKIPI,SKIPJ,SKIPK,SKIPL
      LOGICAL::IIEQJJ,KKEQLL,IJEQKL
      DOUBLE PRECISION::DABMAX,CUTOFF,CUTOFF2,GMAX
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::DAB
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
      DOUBLE PRECISION,PARAMETER::TEN=10.0D+00,TENM9=1.0D-09
!-----------------------------------------------------------------------
!     ROUTINE BASCHK DO:
      KANG=0
      DO N=1,NSHELL
        IF(KTYPE(N).GT.KANG) KANG = KTYPE(N)
      ENDDO
!
!     SET STARTING PARAMETERS
!
!     CUTOFF IS THE SCHWARZ SCREENING CUT OFF 
      CUTOFF=TENM9/TEN
      CUTOFF2=CUTOFF*0.5D+00
!     SET POINTERS FOR PARTITIONING MEMORY
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
!           
!     MAXNUM=NUMBER OF FUNCTIONS WITH ANGULAR MOMENTUM EQUAL TO MAXTYP
      MAXNUM=((KANG)*(KANG+1))/2
!     DO AT LEAST AN L SHELL      
      IF(MAXNUM.LT.4) MAXNUM=4
      MAXNUM=(MAXNUM**4)
!      
      ALLOCATE(IJKLG(MAXNUM))
      ALLOCATE(DAB(MAXNUM))
      ALLOCATE(P(NBF,NBFT))  
      CALL SQUARETRIAN3(QD,P,NBF,NBFT)
      P=P*0.5D+00
      ALLOCATE(CJAUX(NBFT,NBFT))
      ALLOCATE(CKAUX(NBFT,NBFT))
      IF(IPNOF==5) CALL DABNOF5PRE(RO,P,CJAUX,CKAUX)
      IF(IPNOF==7) CALL DABNOF7PRE(RO,P,CJAUX,CKAUX)
      DEALLOCATE(P)
!
      TOTCOUNT=1
!
!----I SHELL
!
      DO II=1,NSHELL
!      
!-----J SHELL
!
       DO JJ=1,II
!        
!-----K SHELL
!
        DO KK=1,II
!        
!-----L SHELL
!
        MAXLL=KK
        IF(KK.EQ.II) MAXLL=JJ
         DO LL=1,MAXLL
!
!         IMPLEMENT INTEGRAL SCREENING HERE USING EXCHANGE INTEGRALS
!                                                                       
          IJIJ=IA(MAX0(II,JJ))+MIN0(II,JJ)                          
          KLKL=IA(MAX0(KK,LL))+MIN0(KK,LL)                          
          GMAX=(XINTS(IJIJ)*XINTS(KLKL))
!
!         COARSE SCREENING, ON JUST THE INTEGRAL VALUE         
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF (GMAX.LT.CUTOFF.AND.NATOMS>5) CYCLE
!
          ISH=II
          JSH=JJ
          KSH=KK
          LSH=LL
!          
!         SELECT CENTERS FOR DERIVATIVES
!
          CALL JKDATMNOF(ISH,JSH,KSH,LSH,SKIPI,SKIPJ,SKIPK,SKIPL,      &
                      INVTYP,KATOM,IIAT,JJAT,KKAT,LLAT)
          IF(SKIPI.AND.SKIPJ.AND.SKIPK.AND.SKIPL) CYCLE
!          
!         SELECT INDICES FOR SHELL BLOCK
!
          CALL JKDSHLNOFlib(ISH,JSH,KSH,LSH,KTYPE,KLOC,KKMIN,KKMAX,     &
                            MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,    &
                            IIEQJJ,KKEQLL,IJEQKL,NUMI,NUMJ,NUMK,NUML)     
          CALL JKDNDXNOFlib(NUMJ,NUMK,NUML,MINI,MAXI,MINJ,MAXJ,MINK,    &
                            MAXK,MINL,MAXL,IGXYZ,JGXYZ,KGXYZ,LGXYZ,     &
                            IIEQJJ,KKEQLL,IJEQKL,IJKLG,MAXNUM)          
!                      
!         OBTAIN 2e DENSITY FOR THIS SHELL BLOCK                      
!
          CALL DABNOF5lib(ISH,JSH,KSH,LSH,KKMIN,KKMAX,KLOC,IGXYZ,       &
                          JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,       &
                          IA,DAB,MAXNUM,DABMAX,CJAUX,CKAUX)
!
!         FINE SCREENING, ON INTEGRAL VALUE TIMES DENSITY FACTOR
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF(DABMAX*GMAX.LT.CUTOFF2.AND.NATOMS>5) CYCLE
!
!         EVALUATE DERIVATIVE INTEGRAL AND ADD TO THE GRADIENT
!
          CALL JKDSPDNOFlib(TOTCOUNT,DAB,II,JJ,KK,LL,MINI,MAXI,MINJ,    &
                            MAXJ,MINK,MAXK,MINL,MAXL,IIEQJJ,KKEQLL,     &
                            IJEQKL,SKIPI,SKIPJ,SKIPK,SKIPL,IJKLG,MAXNUM,&
                            INVTYP,IIAT,JJAT,KKAT,LLAT,GRADS)   
!      
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      DEALLOCATE(IJKLG,DAB,CJAUX,CKAUX)
!     
!     MAKE ZERO GRADIENT CORRESPONDING TO FROZEN COORDINATES
!
      IF(FROZEN) THEN
        DO I=1,200,2
         IF(IFROZEN(I).EQ.0) EXIT
         GRADS(IFROZEN(I),IFROZEN(I+1))=ZERO
        ENDDO
      ENDIF      
!
!     PRINT OUT TOTAL PNOF ENERGY GRADIENT
!
      IF(IPRINTOPT==1)THEN
       WRITE(6,1)
       DO I=1,NATOMS
        WRITE(6,2)I,ATMNAME(I),GRADS(1,I),GRADS(2,I),GRADS(3,I)
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT( /1X,'----------------',                                  &
              /1X,' Total Gradient ',                                  &
              /1X,'----------------',                                  &
              //9X,'Atom',7X,'Ex',10X,'Ey',10X,'Ez' )
    2 FORMAT(/1X,I4,5X,A4,F10.4,2X,F10.4,2X,F10.4)
!-----------------------------------------------------------------------
      RETURN
      END      

! JKDERNOFlib
      SUBROUTINE JKDERNOFlib(KATOM,KTYPE,KLOC,KKMIN,KKMAX,CJ12,CK12,    &
                             QD,RO,GRADS,ATMNAME,XINTS,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      LOGICAL FROZEN
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200)      
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!     INPUT-OUTPUT VARIABLES OR ARGUMENTS
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KATOM,KTYPE,KLOC,KKMIN,KKMAX
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5),INTENT(IN)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF),INTENT(IN)::QD
      DOUBLE PRECISION,DIMENSION(NBF5),INTENT(IN)::RO
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE::P,DAAUX,DAAUX2
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2),INTENT(IN)::XINTS
      CHARACTER*4 ATMNAME(NATOMS)
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::GRADS
      INTEGER,INTENT(IN)::IPRINTOPT
!     INTERMEDIATE VARIABLES 
      INTEGER,DIMENSION(NBF)::IA
      INTEGER,DIMENSION(35)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(:),ALLOCATABLE::IJKLG
      INTEGER::MAXNUM
      INTEGER::TOTCOUNT,INVTYP,KANG,I
      INTEGER::II,JJ,KK,LL,MAXLL,ISH,JSH,KSH,LSH,IIAT,JJAT,KKAT,LLAT
      INTEGER::MINJ,MAXJ,MINK,MAXK,MINL,MAXL,MINI,MAXI
      INTEGER::NUMI,NUMJ,NUMK,NUML
      LOGICAL::SKIPI,SKIPJ,SKIPK,SKIPL
      LOGICAL::IIEQJJ,KKEQLL,IJEQKL
      DOUBLE PRECISION::DABMAX,CUTOFF,CUTOFF2,GMAX
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::DAB
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
      DOUBLE PRECISION,PARAMETER::TEN=10.0D+00,TENM9=1.0D-09
!-----------------------------------------------------------------------
!     ROUTINE BASCHK DO:
      KANG=0
      DO N=1,NSHELL
       IF(KTYPE(N).GT.KANG) KANG = KTYPE(N)
      ENDDO
!
!     SET STARTING PARAMETERS
!
!     CUTOFF IS THE SCHWARZ SCREENING CUT OFF 
      CUTOFF=TENM9/TEN
      CUTOFF2=CUTOFF*0.5D+00
!     SET POINTERS FOR PARTITIONING MEMORY
      DO I=1,NBF
        IA(I) = (I*I-I)/2
      ENDDO   
!           
!     MAXNUM=NUMBER OF FUNCTIONS WITH ANGULAR MOMENTUM EQUAL TO MAXTYP
      MAXNUM=((KANG)*(KANG+1))/2
!     DO AT LEAST AN L SHELL      
      IF(MAXNUM.LT.4) MAXNUM=4
      MAXNUM=(MAXNUM**4)
!
      ALLOCATE(IJKLG(MAXNUM))
      ALLOCATE(DAB(MAXNUM))
      ALLOCATE(P(NBF,NBFT))
      CALL SQUARETRIAN3(QD,P,NBF,NBFT)
      P=P*0.5D+00
      ALLOCATE(DAAUX(NBF,NBFT))
      ALLOCATE(DAAUX2(NBF,NBFT))
      CALL DABNOF2PRE(CJ12,CK12,RO,P,DAAUX,DAAUX2)
!
      TOTCOUNT=1
!
!----I SHELL
!
      DO II=1,NSHELL
!      
!-----J SHELL
!
       DO JJ=1,II
!        
!-----K SHELL
!
        DO KK=1,II
!        
!-----L SHELL
!
        MAXLL=KK
        IF(KK.EQ.II) MAXLL=JJ
         DO LL=1,MAXLL
!
!         IMPLEMENT INTEGRAL SCREENING HERE USING EXCHANGE INTEGRALS
!                                                                       
          IJIJ=IA(MAX0(II,JJ))+MIN0(II,JJ)                          
          KLKL=IA(MAX0(KK,LL))+MIN0(KK,LL)                          
          GMAX=(XINTS(IJIJ)*XINTS(KLKL))
!
!         COARSE SCREENING, ON JUST THE INTEGRAL VALUE         
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF (GMAX.LT.CUTOFF.AND.NATOMS>5) CYCLE
!
          ISH=II
          JSH=JJ
          KSH=KK
          LSH=LL
!          
!         SELECT CENTERS FOR DERIVATIVES
!
          CALL JKDATMNOF(ISH,JSH,KSH,LSH,SKIPI,SKIPJ,SKIPK,SKIPL,       &
                         INVTYP,KATOM,IIAT,JJAT,KKAT,LLAT)              
          IF(SKIPI.AND.SKIPJ.AND.SKIPK.AND.SKIPL) CYCLE                 
!                                                                       
!         SELECT INDICES FOR SHELL BLOCK                                
!                                                                       
          CALL JKDSHLNOFlib(ISH,JSH,KSH,LSH,KTYPE,KLOC,KKMIN,KKMAX,     &
                            MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,    &
                            IIEQJJ,KKEQLL,IJEQKL,NUMI,NUMJ,NUMK,NUML)         
          CALL JKDNDXNOFlib(NUMJ,NUMK,NUML,MINI,MAXI,MINJ,MAXJ,MINK,    &   
                            MAXK,MINL,MAXL,IGXYZ,JGXYZ,KGXYZ,LGXYZ,     &
                            IIEQJJ,KKEQLL,IJEQKL,IJKLG,MAXNUM)          
!                      
!         OBTAIN 2e DENSITY FOR THIS SHELL BLOCK                      
!
          CALL DABNOF2lib(ISH,JSH,KSH,LSH,KKMIN,KKMAX,KLOC,             &
                          IGXYZ,JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL, &
                          IA,P,DAB,MAXNUM,DABMAX,DAAUX,DAAUX2)
!
!         FINE SCREENING, ON INTEGRAL VALUE TIMES DENSITY FACTOR
!         ONLY WORKS IF SCHWARZ SCREENING IS ON (NATOMS>5)
          IF(DABMAX*GMAX.LT.CUTOFF2.AND.NATOMS>5) CYCLE
!
!         EVALUATE DERIVATIVE INTEGRAL AND ADD TO THE GRADIENT
!
          CALL JKDSPDNOFlib(TOTCOUNT,DAB,II,JJ,KK,LL,MINI,MAXI,MINJ,    &
                            MAXJ,MINK,MAXK,MINL,MAXL,IIEQJJ,KKEQLL,     &
                            IJEQKL,SKIPI,SKIPJ,SKIPK,SKIPL,IJKLG,       &
                            MAXNUM,INVTYP,IIAT,JJAT,KKAT,LLAT,GRADS)   
!      
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      DEALLOCATE(P,IJKLG,DAB,DAAUX,DAAUX2)
!     
!     MAKE ZERO GRADIENT CORRESPONDING TO FROZEN COORDINATES
!
      IF(FROZEN) THEN
        DO I=1,200,2
         IF(IFROZEN(I).EQ.0) EXIT
         GRADS(IFROZEN(I),IFROZEN(I+1))=ZERO
        ENDDO
      ENDIF      
!
!     PRINT OUT TOTAL PNOF ENERGY GRADIENT
!
      IF(IPRINTOPT==1)THEN
       WRITE(6,1)
       DO I=1,NATOMS
        WRITE(6,2)I,ATMNAME(I),GRADS(1,I),GRADS(2,I),GRADS(3,I)
       ENDDO
      ENDIF
!-----------------------------------------------------------------------
    1 FORMAT( /1X,'----------------',                                  &
              /1X,' Total Gradient ',                                  &
              /1X,'----------------',                                  &
              //9X,'Atom',7X,'Ex',10X,'Ey',10X,'Ez' )
    2 FORMAT(/1X,I4,5X,A4,F10.4,2X,F10.4,2X,F10.4)
!-----------------------------------------------------------------------
      RETURN
      END
      
! JKDSHLNOFlib
      SUBROUTINE JKDSHLNOFlib(ISH,JSH,KSH,LSH,KTYPE,KLOC,KKMIN,KKMAX,   &
                              MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL,  &
                              IIEQJJ,KKEQLL,IJEQKL,NUMI,NUMJ,NUMK,NUML)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::ISH,JSH,KSH,LSH
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KTYPE,KLOC,KKMIN,KKMAX
      INTEGER,INTENT(OUT)::MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL
      INTEGER,INTENT(OUT)::NUMI,NUMJ,NUMK,NUML
      LOGICAL,INTENT(OUT)::IIEQJJ,KKEQLL,IJEQKL
!-----------------------------------------------------------------------
      IIEQJJ=ISH.EQ.JSH
      KKEQLL=KSH.EQ.LSH
      IJEQKL=ISH.EQ.KSH.AND.JSH.EQ.LSH
!     ----- ISHELL -----
      LIT=KTYPE(ISH)
      MINI=KKMIN(ISH)
      MAXI=KKMAX(ISH)
      NUMI=MAXI-MINI+1
      LOCI=KLOC(ISH)-MINI
!     ----- JSHELL -----
      LJT=KTYPE(JSH)
      MINJ=KKMIN(JSH)
      MAXJ=KKMAX(JSH)
      NUMJ=MAXJ-MINJ+1
      LOCJ=KLOC(JSH)-MINJ
!     ----- KSHELL -----
      LKT=KTYPE(KSH)
      MINK=KKMIN(KSH)
      MAXK=KKMAX(KSH)
      NUMK=MAXK-MINK+1
      LOCK=KLOC(KSH)-MINK
!     ----- LSHELL -----
      LLTT=KTYPE(LSH)
      MINL=KKMIN(LSH)
      MAXL=KKMAX(LSH)
      NUML=MAXL-MINL+1
      LOCL=KLOC(LSH)-MINL
!-----------------------------------------------------------------------
      RETURN
      END

! JKDNDXNOFlib
      SUBROUTINE JKDNDXNOFlib(NUMJ,NUMK,NUML,MINI,MAXI,MINJ,MAXJ,       &
                              MINK,MAXK,MINL,MAXL,IGXYZ,JGXYZ,KGXYZ,    &
                              LGXYZ,IIEQJJ,KKEQLL,IJEQKL,IJKLG,MAXNUM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(MAXNUM)::IJKLG
      INTEGER,INTENT(IN)::NUMJ,NUMK,NUML
      INTEGER,INTENT(IN)::MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL
      INTEGER,DIMENSION(35),INTENT(OUT)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
!-----------------------------------------------------------------------
!     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS -----
      NI=NUML*NUMK*NUMJ
      DO I=MINI,MAXI
        IGXYZ(I)=NI*(I-MINI)+1
      ENDDO
      NJ=NUML*NUMK
      DO J=MINJ,MAXJ
        JGXYZ(J)=NJ*(J-MINJ)
      ENDDO
!     ----- PREPARE INDICES FOR PAIRS OF (K,L) FUNCTIONS -----
      NK=NUML
      DO K=MINK,MAXK
        KGXYZ(K)=NK*(K-MINK)
      ENDDO
      NL=1
      DO L=MINL,MAXL
         LGXYZ(L)=NL*(L-MINL)
      ENDDO
!     ----- PREPARE INDICES FOR (IJ/KL) -----
      IJKL=0
      DO I=MINI,MAXI
        JMAX=MAXJ
        IF(IIEQJJ) JMAX=I
        DO J=MINJ,JMAX
          KMAX=MAXK
          IF(IJEQKL) KMAX=I
          DO K=MINK,KMAX
            LMAX=MAXL
            IF(KKEQLL           ) LMAX=K
            IF(IJEQKL.AND.K.EQ.I) LMAX=J
            DO L=MINL,LMAX
              IJKL=IJKL+1
              NN=((IGXYZ(I)+JGXYZ(J))+KGXYZ(K))+LGXYZ(L)
              IJKLG(IJKL)=   NN
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! DABNOF2lib
      SUBROUTINE DABNOF2lib(II,JJ,KK,LL,KKMIN,KKMAX,KLOC,IGXYZ,         &
                            JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,     &
                            IA,DA,DAB,MAXNUM,DABMAX,DAAUX,DAAUX2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INPFILE_NBF5/NBF5,NBFT5,NSQ5
!
      INTEGER,INTENT(IN)::II,JJ,KK,LL
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(35),INTENT(IN)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(NBF),INTENT(IN)::IA
      INTEGER,INTENT(IN)::MAXNUM
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(IN)::DA
      DOUBLE PRECISION,DIMENSION(NBF,NBFT),INTENT(IN)::DAAUX,DAAUX2
      DOUBLE PRECISION,INTENT(OUT)::DABMAX
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(OUT)::DAB
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00,PT5=0.5D+00
!-----------------------------------------------------------------------
      DABMAX=ZER         
!
!     GET 2e DENSITY FOR THIS SHELL BLOCK
!
      MINI= KKMIN(II)
      MINJ= KKMIN(JJ)
      MINK= KKMIN(KK)
      MINL= KKMIN(LL)
      LOCI= KLOC(II)-MINI
      LOCJ= KLOC(JJ)-MINJ
      LOCK= KLOC(KK)-MINK
      LOCL= KLOC(LL)-MINL
      MAXI= KKMAX(II)
      MAXJ= KKMAX(JJ)
      MAXK= KKMAX(KK)
      MAXL= KKMAX(LL)
         DO I=MINI,MAXI
            JMAX= MAXJ
            IF(IIEQJJ) JMAX= I
            DO J=MINJ,JMAX
               IAJ= MAX0(LOCI+I,LOCJ+J)
               IIJ= MIN0(LOCI+I,LOCJ+J)
               KMMAX=MAXK
               IF(IJEQKL) KMMAX= I
               DO K=MINK,KMMAX
                  LMAX= MAXL
                  IF(KKEQLL) LMAX= K
                  IF(IJEQKL .AND. K.EQ.I) LMAX= J
                  DO L=MINL,LMAX
                     KAL= MAX0(LOCK+K,LOCL+L)
                     KIL= MIN0(LOCK+K,LOCL+L)
                     IN = IAJ
                     JN = IIJ
                     KN = KAL
                     LN = KIL
                     IF(IN.LT.KN .OR.(IN.EQ.KN .AND. JN.LT.LN)) THEN
                        IN = KAL
                        JN = KIL
                        KN = IAJ
                        LN = IIJ
                     ENDIF
                     IJ = IA(IN)+JN
                     IK = IA(IN)+KN
                     IL = IA(IN)+LN
                     JK = IA(MAX0(JN,KN))+MIN0(JN,KN)
                     JL = IA(JN)+LN
                     IF(JN.LT.KN) JL = IA(MAX0(JN,LN))+MIN0(JN,LN)
                     KL = IA(KN)+LN
!                    CONTRACT OVER THE 2nd NO COEFFICIENT
                     DF1=ZER
                     DQ1=ZER
                     DO LQ=1,NBF5
                      DF1 = DF1 + DAAUX(LQ,KL)*DA(LQ,IJ)
                      DQ1 = DQ1 + DAAUX2(LQ,JK)*DA(LQ,IL)
                      DQ1 = DQ1 + DAAUX2(LQ,JL)*DA(LQ,IK)
                     ENDDO
!                    BUILD THE DENSITY TERM SUMMING COULOMB-LIKE
!                    AND EXCHANGE-LIKE PARTS
                     DF1 = DF1 + DF1 - DQ1
!                    AVOID DOUBLE COUNTING OF DIAGONAL TERMS                     
                     IF(JN.EQ.IN               ) DF1= DF1*PT5
                     IF(LN.EQ.KN               ) DF1= DF1*PT5
                     IF(KN.EQ.IN .AND. LN.EQ.JN) DF1= DF1*PT5
                     IF(DABMAX.LT. ABS(DF1)) DABMAX= ABS(DF1)
! IGXYZ AND J, K, AND L ARE SET UP IN JKDNDX
                     IJKL=IGXYZ(I)+JGXYZ(J)+KGXYZ(K)+LGXYZ(L)
                     DAB(IJKL)= DF1
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
!-----------------------------------------------------------------------
      RETURN
      END        

! DABNOF5lib
      SUBROUTINE DABNOF5lib(II,JJ,KK,LL,KKMIN,KKMAX,KLOC,IGXYZ,         &
                            JGXYZ,KGXYZ,LGXYZ,IIEQJJ,KKEQLL,IJEQKL,     &
                            IA,DAB,MAXNUM,DABMAX,CJAUX,CKAUX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::II,JJ,KK,LL
      INTEGER,DIMENSION(NSHELL),INTENT(IN)::KLOC,KKMIN,KKMAX
      INTEGER,DIMENSION(35),INTENT(IN)::IGXYZ,JGXYZ,KGXYZ,LGXYZ
      INTEGER,DIMENSION(NBF),INTENT(IN)::IA
      INTEGER,INTENT(IN)::MAXNUM
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      DOUBLE PRECISION,DIMENSION(NBFT,NBFT),INTENT(IN)::CJAUX,CKAUX
      DOUBLE PRECISION,INTENT(OUT)::DABMAX
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(OUT)::DAB
      DOUBLE PRECISION,PARAMETER::ZER=0.0D+00,PT5=0.5D+00
!-----------------------------------------------------------------------
      DABMAX=ZER         
!
!     GET 2e DENSITY FOR THIS SHELL BLOCK
!
      MINI= KKMIN(II)
      MINJ= KKMIN(JJ)
      MINK= KKMIN(KK)
      MINL= KKMIN(LL)
      LOCI= KLOC(II)-MINI
      LOCJ= KLOC(JJ)-MINJ
      LOCK= KLOC(KK)-MINK
      LOCL= KLOC(LL)-MINL
      MAXI= KKMAX(II)
      MAXJ= KKMAX(JJ)
      MAXK= KKMAX(KK)
      MAXL= KKMAX(LL)
         DO I=MINI,MAXI
            JMAX= MAXJ
            IF(IIEQJJ) JMAX= I
            DO J=MINJ,JMAX
               IAJ= MAX0(LOCI+I,LOCJ+J)
               IIJ= MIN0(LOCI+I,LOCJ+J)
               KMMAX=MAXK
               IF(IJEQKL) KMMAX= I
               DO K=MINK,KMMAX
                  LMAX= MAXL
                  IF(KKEQLL) LMAX= K
                  IF(IJEQKL .AND. K.EQ.I) LMAX= J
                  DO L=MINL,LMAX
                     KAL= MAX0(LOCK+K,LOCL+L)
                     KIL= MIN0(LOCK+K,LOCL+L)
                     IN = IAJ
                     JN = IIJ
                     KN = KAL
                     LN = KIL
                     IF(IN.LT.KN .OR.(IN.EQ.KN .AND. JN.LT.LN)) THEN
                        IN = KAL
                        JN = KIL
                        KN = IAJ
                        LN = IIJ
                     ENDIF
                     IJ = IA(IN)+JN
                     IK = IA(IN)+KN
                     IL = IA(IN)+LN
                     JK = IA(MAX0(JN,KN))+MIN0(JN,KN)
                     JL = IA(JN)+LN
                     IF(JN.LT.KN) JL = IA(MAX0(JN,LN))+MIN0(JN,LN)
                     KL = IA(KN)+LN
                     DF1 = ZER
                     DQ1 = ZER
                     DF1 = CJAUX(IJ,KL)
                     DQ1 = CKAUX(JK,IL) + CKAUX(JL,IK)
                     DF1 = DF1 + DF1 - DQ1
!                    AVOID DOUBLE COUNTING OF DIAGONAL TERMS                     
                     IF(JN.EQ.IN               ) DF1= DF1*PT5
                     IF(LN.EQ.KN               ) DF1= DF1*PT5
                     IF(KN.EQ.IN .AND. LN.EQ.JN) DF1= DF1*PT5
                     IF(DABMAX.LT. ABS(DF1)) DABMAX= ABS(DF1)
! IGXYZ AND J, K, AND L ARE SET UP IN JKDNDX
                     IJKL=IGXYZ(I)+JGXYZ(J)+KGXYZ(K)+LGXYZ(L)
                     DAB(IJKL)= DF1
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
!-----------------------------------------------------------------------
      RETURN
      END      

! JKDSPDNOFlib
      SUBROUTINE JKDSPDNOFlib(TOTCOUNT,DAB,II,JJ,KK,LL,MINI,MAXI,MINJ,  &
                              MAXJ,MINK,MAXK,MINL,MAXL,IIEQJJ,KKEQLL,   &
                              IJEQKL,SKIPI,SKIPJ,SKIPK,SKIPL,IJKLG,     &
                              MAXNUM,INVTYP,IIAT,JJAT,KKAT,LLAT,GRADS)  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      INTEGER,INTENT(IN)::MAXNUM
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(IN)::DAB
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      LOGICAL,INTENT(IN)::SKIPI,SKIPJ,SKIPK,SKIPL
      INTEGER,INTENT(IN)::MINI,MAXI,MINJ,MAXJ,MINK,MAXK,MINL,MAXL
      INTEGER,INTENT(IN)::INVTYP,IIAT,JJAT,KKAT,LLAT
      INTEGER,INTENT(INOUT)::TOTCOUNT
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(INOUT)::GRADS
      DOUBLE PRECISION,DIMENSION(12)::FD
      INTEGER,DIMENSION(MAXNUM),INTENT(IN)::IJKLG

      FD = 0.0d0
      CALL DSPDFSNOFlib(TOTCOUNT,IJKLG,DAB,SKIPI,SKIPJ,SKIPK,SKIPL,     &
                        MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,MAXNUM, &
                        IIEQJJ,KKEQLL,IJEQKL,FD,II,JJ,KK,LL)
      CALL JKDINVNOF(INVTYP,FD,GRADS,IIAT,JJAT,KKAT,LLAT)
!-----------------------------------------------------------------------
      RETURN
      END

! DSPDFSNOFlib
      SUBROUTINE DSPDFSNOFlib(IIFINT,IJKLG,DAB,SKIPI,SKIPJ,SKIPK,SKIPL, &
                              MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,  &
                              MAXNUM,IIEQJJ,KKEQLL,IJEQKL,FD,II,JJ,KK,LL)
      USE ISO_C_BINDING
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL,INTENT(IN)::IIEQJJ,KKEQLL,IJEQKL
      LOGICAL,INTENT(IN)::SKIPI,SKIPJ,SKIPK,SKIPL
      INTEGER,INTENT(IN)::MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL
      INTEGER,INTENT(INOUT)::IIFINT
      INTEGER,DIMENSION(MAXNUM),INTENT(IN)::IJKLG
      DOUBLE PRECISION,DIMENSION(12),INTENT(INOUT)::FD
      DOUBLE PRECISION,DIMENSION(MAXNUM),INTENT(IN)::DAB
!
      TYPE(C_PTR),DIMENSION(500)::BASLIB
      COMMON/LIBRETA/BASLIB
      DOUBLE PRECISION,DIMENSION(30000)::BLK
!-----------------------------------------------------------------------
!lib      CALL erisvalderiv(BASLIB,II,JJ,KK,LL,BLK)

      IJKLN=0
      NIJKL = 0
      DO I=MINI,MAXI
        JMAX=MAXJ
        IF(IIEQJJ) JMAX=I
        DO J=MINJ,JMAX
          KMAX=MAXK
          IF(IJEQKL) KMAX=I
          DO K=MINK,KMAX
            LMAX=MAXL
            IF(KKEQLL           ) LMAX=K
            IF(IJEQKL.AND.K.EQ.I) LMAX=J
            DO L=MINL,LMAX
              IJKLN=IJKLN+1
              NN=IJKLG(IJKLN)
!
              IF(SKIPI) GO TO 530
!
              IIFINT=IIFINT+3
              FD( 1)=FD( 1)+BLK(NIJKL+1)*DAB(NN)
              FD( 2)=FD( 2)+BLK(NIJKL+2)*DAB(NN)
              FD( 3)=FD( 3)+BLK(NIJKL+3)*DAB(NN)
  530         IF(SKIPJ) GO TO 550
!
              IIFINT=IIFINT+3 
              FD( 4)=FD( 4)+BLK(NIJKL+4)*DAB(NN)
              FD( 5)=FD( 5)+BLK(NIJKL+5)*DAB(NN)
              FD( 6)=FD( 6)+BLK(NIJKL+6)*DAB(NN)
  550         IF(SKIPK) GO TO 570
!
              IIFINT=IIFINT+3
              FD( 7)=FD( 7)+BLK(NIJKL+7)*DAB(NN)
              FD( 8)=FD( 8)+BLK(NIJKL+8)*DAB(NN)
              FD( 9)=FD( 9)+BLK(NIJKL+9)*DAB(NN)
  570         IF(SKIPL) GO TO 600
!
              IIFINT=IIFINT+3
              FD(10)=FD(10)+BLK(NIJKL+10)*DAB(NN)
              FD(11)=FD(11)+BLK(NIJKL+11)*DAB(NN)
              FD(12)=FD(12)+BLK(NIJKL+12)*DAB(NN)
  600         CONTINUE
              NIJKL = NIJKL + 12
!
            ENDDO
          ENDDO
        ENDDO
      ENDDO

      END      
      
!======================================================================!
!                                                                      !
!             N O F   H E S S I A N   S U B R O U T I N E S            !
!                                                                      !
!      Computation of Hessian numerically from analytic gradients      !
!                                                                      !
!              2018  Module implemented by Ion Mitxelena               !
!                                                                      !
!   HSSNUMd: Main routine, use the 6-grid numerical formula            !
!   SETFCMd: Form Hessian from the gradients                           !
!   SYMFCMd: Symmetrize the Hessian                                    !
!                                                                      !
!   Dipole derivative matrix calculation for obtaining IR intensities  !
!   SETDDMd: Numerical Dipole derivative matrix computation            !
!   SYMDDMd: Purify the dipole derivative tensor below a threshold     !
!                                                                      !
!   Harmonic Vibrational analysis                                      !
!   FGMTRXd: Main routine to do Harm Vib analysis                      !
!   HESMASd: Computes the mass-weighted Hessian                        !
!   CENMASd: Computes the center of mass with mass-weighting           !
!   STFASEd: Set the fase of Hessian                                   !
!                                                                      !
!   PRJFCMd: Projection of the Force Constant Matrix (FCM)             !
!                                                                      !
!======================================================================!

! HSSNUMd      
      SUBROUTINE HSSNUMd(FCM,NC1,Cxyz,EG,DIP,DDM,NINTEG,IDONTW,         &
                         ZAN,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,          &
                         KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,       &
                         EX1,CS,CP,CD,CF,CG,CH,CI,IRUNTYP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      LOGICAL CONVGDELAG,FROZEN
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/CONVERGENCE/DUMEL,PCONV,CONVGDELAG      
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200)
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/INPFILE_Naux/NBFaux,NSHELLaux
      COMMON/EHFEN/EHF,EN
      COMMON/ENERGIAS/EELEC,EELEC_OLD,DIF_EELEC,EELEC_MIN
      COMMON/ELPROP/IEMOM      
      COMMON/USELIBRETA/ILIBRETA 
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),              &
                  KLAST(100,6),LMAX(100),LPSKIP(100),IZCORE(100)         
!     ARGUMENTS
      INTEGER,INTENT(IN) :: NC1,NINTEG,IDONTW
      DOUBLE PRECISION,DIMENSION(NC1,NC1),INTENT(OUT) :: FCM
      DOUBLE PRECISION,DIMENSION(NC1),INTENT(IN) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NC1),INTENT(INOUT) :: EG
      DOUBLE PRECISION,DIMENSION(3),INTENT(INOUT) :: DIP
      DOUBLE PRECISION,DIMENSION(9,NC1/3),INTENT(OUT)::DDM
      DOUBLE PRECISION,DIMENSION(NC1/3),INTENT(IN) :: ZAN
      INTEGER,DIMENSION(NC1/3),INTENT(IN):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL),INTENT(IN) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI),INTENT(IN) :: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::C1,C2,EX1,CS,CP
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::CD,CF,CG,CH,CI
!     VARIABLES      
      DOUBLE PRECISION,DIMENSION(NC1) :: CDISP,EGDISP
      DOUBLE PRECISION,DIMENSION(2) :: D
      DOUBLE PRECISION,DIMENSION(3) :: DEQ
      LOGICAL,DIMENSION(NATOMS)::SKIP
      DOUBLE PRECISION,PARAMETER :: UNIT=0.52917724924D+00
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00
      CHARACTER*4,DIMENSION(106) :: ATMLAB
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',            &
                  'N   ','O   ','F   ','NE  ','NA  ','MG  ',            &
                  'AL  ','SI  ','P   ','S   ','CL  ','AR  ',            &
                  'K   ','CA  ','SC  ','TI  ','V   ','CR  ',            &
                  'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',            &
                  'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',            &
                  'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',            &
                  'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',            &
                  'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',            &
                  'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',            &
                  'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',            &
                  'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',            &
                  'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',            &
                  'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',            &
                  'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',            &
                  'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',            &
                  'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',            &
                  'LR  ','RF  ','X   ','BQ  '/
!-----------------------------------------------------------------------
!     NVIB   = The number of displacements in each Cartesian
!              direction for force field computation.C
!     VIBSIZ = Displacement size in Bohrs. Default=0.01     
!-----------------------------------------------------------------------
      WRITE(11,1)
      WRITE(6,'(/,72(1H-),/)')
      WRITE(6,*)'Note: Numerical Hessian and Frequencies in CGO file !!'
      WRITE(6,'(/,72(1H-),/)')
      VIBSIZ = 0.01D+00
      NVIB = 2
      D(1) =  VIBSIZ
      D(2) = -VIBSIZ
      DEL = VIBSIZ*NVIB*UNIT
      SKIP = .FALSE.
      CDISP = Cxyz
!     Purify Gradients by Householder method
      CALL GRADSPURIFY(EG,NC1)
      WRITE(11,3)
      EGDISP = EG
!     Print Energy & Convergence achieved by ELag
      WRITE(11,4)EELEC+EN,DUMEL
!     Print Gradients
      WRITE(11,5)
      DO I = 1,NATOMS
        WRITE(11,'(I4,3F15.4)')                                         &
         I,EG(1+(I-1)*3),EG(2+(I-1)*3),EG(3+(I-1)*3)
      ENDDO
      WRITE(11,*)      
      CALL SETDDMd(DDM,DIP,DEL,DEQ,0,NVIB,NC1,NVIB)
      CALL SETFCMd(FCM,NC1,NC1,EG,0)
!     IDENTIFY FROZEN ATOMS
      IF(FROZEN) THEN
       WRITE(11,40)
       DO I = 1,200,2
        IF(IFROZEN(I).EQ.0) EXIT
        SKIP(IFROZEN(I+1)) = .TRUE.
       ENDDO
      END IF
!
      NMAXSKIP = NATOMS
      DO I = NATOMS,1,-1
       IF(SKIP(I) .eqv. .FALSE.)THEN
        NMAXSKIP = I
        EXIT
       ENDIF
      ENDDO
!
      NDISPL=0
      NOPTCG=0
      III=0
      WRITE(11,6)
      IF(MOLDEN==1)THEN
       WRITE(18,7)
      ENDIF 
      DO IVIB = 1,NVIB
       DO IAT = 1,NATOMS
        IF(SKIP(IAT)) CYCLE
        NVA = 3*(IAT-1)
        DO ICOORD = 1,3
         III = III + 1        
         NV = NVA+ICOORD
         CDISP(NV) = CDISP(NV)+D(IVIB)
!        ENERGY AND GRADIENT AT DISPLACED GEOM 
         IF(IVIB==NVIB.AND.IAT==NMAXSKIP.AND.ICOORD==3)NOPTCG=1
!        Update coordinates of shells if use libreta library for ERIs
         if(ILIBRETA==1)CALL UPDCOOSHELL(NSHELL,KATOM,CDISP,NAT)
         CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NATOMS,NBF,NBFaux,NSHELL,    &
                       NPRIMI,ZAN,CDISP,IAN,IMIN,IMAX,KSTART,KATOM,     &
                       KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,         &
                       C1,C2,EX1,CS,CP,CD,CF,CG,CH,CI,EGDISP,           &
                       IRUNTYP,DIP,NOPTCG,0)
!        PURIFY THE GRADIENT BY HOUSEHOLDER METHOD
         CALL GRADSPURIFY(EGDISP,NC1)
         ENERGY = EELEC + EN
!        Displaced Geometries for MOLDEN
         if(MOLDEN==1)then   
          write(18,8)NATOMS
          write(18,9)III,ENERGY
          do jat=1,natoms
           jo = (jat-1)*3
           IZNUC = INT(ZAN(jat))+IZCORE(jat)                 
           write(18,10)ATMLAB(IZNUC),                                   &
           CDISP(1+jo)*UNIT,CDISP(2+jo)*UNIT,CDISP(3+jo)*UNIT
          enddo
         endif
!        MOVE THIS DISPLACED ATOM BACK TO WHERE IT CAME FROM
         CDISP(NV) = CDISP(NV)-D(IVIB)
!        CHECK ENERGY
         WRITE(11,15)III,ENERGY
!        COMPUTE CORRESPONDING HESSIAN AND DIPOLE DERIVATIVES
         CALL SETFCMd(FCM,NC1,NV,EGDISP,IVIB)
         CALL SETDDMd(DDM,DIP,DEL,DEQ,NV,IVIB,NC1,NVIB)
         EGDISP = ZERO
         NDISPL=NDISPL+1
        ENDDO
       ENDDO
      ENDDO      
!     COMPLETE NUMERICAL DIFFERENTIATIONS
!     SYMMETRIZE THE FORCE CONSTANT AND DIPOLE DERIVATIVE MATRIX
      CALL SYMFCMd(FCM,NC1,VIBSIZ)
      CALL SYMDDMd(DDM,NATOMS)
!     ZERO OFF FCM ELEMENTS FOR PARTIAL HESSIAN ANALYSIS      
      IF (FROZEN) THEN
      DO IFF=1,200,2
       IF(IFROZEN(IFF).EQ.0) EXIT
       IFREEZZ = 3*(IFROZEN(IFF+1)-1)+IFROZEN(IFF)
!      SET DIAGONAL FCM ELEMENTS BE 1.0D-08 FOR PARTIAL HESSIAN       
       FCM(IFREEZZ,IFREEZZ)=1.0D-08
       DO I = 1, NC1
        FCM(I,IFREEZZ)=ZERO
        FCM(IFREEZZ,I)=ZERO
       ENDDO
      ENDDO
      ENDIF
!     PRINT OUT TOTAL PNOF HESSIAN
      WRITE(11,20)
      DO I=1,NATOMS
       DO J=1,I
        WRITE(11,30)'X',I,J,FCM(1+(I-1)*3,1+(J-1)*3),                   &
                    FCM(2+(I-1)*3,1+(J-1)*3),FCM(3+(I-1)*3,1+(J-1)*3)    
        WRITE(11,30)'Y',I,J,FCM(1+(I-1)*3,2+(J-1)*3),                   &
                    FCM(2+(I-1)*3,2+(J-1)*3),FCM(3+(I-1)*3,2+(J-1)*3)    
        WRITE(11,30)'Z',I,J,FCM(1+(I-1)*3,3+(J-1)*3),                   &
                    FCM(2+(I-1)*3,3+(J-1)*3),FCM(3+(I-1)*3,3+(J-1)*3)
       ENDDO
      ENDDO
!     END HESSIAN CALCULATION
      WRITE(11,2)
      RETURN
!-----------------------------------------------------------------------
    1 FORMAT(/4X,'- START NUMERICAL HESSIAN CALCULATION -')
    2 FORMAT(/4X,'- END OF NUMERICAL HESSIAN CALCULATION -')
    3 FORMAT(/1X,'1E-06 is used for Gradient Cutoff')
    4 FORMAT(/1X,'Energy:',F16.6,' (',ES7.0,' )')
    5 FORMAT(/1X,'Energy Gradient',/)
    6 FORMAT(1X,'Energy at displaced Geometry',/)
    7 FORMAT('[GEOMETRIES] (XYZ)')
    8 FORMAT(I6)
    9 FORMAT('Displaced Geometry',I6,F20.10)
   10 FORMAT(1X,A4,3F15.4)
   15 FORMAT(I4,F20.10)
   20 FORMAT(//1X,'Hessian computed from analytic Gradients',           &         
              /1X,'----------------------------------------',           &
            //25X,'X',13X,'Y',13X,'Z',/)
   30 FORMAT(A4,2X,2I4,3F14.4)
   40 FORMAT(/1X,'Warning: Gradients related to a frozen Atom are 0')   
      END

! SETFCMd      
      SUBROUTINE SETFCMd(FCM,M,NV,EG,IVIB)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::IVIB,M,NV
      DOUBLE PRECISION,DIMENSION(M,M),INTENT(OUT)::FCM
      DOUBLE PRECISION,DIMENSION(M),INTENT(IN)::EG
      INTEGER:: I
!-----------------------------------------------------------------------      
!     SET ELEMENTS OF THE FORCE CONSTANT MATRIX
!-----------------------------------------------------------------------
      IF(IVIB .EQ. 0) THEN
!       INITIALIZE FCM TO ZERO
        FCM = 0.0D+00
        RETURN
      ENDIF  
!     STORE COLUMN 'NV' IN THE FCM
      IF(IVIB.EQ.1) THEN
!     FIRST DIFFERENCING
       DO I = 1,M
         FCM(I,NV) = EG(I)
       ENDDO
       RETURN
      ENDIF
!     SECOND DIFFERENCING
      DO I = 1,M
         FCM(I,NV) = FCM(I,NV)-EG(I)
      ENDDO
!-----------------------------------------------------------------------      
      RETURN
      END

! SYMFCMd      
      SUBROUTINE SYMFCMd(FCM,NCOORD,VIBSIZ)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::NCOORD
      DOUBLE PRECISION,INTENT(IN)::VIBSIZ
      DOUBLE PRECISION,DIMENSION(NCOORD,NCOORD),INTENT(INOUT)::FCM
      INTEGER:: I,J
      DOUBLE PRECISION:: DUM,AVE
      DOUBLE PRECISION,PARAMETER::HALF=0.5D+00
      DOUBLE PRECISION,PARAMETER::ONE=1.0D+00,TWO=2.0D+00
!-----------------------------------------------------------------------      
!      COMPLETE COMPUTATION OF THE FORCE CONSTANT MATRIX
!      MATRIX IS SYMMETRIZED.COMPLETE THE FINITE DIFFERENCING
!-----------------------------------------------------------------------
      DUM = ONE/(VIBSIZ*TWO)
      DO I = 1,NCOORD
         DO J = 1,NCOORD
            FCM(I,J) = DUM*FCM(I,J)
         ENDDO
      ENDDO
!     SYMMETRIZE THE FORCE CONSTANT MATRIX
      DO I = 2,NCOORD
         DO J = 1,I-1
            AVE = (FCM(I,J)+FCM(J,I))*HALF
            FCM(J,I) = AVE
            FCM(I,J) = AVE
         ENDDO
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! SETDDMd      
      SUBROUTINE SETDDMd(DDM,DIP,DEL,DEQ,NP,IVIB,NCOORD,NVIB)
      IMPLICIT NONE
!     ARGUMENTS      
      INTEGER,INTENT(IN):: NP,IVIB,NCOORD,NVIB
      DOUBLE PRECISION,DIMENSION(3,NCOORD),INTENT(INOUT):: DDM
      DOUBLE PRECISION,DIMENSION(3),INTENT(INOUT):: DEQ
      DOUBLE PRECISION,DIMENSION(3),INTENT(IN):: DIP
      DOUBLE PRECISION,INTENT(IN):: DEL
!     VARIABLES      
      DOUBLE PRECISION:: DELI
      INTEGER:: I
      DOUBLE PRECISION,PARAMETER ::ONE=1.0D+00,ZERO=0.0D+00
!      
      DELI = ONE/DEL
      IF(NP <= 0) THEN
!      INITIALIZE DIPOLE DERIVATIVE MATRIX
       DEQ(1) = DIP(1)
       DEQ(2) = DIP(2)
       DEQ(3) = DIP(3)
       DDM = ZERO
       RETURN
      ENDIF
!     UPDATE DIPOLE DERIVATIVE MATRIX
      IF(IVIB .EQ. 2) THEN
       DO I=1,3
        DDM(I,NP) = (DDM(I,NP) - DIP(I))*DELI
       ENDDO
       RETURN
      ENDIF
      IF(NVIB .EQ. 2) THEN
       DO I=1,3
        DDM(I,NP) = DIP(I)
       ENDDO
       RETURN
      ENDIF
      DO I=1,3
       DDM(I,NP) = (DIP(I) - DEQ(I))*DELI
      ENDDO
!-----------------------------------------------------------------------
      RETURN
      END

! SYMDDMd
      SUBROUTINE SYMDDMd(DDM,NAT)
      IMPLICIT NONE
      INTEGER,INTENT(IN):: NAT
      DOUBLE PRECISION,DIMENSION(9,NAT),INTENT(INOUT):: DDM
      INTEGER:: I,J
      DOUBLE PRECISION,PARAMETER ::ZERO=0.0D+00, TM7=1.0D-07
!     PURIFY DIPOLE DERIVATIVE TENSOR
      DO I=1,NAT
       DO J=1,9
        IF(DABS(DDM(J,I)).LT.TM7)DDM(J,I)=ZERO
       ENDDO
      ENDDO
      RETURN
      END

! FGMTRXd
      SUBROUTINE FGMTRXd(Cxyz,HESS,GRAD,NC1,ZNUC,ZMASS,DDM,IPROJECT,    &
                         ISIGMA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL EFIELDL,FROZEN
      COMMON/MAIN/NATOMS,ICH,MUL,NE,NA,NB,NSHELL,NPRIMI,NBF,NBFT,NSQ
      COMMON/INP_EFIELDL/EX,EY,EZ,EFIELDL
      COMMON/INPNOF_MOLDEN/MOLDEN
      COMMON/INPNOF_FROZEN/FROZEN,IFROZEN(200)
      COMMON/ECP2/CLP(400),ZLP(400),NLP(400),KFRST(100,6),              &
                  KLAST(100,6),LMAX(100),LPSKIP(100),IZCORE(100)         
!
      CHARACTER*2 LETI,IBLANK
      CHARACTER*4 CLAB(3)
      DOUBLE PRECISION :: LAB(9)
      DOUBLE PRECISION,DIMENSION(NC1),INTENT(IN) :: Cxyz !NC1=3*NATOMS
      DOUBLE PRECISION,DIMENSION(NC1,NC1),INTENT(INOUT) :: HESS   
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(IN) :: GRAD
      DOUBLE PRECISION,DIMENSION(3,NC1) :: SVTZR,SVTZT
      DOUBLE PRECISION,DIMENSION(NC1) :: SVTZTT,SVTZRT
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN) :: ZNUC
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN) :: ZMASS
      DOUBLE PRECISION,DIMENSION(3,NC1),INTENT(INOUT)::DDM
!     VARIABLES
      LOGICAL :: PRJGRD,PRJROT
      DOUBLE PRECISION :: ZMASST
      DOUBLE PRECISION,DIMENSION(3) :: CMASS,VMOI
      DOUBLE PRECISION,DIMENSION(NC1) :: FREQ,RM,E
      DOUBLE PRECISION,DIMENSION(3,NATOMS) :: COM
      DOUBLE PRECISION,DIMENSION(NC1,8) :: SCR
      INTEGER :: NIMAG,NLAST,NSKIP                                      
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00, ONE=1.0D+00 
      DOUBLE PRECISION,PARAMETER :: TWO=2.0D+00, THREE=3.0D+00
      DOUBLE PRECISION,PARAMETER :: FOUR=4.0D+00, SIX=6.0D+00
      DOUBLE PRECISION,PARAMETER :: SEVEN=7.0D+00
      DOUBLE PRECISION,PARAMETER :: TFACT=2.642461D+07
      DOUBLE PRECISION,PARAMETER :: PLANCK=6.626176D-34
      DOUBLE PRECISION,PARAMETER :: BOHR = 5.29177249D-11
      DOUBLE PRECISION,PARAMETER :: AVOGAD=6.022045D+23 
      DOUBLE PRECISION,PARAMETER :: TOANGS=0.52917724924D+00
      DOUBLE PRECISION,PARAMETER :: CATOM = 12.011D+00
      CHARACTER*4,DIMENSION(106) :: ATMLAB
      DOUBLE PRECISION,DIMENSION(:,:),ALLOCATABLE :: VEC
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',            &
                  'N   ','O   ','F   ','NE  ','NA  ','MG  ',            &
                  'AL  ','SI  ','P   ','S   ','CL  ','AR  ',            &
                  'K   ','CA  ','SC  ','TI  ','V   ','CR  ',            &
                  'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',            &
                  'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',            &
                  'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',            &
                  'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',            &
                  'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',            &
                  'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',            &
                  'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',            &
                  'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',            &
                  'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',            &
                  'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',            &
                  'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',            &
                  'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',            &
                  'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',            &
                  'LR  ','RF  ','X   ','BQ  '/
      DATA CLAB /'   X','   Y','   Z'/
      DATA LETI,IBLANK/' I','  '/
!
      DOUBLE PRECISION,PARAMETER::DFAC=2.54174D0    ! Debye
!-----------------------------------------------------------------------
!     WILSON -FG- MATRIX VIBRATIONAL ANALYSIS
!     W.D.GWINN   J.CHEM.PHYS.  55, 477-481 (1971)
!-----------------------------------------------------------------------
      ALLOCATE(VEC(NC1,NC1))
      NIMAG = 0
      WRITE(11,9000)
!     ZMASS=MASSES, RM=TRIPLES OF INVERSE SQUARE ROOTS OF MASSES.
      WRITE(11,9030)
      DO IAT = 1,NATOMS
       WRITE(11,9040) IAT,ZMASS(IAT)
      ENDDO
      I0=0
      DO I=1,NATOMS
       IF(ZMASS(I)>ZERO) THEN
        DMY = ONE/DSQRT(ZMASS(I))
       ELSE
        DMY = ONE
       END IF
       RM(I0+1) = DMY
       RM(I0+2) = DMY
       RM(I0+3) = DMY
       I0=I0+3
      ENDDO
!     ----- GENERATE MASS WEIGHTED GRADIENT AND HESSIAN
      I0 = 1
      DO I=1,NATOMS
       DO J=1,3
        SVTZT(J,I) = GRAD(J,I) 
        SVTZT(J,I) = RM(I0) * SVTZT(J,I)
       ENDDO
       I0 = I0+3
      ENDDO
      CALL HESMASd(NC1,HESS,RM)
!
!     ----- GET CENTER OF MASS IN MASS-WEIGHTED CARTESIAN COORDS
      CALL CENMASd(NATOMS,Cxyz,COM,ZMASST,CMASS,ZMASS)
!
!     PROJECT THE FORCE CONSTANT MATRIX (PROJECT=T)
      IF (IPROJECT==1) THEN
       WRITE(11,'(1X)')
       WRITE(11,9045)
       PRJROT = .TRUE.
       IF(EFIELDL) PRJROT = .FALSE.
       PRJGRD = .FALSE.
       CALL PRJFCMd(PRJGRD,PRJROT,ZMASST,HESS,COM,SVTZT,RM,NATOMS,NC1)
      END IF
!
!     ----- GET NORMAL MODES AND FREQUENCIES
      CALL DIAG(NC1,HESS,VEC,E,SCR(:,1))
      CALL STFASEd(VEC,NC1,NC1,NC1)
!
!     ----- TRANSLATIONAL AND ROTATIONAL SAYVETZ CONDITIONS
      SVTZR = ZERO
      SVTZT = ZERO
      DO I=1,NC1
       DO J=1,NATOMS
        JJ=MAX(3*(J-1),6*(J-1)-3*NATOMS)
        AMASS=ONE/RM((J-1)*3+1)
        DO K=1,3
         K1=MOD(K+1,4)+(K+1)/4
         K2=MOD(K+2,4)+(K+2)/4
         SVTZT(K,I)=SVTZT(K,I)+AMASS*VEC(JJ+K,I)
         SVTZR(K,I)=SVTZR(K,I)+COM(K1,J)*VEC(JJ+K2,I)                   &
                              -COM(K2,J)*VEC(JJ+K1,I)
        ENDDO
       ENDDO
       SVTZTT(I)=DSQRT(SVTZT(1,I)**2+SVTZT(2,I)**2+SVTZT(3,I)**2)
       SVTZRT(I)=DSQRT(SVTZR(1,I)**2+SVTZR(2,I)**2+SVTZR(3,I)**2)
      ENDDO
!
!     ----- CONVERT NORMAL MODE DISPLACEMENTS -----
      DO I = 1,NC1
       DO J = 1,NC1
        VEC(J,I) = VEC(J,I)*RM(J)
       END DO
      END DO
!
!     COMPUTE REDUCED MASS
      DO J = 1,NC1
       DD = DDOT(NC1,VEC(1,J),1,VEC(1,J),1)
       SCR(J,4) = ONE/DD
      END DO
!
!     COUNT NUMBER OF NEGATIVE EIGENVALUES
      DO I = 1,NC1
       IF(E(I)<ZERO)NIMAG=NIMAG+1
      ENDDO
!
!     DECIDE WHICH MODES ARE NOT TRUE VIBRATIONS
      NSKIP = 6
      IF(NATOMS==2)NSKIP = 5
      DO IAT=1,NATOMS
       NUCZ = INT(ZNUC(IAT))
       IF(NUCZ.EQ.0) NSKIP=NSKIP+3
      ENDDO
      IF(IPROJECT==1 .and. PRJGRD) NSKIP = NSKIP + 1
!
      NLAST = NSKIP
      DO I=1,NIMAG
       N2OF3 = 0
       MAYBE = I+NSKIP
       IF(MAYBE>NC1) EXIT
       IF(DABS(E(I))>DABS(E(MAYBE))) N2OF3=N2OF3+1
       IF(IPROJECT==1) THEN
        IF(N2OF3.EQ.1) NLAST = NLAST + 1
       ELSE
        IF(0.01D+00+SVTZRT(I)<SVTZRT(MAYBE)) N2OF3=N2OF3+1
        IF(0.01D+00+SVTZTT(I)<SVTZTT(MAYBE)) N2OF3=N2OF3+1
        IF(N2OF3.GE.2) NLAST = NLAST + 1
        IF(N2OF3.EQ.2) WRITE(11,9050) I,MAYBE
        IF(N2OF3.EQ.1) WRITE(11,9050) MAYBE,I
        IF(N2OF3.LE.1) EXIT
       END IF
      ENDDO
!
      NFIRST = NLAST - NSKIP + 1
      NIMAG = NFIRST-1
      WRITE(11,9060) NFIRST,NLAST
!
!     ----- PRINT MESSAGE FOR PARTIAL HESSIAN ANALYSIS -----
      IF(FROZEN) THEN
       NFRZ = 0
       DO I=1,200,2
        IF(IFROZEN(I).EQ.0) EXIT
        NFRZ = NFRZ + 1
       ENDDO      
       IF(NFRZ.GE.6)THEN
        IF(NFRZ.GE.9)THEN
         WRITE(11,9063)NLAST+1, NLAST+NFRZ-6, NLAST+NFRZ-5,             &
         NLAST+NFRZ-3, NLAST+1, NLAST+NFRZ-3                             
        ELSE                                                             
         WRITE(11,9064) NLAST+1, NLAST+NFRZ-3,                          &
         NLAST+1, NLAST+NFRZ-3
        END IF
       END IF
      ENDIF
!
!     ----- CONVERT FREQUENCIES TO WAVENUMBERS -----
      DO I = 1,NC1
       FREQ(I) = DSQRT(DABS(TFACT*E(I)))
      ENDDO
!
!     ----- PRINT WARNING FOR SKIPPING FROZEN FREQUENCIES -----
      IF(FROZEN) THEN
       IF(NFRZ.GE.6)THEN
        IF(FREQ(NLAST+NFRZ-3)>12.AND.FREQ(NLAST+NFRZ-2)<30)             &
        WRITE(11,9065)NLAST+NFRZ-3,NLAST+NFRZ-2
       END IF
      ENDIF
!
!     ----- COMPUTE IR INTENSITIES -----
!     PROJECT THE DIPOLE DERIVATIVE TENSOR ONTO EACH NORMAL MODE,
!     AND TAKE THE SQUARE OF THE NORM OF THIS 3 COMPONENT VECTOR
      DDM(:,:) = DDM(:,:)*DFAC
      DO J = 1,NC1
       DDX = DDOT(NC1,VEC(1,J),1,DDM(1,1),3)
       DDY = DDOT(NC1,VEC(1,J),1,DDM(2,1),3)
       DDZ = DDOT(NC1,VEC(1,J),1,DDM(3,1),3)
       SCR(J,1) = DDX*DDX + DDY*DDY + DDZ*DDZ
      ENDDO
!
!     PRINT OUT UNITS INFO
      WRITE(11,9070)
      MAXCOL = 0
      INCR = 5
!      
!     ----- PRINT THE FREQUENCY AND INTENSITY ----- 
!
      DO
       MINCOL = MAXCOL+1
       MAXCOL = MAXCOL+INCR
       IF (MAXCOL > NC1) MAXCOL = NC1
       WRITE (11,9090)
       WRITE (11,9100) (J,J = MINCOL,MAXCOL)
       DO J=MINCOL,MAXCOL
        JJ = J + 1 - MINCOL
        LAB(JJ) = transfer (LETI,LAB(JJ))            ! LAB(JJ)=LETI
        IF(J>NIMAG)LAB(JJ)=transfer(IBLANK,LAB(JJ))  ! LAB(JJ)=IBLANK
       ENDDO
       WRITE(11,9110)(FREQ(J),LAB(J+1-MINCOL),J = MINCOL,MAXCOL)
       WRITE(11,9120)(SCR(J,1),J=MINCOL,MAXCOL)
       WRITE(11,9115)(SCR(J,4),J=MINCOL,MAXCOL)
       WRITE(11,9090)
!      
!      PRINT AB INITIO NORMAL MODE COMPONENTS
       DO IAT = 1,NATOMS
        I0 = 3*(IAT-1)
        WRITE(11,9150)IAT,                                              &
                      CLAB(1),(VEC(I0+1,J),J=MINCOL,MAXCOL)
        WRITE(11,9160)CLAB(2),(VEC(I0+2,J),J=MINCOL,MAXCOL)
        WRITE(11,9160)CLAB(3),(VEC(I0+3,J),J=MINCOL,MAXCOL)
       ENDDO
!      
!      PRINT SAYVETZ CONDITIONS
       WRITE(11,9090)
       WRITE(11,9180)CLAB(1),(SVTZT(1,I),I=MINCOL,MAXCOL)
       WRITE(11,9160)CLAB(2),(SVTZT(2,I),I=MINCOL,MAXCOL)
       WRITE(11,9160)CLAB(3),(SVTZT(3,I),I=MINCOL,MAXCOL)
       WRITE(11,9200)(SVTZTT(I),I=MINCOL,MAXCOL)
       WRITE(11,9090)
       WRITE(11,9190)CLAB(1),(SVTZR(1,I),I=MINCOL,MAXCOL)
       WRITE(11,9160)CLAB(2),(SVTZR(2,I),I=MINCOL,MAXCOL)
       WRITE(11,9160)CLAB(3),(SVTZR(3,I),I=MINCOL,MAXCOL)
       WRITE(11,9200)(SVTZRT(I),I=MINCOL,MAXCOL)
       IF (MAXCOL>NC1 .OR. MAXCOL.EQ.NC1) EXIT
      ENDDO
      WRITE(11,9220)
      WRITE(11,9090)
      WRITE(11,9095)
!
!     Frequencies and corresponding normal coordinates for MOLDEN
!
       IF(MOLDEN==1)THEN
        WRITE(18,'(A6)')'[FREQ]'
        do j=1,nc1
         write(18,'(F10.2)')FREQ(j)
        enddo
        WRITE(18,'(A5)')'[INT]'
        do j=1,nc1
         write(18,'(F10.5)')SCR(j,1)
        enddo
        WRITE(18,'(A10)')'[FR-COORD]'
        do iat=1,NATOMS
         IZNUC = INT(ZNUC(iat))+IZCORE(iat)      
         io = 3*(iat-1)
         WRITE(18,'(1X,A4,3F15.4)')ATMLAB(IZNUC),                       &
                 Cxyz(1+io),Cxyz(2+io),Cxyz(3+io)         
        enddo
        WRITE(18,'(A15)')'[FR-NORM-COORD]'
        do j=1,nc1
         write(18,'(A9,1X,I5)')'vibration',j
         do iat = 1,NATOMS         
          io = 3*(iat-1)
          write(18,'(3F12.8)')VEC(1+io,j),VEC(2+io,j),VEC(3+io,j)
         enddo 
        enddo
       ENDIF 
!
!     ----- THERMOCHEMISTRY ANALYSIS ----- 
!
      CALL INRTIA(Cxyz,COM,ZMASS,VMOI,NATOMS)
      WRITE(11,9300) (VMOI(I),I=1,3),ONE
      FACT1 = (CATOM*BOHR*BOHR)/(12.0D+03*AVOGAD)
      PI = ACOS(-ONE)
      FACT2 = PLANCK/(8.0D+09*PI*PI)
      ACONST = ZERO
      BCONST = ZERO
      CCONST = ZERO
      IF(VMOI(1).GT.0.001D+00) ACONST = FACT2/(FACT1*VMOI(1))
      IF(VMOI(2).GT.0.001D+00) BCONST = FACT2/(FACT1*VMOI(2))
      IF(VMOI(3).GT.0.001D+00) CCONST = FACT2/(FACT1*VMOI(3))
      WRITE(11,9310) ACONST, BCONST, CCONST
!
      FACT = TOANGS*TOANGS/AVOGAD
      VMOI(1) = FACT * VMOI(1)
      VMOI(2) = FACT * VMOI(2)
      VMOI(3) = FACT * VMOI(3)
!
      NROTRA=NLAST
      CALL THERMO(NC1,NROTRA,FREQ,Cxyz,ZMASS,ISIGMA)
!
      DEALLOCATE(VEC)
      RETURN
!-----------------------------------------------------------------------      
 9000 FORMAT(/1X,                                                       &
       'Normal Coordinate Analysis in the Harmonic Approximation'/      &
       1X,56(1H-))                                                       
 9030 FORMAT(/10X,'ATOMIC WEIGHTS (AMU)'/)                               
 9040 FORMAT(I5,5X,F15.5)                                                
 9045 FORMAT(1X,'The Force Constant Matrix is projected to eliminate'   &
            /1X,'rotational and vibrational contaminants')               
 9050 FORMAT(/1X,'* * * WARNING, MODE',I2,' HAS BEEN CHOSEN AS A ',     &
                'VIBRATION'/10X,'WHILE MODE',I2,                        &
                ' IS ASSUMED TO BE A TRANSLATION/ROTATION.'/            &
             1X,'PLEASE VERIFY THE PROGRAM''S DECISION MANUALLY!'/)      
 9060 FORMAT(/1X,'MODES',I2,' TO',I2,' ARE TAKEN AS ROTATIONS',         &
             ' AND TRANSLATIONS.')                                       
 9063 FORMAT(/1X,'MODES',I3,' TO',I3,' ARE INTERNAL ',                  &
                'VIBRATIONS ',                                          &
                'OF FROZEN ATOMS.',                                     &
                /1X,'MODES',I3,' TO',I3,' ARE RELATIVE ',               &
                'VIBRATIONS ',                                          &
                'BETWEEN FROZEN AND UNFROZEN ATOMS.',                   &
                /1X,'MODES',I3,' TO',I3,' DO NOT CONTRIBUTE TO ',       &
                'VIBRATIONAL PARTITION FUNCTION',                       &
                ' AND ENERGY.',/)                                        
 9064 FORMAT(/1X,'MODES',I3,' TO',I3,' ARE RELATIVE ',                  &
                'VIBRATIONS ',                                          &
                'BETWEEN FROZEN AND UNFROZEN ATOMS.',                   &
                /1X,'MODES',I3,' TO',I3,' DO NOT CONTRIBUTE TO ',       &
                'VIBRATIONAL ',                                         &
                'ENERGIES AND PARTITION FUNCTION.',/)                    
 9065 FORMAT(//1X,'* * * WARNING ! * * *',//                            &
                1X,'MODE',I3,' IS TAKEN AS A RELATIVE VIBRATION ',      &
                'BETWEEN FROZEN AND UNFROZEN ATOMS ',                   &
                /1X,'WHILE MODE',I3,' IS TAKEN AS AN INTERNAL ',        &
                'VIBRATION OF UNFROZEN ATOMS.',//                       &
                1X,'PLEASE VERIFY THE PROGRAM''S DECISION MANUALLY !'/)  
 9070 FORMAT(/1X,'FREQUENCIES IN CM**-1',                               &
             /1X,'IR INTENSITIES IN DEBYE**2/AMU-ANGSTROM**2',          &
             /1X,'REDUCED MASSES IN AMU.')                               
 9090 FORMAT(1X)                                                         
 9095 FORMAT(5X'END OF NORMAL MODES',/)                                  
 9100 FORMAT(20X,9(4X,I3,5X))                                            
 9110 FORMAT(1X,'      FREQUENCY:',3X,9(F10.2,A2))                       
 9115 FORMAT(1X,'   REDUCED MASS:',3X,9(F10.5,2X))                       
 9120 FORMAT(1X,'   IR INTENSITY:',3X,9(F10.5,2X))                       
 9150 FORMAT(I3,13X,A4,9F12.8)                                           
 9160 FORMAT(16X,A4,9F12.8)                                              
 9180 FORMAT(16H TRANS. SAYVETZ ,A4,9F12.8)                              
 9190 FORMAT(16H   ROT. SAYVETZ ,A4,9F12.8)                              
 9200 FORMAT(15X,5HTOTAL,9F12.8)                                         
 9220 FORMAT(/1X,'NOTE - THE MODES J,K ARE ORTHONORMALIZED',            &
                 ' ACCORDING TO'/                                       &
              1X,'SUM ON I   M(I) * (X(I,J)*X(I,K) + Y(I,J)*',          &
                 'Y(I,K) + Z(I,J)*Z(I,K)) = DELTA(J,K)')                 
 9300 FORMAT(1X,'THE MOMENTS OF INERTIA ARE (IN AMU*BOHR**2)'/          &
             1X,3F12.5/                                                 &
             1X,'THE ROTATIONAL SYMMETRY NUMBER IS',F5.1)                
 9310 FORMAT(1X,'THE ROTATIONAL CONSTANTS ARE (IN GHZ)',/               &
             1X,3F12.5)     
      END

! HESMASd      
      SUBROUTINE HESMASd(NCOORD,HESS,RTRMS)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::NCOORD
      DOUBLE PRECISION,DIMENSION(NCOORD,NCOORD),INTENT(INOUT)::HESS
      DOUBLE PRECISION,DIMENSION(NCOORD),INTENT(IN)::RTRMS
      DOUBLE PRECISION,DIMENSION((NCOORD**2+NCOORD)/2):: A
      DOUBLE PRECISION:: RTRMSI
      INTEGER:: I,J,IJ
!-----------------------------------------------------------------------      
      IJ = 0
      DO I=1,NCOORD
       RTRMSI = RTRMS(I)
       DO J=1,I
        IJ = IJ + 1
        A(IJ) = RTRMSI * HESS(I,J) * RTRMS(J)
       END DO
      END DO
!     Symmetrize Hessian
      IJ=0
      DO I=1,NCOORD
       DO J=1,I
        IJ=IJ+1
        HESS(I,J)=A(IJ)
        HESS(J,I)=A(IJ)
       END DO
      END DO
!-----------------------------------------------------------------------      
      RETURN
      END

! CENMASd      
      SUBROUTINE CENMASd(NAT,C,COM,ZMASST,CMASS,ZMASS)
      IMPLICIT NONE
      INTEGER,INTENT(IN):: NAT
      DOUBLE PRECISION,INTENT(OUT):: ZMASST
      DOUBLE PRECISION,DIMENSION(3,NAT),INTENT(IN)::C
      DOUBLE PRECISION,DIMENSION(3,NAT),INTENT(OUT)::COM
      DOUBLE PRECISION,DIMENSION(3),INTENT(OUT)::CMASS
      DOUBLE PRECISION,DIMENSION(NAT),INTENT(IN)::ZMASS
      DOUBLE PRECISION:: AMASS
      INTEGER:: I,J
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
!-----------------------------------------------------------------------      
!     CALCULATE TOTAL MASS AND CENTER OF MASS
!-----------------------------------------------------------------------
      ZMASST= ZERO
      CMASS = ZERO
!
      DO I=1,NAT
       AMASS=ZMASS(I)
       ZMASST=ZMASST+AMASS
       DO J=1,3
        CMASS(J)=CMASS(J)+AMASS*C(J,I)
       END DO
      END DO
!
      DO I=1,3
       CMASS(I)=CMASS(I)/ZMASST
      END DO
!
      DO I=1,NAT
       IF (ZMASS(I)>ZERO) THEN
        AMASS = DSQRT(ZMASS(I))
       ELSE
        AMASS = ONE
       END IF
       DO J=1,3
        COM(J,I) = AMASS * (C(J,I)-CMASS(J))
       END DO
      END DO
!-----------------------------------------------------------------------      
      RETURN
      END   

! PRJFCMd                                                              
      SUBROUTINE PRJFCMd(PRJGRD,PRJROT,TOTM,FCM,X,DX,RM,NATM,NCC)        
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!     ARGUMENTS
      LOGICAL,INTENT(IN):: PRJGRD,PRJROT
      INTEGER,INTENT(IN) :: NATM,NCC
      DOUBLE PRECISION,INTENT(IN) :: TOTM
      DOUBLE PRECISION,DIMENSION(NCC),INTENT(IN) :: X,RM
      DOUBLE PRECISION,DIMENSION(NCC),INTENT(INOUT) :: DX
      DOUBLE PRECISION,DIMENSION(NCC,NCC),INTENT(INOUT) :: FCM
!     VARIABLES 
      DOUBLE PRECISION,DIMENSION(NCC,NCC)::P,BUF
      DOUBLE PRECISION,DIMENSION(3,3,3)::TENS
      DOUBLE PRECISION,DIMENSION(3,3)::ROT,SCR
      INTEGER,DIMENSION(6)::ISCR
      DOUBLE PRECISION,DIMENSION(2)::DETERM
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,CUT8=1.0D-08
      DOUBLE PRECISION,PARAMETER::HALF=0.5D+00,ONE=1.0D+00
!         -TENS- IS "THE USUAL TOTALLY ASYMMETRIC CARTESIAN TENSOR"
      DATA TENS/ 0.0D+00,  0.0D+00,  0.0D+00, &  ! X
                 0.0D+00,  0.0D+00, -1.0D+00, &  ! X
                 0.0D+00,  1.0D+00,  0.0D+00, &  ! Y
                 0.0D+00,  0.0D+00,  1.0D+00, &  ! Y
                 0.0D+00,  0.0D+00,  0.0D+00, &  ! Y
                -1.0D+00,  0.0D+00,  0.0D+00, &  ! Z
                 0.0D+00, -1.0D+00,  0.0D+00, &  ! Z
                 1.0D+00,  0.0D+00,  0.0D+00, &  ! Z
                 0.0D+00,  0.0D+00,  0.0D+00  /
!
!     PROJECTION OF THE FORCE CONSTANT MATRIX AT AN EQUILIBRIUM
!     GEOMETRY IS DONE WITH AN IDENTICALLY ZERO GRADIENT VECTOR
!     SO THAT THE TRANSLATIONAL AND VIBRATIONAL CONTAMINANTS
!     ONLY ARE ELIMINATED.
!
!     PROJECTION OF THE F.C.M. AT A POINT WITH A NON-ZERO GRADIENT
!     ALSO ELIMINATES THESE CONTAMINANTS, BUT ALSO PROJECTS THE
!     MATRIX SO THAT ONE OF ITS NORMAL MODES LIES PARALLEL TO
!     THE MASS-WEIGHTED GRADIENT.  THIS MODE WILL HAVE A ZERO
!     FREQUENCY, AND THE OTHER 3N-7 MODES WILL BE ORTHOGONAL TO
!     THIS MODE.  THIS TYPE OF PROJECTION IS USEFUL IN DYNAMICS.
!
!     FOR A DESCRIPTION OF THE METHOD, SEE W.H.MILLER, N.C.HANDY,
!     J.E.ADAMS, IN J.CHEM.PHYS. 72, 99-112(1980).
!
!     PRJGRD    = IF .TRUE., THE PROJECTION WILL ZERO THE NORMAL
!                 MODE PARALLEL TO THE GRADIENT VECTOR.  USEFUL
!                 IN TRANSITION STATE THEORY.
!     PRJROT    = IF .TRUE., THE PROJECTION WILL ZERO THE NORMAL
!                 MODES CORRESPONDING TO ROTATIONS
!     TOTM      = TOTAL MASS OF SYSTEM (INCLUDING FRAGMENT)
!     FCM       = ON ENTRY, MASS-WEIGHTED FORCE CONSTANT MATRIX.
!                 ON EXIT, PROJECTED TO REMOVE T,R AND POSSIBLY
!                 THE GRADIENT'S DEGREE OF FREEDOM
!     X         = MASS-WEIGHTED COORDINATE
!     DX        = ON ENTRY, MASS-WEIGHTED GRADIENT VECTOR.
!                 ON EXIT, THIS WILL HAVE BEEN DESTROYED
!                 THIS IS NOT USED IF PRJGRD IS FALSE.
!     RM        = INVERSE OF THE SQUARE ROOT MASS.
!     P,BUF     = WORK BUFFERS (NCC*NCC)
!     NATM      = NUMBER OF ATOMS.
!     NCC       = NO OF CARTESIAN COORDINATES (3*NATM)
!
!     ----- NORMALIZE THE GRADIENT -----
      IF(PRJGRD) THEN
       GNORM = DDOT(NCC,DX,1,DX,1)
       GNORM = ONE/DSQRT(GNORM)
       CALL DSCAL(NCC,GNORM,DX,1)
      END IF
!      
!  ----- CALCULATE PROJECTED FORCE CONSTANT MATRIX -----
!  COPIED FROM POLYRATE BY S. KOSEKI, DEC. 2, 1985.
!
!       --- COMPUTE INERTIA TENSOR ---
!
      ROT = ZERO
      IF(.NOT.PRJROT) GO TO 200
!
      DO I=1,NATM
       L=3*(I-1)+1
       ROT(1,1)=ROT(1,1)+X(L+1)**2+X(L+2)**2
       ROT(1,2)=ROT(1,2)-X(L)*X(L+1)
       ROT(1,3)=ROT(1,3)-X(L)*X(L+2)
       ROT(2,2)=ROT(2,2)+X(L)**2+X(L+2)**2
       ROT(2,3)=ROT(2,3)-X(L+1)*X(L+2)
       ROT(3,3)=ROT(3,3)+X(L)**2+X(L+1)**2
      ENDDO
      ROT(2,1)=ROT(1,2)
      ROT(3,1)=ROT(1,3)
      ROT(3,2)=ROT(2,3)
!
      CHK=ROT(1,1)*ROT(2,2)*ROT(3,3)
      IF(DABS(CHK).GT.CUT8) GO TO 180
!
!       --- COMPUTE INVERSE IN CASE OF SOME ZERO MOMENTS ---
!
      IF(DABS(ROT(1,1)).GT.CUT8) GO TO 130
      IF(DABS(ROT(2,2)).GT.CUT8) GO TO 120
      IF(DABS(ROT(3,3)).GT.CUT8) GO TO 110
      WRITE(11,10)ROT(1,1),ROT(2,2),ROT(3,3)
      RETURN
!
!             X,Y=0 BUT Z.NE.0
  110 ROT(3,3)=ONE/ROT(3,3)
      GO TO 170
!
!             Y.NE.0
  120 IF(DABS(ROT(3,3)).GT.CUT8) GO TO 160
!             X,Z=0 BUT Y.NE.0
      ROT(2,2)=ONE/ROT(2,2)
      GO TO 170
!
!             X.NE.0
  130 IF(DABS(ROT(2,2)).GT.CUT8) GO TO 140
      IF(DABS(ROT(3,3)).GT.CUT8) GO TO 150
!
!             Y,Z=0 BUT X.NE.0
      ROT(1,1)=ONE/ROT(1,1)
      GO TO 170
!
!             X,Y.NE.0 BUT Z=0
  140 DET=ROT(1,1)*ROT(2,2)-ROT(1,2)*ROT(2,1)
      TRP=ROT(1,1)
      ROT(1,1)=ROT(2,2)/DET
      ROT(2,2)=TRP/DET
      ROT(1,2)=-ROT(1,2)/DET
      ROT(2,1)=-ROT(2,1)/DET
      GO TO 170
!
!             X,Z.NE.0 BUT Y=0
  150 DET=ROT(1,1)*ROT(3,3)-ROT(1,3)*ROT(3,1)
      TRP=ROT(1,1)
      ROT(1,1)=ROT(3,3)/DET
      ROT(3,3)=TRP/DET
      ROT(1,3)=-ROT(1,3)/DET
      ROT(3,1)=-ROT(3,1)/DET
      GO TO 170
!
!             Y,Z.NE.0 BUT X=0
  160 DET=ROT(3,3)*ROT(2,2)-ROT(3,2)*ROT(2,3)
      TRP=ROT(3,3)
      ROT(3,3)=ROT(2,2)/DET
      ROT(2,2)=TRP/DET
      ROT(3,2)=-ROT(3,2)/DET
      ROT(2,3)=-ROT(2,3)/DET
!
  170 CONTINUE
      GO TO 200
!
!       --- COMPUTE INVERSE FOR ALL MOMENTS NONZERO CASE ---
  180 CONTINUE
      INFO=0
      CALL DGEFA(ROT,3,3,ISCR,INFO)
      IF(INFO.NE.0)THEN
       WRITE(11,20)
       RETURN
      END IF
      CALL DGEDId(ROT,3,3,ISCR,DETERM,SCR,1)
!
  200 CONTINUE
!     COMPUTE P MATRIX by FORMULA (EQN 4.11) OF MILLER, HANDY, ADAMS.  
!     ATOM CENTER
      DO IP=1,NATM
       INDX=3*(IP-1)
       KNDX=MAX(3*(IP-1),6*(IP-1)-3*NATM)
       DO JP=1,IP
        JNDX=3*(JP-1)
        LNDX=MAX(3*(JP-1),6*(JP-1)-3*NATM)
        DO IC=1,3
         II=INDX+IC
         KK=KNDX+IC
         JEND=3
         IF(JP.EQ.IP) JEND=IC
         DO JC=1,JEND
          JJ=JNDX+JC
          LL=LNDX+JC
          XMSUM=ZERO
          IF(PRJROT) THEN
          DO IA=1,3
           DO IB=1,3
            IF(TENS(IA,IB,IC).EQ.ZERO) CYCLE
            DO JA=1,3
             DO JB=1,3
              IF(TENS(JA,JB,JC).EQ.ZERO) CYCLE
              XMSUM = XMSUM + TENS(IA,IB,IC)*TENS(JA,JB,JC)             &
                            * ROT(IA,JA)*X(INDX+IB)*X(JNDX+JB)
             ENDDO
            ENDDO
           ENDDO
          ENDDO
          END IF
          P(KK,LL)=XMSUM
          IF(PRJGRD)P(KK,LL)=P(KK,LL) + DX(KK)*DX(LL)
          IF(IC.EQ.JC)P(KK,LL)=P(KK,LL) + ONE/(RM(II)*RM(JJ)*TOTM)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
!
!        --- COMPUTE (I-P) ---
      DO I=1,NCC
       DO J=1,I
        P(I,J)=-P(I,J)
        IF(I.EQ.J) P(I,J) = ONE + P(I,J)
        IF(DABS(P(I,J)).LT.CUT8) P(I,J)=ZERO
        P(J,I)=P(I,J)
       ENDDO
      ENDDO
!
!        --- PROJECT BY COMPUTING FCM = (I-P)*(FCM*(I-P)) ---
      CALL TFSQUd(BUF,FCM,P,DX,NCC,NCC)
      CALL DCOPY(NCC*NCC,BUF,1,FCM,1)
!
!     ----- ENFORCE SYMMETRY UPON F.C.M. -----
      DO I=1,NCC
       DO J=1,I
        AVRG   = HALF*(FCM(I,J)+FCM(J,I))
        FCM(J,I) = AVRG
        FCM(I,J) = AVRG
       ENDDO
      ENDDO
      RETURN
!-----------------------------------------------------------------------
   10 FORMAT(/1X,'PRJFCM: EVERY DIAGONAL ELEMENT IS ZERO?',3F20.10)
   20 FORMAT(/1X,                                                       &
       'INERTIA MATRIX IS SINGULAR HESSIAN WILL NOT BE PROJECTED!')
      END      

! TFSQUd      
      SUBROUTINE TFSQUd(H,FCM,T,WRK,N,M)                                                        
      IMPLICIT NONE
      INTEGER,INTENT(IN) :: N,M
      DOUBLE PRECISION,DIMENSION(M,M),INTENT(OUT) :: H
      DOUBLE PRECISION,DIMENSION(N),INTENT(OUT) :: WRK
      DOUBLE PRECISION,DIMENSION(N,N),INTENT(IN) :: FCM
      DOUBLE PRECISION,DIMENSION(N,M),INTENT(IN) :: T
      REAL :: DDOT
      INTEGER :: I,II,L,J,IIMAX
      INTEGER,PARAMETER :: MXROWS=5                                                                  
!     ----- TRANSFORM THE SQUARE MATRIX FCM USING VECTORS T -----         
!                      H = T-DAGGER * FCM * T                             
!     THE ORDER OF THE SQUARE MATRICES H, FCM, AND T IS N.                                                                          
      DO I = 1,M,MXROWS                                             
       IIMAX = MIN(M,I+MXROWS-1)                                                                                             
       DO II=I,IIMAX                                              
        DO L=1,N                                                
         WRK(L) = DDOT(N,T(1,II),1,FCM(1,L),1)                      
        ENDDO
        DO J=1,M                                                
         H(II,J) = DDOT(N,WRK,1,T(1,J),1)                         
        ENDDO
       ENDDO
      ENDDO
!-----------------------------------------------------------------------                                                                   
      RETURN                                                            
      END

! DGEDId
      SUBROUTINE DGEDId(A,LDA,N,IPVT,DET,WORK,JOB)                       
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(LDA,*),DET(2),WORK(*),IPVT(*)                         
!                                                                       
!     DGEDI COMPUTES THE DETERMINANT AND INVERSE OF A MATRIX            
!     USING THE FACTORS COMPUTED BY DGECO OR DGEFA.                     
!                                                                       
!     ON ENTRY                                                          
!                                                                       
!        A       DOUBLE PRECISION(LDA, N)                               
!                THE OUTPUT FROM DGECO OR DGEFA.                        
!                                                                       
!        LDA     INTEGER                                                
!                THE LEADING DIMENSION OF THE ARRAY  A .                
!                                                                       
!        N       INTEGER                                                
!                THE ORDER OF THE MATRIX  A .                           
!                                                                       
!        IPVT    INTEGER(N)                                             
!                THE PIVOT VECTOR FROM DGECO OR DGEFA.                  
!                                                                       
!        WORK    DOUBLE PRECISION(N)                                    
!                WORK VECTOR.  CONTENTS DESTROYED.                      
!                                                                       
!        JOB     INTEGER                                                
!                = 11   BOTH DETERMINANT AND INVERSE.                   
!                = 01   INVERSE ONLY.                                   
!                = 10   DETERMINANT ONLY.                               
!                                                                       
!     ON RETURN                                                         
!                                                                       
!        A       INVERSE OF ORIGINAL MATRIX IF REQUESTED.               
!                OTHERWISE UNCHANGED.                                   
!                                                                       
!        DET     DOUBLE PRECISION(2)                                    
!                DETERMINANT OF ORIGINAL MATRIX IF REQUESTED.           
!                OTHERWISE NOT REFERENCED.                              
!                DETERMINANT = DET(1) * 10.0**DET(2)                    
!                WITH  1.0 .LE. ABS(DET(1)) .LT. 10.0                   
!                OR  DET(1) .EQ. 0.0 .                                  
!                                                                       
!     ERROR CONDITION                                                   
!                                                                       
!        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS     
!        A ZERO ON THE DIAGONAL AND THE INVERSE IS REQUESTED.           
!        IT WILL NOT OCCUR IF THE ROUTINES ARE CALLED CORRECTLY         
!        AND IF DGECO HAS SET RCOND .GT. 0.0 OR DGEFA HAS SET           
!        INFO .EQ. 0 .                                                  
!                                                                       
!     LINPACK. THIS VERSION DATED 08/14/78 .                            
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.      
!                                                                       
!     ROUTINES AND FUNCTIONS                                            
!                                                                       
!     BLAS DAXPY,DSCAL,DSWAP                                            
!     FORTRAN ABS,MOD                                                   
!                                                                       
!     COMPUTE DETERMINANT                                               
!                                                                       
      IF (JOB/10 .EQ. 0) GO TO 70                                       
         DET(1) = 1.0D+00                                               
         DET(2) = 0.0D+00                                               
         TEN = 10.0D+00                                                 
         DO 50 I = 1, N                                                 
            IF (IPVT(I) .NE. I) DET(1) = -DET(1)                        
            DET(1) = A(I,I)*DET(1)                                      
!        ...EXIT                                                        
            IF (DET(1) .EQ. 0.0D+00) GO TO 60                           
   10       IF (ABS(DET(1)) .GE. 1.0D+00) GO TO 20                      
               DET(1) = TEN*DET(1)                                      
               DET(2) = DET(2) - 1.0D+00                                
            GO TO 10                                                    
   20       CONTINUE                                                    
   30       IF (ABS(DET(1)) .LT. TEN) GO TO 40                          
               DET(1) = DET(1)/TEN                                      
               DET(2) = DET(2) + 1.0D+00                                
            GO TO 30                                                    
   40       CONTINUE                                                    
   50    CONTINUE                                                       
   60    CONTINUE                                                       
   70 CONTINUE                                                          
!                                                                       
!     COMPUTE INVERSE(U)                                                
!                                                                       
      IF (MOD(JOB,10) .EQ. 0) GO TO 150                                 
         DO 100 K = 1, N                                                
            A(K,K) = 1.0D+00/A(K,K)                                     
            T = -A(K,K)                                                 
            CALL DSCAL(K-1,T,A(1,K),1)                                  
            KP1 = K + 1                                                 
            IF (N .LT. KP1) GO TO 90                                    
            DO 80 J = KP1, N                                            
               T = A(K,J)                                               
               A(K,J) = 0.0D+00                                         
               CALL DAXPY(K,T,A(1,K),1,A(1,J),1)                        
   80       CONTINUE                                                    
   90       CONTINUE                                                    
  100    CONTINUE                                                       
!                                                                       
!        FORM INVERSE(U)*INVERSE(L)                                     
!                                                                       
         NM1 = N - 1                                                    
         IF (NM1 .LT. 1) GO TO 140                                      
         DO 130 KB = 1, NM1                                             
            K = N - KB                                                  
            KP1 = K + 1                                                 
            DO 110 I = KP1, N                                           
               WORK(I) = A(I,K)                                         
               A(I,K) = 0.0D+00                                         
  110       CONTINUE                                                    
            DO 120 J = KP1, N                                           
               T = WORK(J)                                              
               CALL DAXPY(N,T,A(1,J),1,A(1,K),1)                        
  120       CONTINUE                                                    
            L = IPVT(K)                                                 
            IF (L .NE. K) CALL DSWAP(N,A(1,K),1,A(1,L),1)               
  130    CONTINUE                                                       
  140    CONTINUE                                                       
  150 CONTINUE                                                          
      RETURN                                                            
      END

!======================================================================!
!**********************************************************************!
!======================================================================!

!======================================================================!
!                                                                      !
!      SUMSL minimizes a general unconstrained objective function      !
!                                                                      !
!  Reference:                                                          !
!                                                                      !
!    J E Dennis, David Gay, and R E Welsch,                            !
!    An Adaptive Nonlinear Least-squares Algorithm,                    !
!    ACM Transactions on Mathematical Software,                        !
!    Volume 7, Number 3, 1981.                                         !
!                                                                      !
!    J E Dennis, H H W Mei,                                            !
!    Two New Unconstrained Optimization Algorithms Which Use           !
!    Function and Gradient Values,                                     !
!    Journal of Optimization Theory and Applications,                  !
!    Volume 28, pages 453-482, 1979.                                   !
!                                                                      !
!    J E Dennis, Jorge More,                                           !
!    Quasi-Newton Methods, Motivation and Theory,                      !
!    SIAM Review,                                                      !
!    Volume 19, pages 46-89, 1977.                                     !
!                                                                      !
!    D Goldfarb,                                                       !
!    Factorized Variable Metric Methods for Unconstrained Optimization,!
!    Mathematics of Computation,                                       !
!    Volume 30, pages 796-811, 1976.                                   !
!                                                                      !
!======================================================================!

subroutine sumsl(n,d,x,calcf,calcg,iv,liv,lv,v,uiparm,urparm)
!
! The routine uses analytic gradient and hessian approximation from
! the secant update. It interacts with subroutine sumit in an attempt
! to find an n-vector  x*  that minimizes the (unconstrained)
! objective function computed by  calcf.  (often the  x*  found is
! a local minimizer rather than a global one.)
!
! Parameters:
!
! n  (input) the number of variables on which  f  depends, i.e.,
!                  the number of components in  x.
! d  (input/output) a scale vector such that  d(i)*x(i),
!                  i = 1,2,...,n,  are all in comparable units.
!                  d can strongly affect the behavior of sumsl.
!                  finding the best choice of d is generally a trial-
!                  and-error process.  choosing d so that d(i)*x(i)
!                  has about the same value for all i often works well.
!                  the defaults provided by subroutine deflt (see iv
!                  below) require the caller to supply d.
! x........ (input/output) before (initially) calling sumsl, the call-
!                  er should set  x  to an initial guess at  x*.  when
!                  sumsl returns,  x  contains the best point so far
!                  found, i.e., the one that gives the least value so
!                  far seen for  f(x).
! calcf.... (input) a subroutine that, given x, computes f(x).  calcf
!                  must be declared external in the calling program.
!                  it is invoked by
!                    call calcf(n, x, nf, f, uiparm, urparm)
!                  when calcf is called, nf is the invocation
!                  count for calcf.  nf is included for possible use
!                  with calcg.  if x is out of bounds (e.g., if it
!                  would cause overflow in computing f(x)), then calcf
!                  should set nf to 0.  this will cause a shorter step
!                  to be attempted.  (if x is in bounds, then calcf
!                  should not change nf.)  the other parameters are as
!                  described above and below.  calcf should not change
!                  n, p, or x.
! calcg.... (input) a subroutine that, given x, computes g(x), the gra-
!                  dient of f at x.  calcg must be declared external in
!                  the calling program.  it is invoked by
!                    call calcg(n, x, nf, g, uiparm, urparm)
!                  when calcg is called, nf is the invocation
!                  count for calcf at the time f(x) was evaluated.  the
!                  x passed to calcg is usually the one passed to calcf
!                  on either its most recent invocation or the one
!                  prior to it.  if calcf saves intermediate results
!                  for use by calcg, then it is possible to tell from
!                  nf whether they are valid for the current x (or
!                  which copy is valid if two copies are kept).  if g
!                  cannot be computed at x, then calcg should set nf to
!                  0.  in this case, sumsl will return with iv(1) = 65.
!                  (if g can be computed at x, then calcg should not
!                  changed nf.)  the other parameters to calcg are as
!                  described above and below.  calcg should not change
!                  n or x.
! iv....... (input/output) an integer value array of length liv (see
!                  below) that helps control the sumsl algorithm and
!                  that is used to store various intermediate quanti-
!                  ties.  of particular interest are the initialization/
!                  return code iv(1) and the entries in iv that control
!                  printing and limit the number of iterations and func-
!                  tion evaluations.  see the section on iv input
!                  values below.
! liv...... (input) length of iv array.  must be at least 60.  if liv
!                  is too small, then sumsl returns with iv(1) = 15.
!                  when sumsl returns, the smallest allowed value of
!                  liv is stored in iv(lastiv) -- see the section on
!                  iv output values below.  (this is intended for use
!                  with extensions of sumsl that handle constraints.)
! lv....... (input) length of v array.  must be at least 71+n*(n+15)/2.
!                  (at least 77+n*(n+17)/2 for smsno, at least
!                  78+n*(n+12) for humsl).  if lv is too small, then
!                  sumsl returns with iv(1) = 16.  when sumsl returns,
!                  the smallest allowed value of lv is stored in
!                  iv(lastv) -- see the section on iv output values
!                  below.
! v........ (input/output) a floating-point value array of length lv
!                  (see below) that helps control the sumsl algorithm
!                  and that is used to store various intermediate
!                  quantities.  of particular interest are the entries
!                  in v that limit the length of the first step
!                  attempted (lmax0) and specify convergence tolerances
!                  (afctol, lmaxs, rfctol, sctol, xctol, xftol).
! uiparm... (input) user integer parameter array passed without change
!                  to calcf and calcg.
! urparm... (input) user floating-point parameter array passed without
!                  change to calcf and calcg.
!
!   iv input values (from subroutine deflt)
!
! iv(1)...  on input, iv(1) should have a value between 0 and 14......
!             0 and 12 mean this is a fresh start.  0 means that
!                  deflt(2, iv, liv, lv, v)
!             is to be called to provide all default values to iv and
!             v.  12 (the value that deflt assigns to iv(1)) means the
!             caller has already called deflt and has possibly changed
!             some iv and/or v entries to non-default values.
!             13 means deflt has been called and that sumsl (and
!             sumit) should only do their storage allocation.  that is,
!             they should set the output components of iv that tell
!             where various subarrays arrays of v begin, such as iv(g)
!             (and, for humsl and humit only, iv(dtol)), and return.
!             14 means that a storage has been allocated (by a call
!             with iv(1) = 13) and that the algorithm should be
!             started.  when called with iv(1) = 13, sumsl returns
!             iv(1) = 14 unless liv or lv is too small (or n is not
!             positive).  default = 12.
! iv(inith).... iv(25) tells whether the hessian approximation h should
!             be initialized.  1 (the default) means sumit should
!             initialize h to the diagonal matrix whose i-th diagonal
!             element is d(i)**2.  0 means the caller has supplied a
!             cholesky factor  l  of the initial hessian approximation
!             h = l*(l**t)  in v, starting at v(iv(lmat)) = v(iv(42))
!             (and stored compactly by rows).  note that iv(lmat) may
!             be initialized by calling sumsl with iv(1) = 13 (see
!             the iv(1) discussion above).  default = 1.
! iv(mxfcal)... iv(17) gives the maximum number of function evaluations
!             (calls on calcf) allowed.  if this number does not suf-
!             fice, then sumsl returns with iv(1) = 9.  default = 200.
! iv(mxiter)... iv(18) gives the maximum number of iterations allowed.
!             it also indirectly limits the number of gradient evalua-
!             tions (calls on calcg) to iv(mxiter) + 1.  if iv(mxiter)
!             iterations do not suffice, then sumsl returns with
!             iv(1) = 10.  default = 150.
! iv(outlev)... iv(19) controls the number and length of iteration sum-
!             mary lines printed (by itsum).  iv(outlev) = 0 means do
!             not print any summary lines.  otherwise, print a summary
!             line after each abs(iv(outlev)) iterations.  if iv(outlev)
!             is positive, then summary lines of length 78 (plus carri-
!             age control) are printed, including the following...  the
!             iteration and function evaluation counts, f = the current
!             function value, relative difference in function values
!             achieved by the latest step (i.e., reldf = (f0-v(f))/f01,
!             where f01 is the maximum of abs(v(f)) and abs(v(f0)) and
!             v(f0) is the function value from the previous itera-
!             tion), the relative function reduction predicted for the
!             step just taken (i.e., preldf = v(preduc) / f01, where
!             v(preduc) is described below), the scaled relative change
!             in x (see v(reldx) below), the step parameter for the
!             step just taken (stppar = 0 means a full newton step,
!             between 0 and 1 means a relaxed newton step, between 1
!             and 2 means a double dogleg step, greater than 2 means
!             a scaled down Cauchy step -- see subroutine dbldog), the
!             2-norm of the scale vector d times the step just taken
!             (see v(dstnrm) below), and npreldf, i.e.,
!             v(nreduc)/f01, where v(nreduc) is described below -- if
!             npreldf is positive, then it is the relative function
!             reduction predicted for a newton step (one with
!             stppar = 0).  if npreldf is negative, then it is the
!             negative of the relative function reduction predicted
!             for a step computed with step bound v(lmaxs) for use in
!             testing for singular convergence.
!                  if iv(outlev) is negative, then lines of length 50
!             are printed, including only the first 6 items listed
!             above (through reldx).
!             default = 1.
! iv(parprt)... iv(20) = 1 means print any nondefault v values on a
!             fresh start or any changed v values on a restart.
!             iv(parprt) = 0 means skip this printing.  default = 1.
! iv(prunit)... iv(21) is the output unit number on which all printing
!             is done.  iv(prunit) = 0 means suppress all printing.
!             default = standard output unit (unit 6 on most systems).
! iv(solprt)... iv(22) = 1 means print out the value of x returned (as
!             well as the gradient and the scale vector d).
!             iv(solprt) = 0 means skip this printing.  default = 1.
! iv(statpr)... iv(23) = 1 means print summary statistics upon return-
!             ing.  these consist of the function value, the scaled
!             relative change in x caused by the most recent step (see
!             v(reldx) below), the number of function and gradient
!             evaluations (calls on calcf and calcg), and the relative
!             function reductions predicted for the last step taken and
!             for a newton step (or perhaps a step bounded by v(lmaxs)
!             -- see the descriptions of preldf and npreldf under
!             iv(outlev) above).
!             iv(statpr) = 0 means skip this printing.
!             iv(statpr) = -1 means skip this printing as well as that
!             of the one-line termination reason message.  default = 1.
! iv(x0prt).... iv(24) = 1 means print the initial x and scale vector d
!             (on a fresh start only).  iv(x0prt) = 0 means skip this
!             printing.  default = 1.
!
!   (selected) iv output values
!
! iv(1)........ on output, iv(1) is a return code....
!             3 = x-convergence.  the scaled relative difference (see
!                  v(reldx)) between the current parameter vector x and
!                  a locally optimal parameter vector is very likely at
!                  most v(xctol).
!             4 = relative function convergence.  the relative differ-
!                  ence between the current function value and its lo-
!                  cally optimal value is very likely at most v(rfctol).
!             5 = both x- and relative function convergence (i.e., the
!                  conditions for iv(1) = 3 and iv(1) = 4 both hold).
!             6 = absolute function convergence.  the current function
!                  value is at most v(afctol) in absolute value.
!             7 = singular convergence.  the hessian near the current
!                  iterate appears to be singular or nearly so, and a
!                  step of length at most v(lmaxs) is unlikely to yield
!                  a relative function decrease of more than v(sctol).
!             8 = false convergence.  the iterates appear to be converg-
!                  ing to a noncritical point.  this may mean that the
!                  convergence tolerances (v(afctol), v(rfctol),
!                  v(xctol)) are too small for the accuracy to which
!                  the function and gradient are being computed, that
!                  there is an error in computing the gradient, or that
!                  the function or gradient is discontinuous near x.
!             9 = function evaluation limit reached without other con-
!                  vergence (see iv(mxfcal)).
!            10 = iteration limit reached without other convergence
!                  (see iv(mxiter)).
!            11 = STOPX returned .true. (external interrupt).  see the
!                  usage notes below.
!            14 = storage has been allocated (after a call with
!                  iv(1) = 13).
!            17 = restart attempted with n changed.
!            18 = d has a negative component and iv(dtype) <= 0.
!            19...43 = v(iv(1)) is out of range.
!            63 = f(x) cannot be computed at the initial x.
!            64 = bad parameters passed to assess (which should not
!                  occur).
!            65 = the gradient could not be computed at x (see calcg
!                  above).
!            67 = bad first parameter to deflt.
!            80 = iv(1) was out of range.
!            81 = n is not positive.
! iv(g)........ iv(28) is the starting subscript in v of the current
!             gradient vector (the one corresponding to x).
! iv(lastiv)... iv(44) is the least acceptable value of liv.  (it is
!             only set if liv is at least 44.)
! iv(lastv).... iv(45) is the least acceptable value of lv.  (it is
!             only set if liv is large enough, at least iv(lastiv).)
! iv(nfcall)... iv(6) is the number of calls so far made on calcf (i.e.,
!             function evaluations).
! iv(ngcall)... iv(30) is the number of gradient evaluations (calls on
!             calcg).
! iv(niter).... iv(31) is the number of iterations performed.
!
!   (selected) v input values (from subroutine deflt)
!
! v(bias)..... v(43) is the bias parameter used in subroutine dbldog --
!             see that subroutine for details.  default = 0.8.
! v(afctol)... v(31) is the absolute function convergence tolerance.
!             if sumsl finds a point where the function value is less
!             than v(afctol) in absolute value, and if sumsl does not
!             return with iv(1) = 3, 4, or 5, then it returns with
!             iv(1) = 6.  this test can be turned off by setting
!             v(afctol) to zero.  default = max(10**-20, machep**2),
!             where machep is the unit roundoff.
! v(dinit).... v(38), if nonnegative, is the value to which the scale
!             vector d is initialized.  default = -1.
! v(lmax0).... v(35) gives the maximum 2-norm allowed for d times the
!             very first step that sumsl attempts.  this parameter can
!             markedly affect the performance of sumsl.
! v(lmaxs).... v(36) is used in testing for singular convergence -- if
!             the function reduction predicted for a step of length
!             bounded by v(lmaxs) is at most v(sctol) * abs(f0), where
!             f0  is the function value at the start of the current
!             iteration, and if sumsl does not return with iv(1) = 3,
!             4, 5, or 6, then it returns with iv(1) = 7.  default = 1.
! v(rfctol)... v(32) is the relative function convergence tolerance.
!             if the current model predicts a maximum possible function
!             reduction (see v(nreduc)) of at most v(rfctol)*abs(f0)
!             at the start of the current iteration, where  f0  is the
!             then current function value, and if the last step attempt-
!             ed achieved no more than twice the predicted function
!             decrease, then sumsl returns with iv(1) = 4 (or 5).
!             default = max(10**-10, machep**(2/3)), where machep is
!             the unit roundoff.
! v(sctol).... v(37) is the singular convergence tolerance -- see the
!             description of v(lmaxs) above.
! v(tuner1)... v(26) helps decide when to check for false convergence.
!             this is done if the actual function decrease from the
!             current step is no more than v(tuner1) times its predict-
!             ed value.  default = 0.1.
! v(xctol).... v(33) is the x-convergence tolerance.  if a newton step
!             (see v(nreduc)) is tried that has v(reldx) <= v(xctol)
!             and if this step yields at most twice the predicted func-
!             tion decrease, then sumsl returns with iv(1) = 3 (or 5).
!             (see the description of v(reldx) below.)
!             default = machep**0.5, where machep is the unit roundoff.
! v(xftol).... v(34) is the false convergence tolerance.  if a step is
!             tried that gives no more than v(tuner1) times the predict-
!             ed function decrease and that has v(reldx) <= v(xftol),
!             and if sumsl does not return with iv(1) = 3, 4, 5, 6, or
!             7, then it returns with iv(1) = 8.  (see the description
!             of v(reldx) below.)  default = 100*machep, where
!             machep is the unit roundoff.
! v(*)........ deflt supplies to v a number of tuning constants, with
!             which it should ordinarily be unnecessary to tinker.  see
!             section 17 of version 2.2 of the nl2sol usage summary
!             (i.e., the appendix to ref. 1) for details on v(i),
!             i = decfac, incfac, phmnfc, phmxfc, rdfcmn, rdfcmx,
!             tuner2, tuner3, tuner4, tuner5.
!
!   (selected) v output values
!
! v(dgnorm)... v(1) is the 2-norm of (diag(d)**-1)*g, where g is the
!             most recently computed gradient.
! v(dstnrm)... v(2) is the 2-norm of diag(d)*step, where step is the
!             current step.
! v(f)........ v(10) is the current function value.
! v(f0)....... v(13) is the function value at the start of the current
!             iteration.
! v(nreduc)... v(6), if positive, is the maximum function reduction
!             possible according to the current model, i.e., the func-
!             tion reduction predicted for a newton step (i.e.,
!             step = -h**-1 * g,  where  g  is the current gradient and
!             h is the current hessian approximation).
!                  if v(nreduc) is negative, then it is the negative of
!             the function reduction predicted for a step computed with
!             a step bound of v(lmaxs) for use in testing for singular
!             convergence.
! v(preduc)... v(7) is the function reduction predicted (by the current
!             quadratic model) for the current step.  this (divided by
!             v(f0)) is used in testing for relative function
!             convergence.
! v(reldx).... v(17) is the scaled relative change in x caused by the
!             current step, computed as
!                  max(abs(d(i)*(x(i)-x0(i)), 1 <= i <= p) /
!                     max(d(i)*(abs(x(i))+abs(x0(i))), 1 <= i <= p),
!             where x = x0 + step.
!
!  notes
!
!   algorithm notes
!
!        this routine uses a hessian approximation computed from the
!     bfgs update (see ref 3).  only a cholesky factor of the hessian
!     approximation is stored, and this is updated using ideas from
!     ref. 4.  steps are computed by the double dogleg scheme described
!     in ref. 2.  the steps are assessed as in ref. 1.
!
!   usage notes
!
!        after a return with iv(1) <= 11, it is possible to restart,
!     i.e., to change some of the iv and v input values described above
!     and continue the algorithm from the point where it was interrupt-
!     ed.  iv(1) should not be changed, nor should any entries of iv
!     and v other than the input values (those supplied by deflt).
!        those who do not wish to write a calcg which computes the
!     gradient analytically should call smsno rather than sumsl.
!     smsno uses finite differences to compute an approximate gradient.
!        those who would prefer to provide f and g (the function and
!     gradient) by reverse communication rather than by writing subrou-
!     tines calcf and calcg may call on sumit directly.  see the com-
!     ments at the beginning of sumit.
!        those who use sumsl interactively may wish to supply their
!     own STOPX function, which should return .true. if the break key
!     has been pressed since STOPX was last invoked.  this makes it
!     possible to externally interrupt sumsl (which will return with
!     iv(1) = 11 if STOPX returns .true.).
!        storage for g is allocated at the end of v.  thus the caller
!     may make v longer than specified above and may allow calcg to use
!     elements of g beyond the first n as scratch storage.
!
!   portability notes
!
!        the sumsl distribution tape contains both single- and double-
!     precision versions of the sumsl source code, so it should be un-
!     necessary to change precisions.
!        only the function rmdcon contains machine-dependent
!     constants.  to change from one machine to another, it should
!     suffice to change the (few) relevant lines in these functions.
!        intrinsic functions are explicitly declared.  on certain com-
!     puters (e.g. univac), it may be necessary to comment out these
!     declarations.  so that this may be done automatically by a simple
!     program, such declarations are preceded by a comment having c/+
!     in columns 1-3 and blanks in columns 4-72 and are followed by
!     a comment having c/ in columns 1 and 2 and blanks in columns 3-72.
!        the sumsl source code is expressed in 1966 ansi standard
!     fortran.  it may be converted to fortran 77 by commenting out all
!     lines that fall between a line having c/6 in columns 1-3 and a
!     line having c/7 in columns 1-3 and by removing (i.e., replacing
!     by a blank) the c in column 1 of the lines that follow the c/7
!     line and precede a line having c/ in columns 1-2 and blanks in
!     columns 3-72.  these changes convert some data statements into
!     parameter statements, convert some variables from real to
!     character*4, and make the data statements that initialize these
!     variables use character strings delimited by primes instead
!     of hollerith constants.  (such variables and data statements
!     appear only in modules itsum and parck.  parameter statements
!     appear nearly everywhere.)  these changes also add save state-
!     ments for variables given machine-dependent constants by rmdcon.
!
  implicit double precision (a-h,o-z)   
  integer n, liv, lv
  integer iv(liv), uiparm(*)
  double precision d(n), x(n), v(lv), urparm(*)
!
  integer g1, iv1, nf
  double precision f
  integer nextv, nfcall, nfgcal, g, toobig, vneed

  parameter (nextv=47, nfcall=6, nfgcal=7, g=28, toobig=2, vneed=4)

  if (iv(1) == 0) call deflt(2, iv, liv, lv, v)
  iv1 = iv(1)
  if (iv1 == 12 .or. iv1 == 13) iv(vneed) = iv(vneed) + n
  if (iv1 == 14) go to 10
  if (iv1 > 2 .and. iv1 < 12) go to 10
  g1 = 1
  if (iv1 == 12) iv(1) = 13
  go to 20

 10   g1 = iv(g)

 20   call sumit(d, f, v(g1), iv, liv, lv, n, v, x)
  if (iv(1) - 2) 30, 40, 50

 30   nf = iv(nfcall)
  call calcf(n, x, nf, f, uiparm, urparm)
  if (nf <= 0) iv(toobig) = 1
  go to 20

 40   call calcg(n, x, iv(nfgcal), v(g1), uiparm, urparm)
  go to 20

 50   if (iv(1) /= 14) then
        return
      end if
!
!  Storage allocation
!
  iv(g) = iv(nextv)
  iv(nextv) = iv(g) + n
  if (iv1 /= 13) go to 10

  return
end

subroutine deflt ( alg, iv, liv, lv, v )
!
!! DEFLT: supply default values to IV and V.
!
!  Discussion:
!
!   ALG = 1 means regression constants.
!   ALG = 2 means general unconstrained optimization constants.
!
  integer liv
  integer lv

  integer alg
  integer iv(liv)
  double precision v(lv)
  external vdflt
  integer miv, mv
  integer miniv(2), minv(2)
  integer algsav, covprt, covreq, dtype, hc, ierr, inith, inits
  integer ipivot, ivneed, lastiv, lastv, lmat, mxfcal, mxiter
  integer nfcov, ngcov, nvdflt, outlev, parprt, parsav, perm
  integer prunit, qrtyp, rdreq, rmat, solprt, statpr, vneed
  integer vsave, x0prt

  parameter (algsav=51, covprt=14, covreq=15, dtype=16, hc=71 )
  parameter (ierr=75, inith=25, inits=25, ipivot=76, ivneed=3 )
  parameter (lastiv=44, lastv=45, lmat=42, mxfcal=17, mxiter=18 )
  parameter (nfcov=52, ngcov=53, nvdflt=50, outlev=19, parprt=20 )
  parameter (parsav=49, perm=58, prunit=21, qrtyp=80, rdreq=57 )
  parameter (rmat=78, solprt=22, statpr=23, vneed=4, vsave=60 )
  parameter (x0prt=24)

  data miniv(1)/80/, miniv(2)/59/, minv(1)/98/, minv(2)/71/

  if ( alg < 1 .or. 2 < alg ) then
    iv(1) = 67
    return
  end if

  miv = miniv(alg)

  if ( liv < miv ) then
    iv(1) = 15
    return
  end if

  mv = minv(alg)

  if ( lv < mv ) then
    iv(1) = 16
    return
  end if

  call vdflt(alg, lv, v)
  iv(1) = 12
  iv(algsav) = alg
  iv(ivneed) = 0
  iv(lastiv) = miv
  iv(lastv) = mv
  iv(lmat) = mv + 1
  iv(mxfcal) = 1000
  iv(mxiter) = 150
  iv(outlev) = 1
  iv(parprt) = 1
  iv(perm) = miv + 1
! change
  iv(prunit) = 2
! change
  iv(solprt) = 1
  iv(statpr) = 1
  iv(vneed) = 0
  iv(x0prt) = 1
!
!  General optimization values.
!
  if ( 2 <= alg ) then

    iv(dtype) = 0
    iv(inith) = 1
    iv(nfcov) = 0
    iv(ngcov) = 0
    iv(nvdflt) = 25
    iv(parsav) = 47
!
!  Regression values.
!
  else

    iv(covprt) = 3
    iv(covreq) = 1
    iv(dtype) = 1
    iv(hc) = 0
    iv(ierr) = 0
    iv(inits) = 0
    iv(ipivot) = 0
    iv(nvdflt) = 32
    iv(parsav) = 67
    iv(qrtyp) = 1
    iv(rdreq) = 3
    iv(rmat) = 0
    iv(vsave) = 58

  end if

  return
end

subroutine vdflt ( alg, lv, v )
!
!! VDFLT supplies default values to V.
!
!  Discussion:
!
!    alg = 1 means regression constants.
!    alg = 2 means general unconstrained optimization constants.
!
  implicit none

  integer alg, lv
  double precision v(lv)
  double precision rmdcon
  double precision machep, mepcrt, one, sqteps, three
  integer afctol, bias, cosmin, decfac, delta0, dfac, dinit, dltfdc
  integer dltfdj, dtinit, d0init, epslon, eta0, fuzz, huberc
  integer incfac, lmax0, lmaxs, phmnfc, phmxfc, rdfcmn, rdfcmx
  integer rfctol, rlimit, rsptol, sctol, sigmin, tuner1, tuner2
  integer tuner3, tuner4, tuner5, xctol, xftol

  parameter (one=1.d+0, three=3.d+0)

  parameter (afctol=31, bias=43, cosmin=47, decfac=22, delta0=44 )
  parameter ( dfac=41, dinit=38, dltfdc=42, dltfdj=43, dtinit=39 )
  parameter ( d0init=40, epslon=19, eta0=42, fuzz=45, huberc=48 )
  parameter ( incfac=23, lmax0=35, lmaxs=36, phmnfc=20, phmxfc=21 )
  parameter ( rdfcmn=24, rdfcmx=25, rfctol=32, rlimit=46, rsptol=49 )
  parameter ( sctol=37, sigmin=50, tuner1=26, tuner2=27, tuner3=28 )
  parameter ( tuner4=29, tuner5=30, xctol=33, xftol=34)

  machep = rmdcon(3)
  v(afctol) = 1.d-20

  if ( machep > 1.d-10 ) then
    v(afctol) = machep**2
  end if

  v(decfac) = 0.5d+0
  sqteps = rmdcon(4)
  v(dfac) = 0.6d+0
  v(delta0) = sqteps
  v(dtinit) = 1.d-6
  mepcrt = machep ** (one/three)
  v(d0init) = 1.d+0
  v(epslon) = 0.1d+0
  v(incfac) = 2.d+0
  v(lmax0) = 1.d+0
  v(lmaxs) = 1.d+0
  v(phmnfc) = -0.1d+0
  v(phmxfc) = 0.1d+0
  v(rdfcmn) = 0.1d+0
  v(rdfcmx) = 4.d+0
  v(rfctol) = max (1.d-10, mepcrt**2)
  v(sctol) = v(rfctol)
  v(tuner1) = 0.1d+0
  v(tuner2) = 1.d-4
  v(tuner3) = 0.75d+0
  v(tuner4) = 0.5d+0
  v(tuner5) = 0.75d+0
  v(xctol) = sqteps
  v(xftol) = 1.d+2 * machep

  if ( alg < 2 ) then
    v(cosmin) = max (1.d-6, 1.d+2 * machep)
    v(dinit) = 0.d+0
    v(dltfdc) = mepcrt
    v(dltfdj) = sqteps
    v(fuzz) = 1.5d+0
    v(huberc) = 0.7d+0
    v(rlimit) = rmdcon(5)
    v(rsptol) = 1.d-3
    v(sigmin) = 1.d-4
  else
    v(bias) = 0.8d+0
    v(dinit) = -1.0d+0
    v(eta0) = 1.0d+3 * machep
  end if

  return
end

subroutine sumit ( d, fx, g, iv, liv, lv, n, v, x)
!
!  SUMIT carries out unconstrained minimization iterations for SUMSL.
!
!  Discussion:
!
!    The routine uses double-dogleg/BFGS steps.
!
!    parameters iv, n, v, and x are the same as the corresponding
!    ones to sumsl (which see), except that v can be shorter (since
!    the part of v that sumsl uses for storing g is not needed).
!    moreover, compared with sumsl, iv(1) may have the two additional
!    output values 1 and 2, which are explained below, as is the use
!    of iv(toobig) and iv(nfgcal).  the value iv(g), which is an
!    output value from sumsl (and smsno), is not referenced by
!    sumit or the subroutines it calls.
!
!    fx and g need not have been initialized when sumit is called
!    with iv(1) = 12, 13, or 14.
!
! iv(1) = 1 means the caller should set fx to f(x), the function value
!             at x, and call sumit again, having changed none of the
!             other parameters.  an exception occurs if f(x) cannot be
!             (e.g. if overflow would occur), which may happen because
!             of an oversized step.  in this case the caller should set
!             iv(toobig) = iv(2) to 1, which will cause sumit to ig-
!             nore fx and try a smaller step.  the parameter nf that
!             sumsl passes to calcf (for possible use by calcg) is a
!             copy of iv(nfcall) = iv(6).
! iv(1) = 2 means the caller should set g to g(x), the gradient vector
!             of f at x, and call sumit again, having changed none of
!             the other parameters except possibly the scale vector d
!             when iv(dtype) = 0.  the parameter nf that sumsl passes
!             to calcg is iv(nfgcal) = iv(7).  if g(x) cannot be
!             evaluated, then the caller may set iv(nfgcal) to 0, in
!             which case sumit will return with iv(1) = 65.
!
!  Parameters:
!
! d.... scale vector.
! fx... function value.
! g.... gradient vector.
! iv... integer value array.
! liv.. length of iv (at least 60).
! lv... length of v (at least 71 + n*(n+13)/2).
! n.... number of variables (components in x and g).
! v.... floating-point value array.
! x.... vector of parameters to be optimized.
!
  integer liv
  integer lv
  integer n

  integer iv(liv)
  double precision d(n)
  double precision fx
  double precision g(n)
  double precision v(lv)
  double precision x(n)
  integer dg1, g01, i, k, l, lstgst, nwtst1, step1
  integer        temp1, w, x01, z
  double precision t
  double precision half, negone, one, onep2, zero
  logical stopx
  double precision dotprd, reldst, v2norm
  integer cnvcod, dg, dgnorm, dinit, dstnrm, dst0, f, f0, fdif
  integer gthg, gtstep, g0, incfac, inith, irc, kagqt, lmat, lmax0
  integer lmaxs, mode, model, mxfcal, mxiter, nextv, nfcall, nfgcal
  integer ngcall, niter, nreduc, nwtstp, preduc, radfac, radinc
  integer radius, rad0, reldx, restor, step, stglim, stlstg, toobig
  integer tuner4, tuner5, vneed, xirc, x0

  parameter (cnvcod=55, dg=37, g0=48, inith=25, irc=29, kagqt=33 )
  parameter ( mode=35, model=5, mxfcal=17, mxiter=18, nfcall=6 )
  parameter ( nfgcal=7, ngcall=30, niter=31, nwtstp=34, radinc=8 )
  parameter ( restor=9, step=40, stglim=11, stlstg=41, toobig=2 )
  parameter ( vneed=4, xirc=13, x0=43)

  parameter (dgnorm=1, dinit=38, dstnrm=2, dst0=3, f=10, f0=13 )
  parameter ( fdif=11, gthg=44, gtstep=4, incfac=23, lmat=42 )
  parameter ( lmax0=35, lmaxs=36, nextv=47, nreduc=6, preduc=7 )
  parameter ( radfac=16, radius=8, rad0=9, reldx=17, tuner4=29 )
  parameter ( tuner5=30)

  parameter (half=0.5d+0, negone=-1.d+0, one=1.d+0, onep2=1.2d+0, zero=0.d+0)
!
  i = iv(1)
  if (i == 1) go to 50
  if (i == 2) go to 60
!
!   check validity of iv and v input values
!
  if (iv(1) == 0) call deflt(2, iv, liv, lv, v)
  if (iv(1) == 12 .or. iv(1) == 13) then
    iv(vneed) = iv(vneed) + n*(n+13)/2
  end if
  call parck(2, d, iv, liv, lv, n, v)
  i = iv(1) - 2
  if (i > 12) then
    return
  end if
  go to (180, 180, 180, 180, 180, 180, 120, 90, 120, 10, 10, 20), i
!
!   storage allocation
!
10    l = iv(lmat)
  iv(x0) = l + n*(n+1)/2
  iv(step) = iv(x0) + n
  iv(stlstg) = iv(step) + n
  iv(g0) = iv(stlstg) + n
  iv(nwtstp) = iv(g0) + n
  iv(dg) = iv(nwtstp) + n
  iv(nextv) = iv(dg) + n
  if (iv(1) /= 13) go to 20
     iv(1) = 14
     return
!
!   initialization
!
 20   iv(niter) = 0
  iv(nfcall) = 1
  iv(ngcall) = 1
  iv(nfgcal) = 1
  iv(mode) = -1
  iv(model) = 1
  iv(stglim) = 1
  iv(toobig) = 0
  iv(cnvcod) = 0
  iv(radinc) = 0
  v(rad0) = 0.0D+00
  if (v(dinit) >= 0.0D+00) call vscopy(n, d, v(dinit))
  if (iv(inith) /= 1) go to 40
!
!  set the initial hessian approximation to diag(d)**-2
!
     l = iv(lmat)
     call vscopy(n*(n+1)/2, v(l), zero)
     k = l - 1

     do i = 1, n
       k = k + i
       t = d(i)
       if (t <= 0.0D+00) t = one
       v(k) = t
     end do
!
!  compute initial function value
!
 40   iv(1) = 1
  return

 50   v(f) = fx
  if (iv(mode) >= 0) go to 180
  iv(1) = 2
  if (iv(toobig) == 0) then
    return
  end if
     iv(1) = 63
     go to 300
!
!   make sure gradient could be computed
!
 60   if (iv(nfgcal) /= 0) go to 70
     iv(1) = 65
     go to 300

 70   dg1 = iv(dg)
  call vvmulp(n, v(dg1), g, d, -1)
  v(dgnorm) = v2norm(n, v(dg1))

  if (iv(cnvcod) /= 0) go to 290
  if (iv(mode) == 0) go to 250
!
!   allow first step to have scaled 2-norm at most v(lmax0)
!
  v(radius) = v(lmax0)

  iv(mode) = 0
!
!  main loop
!
!   print iteration summary, check iteration limit
!
 80   call itsum(d, g, iv, liv, lv, n, v, x)
 90   k = iv(niter)
  if (k < iv(mxiter)) go to 100
     iv(1) = 10
     go to 300
!
!   update radius
!
 100  iv(niter) = k + 1
  if(k>0)v(radius) = v(radfac) * v(dstnrm)
!
!   initialize for start of next iteration
!
  g01 = iv(g0)
  x01 = iv(x0)
  v(f0) = v(f)
  iv(irc) = 4
  iv(kagqt) = -1
!
!      copy x to x0, g to g0
!
  call vcopy(n, v(x01), x)
  call vcopy(n, v(g01), g)
!
!  Check STOPX and function evaluation limit
!
 110  if ( .not. stopx ( ) ) go to 130
     iv(1) = 11
     go to 140
!
!  Come here when restarting after func. eval. limit or STOPX.
!
 120  if (v(f) >= v(f0)) go to 130
     v(radfac) = one
     k = iv(niter)
     go to 100

 130  if (iv(nfcall) < iv(mxfcal)) go to 150
     iv(1) = 9
 140     if (v(f) >= v(f0)) go to 300
!
!  in case of STOPX or function evaluation limit with
!  improved v(f), evaluate the gradient at x.
!
          iv(cnvcod) = iv(1)
          go to 240
!
!  Compute candidate step
!
 150  step1 = iv(step)
  dg1 = iv(dg)
  nwtst1 = iv(nwtstp)
  if (iv(kagqt) >= 0) go to 160
     l = iv(lmat)
     call livmul(n, v(nwtst1), v(l), g)
     v(nreduc) = half * dotprd(n, v(nwtst1), v(nwtst1))
     call litvmu(n, v(nwtst1), v(l), v(nwtst1))
     call vvmulp(n, v(step1), v(nwtst1), d, 1)
     v(dst0) = v2norm(n, v(step1))
     call vvmulp(n, v(dg1), v(dg1), d, -1)
     call ltvmul(n, v(step1), v(l), v(dg1))
     v(gthg) = v2norm(n, v(step1))
     iv(kagqt) = 0
 160  call dbdog(v(dg1), lv, n, v(nwtst1), v(step1), v)
  if (iv(irc) == 6) go to 180
!
!   check whether evaluating f(x0 + step) looks worthwhile
!
  if (v(dstnrm) <= 0.0D+00) go to 180
  if (iv(irc) /= 5) go to 170
  if (v(radfac) <= one) go to 170
  if (v(preduc) <= onep2 * v(fdif)) go to 180
!
!  Compute f(x0 + step)
!
 170  x01 = iv(x0)
  step1 = iv(step)
  call vaxpy(n, x, one, v(step1), v(x01))
  iv(nfcall) = iv(nfcall) + 1
  iv(1) = 1
  iv(toobig) = 0
  return
!
!  Assess candidate step.
!
 180  x01 = iv(x0)
  v(reldx) = reldst(n, d, x, v(x01))
  call assst(iv, liv, lv, v)
  step1 = iv(step)
  lstgst = iv(stlstg)
  if (iv(restor) == 1) call vcopy(n, x, v(x01))
  if (iv(restor) == 2) call vcopy(n, v(lstgst), v(step1))
  if (iv(restor) /= 3) go to 190
     call vcopy(n, v(step1), v(lstgst))
     call vaxpy(n, x, one, v(step1), v(x01))
     v(reldx) = reldst(n, d, x, v(x01))

 190  k = iv(irc)
  go to (200,230,230,230,200,210,220,220,220,220,220,220,280,250), k
!
!      recompute step with changed radius
!
 200     v(radius) = v(radfac) * v(dstnrm)
     go to 110
!
!   compute step of length v(lmaxs) for singular convergence test.
!
 210  v(radius) = v(lmaxs)
  go to 150
!
!   convergence or false convergence
!
 220  iv(cnvcod) = k - 4
  if (v(f) >= v(f0)) go to 290
     if (iv(xirc) == 14) go to 290
          iv(xirc) = 14
!
!  Process acceptable step.
!
 230  if (iv(irc) /= 3) go to 240
     step1 = iv(step)
     temp1 = iv(stlstg)
!
!      set  temp1 = hessian * step  for use in gradient tests
!
     l = iv(lmat)
     call ltvmul(n, v(temp1), v(l), v(step1))
     call lvmul(n, v(temp1), v(l), v(temp1))
!
!   compute gradient
!
 240  iv(ngcall) = iv(ngcall) + 1
  iv(1) = 2
  return
!
!   initializations -- g0 = g - g0, etc.
!
 250  g01 = iv(g0)
  call vaxpy(n, v(g01), negone, v(g01), g)
  step1 = iv(step)
  temp1 = iv(stlstg)
  if (iv(irc) /= 3) go to 270
!
!   set v(radfac) by gradient tests
!
!  Set  temp1 = diag(d)**-1 * (hessian*step + (g(x0)-g(x)))
!
     call vaxpy(n, v(temp1), negone, v(g01), v(temp1))
     call vvmulp(n, v(temp1), v(temp1), d, -1)
!
!  Do gradient tests
!
     if (v2norm(n, v(temp1)) <= v(dgnorm) * v(tuner4)) then
       go to 260
     end if

     if (dotprd(n, g, v(step1)) >= v(gtstep) * v(tuner5))  then
       go to 270
     end if

 260               v(radfac) = v(incfac)
!
!   update h, loop
!
 270  w = iv(nwtstp)
  z = iv(x0)
  l = iv(lmat)
  call wzbfgs(v(l), n, v(step1), v(w), v(g01), v(z))
!
!  Use the n-vectors starting at v(step1) and v(g01) for scratch.
!
  call lupdat(v(temp1), v(step1), v(l), v(g01), v(l), n, v(w), v(z))
  iv(1) = 2
  go to 80
!
!   misc. details
!
!   bad parameters to assess
!
 280  iv(1) = 64
  go to 300
!
!  Print summary of final iteration and other requested items
!
 290  iv(1) = iv(cnvcod)
  iv(cnvcod) = 0
 300  call itsum(d, g, iv, liv, lv, n, v, x)

  return
end

subroutine parck ( alg, d, iv, liv, lv, n, v )
!
!  PARCK checks parameters, prints changed values.
!
!  Discussion:
!
!    alg = 1 for regression, alg = 2 for general unconstrained opt.
!
  integer alg, liv, lv, n
  integer iv(liv)
  double precision d(n), v(lv)
  double precision rmdcon
  integer max0
  integer i, ii, iv1, j, k, l, m, miv1, miv2, ndfalt, parsv1, pu
  integer ijmp, jlim(2), miniv(2), ndflt(2)
  character*1 varnm(2), sh(2)
  character*4 cngd(3), dflt(3), vn(2,34), which(3)
  double precision big, machep, tiny, vk, vm(34), vx(34)
  integer algsav, dinit, dtype, dtype0, epslon, inits, ivneed
  integer lastiv, lastv, lmat, nextiv, nextv, nvdflt, oldn
  integer parprt, parsav, perm, prunit, vneed

  parameter (algsav=51, dinit=38, dtype=16, dtype0=54, epslon=19 )
  parameter ( inits=25, ivneed=3, lastiv=44, lastv=45, lmat=42 )
  parameter ( nextiv=46, nextv=47, nvdflt=50, oldn=38, parprt=20 )
  parameter ( parsav=49, perm=58, prunit=21, vneed=4)
  save big, machep, tiny

  data big/0.d+0/, machep/-1.d+0/, tiny/1.d+0/

     data vn(1,1),vn(2,1)/'epsl','on..'/
     data vn(1,2),vn(2,2)/'phmn','fc..'/
     data vn(1,3),vn(2,3)/'phmx','fc..'/
     data vn(1,4),vn(2,4)/'decf','ac..'/
     data vn(1,5),vn(2,5)/'incf','ac..'/
     data vn(1,6),vn(2,6)/'rdfc','mn..'/
     data vn(1,7),vn(2,7)/'rdfc','mx..'/
     data vn(1,8),vn(2,8)/'tune','r1..'/
     data vn(1,9),vn(2,9)/'tune','r2..'/
     data vn(1,10),vn(2,10)/'tune','r3..'/
     data vn(1,11),vn(2,11)/'tune','r4..'/
     data vn(1,12),vn(2,12)/'tune','r5..'/
     data vn(1,13),vn(2,13)/'afct','ol..'/
     data vn(1,14),vn(2,14)/'rfct','ol..'/
     data vn(1,15),vn(2,15)/'xcto','l...'/
     data vn(1,16),vn(2,16)/'xfto','l...'/
     data vn(1,17),vn(2,17)/'lmax','0...'/
     data vn(1,18),vn(2,18)/'lmax','s...'/
     data vn(1,19),vn(2,19)/'scto','l...'/
     data vn(1,20),vn(2,20)/'dini','t...'/
     data vn(1,21),vn(2,21)/'dtin','it..'/
     data vn(1,22),vn(2,22)/'d0in','it..'/
     data vn(1,23),vn(2,23)/'dfac','....'/
     data vn(1,24),vn(2,24)/'dltf','dc..'/
     data vn(1,25),vn(2,25)/'dltf','dj..'/
     data vn(1,26),vn(2,26)/'delt','a0..'/
     data vn(1,27),vn(2,27)/'fuzz','....'/
     data vn(1,28),vn(2,28)/'rlim','it..'/
     data vn(1,29),vn(2,29)/'cosm','in..'/
     data vn(1,30),vn(2,30)/'hube','rc..'/
     data vn(1,31),vn(2,31)/'rspt','ol..'/
     data vn(1,32),vn(2,32)/'sigm','in..'/
     data vn(1,33),vn(2,33)/'eta0','....'/
     data vn(1,34),vn(2,34)/'bias','....'/

  data vm(1)/1.0d-3/, vm(2)/-0.99d+0/, vm(3)/1.0d-3/, vm(4)/1.0d-2/
  data vm(5)/1.2d+0/, vm(6)/1.d-2/, vm(7)/1.2d+0/, vm(8)/0.d+0/
  data vm(9)/0.d+0/, vm(10)/1.d-3/, vm(11)/-1.d+0/, vm(13)/0.d+0/
  data vm(15)/0.d+0/, vm(16)/0.d+0/, vm(19)/0.d+0/, vm(20)/-10.d+0/
  data vm(21)/0.d+0/, vm(22)/0.d+0/, vm(23)/0.d+0/, vm(27)/1.01d+0/
  data vm(28)/1.d+10/, vm(30)/0.d+0/, vm(31)/0.d+0/, vm(32)/0.d+0/
  data vm(34)/0.d+0/

  data vx(1)/0.9d+0/, vx(2)/-1.d-3/, vx(3)/1.d+1/, vx(4)/0.8d+0/
  data vx(5)/1.d+2/, vx(6)/0.8d+0/, vx(7)/1.d+2/, vx(8)/0.5d+0/
  data vx(9)/0.5d+0/, vx(10)/1.d+0/, vx(11)/1.d+0/, vx(14)/0.1d+0/
  data vx(15)/1.d+0/, vx(16)/1.d+0/, vx(19)/1.d+0/, vx(23)/1.d+0/
  data vx(24)/1.d+0/, vx(25)/1.d+0/, vx(26)/1.d+0/, vx(27)/1.d+10/
  data vx(29)/1.d+0/, vx(31)/1.d+0/, vx(32)/1.d+0/, vx(33)/1.d+0/
  data vx(34)/1.d+0/

  data varnm(1)/'p'/, varnm(2)/'n'/, sh(1)/'s'/, sh(2)/'h'/
  data cngd(1),cngd(2),cngd(3)/'---c','hang','ed v'/
  data dflt(1),dflt(2),dflt(3)/'nond','efau','lt v'/
  data ijmp/33/, jlim(1)/0/, jlim(2)/24/, ndflt(1)/32/, ndflt(2)/25/
  data miniv(1)/80/, miniv(2)/59/

  pu = 0
  if (prunit <= liv) pu = iv(prunit)
  if (alg < 1 .or. alg > 2) go to 340
  if (iv(1) == 0) call deflt(alg, iv, liv, lv, v)
  iv1 = iv(1)
  if (iv1 /= 13 .and. iv1 /= 12) go to 10
  miv1 = miniv(alg)
  if (perm <= liv) miv1 = max0(miv1, iv(perm) - 1)
  if (ivneed <= liv) miv2 = miv1 + max0(iv(ivneed), 0)
  if (lastiv <= liv) iv(lastiv) = miv2
  if (liv < miv1) go to 300
  iv(ivneed) = 0
  iv(lastv) = max0(iv(vneed), 0) + iv(lmat) - 1
  iv(vneed) = 0
  if (liv < miv2) go to 300
  if (lv < iv(lastv)) go to 320
 10   if (alg == iv(algsav)) go to 30
  if (pu /= 0) write(pu,20) alg, iv(algsav)
 20 format(/39h the first parameter to deflt should be,i3,12h rather than,i3)
     iv(1) = 82
     return
 30   if (iv1 < 12 .or. iv1 > 14) go to 60
     if (n >= 1) go to 50
          iv(1) = 81
          if (pu == 0) then
            return
          end if
          write(pu,40) varnm(alg), n
 40           format(/8h /// bad,a1,2h =,i5)
          return
 50      if (iv1 /= 14) iv(nextiv) = iv(perm)
     if (iv1 /= 14) iv(nextv) = iv(lmat)
     if (iv1 == 13) then
       return
     end if
     k = iv(parsav) - epslon
     call vdflt(alg, lv-k, v(k+1))
     iv(dtype0) = 2 - alg
     iv(oldn) = n
     which(1) = dflt(1)
     which(2) = dflt(2)
     which(3) = dflt(3)
     go to 110
 60   if (n == iv(oldn)) go to 80
     iv(1) = 17
     if (pu == 0) then
       return
     end if
     write(pu,70) varnm(alg), iv(oldn), n
 70      format(/5h /// ,1a1,14h changed from ,i5,4h to ,i5)
     return

 80   if (iv1 <= 11 .and. iv1 >= 1) go to 100
     iv(1) = 80
     if (pu /= 0) write(pu,90) iv1
 90      format(/13h ///  iv(1) =,i5,28h should be between 0 and 14.)
     return

 100  which(1) = cngd(1)
  which(2) = cngd(2)
  which(3) = cngd(3)

 110  if (iv1 == 14) iv1 = 12
  if (big > tiny) go to 120
     tiny = rmdcon(1)
     machep = rmdcon(3)
     big = rmdcon(6)
     vm(12) = machep
     vx(12) = big
     vx(13) = big
     vm(14) = machep
     vm(17) = tiny
     vx(17) = big
     vm(18) = tiny
     vx(18) = big
     vx(20) = big
     vx(21) = big
     vx(22) = big
     vm(24) = machep
     vm(25) = machep
     vm(26) = machep
     vx(28) = rmdcon(5)
     vm(29) = machep
     vx(30) = big
     vm(33) = machep
 120  m = 0
  i = 1
  j = jlim(alg)
  k = epslon
  ndfalt = ndflt(alg)

  do l = 1, ndfalt
    vk = v(k)
    if (vk >= vm(i) .and. vk <= vx(i)) go to 140
      m = k
      if (pu /= 0) write(pu,130) vn(1,i), vn(2,i), k, vk,vm(i), vx(i)
 130  format(/6h ///  ,2a4,5h.. v(,i2,3h) =,d11.3,7h should, &
      11h be between,d11.3,4h and,d11.3)
 140  k = k + 1
     i = i + 1
     if (i == j) i = ijmp
  end do

  if (iv(nvdflt) == ndfalt) go to 170
     iv(1) = 51
     if (pu == 0) then
       return
     end if
     write(pu,160) iv(nvdflt), ndfalt
 160     format(/13h iv(nvdflt) =,i5,13h rather than ,i5)
     return
 170  if ((iv(dtype) > 0 .or. v(dinit) > 0.0D+00) .and. iv1 == 12) then
             go to 200
  end if

  do i = 1, n
     if (d(i) > 0.0D+00) go to 190
          m = 18
          if (pu /= 0) write(pu,180) i, d(i)
 180     format(/8h ///  d(,i3,3h) =,d11.3,19h should be positive)
 190     continue
  end do

 200  if (m == 0) go to 210
     iv(1) = m
     return

 210  if (pu == 0 .or. iv(parprt) == 0) then
        return
      end if
  if (iv1 /= 12 .or. iv(inits) == alg-1) go to 230
     m = 1
     write(pu,220) sh(alg), iv(inits)
 220 format(/22h nondefault values..../5h init,a1,14h      iv(25) =,i3)
 230  if (iv(dtype) == iv(dtype0)) go to 250
     if (m == 0) write(pu,260) which
     m = 1
     write(pu,240) iv(dtype)
 240     format(20h dtype      iv(16) =,i3)
 250  i = 1
  j = jlim(alg)
  k = epslon
  l = iv(parsav)
  ndfalt = ndflt(alg)

  do ii = 1, ndfalt
     if (v(k) == v(l)) go to 280
          if (m == 0) write(pu,260) which
 260          format(/1h ,3a4,9halues..../)
          m = 1
          write(pu,270) vn(1,i), vn(2,i), k, v(k)
 270          format(1x,2a4,5h.. v(,i2,3h) =,d15.7)
 280     k = k + 1
     l = l + 1
     i = i + 1
     if (i == j) i = ijmp
  end do

  iv(dtype0) = iv(dtype)
  parsv1 = iv(parsav)
  call vcopy(iv(nvdflt), v(parsv1), v(epslon))
  return

 300  iv(1) = 15
  if (pu == 0) then
    return
  end if
  write(pu,310) liv, miv2
 310  format(/10h /// liv =,i5,17h must be at least,i5)
  if (liv < miv1) then
    return
  end if
  if (lv < iv(lastv)) go to 320
  return

 320  iv(1) = 16
  if (pu == 0) then
    return
  end if
  write(pu,330) lv, iv(lastv)
 330  format(/9h /// lv =,i5,17h must be at least,i5)
  return

 340  iv(1) = 67
  if (pu == 0) then
    return
  end if
  write(pu,350) alg
 350  format(/10h /// alg =,i5,15h must be 1 or 2)

  return
end

subroutine itsum ( d, g, iv, liv, lv, p, v, x )

!
! ITSUM prints an iteration summary.
!
  integer liv
  integer lv
  integer p

  double precision d(p)
  double precision g(p)
  integer iv(liv)
  double precision v(lv)
  double precision x(p)
  integer alg, i, iv1, m, nf, ng, ol, pu
  character*4 model1(6), model2(6)
  double precision nreldf, oldf, preldf, reldf
  integer algsav, dstnrm, f, fdif, f0, needhd, nfcall, nfcov, ngcov
  integer ngcall, niter, nreduc, outlev, preduc, prntit, prunit
  integer reldx, solprt, statpr, stppar, sused, x0prt

  parameter (algsav=51, needhd=36, nfcall=6, nfcov=52, ngcall=30 )
  parameter ( ngcov=53, niter=31, outlev=19, prntit=39, prunit=21 )
  parameter ( solprt=22, statpr=23, sused=64, x0prt=24)
  parameter (dstnrm=2, f=10, f0=13, fdif=11, nreduc=6, preduc=7, reldx=17 )
  parameter ( stppar=5)

  data model1/'    ','    ','    ','    ','  g ','  s '/
  data model2/' g  ',' s  ','g-s ','s-g ','-s-g','-g-s'/

  pu = iv(prunit)

  if ( pu == 0 ) then
    return
  end if

  iv1 = iv(1)
  if (iv1 > 62) iv1 = iv1 - 51
  ol = iv(outlev)
  alg = iv(algsav)
  if (iv1 < 2 .or. iv1 > 15) go to 370
  if (iv1 >= 12) go to 120
  if (iv1 == 2 .and. iv(niter) == 0) go to 390
  if (ol == 0) go to 120
  if (iv1 >= 10 .and. iv(prntit) == 0) go to 120
  if (iv1 > 2) go to 10
     iv(prntit) = iv(prntit) + 1
     if (iv(prntit) < iabs(ol)) then
       return
     end if
 10   nf = iv(nfcall) - iabs(iv(nfcov))
  iv(prntit) = 0
  reldf = 0.0D+00
  preldf = 0.0D+00
  oldf = max (abs(v(f0)), abs(v(f)))
  if (oldf <= 0.0D+00) go to 20
     reldf = v(fdif) / oldf
     preldf = v(preduc) / oldf
 20   if (ol > 0) go to 60
!
!  print short summary line
!
     if (iv(needhd) == 1 .and. alg == 1) write(pu,30)
 30   format(/'   it   nf',6x,'f',7x,'reldf',3x,'preldf',3x,'reldx', &
     &  2x,'model  stppar')
     if (iv(needhd) == 1 .and. alg == 2) write(pu,40)
 40  format(/'    it   nf',7x,'f',8x,'reldf',4x,'preldf',4x,'reldx   stppar')
     iv(needhd) = 0
     if (alg == 2) go to 50
     m = iv(sused)
     write(pu,100) iv(niter), nf, v(f), reldf, preldf, v(reldx), &
       model1(m), model2(m), v(stppar)
     go to 120

 50  write(pu,110) iv(niter), nf, v(f), reldf, preldf, v(reldx), v(stppar)
     go to 120
!
!  print long summary line
!
 60   if (iv(needhd) == 1 .and. alg == 1) write(pu,70)
 70   format(/11h    it   nf,6x,1hf,7x,5hreldf,3x,6hpreldf,3x,5hreldx, &
        2x,13hmodel  stppar,2x,6hd*step,2x,7hnpreldf)
  if (iv(needhd) == 1 .and. alg == 2) write(pu,80)
 80   format(/11h    it   nf,7x,1hf,8x,5hreldf,4x,6hpreldf,4x,5hreldx, &
        3x,6hstppar,3x,6hd*step,3x,7hnpreldf)
  iv(needhd) = 0
  nreldf = 0.0D+00
  if (oldf > 0.0D+00) nreldf = v(nreduc) / oldf
  if (alg == 2) go to 90
  m = iv(sused)
  write(pu,100) iv(niter), nf, v(f), reldf, preldf, v(reldx), &
              model1(m), model2(m), v(stppar), v(dstnrm), nreldf
  go to 120

 90   write(pu,110) iv(niter), nf, v(f), reldf, preldf, &
             v(reldx), v(stppar), v(dstnrm), nreldf
 100  format(i6,i5,d10.3,2d9.2,d8.1,a3,a4,2d8.1,d9.2)
 110  format(i6,i5,d11.3,2d10.2,3d9.1,d10.2)

 120  if (iv(statpr) < 0) go to 430
  go to (999, 999, 130, 150, 170, 190, 210, 230, 250, 270, 290, 310, &
    330, 350, 520), iv1

 130  write(pu,140)
 140  format(/' x-convergence')
  go to 430

 150  write ( pu, 160 )
 160  format(/'relative function convergence')
  go to 430

 170  write(pu,180)
 180  format(/'x- and relative function convergence')
  go to 430

 190  write(pu,200)
 200  format(/'Absolute function convergence.')
  go to 430

 210  write(pu,220)
 220  format(/'Singular convergence.')
  go to 430

 230  write(pu,240)
 240  format(/'False convergence.')
  go to 430

 250  write(pu,260)
 260  format(/'Function evaluation limit.')
  go to 430

 270  write(pu,280)
 280  format(/'Iteration limit.')
  go to 430

 290  write(pu,300)
 300  format(/'STOPX')
  go to 430

 310  write(pu,320)
 320  format(/'Initial f(x) cannot be computed.')

  go to 390

 330  write(pu,340)
 340  format(/'Bad parameters to assess.')
  go to 999

 350  write(pu,360)
 360  format(/'Gradient could not be computed.')
  if (iv(niter) > 0) go to 480
  go to 390

 370  write(pu,380) iv(1)
 380  format(/'iv(1) =',i5)
  go to 999
!
!   initial call on itsum
!
 390  if (iv(x0prt) /= 0) write(pu,400) (i, x(i), d(i), i = 1, p)
 400  format(/23h     i     initial x(i),8x,4hd(i)//(1x,i5,d17.6,d14.3))
!     the following are to avoid undefined variables when the
!     function evaluation limit is 1...
!
  v(dstnrm) = 0.0D+00
  v(fdif) = 0.0D+00
  v(nreduc) = 0.0D+00
  v(preduc) = 0.0D+00
  v(reldx)  = 0.0D+00
  if (iv1 >= 12) go to 999
  iv(needhd) = 0
  iv(prntit) = 0
  if (ol == 0) go to 999
  if (ol < 0 .and. alg == 1) write(pu,30)
  if (ol < 0 .and. alg == 2) write(pu,40)
  if (ol > 0 .and. alg == 1) write(pu,70)
  if (ol > 0 .and. alg == 2) write(pu,80)
  if (alg == 1) write(pu,410) v(f)
  if (alg == 2) write(pu,420) v(f)
 410  format(/11h     0    1,d10.3)
!365  format(/11h     0    1,e11.3)
 420  format(/11h     0    1,d11.3)
  go to 999
!
!  Print various information requested on solution
!
 430  iv(needhd) = 1
  if (iv(statpr) == 0) go to 480
     oldf = max (abs(v(f0)), abs(v(f)))
     preldf = 0.0D+00
     nreldf = 0.0D+00
     if (oldf <= 0.0D+00) go to 440
          preldf = v(preduc) / oldf
          nreldf = v(nreduc) / oldf
 440     nf = iv(nfcall) - iv(nfcov)
     ng = iv(ngcall) - iv(ngcov)
     write(pu,450) v(f), v(reldx), nf, ng, preldf, nreldf
 450  format(/9h function,d17.6,8h   reldx,d17.3/12h func. evals, &
    i8,9x,11hgrad. evals,i8/7h preldf,d16.3,6x,7hnpreldf,d15.3)

     if (iv(nfcov) > 0) write(pu,460) iv(nfcov)
 460     format(/1x,i4,50h extra func. evals for covariance and diagnostics.)
     if (iv(ngcov) > 0) write(pu,470) iv(ngcov)
 470     format(1x,i4,50h extra grad. evals for covariance and diagnostics.)

 480  if (iv(solprt) == 0) go to 999
     iv(needhd) = 1
     write(pu,490)
 490  format(/22h     i      final x(i),8x,4hd(i),10x,4hg(i)/)
     do i = 1, p
          write(pu,510) i, x(i), d(i), g(i)
     end do
 510     format(1x,i5,d16.6,2d14.3)
  go to 999

 520  write(pu,530)
 530  format(/'Inconsistent dimensions.')
 999  continue

  return
end

function v2norm ( p, x )
!
!! V2NORM returns the 2-norm of the p-vector X.
!
!  Discussion:
!
!    The routine tries to avoid underflow.
!
!  Parameters:
!
  integer p

  double precision x(p)
  integer i, j
  double precision r, scale
  double precision, save :: sqteta = 0.0D+00
  double precision t, xi
  double precision rmdcon
  double precision v2norm

  v2norm = 0.0D+00

  if (p <= 0 ) then
    return
  end if

  if ( all ( x(1:p) == 0.0D+00 ) ) then
    return
  end if

  scale = 0.0D+00
  do i = 1, p
    if ( x(i) /= 0.0D+00 ) then
      scale = abs(x(i))
      exit
    end if
  end do

  if ( scale == 0.0D+00 ) then
    return
  end if

  if ( p <= i ) then
    v2norm = scale
    return
  end if

  t = 1.0D+00
  if ( sqteta == 0.0D+00 ) then
    sqteta = rmdcon(2)
  end if
!
!  sqteta is (slightly larger than) the square root of the
!  smallest positive floating point number on the machine.
!  the tests involving sqteta are done to prevent underflows.
!
  j = i + 1
  do i = j, p
    xi = abs(x(i))
    if (xi <= scale) then
      r = xi / scale
      if (r > sqteta) t = t + r*r
    else
      r = scale / xi
      if (r <= sqteta) r = 0.0D+00
      t = 1.0D+00  +  t * r*r
      scale = xi
    end if
  end do

  v2norm = scale * sqrt(t)

  return
end

function rmdcon ( k )
!
!! RMDCON returns machine dependent constants.
!
!  Discussion:
!
!    Comments below contain data statements for various machines.
!    To convert to another machine, place a c in column 1 of the
!    data statement line(s) that correspond to the current machine
!    and remove the c from column 1 of the data statement line(s)
!    that correspond to the new machine.
!
!    the constant returned depends on k...
!
!         k = 1... smallest pos. eta such that -eta exists.
!         k = 2... square root of eta.
!         k = 3... unit roundoff = smallest pos. no. machep such
!                  that 1 + machep > 1 .and. 1 - machep < 1.
!         k = 4... square root of machep.
!         k = 5... square root of big (see k = 6).
!         k = 6... largest machine no. big such that -big exists.
!
  integer k
  double precision rmdcon
  double precision big, eta, machep
  integer bigi(4), etai(4), machei(4)
  equivalence (big,bigi(1)), (eta,etai(1)), (machep,machei(1))
!
!  ibm 360, ibm 370, or xerox
!
!     data big/z7fffffffffffffff/, eta/z0010000000000000/,
!    1     machep/z3410000000000000/
!
!  data general
!
!     data big/0.7237005577d+76/, eta/0.5397605347d-78/,
!    1     machep/2.22044605d-16/
!
!  dec 11
!
!     data big/1.7d+38/, eta/2.938735878d-39/, machep/2.775557562d-17/
!
!  hp3000
!
!     data big/1.157920892d+77/, eta/8.636168556d-78/,
!    1     machep/5.551115124d-17/
!
!  honeywell
!
!     data big/1.69d+38/, eta/5.9d-39/, machep/2.1680435d-19/
!
!  dec10
!
!     data big/"377777100000000000000000/,
!    1     eta/"002400400000000000000000/,
!    2     machep/"104400000000000000000000/
!
!  burroughs
!
!     data big/o0777777777777777,o7777777777777777/,
!    1     eta/o1771000000000000,o7770000000000000/,
!    2     machep/o1451000000000000,o0000000000000000/
!
!  control data
!
!     data big/37767777777777777777b,37167777777777777777b/,
!    1     eta/00014000000000000000b,00000000000000000000b/,
!    2     machep/15614000000000000000b,15010000000000000000b/
!
!  prime
!
!     data big/1.0d+9786/, eta/1.0d-9860/, machep/1.4210855d-14/
!
!  univac
!
!     data big/8.988d+307/, eta/1.2d-308/, machep/1.734723476d-18/
!
!  vax
!
  data big/1.7d+38/, eta/2.939d-39/, machep/1.3877788d-17/
!
!  cray 1
!
!     data bigi(1)/577767777777777777777b/,
!    1     bigi(2)/000007777777777777776b/,
!    2     etai(1)/200004000000000000000b/,
!    3     etai(2)/000000000000000000000b/,
!    4     machei(1)/377224000000000000000b/,
!    5     machei(2)/000000000000000000000b/
!
!  port library -- requires more than just a data statement...
!
!     external d1mach
!     double precision d1mach, zero
!     data big/0.d+0/, eta/0.d+0/, machep/0.d+0/, zero/0.d+0/
!     if (big > 0.0D+00) go to 1
!        big = d1mach(2)
!        eta = d1mach(1)
!        machep = d1mach(4)
!1    continue
!
! end of port
!
!  body -
!
  go to (10, 20, 30, 40, 50, 60), k

 10   rmdcon = eta
  return

 20   rmdcon = sqrt(256.d+0*eta)/16.d+0
  return

 30   rmdcon = machep
  return

 40   rmdcon = sqrt(machep)
  return

 50   rmdcon = sqrt(big/256.d+0)*16.d+0
  return

 60   rmdcon = big

  return
end

subroutine vcopy ( p, y, x )
!
!! VCOPY sets y = x.
!
!  Discussion:
!
!    x and y are p-vectors
!
  implicit none

  integer p
  double precision x(p)
  double precision y(p)

  y(1:p) = x(1:p)

  return
end

subroutine vscopy ( p, y, s )
!
!! VSCOPY sets the vector Y to scalar S.
!
  implicit none
  integer p
  double precision s
  double precision y(p)

  y(1:p) = s

  return
end

subroutine vvmulp ( n, x, y, z, k )
!
!! VVMULP sets x(i) = y(i) * z(i)**k, 1 <= i <= n (for k = 1 or -1)
!
  implicit none
  integer n
  integer k
  double precision x(n)
  double precision y(n)
  double precision z(n)

  if ( k < 0 ) then
    x(1:n) = y(1:n) / z(1:n)
  else
    x(1:n) = y(1:n) * z(1:n)
  end if

  return
end

subroutine lvmul ( n, x, l, y )
!
!! LVMUL computes x = L * y.
!
!  Discussion:
!
!    L  is an  n x n  lower triangular matrix stored compactly by rows.
!    x and y may occupy the same storage.
!
  integer n

  double precision x(n), l(*), y(n)
!     dimension l(n*(n+1)/2)
  integer i, ii, ij, i0, j, np1
  double precision t

  np1 = n + 1
  i0 = n*(n+1)/2

  do ii = 1, n
    i = np1 - ii
    i0 = i0 - i
    t = 0.0D+00
    do j = 1, i
      ij = i0 + j
      t = t + l(ij)*y(j)
    end do
    x(i) = t
  end do

  return
end

subroutine livmul ( n, x, l, y )
!
!! LIVMUL solves L * x = y.
!
!  Discussion:
!
!    L is an  n x n  lower triangular
!    matrix stored compactly by rows.  x and y may occupy the same
!    storage.
!
  integer n

  double precision x(n), l(*), y(n)
  external dotprd
  double precision dotprd
  integer i, j, k
  double precision t

  do k = 1, n
    if (y(k) /= 0.0D+00 ) go to 20
    x(k) = 0.0D+00
  end do

  return

20 continue

  j = k*(k+1)/2
  x(k) = y(k) / l(j)

  if (k >= n) then
    return
  end if

  k = k + 1

  do i = k, n
     t = dotprd(i-1, l(j+1), x)
     j = j + i
     x(i) = (y(i) - t)/l(j)
  end do

  return
end

subroutine litvmu ( n, x, l, y )
!
!! LITVMU solves L' * x = y.
!
!  Discussion:
!
!    L is an  n x n  lower triangular
!    matrix stored compactly by rows.  x and y may occupy the same
!    storage.
!
  integer n

  double precision l(*)
  double precision x(n)
  double precision y(n)
  integer i, ii, ij, i0, j
  double precision xi

  x(1:n) = y(1:n)

  i0 = n*(n+1)/2

  do ii = 1, n
    i = n+1 - ii
    xi = x(i)/l(i0)
    x(i) = xi
    if ( i <= 1 ) then
      exit
    end if
    i0 = i0 - i
    if ( xi /= 0.0D+00 ) then
      do j = 1, i-1
        ij = i0 + j
        x(j) = x(j) - xi*l(ij)
      end do
    end if
  end do

  return
end

subroutine ltvmul ( n, x, l, y )
!
!! LTVMUL computes  x = (l**t)*y.
!
!  Discussion:
!
!    L is an  n x n  lower triangular matrix stored compactly by rows.
!    x and y may occupy the same storage.
!
  integer n
  double precision x(n), l(*), y(n)
!     dimension l(n*(n+1)/2)
  integer i, ij, i0, j
  double precision yi

  i0 = 0
  do i = 1, n
    yi = y(i)
    x(i) = 0.0D+00
    do j = 1, i
      ij = i0 + j
      x(j) = x(j) + yi * l(ij)
    end do
    i0 = i0 + i
  end do

  return
end

subroutine lupdat ( beta, gamma, l, lambda, lplus, n, w, z )
!
!! LUPDAT computes lplus = secant update of L.
!
!  Discussion:
!
!    this routine updates the cholesky factor  l  of a symmetric
!    positive definite matrix to which a secant update is being
!    applied -- it computes a cholesky factor  lplus  of
!    l * (i + z*w**t) * (i + w*z**t) * l**t.  it is assumed that  w
!    and  z  have been chosen so that the updated matrix is strictly
!    positive definite.
!
!    this code uses recurrence 3 of ref. 1 (with d(j) = 1 for all j)
!    to compute  lplus  of the form  l * (i + z*w**t) * q,  where  q
!    is an orthogonal matrix that makes the result lower triangular.
!    lplus may have some negative diagonal elements.
!
!  Reference:
!
!    D Goldfarb,
!    Factorized Variable Metric Methods for Unconstrained Optimization,
!    Mathematics of Computation,
!    Volume 30, pages 796-811, 1976.
!
!  Parameters:
!
!   beta = scratch vector.
!  gamma = scratch vector.
!      l (input) lower triangular matrix, stored rowwise.
! lambda = scratch vector.
!  lplus (output) lower triangular matrix, stored rowwise, which may
!             occupy the same storage as  l.
!      n (input) length of vector parameters and order of matrices.
!      w (input, destroyed on output) right singular vector of rank 1
!             correction to  l.
!      z (input, destroyed on output) left singular vector of rank 1
!             correction to  l.
!
  integer n
  double precision beta(n), gamma(n), l(*), lambda(n), lplus(*), w(n), z(n)
!     dimension l(n*(n+1)/2), lplus(n*(n+1)/2)
!
  integer i, ij, j, jj, jp1, k, nm1
  integer np1
  double precision a, b, bj, eta, gj, lj, lij, ljj, nu, s, theta, wj, zj
  double precision one

  parameter (one=1.d+0 )

  nu = one
  eta = 0.0D+00
  if (n <= 1) go to 30
  nm1 = n - 1
!
!  temporarily store s(j) = sum over k = j+1 to n of w(k)**2 in
!  lambda(j).
!
  s = 0.0D+00
  do i = 1, nm1
     j = n - i
     s = s + w(j+1)**2
     lambda(j) = s
  end do
!
!  compute lambda, gamma, and beta by goldfarb*s recurrence 3.
!
  do 20 j = 1, nm1
     wj = w(j)
     a = nu*z(j) - eta*wj
     theta = one + a*wj
     s = a*lambda(j)
     lj = sqrt(theta**2 + a*s)
     if (theta > 0.0D+00) lj = -lj
     lambda(j) = lj
     b = theta*wj + s
     gamma(j) = b * nu / lj
     beta(j) = (a - b*eta) / lj
     nu = -nu / lj
     eta = -(eta + (a**2)/(theta - lj)) / lj
 20      continue
 30   lambda(n) = one + (nu*z(n) - eta*w(n))*w(n)
!
!  update l, gradually overwriting  w  and  z  with  l*w  and  l*z.
!
  np1 = n + 1
  jj = n * (n + 1) / 2

  do k = 1, n

     j = np1 - k
     lj = lambda(j)
     ljj = l(jj)
     lplus(jj) = lj * ljj
     wj = w(j)
     w(j) = ljj * wj
     zj = z(j)
     z(j) = ljj * zj
     if (k == 1) go to 50
     bj = beta(j)
     gj = gamma(j)
     ij = jj + j
     jp1 = j + 1

     do i = jp1, n
          lij = l(ij)
          lplus(ij) = lj*lij + bj*w(i) + gj*z(i)
          w(i) = w(i) + lij*wj
          z(i) = z(i) + lij*zj
          ij = ij + i
     end do

 50      jj = jj - j

  end do

  return
end

subroutine dbdog ( dig, lv, n, nwtstp, step, v )
!
!! DBDOG: compute a double dogleg step.
!
!  Discussion:
!
!    This subroutine computes a candidate step (for use in an
!    unconstrained minimization code) by the double dogleg algorithm of
!    dennis and mei (ref. 1), which is a variation on powell*s dogleg
!    scheme (ref. 2, p. 95).
!
!    let  g  and  h  be the current gradient and hessian approxima-
!    tion respectively and let d be the current scale vector.  this
!    routine assumes dig = diag(d)**-2 * g  and  nwtstp = h**-1 * g.
!    the step computed is the same one would get by replacing g and h
!    by  diag(d)**-1 * g  and  diag(d)**-1 * h * diag(d)**-1,
!    computing step, and translating step back to the original
!    variables, i.e., premultiplying it by diag(d)**-1.
!
!  Reference:
!
!    John Dennis, Howell Mei,
!    Two New Unconstrained Optimization Algorithms Which Use
!    Function and Gradient Values,
!    Journal of Optimization Theory and Applications,
!    Volume 28, pages 453-482, 1979.
!
!    M J D Powell,
!    A Hybrid Method for Non-linear Equations,
!    in Numerical Methods for Non-linear Equations,
!    edited by Philip Rabinowitz,
!    Gordon and Breach, London, 1970.
!
!  Parameters:
!
!    dig (input) diag(d)**-2 * g -- see algorithm notes.
!      g (input) the current gradient vector.
!     lv (input) length of v.
!      n (input) number of components in  dig, g, nwtstp,  and  step.
! nwtstp (input) negative newton step -- see algorithm notes.
!   step (output) the computed step.
!      v (i/o) values array, the following components of which are
!             used here...
! v(bias)   (input) bias for relaxed newton step, which is v(bias) of
!             the way from the full newton to the fully relaxed newton
!             step.  recommended value = 0.8 .
! v(dgnorm) (input) 2-norm of diag(d)**-1 * g -- see algorithm notes.
! v(dstnrm) (output) 2-norm of diag(d) * step, which is v(radius)
!             unless v(stppar) = 0 -- see algorithm notes.
! v(dst0) (input) 2-norm of diag(d) * nwtstp -- see algorithm notes.
! v(grdfac) (output) the coefficient of  dig  in the step returned --
!             step(i) = v(grdfac)*dig(i) + v(nwtfac)*nwtstp(i).
! v(gthg)   (input) square-root of (dig**t) * (hessian) * dig -- see
!             algorithm notes.
! v(gtstep) (output) inner product between g and step.
! v(nreduc) (output) function reduction predicted for the full newton
!             step.
! v(nwtfac) (output) the coefficient of  nwtstp  in the step returned --
!             see v(grdfac) above.
! v(preduc) (output) function reduction predicted for the step returned.
! v(radius) (input) the trust region radius.  d times the step returned
!             has 2-norm v(radius) unless v(stppar) = 0.
! v(stppar) (output) code telling how step was computed... 0 means a
!             full newton step.  between 0 and 1 means v(stppar) of the
!             way from the newton to the relaxed newton step.  between
!             1 and 2 means a true double dogleg step, v(stppar) - 1 of
!             the way from the relaxed newton to the Cauchy step.
!             greater than 2 means 1 / (v(stppar) - 1) times the Cauchy
!             step.
!
  integer lv
  integer n

  double precision dig(n), nwtstp(n), step(n), v(lv)
  external dotprd, v2norm
  double precision dotprd, v2norm
  double precision cfact, cnorm, ctrnwt, ghinvg, femnsq, gnorm
  double precision nwtnrm, relax, rlambd, t, t1, t2
  double precision half, two
  integer bias, dgnorm, dstnrm, dst0, grdfac, gthg, gtstep
  integer nreduc, nwtfac, preduc, radius, stppar
  parameter (half=0.5d+0, two=2.d+0)
  parameter (bias=43, dgnorm=1, dstnrm=2, dst0=3, grdfac=45 )
  parameter ( gthg=44, gtstep=4, nreduc=6, nwtfac=46, preduc=7 )
  parameter ( radius=8, stppar=5)

  nwtnrm = v(dst0)
  rlambd = 1.0D+00
  if (nwtnrm > 0.0D+00 ) rlambd = v(radius) / nwtnrm
  gnorm = v(dgnorm)
  ghinvg = two * v(nreduc)
  v(grdfac) = 0.0D+00
  v(nwtfac) = 0.0D+00
  if (rlambd < 1.0D+00 ) go to 30
!
!  The Newton step is inside the trust region.
!
     v(stppar) = 0.0D+00
     v(dstnrm) = nwtnrm
     v(gtstep) = -ghinvg
     v(preduc) = v(nreduc)
     v(nwtfac) = -1.0D+00
     step(1:n) = -nwtstp(1:n)
     return

 30   v(dstnrm) = v(radius)
  cfact = (gnorm / v(gthg))**2
!
!  Cauchy step = -cfact * g.
!
  cnorm = gnorm * cfact
  relax = 1.0D+00 - v(bias) * ( 1.0D+00 - gnorm*cnorm/ghinvg)
  if (rlambd < relax) go to 50
!
!  Step is between relaxed Newton and full Newton steps.
!
     v(stppar) = 1.0D+00 -  (rlambd - relax) / ( 1.0D+00 - relax)
     t = -rlambd
     v(gtstep) = t * ghinvg
     v(preduc) = rlambd * ( 1.0D+00 - half*rlambd) * ghinvg
     v(nwtfac) = t
     step(1:n) = t * nwtstp(1:n)
     return

 50   if (cnorm < v(radius)) go to 70
!
!  The Cauchy step lies outside the trust region --
!  step = scaled Cauchy step.
!
     t = -v(radius) / gnorm
     v(grdfac) = t
     v(stppar) = 1.0D+00  +  cnorm / v(radius)
     v(gtstep) = -v(radius) * gnorm
  v(preduc) = v(radius)*(gnorm - half*v(radius)*(v(gthg)/gnorm)**2)
     step(1:n) = t * dig(1:n)
     return
!
!  Compute dogleg step between Cauchy and relaxed Newton
!  femur = relaxed newton step minus Cauchy step.
!
 70   ctrnwt = cfact * relax * ghinvg / gnorm
!
!  ctrnwt = inner product of Cauchy and relaxed Newton steps,
!  scaled by gnorm**-1.
!
  t1 = ctrnwt - gnorm*cfact**2
!
!  t1 = inner prod. of femur and Cauchy step, scaled by gnorm**-1.
!
  t2 = v(radius)*(v(radius)/gnorm) - gnorm*cfact**2
  t = relax * nwtnrm
  femnsq = (t/gnorm)*t - ctrnwt - t1
!
!  femnsq = square of 2-norm of femur, scaled by gnorm**-1.
!
  t = t2 / (t1 + sqrt(t1**2 + femnsq*t2))
!
!  Dogleg step  =  Cauchy step  +  t * femur.
!
  t1 = (t - 1.0D+00 ) * cfact
  v(grdfac) = t1
  t2 = -t * relax
  v(nwtfac) = t2
  v(stppar) = two - t
  v(gtstep) = t1*gnorm**2 + t2*ghinvg
  v(preduc) = -t1*gnorm * ((t2 + 1.0D+00 )*gnorm) &
                  - t2 * ( 1.0D+00 + half*t2)*ghinvg &
                   - half * (v(gthg)*t1)**2

  step(1:n) = t1 * dig(1:n) + t2 * nwtstp(1:n)

  return
end

function dotprd ( p, x, y )
!
!! DOTPRD returns the inner product of vectors X and Y.
!
  integer p

  double precision dotprd
  integer i
  double precision rmdcon
  double precision, save :: sqteta = 0.0D+00
  double precision t
  double precision x(p)
  double precision y(p)

  dotprd = 0.0D+00

  if ( sqteta == 0.0D+00 ) then
    sqteta = rmdcon(2)
  end if

  do i = 1, p

    t = max ( abs ( x(i) ), abs ( y(i) ) )
    if ( t > 1.0D+00 ) go to 10
    if (t < sqteta) go to 20
    t = (x(i)/sqteta)*y(i)
    if (abs(t) < sqteta) go to 20
 10   dotprd = dotprd + x(i)*y(i)

 20 continue

  end do

  return
end

function stopx ( )
!
!! STOPX checks to see if the BREAK key has been pressed.
!
!  Discussion:
!
!     this function may serve as the stopx (asynchronous interruption)
!     function for the nl2sol (nonlinear least-squares) package at
!     those installations which do not wish to implement a
!     dynamic stopx.
!
!     at installations where the nl2sol system is used
!     interactively, this dummy stopx should be replaced by a
!     function that returns .true. if and only if the interrupt
!     (break) key has been pressed since the last call on stopx.
!
  logical stopx

  stopx = .false.

  return
end

subroutine vaxpy ( p, w, a, x, y )
!
!! VAXPY sets w = a*x + y.
!
!  Discussion:
!
!    w, x, y = p-vectors, a = scalar
!
!  Parameters:
!
  implicit none

  integer p

  double precision a
  double precision w(p)
  double precision x(p)
  double precision y(p)

  w(1:p) = a * x(1:p) + y(1:p)

  return
end

function reldst ( p, d, x, x0 )
!
!! RELDST computes the relative difference between X and X0.
!
  integer p

  double precision reldst
  double precision d(p), x(p), x0(p)
  integer i
  double precision emax, t, xmax

  emax = 0.0D+00
  xmax = 0.0D+00

  do i = 1, p
    t = abs(d(i) * (x(i) - x0(i)))
    if (emax < t) emax = t
    t = d(i) * (abs(x(i)) + abs(x0(i)))
    if (xmax < t) xmax = t
  end do

  reldst = 0.0D+00
  if ( xmax > 0.0D+00 ) reldst = emax / xmax

  return
end

subroutine assst ( iv, liv, lv, v )
!
!! ASSST assesses a candidate step.
!
!  Discussion:
!
!    This subroutine is called by an unconstrained minimization
!    routine to assess the next candidate step.  it may recommend one
!    of several courses of action, such as accepting the step, recom-
!    puting it using the same or a new quadratic model, or halting due
!    to convergence or false convergence.  See the return code listing
!    below.
!
!  Reference:
!
!    John Dennis, David Gay, Roy Welsch,
!    An Adaptive Nonlinear Least-squares Algorithm,
!    ACM Transactions on Mathematical Software,
!    Volume 7, Number 3, 1981.
!
!    M J D Powell,
!    A Fortran Subroutine for Solving Systems of Nonlinear Algebraic Equations,
!    in Numerical Methods for Nonlinear Algebraic Equations,
!    edited by Philip Rabinowitz,
!    Gordon and Breach, London, 1970.
!
!  Parameters:
!
!  iv (i/o) integer parameter and scratch vector -- see description
!             below of iv values referenced.
!
! liv (in)  length of iv array.
!
!  lv (in)  length of v array.
!
!   v (i/o) real parameter and scratch vector -- see description
!             below of v values referenced.
!
!   iv values referenced
!
!    iv(irc) (i/o) on input for the first step tried in a new iteration,
!             iv(irc) should be set to 3 or 4 (the value to which it is
!             set when step is definitely to be accepted).  on input
!             after step has been recomputed, iv(irc) should be
!             unchanged since the previous return of assst.
!                on output, iv(irc) is a return code having one of the
!             following values...
!                  1 = switch models or try smaller step.
!                  2 = switch models or accept step.
!                  3 = accept step and determine v(radfac) by gradient
!                       tests.
!                  4 = accept step, v(radfac) has been determined.
!                  5 = recompute step (using the same model).
!                  6 = recompute step with radius = v(lmaxs) but do not
!                       evaulate the objective function.
!                  7 = x-convergence (see v(xctol)).
!                  8 = relative function convergence (see v(rfctol)).
!                  9 = both x- and relative function convergence.
!                 10 = absolute function convergence (see v(afctol)).
!                 11 = singular convergence (see v(lmaxs)).
!                 12 = false convergence (see v(xftol)).
!                 13 = iv(irc) was out of range on input.
!             return code i has precdence over i+1 for i = 9, 10, 11.
! iv(mlstgd) (i/o) saved value of iv(model).
!  iv(model) (i/o) on input, iv(model) should be an integer identifying
!             the current quadratic model of the objective function.
!             if a previous step yielded a better function reduction,
!             then iv(model) will be set to iv(mlstgd) on output.
! iv(nfcall) (in)  invocation count for the objective function.
! iv(nfgcal) (i/o) value of iv(nfcall) at step that gave the biggest
!             function reduction this iteration.  iv(nfgcal) remains
!             unchanged until a function reduction is obtained.
! iv(radinc) (i/o) the number of radius increases (or minus the number
!             of decreases) so far this iteration.
! iv(restor) (out) set to 1 if v(f) has been restored and x should be
!             restored to its initial value, to 2 if x should be saved,
!             to 3 if x should be restored from the saved value, and to
!             0 otherwise.
!  iv(stage) (i/o) count of the number of models tried so far in the
!             current iteration.
! iv(stglim) (in)  maximum number of models to consider.
! iv(switch) (out) set to 0 unless a new model is being tried and it
!             gives a smaller function value than the previous model,
!             in which case assst sets iv(switch) = 1.
! iv(toobig) (in)  is nonzero if step was too big (e.g. if it caused
!             overflow).
!   iv(xirc) (i/o) value that iv(irc) would have in the absence of
!             convergence, false convergence, and oversized steps.
!
!   v values referenced
!
! v(afctol) (in)  absolute function convergence tolerance.  if the
!             absolute value of the current function value v(f) is less
!             than v(afctol), then assst returns with iv(irc) = 10.
! v(decfac) (in)  factor by which to decrease radius when iv(toobig) is
!             nonzero.
! v(dstnrm) (in)  the 2-norm of d*step.
! v(dstsav) (i/o) value of v(dstnrm) on saved step.
!   v(dst0) (in)  the 2-norm of d times the newton step (when defined,
!             i.e., for v(nreduc) >= 0).
!      v(f) (i/o) on both input and output, v(f) is the objective func-
!             tion value at x.  if x is restored to a previous value,
!             then v(f) is restored to the corresponding value.
!   v(fdif) (out) the function reduction v(f0) - v(f) (for the output
!             value of v(f) if an earlier step gave a bigger function
!             decrease, and for the input value of v(f) otherwise).
! v(flstgd) (i/o) saved value of v(f).
!     v(f0) (in)  objective function value at start of iteration.
! v(gtslst) (i/o) value of v(gtstep) on saved step.
! v(gtstep) (in)  inner product between step and gradient.
! v(incfac) (in)  minimum factor by which to increase radius.
!  v(lmaxs) (in)  maximum reasonable step size (and initial step bound).
!             if the actual function decrease is no more than twice
!             what was predicted, if a return with iv(irc) = 7, 8, 9,
!             or 10 does not occur, if v(dstnrm) > v(lmaxs), and if
!             v(preduc) <= v(sctol) * abs(v(f0)), then assst re-
!             turns with iv(irc) = 11.  if so doing appears worthwhile,
!             then assst repeats this test with v(preduc) computed for
!             a step of length v(lmaxs) (by a return with iv(irc) = 6).
! v(nreduc) (i/o)  function reduction predicted by quadratic model for
!             newton step.  if assst is called with iv(irc) = 6, i.e.,
!             if v(preduc) has been computed with radius = v(lmaxs) for
!             use in the singular convervence test, then v(nreduc) is
!             set to -v(preduc) before the latter is restored.
! v(plstgd) (i/o) value of v(preduc) on saved step.
! v(preduc) (i/o) function reduction predicted by quadratic model for
!             current step.
! v(radfac) (out) factor to be used in determining the new radius,
!             which should be v(radfac)*dst, where  dst  is either the
!             output value of v(dstnrm) or the 2-norm of
!             diag(newd)*step  for the output value of step and the
!             updated version, newd, of the scale vector d.  for
!             iv(irc) = 3, v(radfac) = 1.0D+00 is returned.
! v(rdfcmn) (in)  minimum value for v(radfac) in terms of the input
!             value of v(dstnrm) -- suggested value = 0.1.
! v(rdfcmx) (in)  maximum value for v(radfac) -- suggested value = 4.0.
!  v(reldx) (in) scaled relative change in x caused by step, computed
!             (e.g.) by function  reldst  as
!                 max (d(i)*abs(x(i)-x0(i)), 1 <= i <= p) /
!                    max (d(i)*(abs(x(i))+abs(x0(i))), 1 <= i <= p).
! v(rfctol) (in)  relative function convergence tolerance.  if the
!             actual function reduction is at most twice what was pre-
!             dicted and  v(nreduc) <= v(rfctol)*abs(v(f0)),  then
!             assst returns with iv(irc) = 8 or 9.
! v(stppar) (in)  marquardt parameter -- 0 means full newton step.
! v(tuner1) (in)  tuning constant used to decide if the function
!             reduction was much less than expected.  suggested
!             value = 0.1.
! v(tuner2) (in)  tuning constant used to decide if the function
!             reduction was large enough to accept step.  suggested
!             value = 10**-4.
! v(tuner3) (in)  tuning constant used to decide if the radius
!             should be increased.  suggested value = 0.75.
!  v(xctol) (in)  x-convergence criterion.  if step is a newton step
!             (v(stppar) = 0) having v(reldx) <= v(xctol) and giving
!             at most twice the predicted function decrease, then
!             assst returns iv(irc) = 7 or 9.
!  v(xftol) (in)  false convergence tolerance.  if step gave no or only
!             a small function decrease and v(reldx) <= v(xftol),
!             then assst returns with iv(irc) = 12.
!
!  notes
!
!   application and usage restrictions
!
!        this routine is called as part of the nl2sol (nonlinear
!     least-squares) package.  it may be used in any unconstrained
!     minimization solver that uses dogleg, goldfeld-quandt-trotter,
!     or levenberg-marquardt steps.
!
!   algorithm notes
!
!        see (1) for further discussion of the assessing and model
!     switching strategies.  while nl2sol considers only two models,
!     assst is designed to handle any number of models.
!
!   usage notes
!
!        on the first call of an iteration, only the i/o variables
!     step, x, iv(irc), iv(model), v(f), v(dstnrm), v(gtstep), and
!     v(preduc) need have been initialized.  between calls, no i/o
!     values execpt step, x, iv(model), v(f) and the stopping toler-
!     ances should be changed.
!        after a return for convergence or false convergence, one can
!     change the stopping tolerances and call assst again, in which
!     case the stopping tests will be repeated.
!
!   history
!
!        john dennis designed much of this routine, starting with
!     ideas in (2). roy welsch suggested the model switching strategy.
!        david gay and stephen peters cast this subroutine into a more
!     portable form (winter 1977), and david gay cast it into its
!     present form (fall 1978).
!
  integer liv
  integer lv

  integer iv(liv)
  double precision v(lv)
  logical goodx
  integer i, nfc
  double precision emax, emaxs, gts, rfac1, xmax
  double precision half, one, onep2, two
  integer afctol, decfac, dstnrm, dstsav, dst0, f, fdif, flstgd, f0
  integer gtslst, gtstep, incfac, irc, lmaxs, mlstgd, model, nfcall
  integer nfgcal, nreduc, plstgd, preduc, radfac, radinc, rdfcmn
  integer rdfcmx, reldx, restor, rfctol, sctol, stage, stglim
  integer stppar, switch, toobig, tuner1, tuner2, tuner3, xctol
  integer xftol, xirc

  parameter ( half=0.5d+0, one=1.d+0, onep2=1.2d+0, two=2.d+0)
  parameter ( irc=29, mlstgd=32, model=5, nfcall=6, nfgcal=7 )
  parameter ( radinc=8, restor=9, stage=10, stglim=11, switch=12 )
  parameter ( toobig=2, xirc=13)
  parameter (afctol=31, decfac=22, dstnrm=2, dst0=3, dstsav=18 )
  parameter (f=10, fdif=11, flstgd=12, f0=13, gtslst=14, gtstep=4 )
  parameter (incfac=23, lmaxs=36, nreduc=6, plstgd=15, preduc=7 )
  parameter (radfac=16, rdfcmn=24, rdfcmx=25, reldx=17, rfctol=32 )
  parameter (sctol=37, stppar=5, tuner1=26, tuner2=27, tuner3=28 )
  parameter (xctol=33, xftol=34)

  nfc = iv(nfcall)
  iv(switch) = 0
  iv(restor) = 0
  rfac1 = one
  goodx = .true.
  i = iv(irc)

  if (i >= 1 .and. i <= 12) then
        go to (20,30,10,10,40,280,220,220,220,220,220,170), i
  end if

  iv(irc) = 13
  return
!
!  Initialize for new iteration.
!
 10   iv(stage) = 1
  iv(radinc) = 0
  v(flstgd) = v(f0)
  if (iv(toobig) == 0) go to 110
     iv(stage) = -1
     iv(xirc) = i
     go to 60
!
!  Step was recomputed with new model or smaller radius
!  first decide which
!
 20   if (iv(model) /= iv(mlstgd)) go to 30
!
!  Old model retained, smaller radius tried
!  do not consider any more new models this iteration
!
     iv(stage) = iv(stglim)
     iv(radinc) = -1
     go to 110
!
!  A new model is being tried.  decide whether to keep it.
!
 30   iv(stage) = iv(stage) + 1
!
!  Now we add the possibiltiy that step was recomputed with
!  the same model, perhaps because of an oversized step.
!
 40   if (iv(stage) > 0) go to 50
!
!  Step was recomputed because it was too big.
!
     if (iv(toobig) /= 0) go to 60
!
!  Restore iv(stage) and pick up where we left off.
!
     iv(stage) = -iv(stage)
     i = iv(xirc)
     go to (20, 30, 110, 110, 70), i

 50   if (iv(toobig) == 0) go to 70
!
!  Handle oversize step
!
  if (iv(radinc) > 0) go to 80
     iv(stage) = -iv(stage)
     iv(xirc) = iv(irc)

 60      v(radfac) = v(decfac)
     iv(radinc) = iv(radinc) - 1
     iv(irc) = 5
     iv(restor) = 1
     return

 70   if (v(f) < v(flstgd)) go to 110
!
!  The new step is a loser.  restore old model.
!
  if (iv(model) == iv(mlstgd)) go to 80
     iv(model) = iv(mlstgd)
     iv(switch) = 1
!
!  Restore step, etc. only if a previous step decreased v(f).
!
 80   if (v(flstgd) >= v(f0)) go to 110
     iv(restor) = 1
     v(f) = v(flstgd)
     v(preduc) = v(plstgd)
     v(gtstep) = v(gtslst)
     if (iv(switch) == 0) rfac1 = v(dstnrm) / v(dstsav)
     v(dstnrm) = v(dstsav)
     nfc = iv(nfgcal)
     goodx = .false.

 110  v(fdif) = v(f0) - v(f)
  if (v(fdif) > v(tuner2) * v(preduc)) go to 140
  if(iv(radinc)>0) go to 140
!
!         no (or only a trivial) function decrease
!         so try new model or smaller radius
!
     if (v(f) < v(f0)) go to 120
          iv(mlstgd) = iv(model)
          v(flstgd) = v(f)
          v(f) = v(f0)
          iv(restor) = 1
          go to 130
 120     iv(nfgcal) = nfc
 130     iv(irc) = 1
     if (iv(stage) < iv(stglim)) go to 160
          iv(irc) = 5
          iv(radinc) = iv(radinc) - 1
          go to 160
!
!  Nontrivial function decrease achieved
!
 140  iv(nfgcal) = nfc
  rfac1 = 1.0D+00
  v(dstsav) = v(dstnrm)
  if (v(fdif) > v(preduc)*v(tuner1)) go to 190
!
!  Decrease was much less than predicted -- either change models
!  or accept step with decreased radius.
!
  if (iv(stage) >= iv(stglim)) go to 150
!
!  Consider switching models
!
     iv(irc) = 2
     go to 160
!
!  Accept step with decreased radius
!
 150  iv(irc) = 4
!
!   set v(radfac) to fletcher*s decrease factor
!
 160  iv(xirc) = iv(irc)
  emax = v(gtstep) + v(fdif)
  v(radfac) = half * rfac1

  if (emax < v(gtstep)) then
    v(radfac) = rfac1 * max (v(rdfcmn),half * v(gtstep)/emax)
  end if
!
!  Do false convergence test
!
 170  if (v(reldx) <= v(xftol)) go to 180
     iv(irc) = iv(xirc)
     if (v(f) < v(f0)) go to 200
          go to 230

 180  iv(irc) = 12
  go to 240
!
!  Handle good function decrease
!
 190  if (v(fdif) < (-v(tuner3) * v(gtstep))) go to 210
!
!  Increasing radius looks worthwhile.  see if we just
!  recomputed step with a decreased radius or restored step
!  after recomputing it with a larger radius.
!
  if (iv(radinc) < 0) go to 210
  if (iv(restor) == 1) go to 210
!
!  We did not.  try a longer step unless this was a newton step.
!
     v(radfac) = v(rdfcmx)
     gts = v(gtstep)
     if (v(fdif) < (half/v(radfac) - 1.0D+00 ) * gts) then
       v(radfac) = max (v(incfac), half*gts/(gts + v(fdif)))
     end if
     iv(irc) = 4
     if (v(stppar) == 0.0D+00 ) go to 230
     if (v(dst0) >= 0.0D+00 .and. (v(dst0) < two*v(dstnrm) &
              .or. v(nreduc) < onep2*v(fdif)))  then
       go to 230
     end if
!
!  Step was not a newton step.  recompute it with a larger radius.
!
          iv(irc) = 5
          iv(radinc) = iv(radinc) + 1
!
!  Save values corresponding to good step
!
 200  v(flstgd) = v(f)
  iv(mlstgd) = iv(model)
  if (iv(restor) /= 1) iv(restor) = 2
  v(dstsav) = v(dstnrm)
  iv(nfgcal) = nfc
  v(plstgd) = v(preduc)
  v(gtslst) = v(gtstep)
  go to 230
!
!  Accept step with radius unchanged.
!
 210  v(radfac) = 1.0D+00
  iv(irc) = 3
  go to 230
!
!  Come here for a restart after convergence.
!
 220  iv(irc) = iv(xirc)
  if (v(dstsav) >= 0.0D+00 ) go to 240
     iv(irc) = 12
     go to 240
!
!  Perform convergence tests.
!
 230  iv(xirc) = iv(irc)
 240  if (iv(restor) == 1 .and. v(flstgd) < v(f0)) iv(restor) = 3
  if (abs(v(f)) < v(afctol)) iv(irc) = 10

  if (half * v(fdif) > v(preduc)) then
    return
  end if

  emax = v(rfctol) * abs(v(f0))
  emaxs = v(sctol) * abs(v(f0))
  if (v(dstnrm) > v(lmaxs) .and. v(preduc) <= emaxs) then
    iv(irc) = 11
  end if
  if (v(dst0) < 0.0D+00 ) go to 250
  i = 0

  if ((v(nreduc) > 0.0D+00 .and. v(nreduc) <= emax) .or. &
      (v(nreduc) == 0.0D+00 .and. v(preduc) == 0.0D+00 )) then
    i = 2
  end if

  if (v(stppar) == 0.0D+00 .and. v(reldx) <= v(xctol) .and. goodx) then
    i = i + 1
  end if

  if (i > 0) iv(irc) = i + 6
!
!  Consider recomputing step of length v(lmaxs) for singular
!  convergence test.
!
 250  if (iv(irc) > 5 .and. iv(irc) /= 12) then
     return
  end if

  if (v(dstnrm) > v(lmaxs)) go to 260
     if (v(preduc) >= emaxs) then
       return
     end if
          if (v(dst0) <= 0.0D+00 ) go to 270
               if (half * v(dst0) <= v(lmaxs)) then
                 return
               end if
                    go to 270
 260  if (half * v(dstnrm) <= v(lmaxs)) then
        return
      end if
  xmax = v(lmaxs) / v(dstnrm)
  if (xmax * (two - xmax) * v(preduc) >= emaxs) then
    return
  end if
 270  if (v(nreduc) < 0.0D+00 ) go to 290
!
!   recompute v(preduc) for use in singular convergence test
!
  v(gtslst) = v(gtstep)
  v(dstsav) = v(dstnrm)
  if (iv(irc) == 12) v(dstsav) = -v(dstsav)
  v(plstgd) = v(preduc)
  i = iv(restor)
  iv(restor) = 2
  if (i == 3) iv(restor) = 0
  iv(irc) = 6
  return
!
!  Perform singular convergence test with recomputed v(preduc)
!
 280  v(gtstep) = v(gtslst)
  v(dstnrm) = abs(v(dstsav))
  iv(irc) = iv(xirc)
  if (v(dstsav) <= 0.0D+00 ) iv(irc) = 12
  v(nreduc) = -v(preduc)
  v(preduc) = v(plstgd)
  iv(restor) = 3

 290  if (-v(nreduc) <= v(rfctol) * abs(v(f0))) iv(irc) = 11

  return
end

subroutine wzbfgs ( l, n, s, w, y, z )
!
!! WZBFGS compute Y and Z for LUPDAT corresponding to BFGS update.
!
!  Discussion:
!
!    When S is computed in certain ways, for example by GQTSTP or
!    DBLDOG, it is possible to save N**2/2 operations since L'*S
!    or L*L'*S is then known.
!
!    If the BFGS update to L*L' would reduce its determinant to
!    less than EPS times its old value, then this routine in effect
!    replaces Y by THETA*Y + (1-THETA)*L*L'*S, where THETA
!    (between 0 and 1) is chosen to make the reduction factor = EPS.
!
!  Parameters:
!
!    l (i/o) cholesky factor of hessian, a lower triang. matrix stored
!             compactly by rows.
!
!    n (input) order of  l  and length of  s,  w,  y,  z.
!
!    s (input) the step just taken.
!
!    w (output) right singular vector of rank 1 correction to l.
!
!    y (input) change in gradients corresponding to s.
!
!    z (output) left singular vector of rank 1 correction to l.
!
  implicit none

  integer n

  double precision dotprd
  double precision cs
  double precision cy
  double precision, parameter :: eps = 0.1D+00
  double precision epsrt
  double precision l(n*(n+1)/2)
  double precision s(n)
  double precision shs
  double precision theta
  double precision w(n)
  double precision y(n)
  double precision ys
  double precision z(n)

  call ltvmul ( n, w, l, s )
  shs = dotprd ( n, w, w )
  ys = dotprd ( n, y, s )

  if ( ys < eps * shs ) then
    theta = ( 1.0D+00 - eps ) * shs / ( shs - ys )
    epsrt = sqrt ( eps )
    cy = theta / ( shs * epsrt )
    cs = ( 1.0D+00 + ( theta - 1.0D+00 ) / epsrt ) / shs
  else
    cy = 1.0D+00 / ( sqrt ( ys ) * sqrt ( shs ) )
    cs = 1.0D+00 / shs
  end if

  call livmul ( n, z, l, y )

  z(1:n) = cy * z(1:n) - cs * w(1:n)

  return
end

!======================================================================!
!                                                                      !
!                           LBFGS SUBROUTINES                          !
!                                                                      !
!======================================================================!

      SUBROUTINE LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER N,M,IPRINT(2),IFLAG
      DOUBLE PRECISION X(N),G(N),DIAG(N),W(N*(2*M+1)+2*M)
      DOUBLE PRECISION F,EPS,XTOL
      LOGICAL DIAGCO
!
!        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION
!                          JORGE NOCEDAL
!                        *** July 1990 ***
!
! 
!     This subroutine solves the unconstrained minimization problem
! 
!                      min F(x),    x= (x1,x2,...,xN),
!
!      using the limited memory BFGS method. The routine is especially
!      effective on problems involving a large number of variables. In
!      a typical iteration of this method an approximation Hk to the
!      inverse of the Hessian is obtained by applying M BFGS updates to
!      a diagonal matrix Hk0, using information from the previous M steps.
!      The user specifies the number M, which determines the amount of
!      storage required by the routine. The user may also provide the
!      diagonal matrices Hk0 if not satisfied with the default choice.
!      The algorithm is described in "On the limited memory BFGS method
!      for large scale optimization", by D. Liu and J. Nocedal,
!      Mathematical Programming B 45 (1989) 503-528.
! 
!      The user is required to calculate the function value F and its
!      gradient G. In order to allow the user complete control over
!      these computations, reverse  communication is used. The routine
!      must be called repeatedly under the control of the parameter
!      IFLAG. 
!
!      The steplength is determined at each iteration by means of the
!      line search routine MCVSRCH, which is a slight modification of
!      the routine CSRCH written by More' and Thuente.
! 
!      The calling statement is 
! 
!          CALL LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
! 
!      where
! 
!     N       is an INTEGER variable that must be set by the user to the
!             number of variables. It is not altered by the routine.
!             Restriction: N>0.
! 
!     M       is an INTEGER variable that must be set by the user to
!             the number of corrections used in the BFGS update. It
!             is not altered by the routine. Values of M less than 3 are
!             not recommended; large values of M will result in excessive
!             computing time. 3<= M <=7 is recommended. Restriction: M>0.
! 
!     X       is a DOUBLE PRECISION array of length N. On initial entry
!             it must be set by the user to the values of the initial
!             estimate of the solution vector. On exit with IFLAG=0, it
!             contains the values of the variables at the best point
!             found (usually a solution).
! 
!     F       is a DOUBLE PRECISION variable. Before initial entry and on
!             a re-entry with IFLAG=1, it must be set by the user to
!             contain the value of the function F at the point X.
! 
!     G       is a DOUBLE PRECISION array of length N. Before initial
!             entry and on a re-entry with IFLAG=1, it must be set by
!             the user to contain the components of the gradient G at
!             the point X.
! 
!     DIAGCO  is a LOGICAL variable that must be set to .TRUE. if the
!             user  wishes to provide the diagonal matrix Hk0 at each
!             iteration. Otherwise it should be set to .FALSE., in which
!             case  LBFGS will use a default value described below. If
!             DIAGCO is set to .TRUE. the routine will return at each
!             iteration of the algorithm with IFLAG=2, and the diagonal
!              matrix Hk0  must be provided in the array DIAG.
! 
! 
!     DIAG    is a DOUBLE PRECISION array of length N. If DIAGCO=.TRUE.,
!             then on initial entry or on re-entry with IFLAG=2, DIAG
!             it must be set by the user to contain the values of the 
!             diagonal matrix Hk0.  Restriction: all elements of DIAG
!             must be positive.
! 
!     IPRINT  is an INTEGER array of length two which must be set by the
!             user.
! 
!             IPRINT(1) specifies the frequency of the output:
!                IPRINT(1) < 0 : no output is generated,
!                IPRINT(1) = 0 : output only at first and last iteration,
!                IPRINT(1) > 0 : output every IPRINT(1) iterations.
! 
!             IPRINT(2) specifies the type of output generated:
!                IPRINT(2) = 0 : iteration count, number of function 
!                                evaluations, function value, norm of the
!                                gradient, and steplength,
!                IPRINT(2) = 1 : same as IPRINT(2)=0, plus vector of
!                                variables and  gradient vector at the
!                                initial point,
!                IPRINT(2) = 2 : same as IPRINT(2)=1, plus vector of
!                                variables,
!                IPRINT(2) = 3 : same as IPRINT(2)=2, plus gradient vector.
! 
! 
!     EPS     is a positive DOUBLE PRECISION variable that must be set by
!             the user, and determines the accuracy with which the solution
!             is to be found. The subroutine terminates when
!
!                         ||G|| < EPS max(1,||X||),
!
!             where ||.|| denotes the Euclidean norm.
! 
!     XTOL    is a  positive DOUBLE PRECISION variable that must be set by
!             the user to an estimate of the machine precision (e.g.
!             10**(-16) on a SUN station 3/60). The line search routine will
!             terminate if the relative width of the interval of uncertainty
!             is less than XTOL.
! 
!     W       is a DOUBLE PRECISION array of length N(2M+1)+2M used as
!             workspace for LBFGS. This array must not be altered by the
!             user.
! 
!     IFLAG   is an INTEGER variable that must be set to 0 on initial entry
!             to the subroutine. A return with IFLAG<0 indicates an error,
!             and IFLAG=0 indicates that the routine has terminated without
!             detecting errors. On a return with IFLAG=1, the user must
!             evaluate the function F and gradient G. On a return with
!             IFLAG=2, the user must provide the diagonal matrix Hk0.
! 
!             The following negative values of IFLAG, detecting an error,
!             are possible:
! 
!              IFLAG=-1  The line search routine MCSRCH failed. The
!                        parameter INFO provides more detailed information
!                        (see also the documentation of MCSRCH):
!
!                       INFO = 0  IMPROPER INPUT PARAMETERS.
!
!                       INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF
!                                 UNCERTAINTY IS AT MOST XTOL.
!
!                       INFO = 3  MORE THAN 20 FUNCTION EVALUATIONS WERE
!                                 REQUIRED AT THE PRESENT ITERATION.
!
!                       INFO = 4  THE STEP IS TOO SMALL.
!
!                       INFO = 5  THE STEP IS TOO LARGE.
!
!                       INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS. 
!                                 THERE MAY NOT BE A STEP WHICH SATISFIES
!                                 THE SUFFICIENT DECREASE AND CURVATURE
!                                 CONDITIONS. TOLERANCES MAY BE TOO SMALL.
!
! 
!              IFLAG=-2  The i-th diagonal element of the diagonal inverse
!                        Hessian approximation, given in DIAG, is not
!                        positive.
!           
!              IFLAG=-3  Improper input parameters for LBFGS (N or M are
!                        not positive).
! 
!
!
!    ON THE DRIVER:
!
!    The program that calls LBFGS must contain the declaration:
!
!                       EXTERNAL LB2
!
!    LB2 is a BLOCK DATA that defines the default values of several
!    parameters described in the COMMON section. 
!
! 
! 
!    COMMON:
! 
!     The subroutine contains one common area, which the user may wish to
!    reference:
! 
         COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
! 
!    MP  is an INTEGER variable with default value 6. It is used as the
!        unit number for the printing of the monitoring information
!        controlled by IPRINT.
! 
!    LP  is an INTEGER variable with default value 6. It is used as the
!        unit number for the printing of error messages. This printing
!        may be suppressed by setting LP to a non-positive value.
! 
!    GTOL is a DOUBLE PRECISION variable with default value 0.9, which
!        controls the accuracy of the line search routine MCSRCH. If the
!        function and gradient evaluations are inexpensive with respect
!        to the cost of the iteration (which is sometimes the case when
!        solving very large problems) it may be advantageous to set GTOL
!        to a small value. A typical small value is 0.1.  Restriction:
!        GTOL should be greater than 1.D-04.
! 
!    STPMIN and STPMAX are non-negative DOUBLE PRECISION variables which
!        specify lower and uper bounds for the step in the line search.
!        Their default values are 1.D-20 and 1.D+20, respectively. These
!        values need not be modified unless the exponents are too large
!        for the machine being used, or unless the problem is extremely
!        badly scaled (in which case the exponents should be increased).
! 
!
!  MACHINE DEPENDENCIES
!
!        The only variables that are machine-dependent are XTOL,
!        STPMIN and STPMAX.
! 
!
!  GENERAL INFORMATION
! 
!    Other routines called directly:  DAXPY, DDOT, LB1, MCSRCH
! 
!    Input/Output  :  No input; diagnostic messages on unit MP and
!                     error messages on unit LP.
! 
! 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
!
      DOUBLE PRECISION GTOL,ONE,ZERO,GNORM,DDOT,STP1,FTOL,STPMIN,      &
                       STPMAX,STP,YS,YY,SQ,YR,BETA,XNORM
      INTEGER MP,LP,ITER,NFUN,POINT,ISPT,IYPT,MAXFEV,INFO,             &
              BOUND,NPT,CP,I,NFEV,INMC,IYCN,ISCN
      LOGICAL FINISH
!
      SAVE
      DATA ONE,ZERO/1.0D+0,0.0D+0/
!
!     INITIALIZE
!     ----------
!
      IF(IFLAG.EQ.0) GO TO 10
      GO TO (172,100) IFLAG
  10  ITER= 0
      IF(N.LE.0.OR.M.LE.0) GO TO 196
      IF(GTOL.LE.1.D-04) THEN
        IF(LP.GT.0) WRITE(LP,245)
        GTOL=9.D-01
      ENDIF
      NFUN= 1
      POINT= 0
      FINISH= .FALSE.
      IF(DIAGCO) THEN
         DO 30 I=1,N
 30      IF (DIAG(I).LE.ZERO) GO TO 195
      ELSE
         DO 40 I=1,N
 40      DIAG(I)= 1.0D0
      ENDIF
!
!     THE WORK VECTOR W IS DIVIDED AS FOLLOWS:
!     ---------------------------------------
!     THE FIRST N LOCATIONS ARE USED TO STORE THE GRADIENT AND
!         OTHER TEMPORARY INFORMATION.
!     LOCATIONS (N+1)...(N+M) STORE THE SCALARS RHO.
!     LOCATIONS (N+M+1)...(N+2M) STORE THE NUMBERS ALPHA USED
!         IN THE FORMULA THAT COMPUTES H*G.
!     LOCATIONS (N+2M+1)...(N+2M+NM) STORE THE LAST M SEARCH
!         STEPS.
!     LOCATIONS (N+2M+NM+1)...(N+2M+2NM) STORE THE LAST M
!         GRADIENT DIFFERENCES.
!
!     THE SEARCH STEPS AND GRADIENT DIFFERENCES ARE STORED IN A
!     CIRCULAR ORDER CONTROLLED BY THE PARAMETER POINT.
!
      ISPT= N+2*M
      IYPT= ISPT+N*M     
      DO 50 I=1,N
 50   W(ISPT+I)= -G(I)*DIAG(I)
      GNORM= DSQRT(DDOT(N,G,1,G,1))
      STP1= ONE/GNORM
!
!     PARAMETERS FOR LINE SEARCH ROUTINE
!     
      FTOL= 1.0D-4
      MAXFEV= 20
!
      IF(IPRINT(1).GE.0) CALL LB1(IPRINT,ITER,NFUN,GNORM,              &
                                  N,M,X,F,G,STP,FINISH)
!
!    --------------------
!     MAIN ITERATION LOOP
!    --------------------
!
 80   ITER= ITER+1
      INFO=0
      BOUND=ITER-1
      IF(ITER.EQ.1) GO TO 165
      IF (ITER .GT. M)BOUND=M
!
         YS= DDOT(N,W(IYPT+NPT+1),1,W(ISPT+NPT+1),1)
      IF(.NOT.DIAGCO) THEN
         YY= DDOT(N,W(IYPT+NPT+1),1,W(IYPT+NPT+1),1)
         DO 90 I=1,N
   90    DIAG(I)= YS/YY
      ELSE
         IFLAG=2
         RETURN
      ENDIF
 100  CONTINUE
      IF(DIAGCO) THEN
        DO 110 I=1,N
 110    IF (DIAG(I).LE.ZERO) GO TO 195
      ENDIF
!
!     COMPUTE -H*G USING THE FORMULA GIVEN IN: Nocedal, J. 1980,
!     "Updating quasi-Newton matrices with limited storage",
!     Mathematics of Computation, Vol.24, No.151, pp. 773-782.
!     ---------------------------------------------------------
!
      CP= POINT
      IF (POINT.EQ.0) CP=M
      W(N+CP)= ONE/YS
      DO 112 I=1,N
 112  W(I)= -G(I)
      CP= POINT
      DO 125 I= 1,BOUND
         CP=CP-1
         IF (CP.EQ. -1)CP=M-1
         SQ= DDOT(N,W(ISPT+CP*N+1),1,W,1)
         INMC=N+M+CP+1
         IYCN=IYPT+CP*N
         W(INMC)= W(N+CP+1)*SQ
         CALL DAXPY(N,-W(INMC),W(IYCN+1),1,W,1)
 125  CONTINUE
!
      DO 130 I=1,N
 130  W(I)=DIAG(I)*W(I)
!
      DO 145 I=1,BOUND
         YR= DDOT(N,W(IYPT+CP*N+1),1,W,1)
         BETA= W(N+CP+1)*YR
         INMC=N+M+CP+1
         BETA= W(INMC)-BETA
         ISCN=ISPT+CP*N
         CALL DAXPY(N,BETA,W(ISCN+1),1,W,1)
         CP=CP+1
         IF (CP.EQ.M)CP=0
 145  CONTINUE
!
!     STORE THE NEW SEARCH DIRECTION
!     ------------------------------
!
       DO 160 I=1,N
 160   W(ISPT+POINT*N+I)= W(I)
!
!     OBTAIN THE ONE-DIMENSIONAL MINIMIZER OF THE FUNCTION 
!     BY USING THE LINE SEARCH ROUTINE MCSRCH
!     ----------------------------------------------------
 165  NFEV=0
      STP=ONE
      IF (ITER.EQ.1) STP=STP1
      DO 170 I=1,N
 170  W(I)=G(I)
 172  CONTINUE
      CALL MCSRCH(N,X,F,G,W(ISPT+POINT*N+1),STP,FTOL,    &
                  XTOL,MAXFEV,INFO,NFEV,DIAG)
      IF (INFO .EQ. -1) THEN
        IFLAG=1
        RETURN
      ENDIF
      IF (INFO .NE. 1) GO TO 190
      NFUN= NFUN + NFEV
!
!     COMPUTE THE NEW STEP AND GRADIENT CHANGE 
!     -----------------------------------------
!
      NPT=POINT*N
      DO 175 I=1,N
      W(ISPT+NPT+I)= STP*W(ISPT+NPT+I)
 175  W(IYPT+NPT+I)= G(I)-W(I)
      POINT=POINT+1
      IF (POINT.EQ.M)POINT=0
!
!     TERMINATION TEST
!     ----------------
!
      GNORM= DSQRT(DDOT(N,G,1,G,1))
      XNORM= DSQRT(DDOT(N,X,1,X,1))
      XNORM= DMAX1(1.0D0,XNORM)
      IF (GNORM/XNORM .LE. EPS) FINISH=.TRUE.
!
      IF(IPRINT(1).GE.0) CALL LB1(IPRINT,ITER,NFUN,GNORM,              &
                                  N,M,X,F,G,STP,FINISH)
      IF (FINISH) THEN
         IFLAG=0
         RETURN
      ENDIF
      GO TO 80
!
!     ------------------------------------------------------------
!     END OF MAIN ITERATION LOOP. ERROR EXITS.
!     ------------------------------------------------------------
!
 190  IFLAG=-1
      IF(LP.GT.0) WRITE(LP,200) INFO
      RETURN
 195  IFLAG=-2
      IF(LP.GT.0) WRITE(LP,235) I
      RETURN
 196  IFLAG= -3
      IF(LP.GT.0) WRITE(LP,240)
!
!     FORMATS
!     -------
!
 200  FORMAT(/' IFLAG= -1 ',/' LINE SEARCH FAILED. SEE'                &
              ' DOCUMENTATION OF ROUTINE MCSRCH',/' ERROR RETURN'      &
              ' OF LINE SEARCH: INFO= ',I2,/                           &
              ' POSSIBLE CAUSES: FUNCTION OR GRADIENT ARE INCORRECT',  &
            /,' OR INCORRECT TOLERANCES')
 235  FORMAT(/' IFLAG= -2',/' THE',I5,'-TH DIAGONAL ELEMENT OF THE',/, &
             ' INVERSE HESSIAN APPROXIMATION IS NOT POSITIVE')
 240  FORMAT(/' IFLAG= -3',/' IMPROPER INPUT PARAMETERS (N OR M',      &
              ' ARE NOT POSITIVE)')
 245  FORMAT(/'  GTOL IS LESS THAN OR EQUAL TO 1.D-04',                &
             /' IT HAS BEEN RESET TO 9.D-01')
      RETURN
      END

      SUBROUTINE LB1(IPRINT,ITER,NFUN,GNORM,N,M,X,F,G,STP,FINISH)
!
!     -------------------------------------------------------------
!     THIS ROUTINE PRINTS MONITORING INFORMATION. THE FREQUENCY AND
!     AMOUNT OF OUTPUT ARE CONTROLLED BY IPRINT.
!     -------------------------------------------------------------
!
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER IPRINT(2),ITER,NFUN,LP,MP,N,M
      DOUBLE PRECISION X(N),G(N),F,GNORM,STP,GTOL,STPMIN,STPMAX
      LOGICAL FINISH
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
!
      IF (ITER.EQ.0)THEN
           WRITE(MP,10)
           WRITE(MP,*)
           WRITE(MP,20) N,M
           WRITE(MP,30)F,GNORM
                 IF (IPRINT(2).GE.1)THEN
                     WRITE(MP,40)
                     WRITE(MP,50) (X(I),I=1,N)
                     WRITE(MP,60)
                     WRITE(MP,50) (G(I),I=1,N)
                  ENDIF
!ION           WRITE(MP,10)
!ION           WRITE(MP,70)
      ELSE
          IF ((IPRINT(1).EQ.0).AND.(ITER.NE.1.AND..NOT.FINISH))RETURN
              IF (IPRINT(1).NE.0)THEN
                   IF(MOD(ITER-1,IPRINT(1)).EQ.0.OR.FINISH)THEN
                         IF(IPRINT(2).GT.1.AND.ITER.GT.1) WRITE(MP,70)
                         WRITE(MP,80)ITER,NFUN,F,GNORM,STP
                   ELSE
                         RETURN
                   ENDIF
              ELSE
                   IF( IPRINT(2).GT.1.AND.FINISH) WRITE(MP,70)
                   WRITE(MP,80)ITER,NFUN,F,GNORM,STP
              ENDIF
              IF (IPRINT(2).EQ.2.OR.IPRINT(2).EQ.3)THEN
                    IF (FINISH)THEN
                        WRITE(MP,90) F
                    ELSE
                        WRITE(MP,40)
                    ENDIF
                      WRITE(MP,50)(X(I),I=1,N)
                  IF (IPRINT(2).EQ.3)THEN
                      WRITE(MP,60)
                      WRITE(MP,50)(G(I),I=1,N)
                  ENDIF
              ENDIF
            IF (FINISH) THEN
             WRITE(MP,100)
             WRITE(MP,*)
             WRITE(MP,90) F
            ENDIF
      ENDIF
!
 10   FORMAT('  Start of LBFGS optimization details')
 20   FORMAT('  N=',I5,'   NUMBER OF CORRECTIONS=',I2,                 &
            /,  '       INITIAL VALUES')
 30   FORMAT(' F= ',1PD10.3,'   GNORM= ',1PD10.3)
 40   FORMAT(' VECTOR X= ')
 50   FORMAT(6(2X,1PD10.3))
 60   FORMAT(' GRADIENT VECTOR G= ')
 70   FORMAT(/'   I   NFN',4X,'FUNC',8X,'GNORM',7X,'STEPLENGTH'/)
 80   FORMAT(2(I4,1X),3X,3(1PD10.3,2X))
 90   FORMAT(' Final objective value = ',1PD10.3)
 100  FORMAT(/' THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.' &
            ,/' IFLAG = 0')
!
      RETURN
      END

      BLOCK DATA LB2
      INTEGER LP,MP
      DOUBLE PRECISION GTOL,STPMIN,STPMAX
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
!     DATA MP,LP,GTOL,STPMIN,STPMAX/6,6,9.0D-01,1.0D-20,1.0D+20/
! SET UNIT=100 AS THE FILE WHERE WRITE DOWN OPTIMIZATION INFORMATION
      DATA MP,LP,GTOL,STPMIN,STPMAX/11,11,9.0D-01,1.0D-20,1.0D+20/
      END

      SUBROUTINE MCSRCH(N,X,F,G,S,STP,FTOL,XTOL,MAXFEV,INFO,NFEV,WA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      INTEGER N,MAXFEV,INFO,NFEV
      DOUBLE PRECISION F,STP,FTOL,GTOL,XTOL,STPMIN,STPMAX
      DOUBLE PRECISION X(N),G(N),S(N),WA(N)
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
      SAVE
!
!                     LINE SEARCH SUBROUTINE MCSRCH
!                
!     A slight modification of the subroutine CSRCH of More' and Thuente.
!     The changes are to allow reverse communication, and do not affect
!     the performance of the routine. 
!
!     THE PURPOSE OF MCSRCH IS TO FIND A STEP WHICH SATISFIES
!     A SUFFICIENT DECREASE CONDITION AND A CURVATURE CONDITION.
!
!     AT EACH STAGE THE SUBROUTINE UPDATES AN INTERVAL OF
!     UNCERTAINTY WITH ENDPOINTS STX AND STY. THE INTERVAL OF
!     UNCERTAINTY IS INITIALLY CHOSEN SO THAT IT CONTAINS A
!     MINIMIZER OF THE MODIFIED FUNCTION
!
!          F(X+STP*S) - F(X) - FTOL*STP*(GRADF(X)'S).
!
!     IF A STEP IS OBTAINED FOR WHICH THE MODIFIED FUNCTION
!     HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE DERIVATIVE,
!     THEN THE INTERVAL OF UNCERTAINTY IS CHOSEN SO THAT IT
!     CONTAINS A MINIMIZER OF F(X+STP*S).
!
!     THE ALGORITHM IS DESIGNED TO FIND A STEP WHICH SATISFIES
!     THE SUFFICIENT DECREASE CONDITION
!
!           F(X+STP*S) .LE. F(X) + FTOL*STP*(GRADF(X)'S),
!
!     AND THE CURVATURE CONDITION
!
!           ABS(GRADF(X+STP*S)'S)) .LE. GTOL*ABS(GRADF(X)'S).
!
!     IF FTOL IS LESS THAN GTOL AND IF, FOR EXAMPLE, THE FUNCTION
!     IS BOUNDED BELOW, THEN THERE IS ALWAYS A STEP WHICH SATISFIES
!     BOTH CONDITIONS. IF NO STEP CAN BE FOUND WHICH SATISFIES BOTH
!     CONDITIONS, THEN THE ALGORITHM USUALLY STOPS WHEN ROUNDING
!     ERRORS PREVENT FURTHER PROGRESS. IN THIS CASE STP ONLY
!     SATISFIES THE SUFFICIENT DECREASE CONDITION.
!
!     THE SUBROUTINE STATEMENT IS
!
!        SUBROUTINE MCSRCH(N,X,F,G,S,STP,FTOL,XTOL, MAXFEV,INFO,NFEV,WA)
!     WHERE
!
!       N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER
!         OF VARIABLES.
!
!       X IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE
!         BASE POINT FOR THE LINE SEARCH. ON OUTPUT IT CONTAINS
!         X + STP*S.
!
!       F IS A VARIABLE. ON INPUT IT MUST CONTAIN THE VALUE OF F
!         AT X. ON OUTPUT IT CONTAINS THE VALUE OF F AT X + STP*S.
!
!       G IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE
!         GRADIENT OF F AT X. ON OUTPUT IT CONTAINS THE GRADIENT
!         OF F AT X + STP*S.
!
!       S IS AN INPUT ARRAY OF LENGTH N WHICH SPECIFIES THE
!         SEARCH DIRECTION.
!
!       STP IS A NONNEGATIVE VARIABLE. ON INPUT STP CONTAINS AN
!         INITIAL ESTIMATE OF A SATISFACTORY STEP. ON OUTPUT
!         STP CONTAINS THE FINAL ESTIMATE.
!
!       FTOL AND GTOL ARE NONNEGATIVE INPUT VARIABLES. (In this reverse
!         communication implementation GTOL is defined in a COMMON
!         statement.) TERMINATION OCCURS WHEN THE SUFFICIENT DECREASE
!         CONDITION AND THE DIRECTIONAL DERIVATIVE CONDITION ARE
!         SATISFIED.
!
!       XTOL IS A NONNEGATIVE INPUT VARIABLE. TERMINATION OCCURS
!         WHEN THE RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
!         IS AT MOST XTOL.
!
!       STPMIN AND STPMAX ARE NONNEGATIVE INPUT VARIABLES WHICH
!         SPECIFY LOWER AND UPPER BOUNDS FOR THE STEP. (In this reverse
!         communication implementatin they are defined in a COMMON
!         statement).
!
!       MAXFEV IS A POSITIVE INTEGER INPUT VARIABLE. TERMINATION
!         OCCURS WHEN THE NUMBER OF CALLS TO FCN IS AT LEAST
!         MAXFEV BY THE END OF AN ITERATION.
!
!       INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
!
!         INFO = 0  IMPROPER INPUT PARAMETERS.
!
!         INFO =-1  A RETURN IS MADE TO COMPUTE THE FUNCTION AND GRADIENT.
!
!         INFO = 1  THE SUFFICIENT DECREASE CONDITION AND THE
!                   DIRECTIONAL DERIVATIVE CONDITION HOLD.
!
!         INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
!                   IS AT MOST XTOL.
!
!         INFO = 3  NUMBER OF CALLS TO FCN HAS REACHED MAXFEV.
!
!         INFO = 4  THE STEP IS AT THE LOWER BOUND STPMIN.
!
!         INFO = 5  THE STEP IS AT THE UPPER BOUND STPMAX.
!
!         INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS.
!                   THERE MAY NOT BE A STEP WHICH SATISFIES THE
!                   SUFFICIENT DECREASE AND CURVATURE CONDITIONS.
!                   TOLERANCES MAY BE TOO SMALL.
!
!       NFEV IS AN INTEGER OUTPUT VARIABLE SET TO THE NUMBER OF
!         CALLS TO FCN.
!
!       WA IS A WORK ARRAY OF LENGTH N.
!
!     SUBPROGRAMS CALLED
!
!       MCSTEP
!
!       FORTRAN-SUPPLIED...ABS,MAX,MIN
!
!     ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
!     JORGE J. MORE', DAVID J. THUENTE
!
!     **********
      INTEGER INFOC,J
      LOGICAL BRACKT,STAGE1
      DOUBLE PRECISION DG,DGM,DGINIT,DGTEST,DGX,DGXM,DGY,DGYM,         &
                 FINIT,FTEST1,FM,FX,FXM,FY,FYM,P5,P66,STX,STY,         &
                 STMIN,STMAX,WIDTH,WIDTH1,XTRAPF,ZERO
      DATA P5,P66,XTRAPF,ZERO /0.5D0,0.66D0,4.0D0,0.0D0/
      IF(INFO.EQ.-1) GO TO 45
      INFOC = 1
!
!     CHECK THE INPUT PARAMETERS FOR ERRORS.
!
      IF (N .LE. 0 .OR. STP .LE. ZERO .OR. FTOL .LT. ZERO .OR.         &
          GTOL .LT. ZERO .OR. XTOL .LT. ZERO .OR. STPMIN .LT. ZERO     &
          .OR. STPMAX .LT. STPMIN .OR. MAXFEV .LE. 0) RETURN
!
!     COMPUTE THE INITIAL GRADIENT IN THE SEARCH DIRECTION
!     AND CHECK THAT S IS A DESCENT DIRECTION.
!
      DGINIT = ZERO
      DO 10 J = 1, N
         DGINIT = DGINIT + G(J)*S(J)
   10    CONTINUE
      IF (DGINIT .GE. ZERO) then
         write(LP,15)
   15    FORMAT(/'  THE SEARCH DIRECTION IS NOT A DESCENT DIRECTION')
         RETURN
         ENDIF
!
!     INITIALIZE LOCAL VARIABLES.
!
      BRACKT = .FALSE.
      STAGE1 = .TRUE.
      NFEV = 0
      FINIT = F
      DGTEST = FTOL*DGINIT
      WIDTH = STPMAX - STPMIN
      WIDTH1 = WIDTH/P5
      DO 20 J = 1, N
         WA(J) = X(J)
   20    CONTINUE
!
!     THE VARIABLES STX, FX, DGX CONTAIN THE VALUES OF THE STEP,
!     FUNCTION, AND DIRECTIONAL DERIVATIVE AT THE BEST STEP.
!     THE VARIABLES STY, FY, DGY CONTAIN THE VALUE OF THE STEP,
!     FUNCTION, AND DERIVATIVE AT THE OTHER ENDPOINT OF
!     THE INTERVAL OF UNCERTAINTY.
!     THE VARIABLES STP, F, DG CONTAIN THE VALUES OF THE STEP,
!     FUNCTION, AND DERIVATIVE AT THE CURRENT STEP.
!
      STX = ZERO
      FX = FINIT
      DGX = DGINIT
      STY = ZERO
      FY = FINIT
      DGY = DGINIT
!
!     START OF ITERATION.
!
   30 CONTINUE
!
!        SET THE MINIMUM AND MAXIMUM STEPS TO CORRESPOND
!        TO THE PRESENT INTERVAL OF UNCERTAINTY.
!
         IF (BRACKT) THEN
            STMIN = MIN(STX,STY)
            STMAX = MAX(STX,STY)
         ELSE
            STMIN = STX
            STMAX = STP + XTRAPF*(STP - STX)
            END IF
!
!        FORCE THE STEP TO BE WITHIN THE BOUNDS STPMAX AND STPMIN.
!
         STP = MAX(STP,STPMIN)
         STP = MIN(STP,STPMAX)
!
!        IF AN UNUSUAL TERMINATION IS TO OCCUR THEN LET
!        STP BE THE LOWEST POINT OBTAINED SO FAR.
!
         IF ((BRACKT .AND. (STP .LE. STMIN .OR. STP .GE. STMAX))       &
            .OR. NFEV .GE. MAXFEV-1 .OR. INFOC .EQ. 0                  &
            .OR. (BRACKT .AND. STMAX-STMIN .LE. XTOL*STMAX)) STP = STX
!
!        EVALUATE THE FUNCTION AND GRADIENT AT STP
!        AND COMPUTE THE DIRECTIONAL DERIVATIVE.
!        We return to main program to obtain F and G.
!
         DO 40 J = 1, N
            X(J) = WA(J) + STP*S(J)
   40       CONTINUE
         INFO=-1
         RETURN
!
   45    INFO=0
         NFEV = NFEV + 1
         DG = ZERO
         DO 50 J = 1, N
            DG = DG + G(J)*S(J)
   50       CONTINUE
         FTEST1 = FINIT + STP*DGTEST
!
!        TEST FOR CONVERGENCE.
!
         IF ((BRACKT .AND. (STP .LE. STMIN .OR. STP .GE. STMAX))       &
            .OR. INFOC .EQ. 0) INFO = 6
         IF (STP .EQ. STPMAX .AND.                                     &
             F .LE. FTEST1 .AND. DG .LE. DGTEST) INFO = 5
         IF (STP .EQ. STPMIN .AND.                                     &
            (F .GT. FTEST1 .OR. DG .GE. DGTEST)) INFO = 4
         IF (NFEV .GE. MAXFEV) INFO = 3
         IF (BRACKT .AND. STMAX-STMIN .LE. XTOL*STMAX) INFO = 2
         IF (F .LE. FTEST1 .AND. ABS(DG) .LE. GTOL*(-DGINIT)) INFO = 1
!
!        CHECK FOR TERMINATION.
!
         IF (INFO .NE. 0) RETURN
!
!        IN THE FIRST STAGE WE SEEK A STEP FOR WHICH THE MODIFIED
!        FUNCTION HAS A NONPOSITIVE VALUE AND NONNEGATIVE DERIVATIVE.
!
         IF (STAGE1 .AND. F .LE. FTEST1 .AND.                          &
             DG .GE. MIN(FTOL,GTOL)*DGINIT) STAGE1 = .FALSE.
!
!        A MODIFIED FUNCTION IS USED TO PREDICT THE STEP ONLY IF
!        WE HAVE NOT OBTAINED A STEP FOR WHICH THE MODIFIED
!        FUNCTION HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE
!        DERIVATIVE, AND IF A LOWER FUNCTION VALUE HAS BEEN
!        OBTAINED BUT THE DECREASE IS NOT SUFFICIENT.
!
         IF (STAGE1 .AND. F .LE. FX .AND. F .GT. FTEST1) THEN
!
!           DEFINE THE MODIFIED FUNCTION AND DERIVATIVE VALUES.
!
            FM = F - STP*DGTEST
            FXM = FX - STX*DGTEST
            FYM = FY - STY*DGTEST
            DGM = DG - DGTEST
            DGXM = DGX - DGTEST
            DGYM = DGY - DGTEST
!
!           CALL CSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
!           AND TO COMPUTE THE NEW STEP.
!
            CALL MCSTEP(STX,FXM,DGXM,STY,FYM,DGYM,STP,FM,DGM,          &
                        BRACKT,STMIN,STMAX,INFOC)
!
!           RESET THE FUNCTION AND GRADIENT VALUES FOR F.
!
            FX = FXM + STX*DGTEST
            FY = FYM + STY*DGTEST
            DGX = DGXM + DGTEST
            DGY = DGYM + DGTEST
         ELSE
!
!           CALL MCSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
!           AND TO COMPUTE THE NEW STEP.
!
            CALL MCSTEP(STX,FX,DGX,STY,FY,DGY,STP,F,DG,                &
                        BRACKT,STMIN,STMAX,INFOC)
            END IF
!
!        FORCE A SUFFICIENT DECREASE IN THE SIZE OF THE
!        INTERVAL OF UNCERTAINTY.
!
         IF (BRACKT) THEN
            IF (ABS(STY-STX) .GE. P66*WIDTH1)STP=STX+P5*(STY-STX)
            WIDTH1 = WIDTH
            WIDTH = ABS(STY-STX)
            END IF
!
!        END OF ITERATION.
!
         GO TO 30
!
!     LAST LINE OF SUBROUTINE MCSRCH.
!
      END
      
      SUBROUTINE MCSTEP(STX,FX,DX,STY,FY,DY,STP,FP,DP,BRACKT,           &
                        STPMIN,STPMAX,INFO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER INFO
      DOUBLE PRECISION STX,FX,DX,STY,FY,DY,STP,FP,DP,STPMIN,STPMAX
      LOGICAL BRACKT,BOUND
!
!     SUBROUTINE MCSTEP
!
!     THE PURPOSE OF MCSTEP IS TO COMPUTE A SAFEGUARDED STEP FOR
!     A LINESEARCH AND TO UPDATE AN INTERVAL OF UNCERTAINTY FOR
!     A MINIMIZER OF THE FUNCTION.
!
!     THE PARAMETER STX CONTAINS THE STEP WITH THE LEAST FUNCTION
!     VALUE. THE PARAMETER STP CONTAINS THE CURRENT STEP. IT IS
!     ASSUMED THAT THE DERIVATIVE AT STX IS NEGATIVE IN THE
!     DIRECTION OF THE STEP. IF BRACKT IS SET TRUE THEN A
!     MINIMIZER HAS BEEN BRACKETED IN AN INTERVAL OF UNCERTAINTY
!     WITH ENDPOINTS STX AND STY.
!
!     THE SUBROUTINE STATEMENT IS
!
!       SUBROUTINE MCSTEP(STX,FX,DX,STY,FY,DY,STP,FP,DP,BRACKT,
!                        STPMIN,STPMAX,INFO)
!
!     WHERE
!
!       STX, FX, AND DX ARE VARIABLES WHICH SPECIFY THE STEP,
!         THE FUNCTION, AND THE DERIVATIVE AT THE BEST STEP OBTAINED
!         SO FAR. THE DERIVATIVE MUST BE NEGATIVE IN THE DIRECTION
!         OF THE STEP, THAT IS, DX AND STP-STX MUST HAVE OPPOSITE
!         SIGNS. ON OUTPUT THESE PARAMETERS ARE UPDATED APPROPRIATELY.
!
!       STY, FY, AND DY ARE VARIABLES WHICH SPECIFY THE STEP,
!         THE FUNCTION, AND THE DERIVATIVE AT THE OTHER ENDPOINT OF
!         THE INTERVAL OF UNCERTAINTY. ON OUTPUT THESE PARAMETERS ARE
!         UPDATED APPROPRIATELY.
!
!       STP, FP, AND DP ARE VARIABLES WHICH SPECIFY THE STEP,
!         THE FUNCTION, AND THE DERIVATIVE AT THE CURRENT STEP.
!         IF BRACKT IS SET TRUE THEN ON INPUT STP MUST BE
!         BETWEEN STX AND STY. ON OUTPUT STP IS SET TO THE NEW STEP.
!
!       BRACKT IS A LOGICAL VARIABLE WHICH SPECIFIES IF A MINIMIZER
!         HAS BEEN BRACKETED. IF THE MINIMIZER HAS NOT BEEN BRACKETED
!         THEN ON INPUT BRACKT MUST BE SET FALSE. IF THE MINIMIZER
!         IS BRACKETED THEN ON OUTPUT BRACKT IS SET TRUE.
!
!       STPMIN AND STPMAX ARE INPUT VARIABLES WHICH SPECIFY LOWER
!         AND UPPER BOUNDS FOR THE STEP.
!
!       INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
!         IF INFO = 1,2,3,4,5, THEN THE STEP HAS BEEN COMPUTED
!         ACCORDING TO ONE OF THE FIVE CASES BELOW. OTHERWISE
!         INFO = 0, AND THIS INDICATES IMPROPER INPUT PARAMETERS.
!
!     SUBPROGRAMS CALLED
!
!       FORTRAN-SUPPLIED ... ABS,MAX,MIN,SQRT
!
!     ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
!     JORGE J. MORE', DAVID J. THUENTE
!
      DOUBLE PRECISION GAMMA,P,Q,R,S,SGND,STPC,STPF,STPQ,THETA
      INFO = 0
!
!     CHECK THE INPUT PARAMETERS FOR ERRORS.
!
      IF ((BRACKT .AND. (STP .LE. MIN(STX,STY) .OR.                    &
           STP .GE. MAX(STX,STY))) .OR.                                &
           DX*(STP-STX) .GE. 0.0 .OR. STPMAX .LT. STPMIN) RETURN
!
!     DETERMINE IF THE DERIVATIVES HAVE OPPOSITE SIGN.
!
      SGND = DP*(DX/ABS(DX))
!
!     FIRST CASE. A HIGHER FUNCTION VALUE.
!     THE MINIMUM IS BRACKETED. IF THE CUBIC STEP IS CLOSER
!     TO STX THAN THE QUADRATIC STEP, THE CUBIC STEP IS TAKEN,
!     ELSE THE AVERAGE OF THE CUBIC AND QUADRATIC STEPS IS TAKEN.
!
      IF (FP .GT. FX) THEN
         INFO = 1
         BOUND = .TRUE.
         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
         S = MAX(ABS(THETA),ABS(DX),ABS(DP))
         GAMMA = S*SQRT((THETA/S)**2 - (DX/S)*(DP/S))
         IF (STP .LT. STX) GAMMA = -GAMMA
         P = (GAMMA - DX) + THETA
         Q = ((GAMMA - DX) + GAMMA) + DP
         R = P/Q
         STPC = STX + R*(STP - STX)
         STPQ = STX + ((DX/((FX-FP)/(STP-STX)+DX))/2)*(STP - STX)
         IF (ABS(STPC-STX) .LT. ABS(STPQ-STX)) THEN
            STPF = STPC
         ELSE
           STPF = STPC + (STPQ - STPC)/2
           END IF
         BRACKT = .TRUE.
!
!     SECOND CASE. A LOWER FUNCTION VALUE AND DERIVATIVES OF
!     OPPOSITE SIGN. THE MINIMUM IS BRACKETED. IF THE CUBIC
!     STEP IS CLOSER TO STX THAN THE QUADRATIC (SECANT) STEP,
!     THE CUBIC STEP IS TAKEN, ELSE THE QUADRATIC STEP IS TAKEN.
!
      ELSE IF (SGND .LT. 0.0) THEN
         INFO = 2
         BOUND = .FALSE.
         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
         S = MAX(ABS(THETA),ABS(DX),ABS(DP))
         GAMMA = S*SQRT((THETA/S)**2 - (DX/S)*(DP/S))
         IF (STP .GT. STX) GAMMA = -GAMMA
         P = (GAMMA - DP) + THETA
         Q = ((GAMMA - DP) + GAMMA) + DX
         R = P/Q
         STPC = STP + R*(STX - STP)
         STPQ = STP + (DP/(DP-DX))*(STX - STP)
         IF (ABS(STPC-STP) .GT. ABS(STPQ-STP)) THEN
            STPF = STPC
         ELSE
            STPF = STPQ
            END IF
         BRACKT = .TRUE.
!
!     THIRD CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
!     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DECREASES.
!     THE CUBIC STEP IS ONLY USED IF THE CUBIC TENDS TO INFINITY
!     IN THE DIRECTION OF THE STEP OR IF THE MINIMUM OF THE CUBIC
!     IS BEYOND STP. OTHERWISE THE CUBIC STEP IS DEFINED TO BE
!     EITHER STPMIN OR STPMAX. THE QUADRATIC (SECANT) STEP IS ALSO
!     COMPUTED AND IF THE MINIMUM IS BRACKETED THEN THE THE STEP
!     CLOSEST TO STX IS TAKEN, ELSE THE STEP FARTHEST AWAY IS TAKEN.
!
      ELSE IF (ABS(DP) .LT. ABS(DX)) THEN
         INFO = 3
         BOUND = .TRUE.
         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
         S = MAX(ABS(THETA),ABS(DX),ABS(DP))
!
!        THE CASE GAMMA = 0 ONLY ARISES IF THE CUBIC DOES NOT TEND
!        TO INFINITY IN THE DIRECTION OF THE STEP.
!
         GAMMA = S*SQRT(MAX(0.0D0,(THETA/S)**2 - (DX/S)*(DP/S)))
         IF (STP .GT. STX) GAMMA = -GAMMA
         P = (GAMMA - DP) + THETA
         Q = (GAMMA + (DX - DP)) + GAMMA
         R = P/Q
         IF (R .LT. 0.0 .AND. GAMMA .NE. 0.0) THEN
            STPC = STP + R*(STX - STP)
         ELSE IF (STP .GT. STX) THEN
            STPC = STPMAX
         ELSE
            STPC = STPMIN
            END IF
         STPQ = STP + (DP/(DP-DX))*(STX - STP)
         IF (BRACKT) THEN
            IF (ABS(STP-STPC) .LT. ABS(STP-STPQ)) THEN
               STPF = STPC
            ELSE
               STPF = STPQ
               END IF
         ELSE
            IF (ABS(STP-STPC) .GT. ABS(STP-STPQ)) THEN
               STPF = STPC
            ELSE
               STPF = STPQ
               END IF
            END IF
!
!     FOURTH CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
!     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DOES
!     NOT DECREASE. IF THE MINIMUM IS NOT BRACKETED, THE STEP
!     IS EITHER STPMIN OR STPMAX, ELSE THE CUBIC STEP IS TAKEN.
!
      ELSE
         INFO = 4
         BOUND = .FALSE.
         IF (BRACKT) THEN
            THETA = 3*(FP - FY)/(STY - STP) + DY + DP
            S = MAX(ABS(THETA),ABS(DY),ABS(DP))
            GAMMA = S*SQRT((THETA/S)**2 - (DY/S)*(DP/S))
            IF (STP .GT. STY) GAMMA = -GAMMA
            P = (GAMMA - DP) + THETA
            Q = ((GAMMA - DP) + GAMMA) + DY
            R = P/Q
            STPC = STP + R*(STY - STP)
            STPF = STPC
         ELSE IF (STP .GT. STX) THEN
            STPF = STPMAX
         ELSE
            STPF = STPMIN
            END IF
         END IF
!
!     UPDATE THE INTERVAL OF UNCERTAINTY. THIS UPDATE DOES NOT
!     DEPEND ON THE NEW STEP OR THE CASE ANALYSIS ABOVE.
!
      IF (FP .GT. FX) THEN
         STY = STP
         FY = FP
         DY = DP
      ELSE
         IF (SGND .LT. 0.0) THEN
            STY = STX
            FY = FX
            DY = DX
            END IF
         STX = STP
         FX = FP
         DX = DP
         END IF
!
!     COMPUTE THE NEW STEP AND SAFEGUARD IT.
!
      STPF = MIN(STPMAX,STPF)
      STPF = MAX(STPMIN,STPF)
      STP = STPF
      IF (BRACKT .AND. BOUND) THEN
         IF (STY .GT. STX) THEN
            STP = MIN(STX+0.66*(STY-STX),STP)
         ELSE
            STP = MAX(STX+0.66*(STY-STX),STP)
            END IF
         END IF
      RETURN
!
!     LAST LINE OF SUBROUTINE MCSTEP.
!
      END

!----------------------------------------------------------------------!
