!======================================================================!
!                                                                      !
!                               Do N O F                               !
!                                                                      !
!       (Donostia Natural Orbital Functional Software Program)         !
!                                                                      !
!                  COPYRIGHT by Mario Piris (2009)                     !
!    IPR registered under Basque Government and Spanish Ministry ECD   !
!                  Registration number 01/2020/360                     !
!                                                                      !
!           Donostia International Physics Center (DIPC)               !
!            University of the Basque Country (UPV/EHU)                !
!            Basque Foundation for Science (IKERBASQUE)                !
!                                                                      !
!               GNU General Public License version 3                   !
!                                                                      !
! ==================================================================== !
!                                                                      !
!      Please inform me of any bugs, by phone at: +34 943 01 8328,     !
!        by e-mail to: mario.piris@ehu.eus, or write to me at:         !
!            Donostia International Physics Center (DIPC),             !
!            Manuel de Lardizabal 4, 20018 Donostia, Spain.            !
!                                                                      !
! ==================================================================== !
!                                                                      !
!                           Date: April 2020                           !
!                                                                      !
!    Program to compute the ground state properties of a molecule      !
!    in the gas phase using PNOF5 - PNOF7 + perturbation corrections   !
!                                                                      !
!======================================================================!
!                                                                      !
!    2013 Four-index transformation of the electron repulsion          !
!         integrals was parallelized by Eduard Matito                  !
!                                                                      !
!    2015 Electrostatic dipole, quadrupole and octupole moments        !
!         implemented by Ion Mitxelena                                 !
!                                                                      !
!    2017 NOF energy gradients implemented by Ion Mitxelena            !
!                                                                      !
!======================================================================!

      PROGRAM DoNOF                                                    
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"                                                      
      character(8) :: date
      character(10):: time
      character(5) :: zone
      integer,dimension(8) :: val
!
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IAN,IMIN,IMAX,KSTART,KATOM
      INTEGER,ALLOCATABLE,DIMENSION(:) :: KTYPE,KLOC,INTYP,KNG,KMIN
      INTEGER,ALLOCATABLE,DIMENSION(:) :: KMAX,ISH,ITYP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: EVEC,ZAN,ZMASS,GRADS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: C1,C2,EX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: Cxyz0,Cxyz
      DOUBLE PRECISION,DIMENSION(3) :: DIPS
!-----------------------------------------------------------------------
!     MPI initialization
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL INIMPI()
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      call date_and_time(date,time,zone,val)
      write(6,1)val(5),val(6),val(2),val(3),val(1)
      call cpu_time(timestart)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Write Header on the output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,2)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Input namelist INPRUN variables (NINTEG=NINTMX)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!     IRUNTYP: Specifies the run calculation
!         ICH: Molecular charge  
!         MUL: Multiplicity of the electronic state
!      NINTEG: Total Number of 2e- integrals (NINTEG = NINTMX)
!      IDONTW: Do not write 2e- integrals on the disk (Unit=1)
!       IEMOM: Electrostatic moments calculation
!        EVEC: An array of the three x,y,z components of
!        IECP: Effective Core Potentials
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(EVEC(3))
      CALL NAMELIST_INPRUN(IRUNTYP,ICH,MUL,NINTEG,IDONTW,IEMOM,
     &                     EVEC,IECP)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Initialize for the integral quadratures
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL INIINTQUAD
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!     Maximum Number of Atoms = 100
!     Maximum Number of Shells = 500
!     Maximum Number of Gaussian Functions = 2000
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ZAN(100),Cxyz0(3,100),IAN(100),IMIN(100),
     &         IMAX(100),ZMASS(100),KSTART(500),KATOM(500),
     &         KTYPE(500),KLOC(500),INTYP(500),KNG(500),KMIN(500),
     &         KMAX(500),ISH(2000),ITYP(2000),C1(2000),
     &         C2(2000),EX(2000),CS(2000),CP(2000),CD(2000),
     &         CF(2000),CG(2000),CH(2000),CI(2000),STAT=IER)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Read in Basis Set and get initial Molecular Orbitals
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL START(NAT,NBF,NQMT,NE,NA,NB,NSHELL,NPRIMI,ZAN,Cxyz0,IAN,
     &           IMIN,IMAX,ZMASS,KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,
     &           KMIN,KMAX,ISH,ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,CI)
      ALLOCATE(Cxyz(3,NAT))
      do i=1,3
       Cxyz(i,1:nat) = Cxyz0(i,1:nat)
      end do
      deallocate(Cxyz0)
      IF(NAT==1.and.IRUNTYP==3)THEN
       WRITE(6,5)
       IRUNTYP = 2
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     Header on the output file
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!        NAT: Number of Atoms             
!        ICH: Charge of Molecule
!        MUL: State Multiplicity
!        NBF: Number of Basis Functions (NSQ=NBF*NBF,NBFT=NBF(NBF+1)/2)   
!       NQMT: Number of linearly independent orbitals  
!         NE: Number of Electrons
!         NA: Number of Alpha electrons
!         NB: Number of Beta electrons
!       EVEC: Electric Field components
!     NSHELL: Total number of shells
!     NPRIMI: Total number of primitive exponents
!        IAN: True nuclear charge
!      IEMOM: Electrostatic moments calculation
!       IECP: Effective Core Potentials
!
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL RUNNOFHEADER(NAT,ICH,MUL,NBF,NQMT,NE,NA,NB,EVEC(1),EVEC(2),
     &                  EVEC(3),NSHELL,NPRIMI,IAN,IEMOM,IECP,IRUNTYP,
     &                  Cxyz,ZAN)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     If RUNTYP = 1) ENERGY  : single-point energy
!                 2) GRADIENT: single-point energy + gradients
!                 3) OPTIMIZE: optimize the molecular geometry
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IRUNTYP==1.or.IRUNTYP==2)THEN
       ALLOCATE(GRADS(3*NAT))
       CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NSHELL,NPRIMI,
     &               ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,
     &               KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX,CS,CP,
     &               CD,CF,CG,CH,CI,GRADS,IRUNTYP,DIPS,1,1)
       DEALLOCATE(GRADS)
      ELSE IF(IRUNTYP==3)THEN
       CALL OPTIMIZE(NINTEG,IDONTW,NAT,ZAN,Cxyz,IAN,IMIN,IMAX,
     &              ZMASS,KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,
     &              ISH,ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,IRUNTYP)
      END IF
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(EVEC,ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC)
      DEALLOCATE(INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,EX,CS,CP,CD,CF,CG)
      DEALLOCATE(CH,CI)
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      call cpu_time(timefinish)
      DELTATIME = timefinish - timestart
      WRITE(6,3)DELTATIME
!-----------------------------------------------------------------------
      call date_and_time(date,time,zone,val)
      write(6,4)val(5),val(6),val(2),val(3),val(1)
!-----------------------------------------------------------------------
!     Format definitions
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(/' The execution started at ',I2,'h ',I2,'min on the ',
     &          I2,'/',I2,'/',I4)
    2 FORMAT(
     */4X,'==========================================================='
     */4X,'!                                                         !',                                                                     
     */4X,'!                        Do N O F                         !',   
     */4X,'!                                                         !',                                                                     
     */4X,'!  (Donostia Natural Orbital Functional Software Program) !',   
     */4X,'!                                                         !',                                                                     
     */4X,'!               COPYRIGHT by Mario Piris                  !', 
     */4X,'!                                                         !', 
     */4X,'!      Donostia International Physics Center (DIPC)       !',
     */4X,'!       University of the Basque Country (UPV/EHU)        !',
     */4X,'!       Basque Foundation for Science (IKERBASQUE)        !',
     */4X,'!                                                         !', 
     */4X,'!          GNU General Public License version 3           !',                                                                     
     */4X,'!                                                         !',                                                                     
     */4X,'!                 VERSION: April 2020                     !',
     */4X,'!                                                         !',
     */4X,'===========================================================')
    3 FORMAT(/,'  Elapsed real time :',F10.2,'  (Seconds)')
    4 FORMAT(/' The execution finished at ',I2,'h ',I2,'min on the ',
     &          I2,'/',I2,'/',I4)                                                                                                                       
    5 FORMAT(/1X,'Warning: For geometry optimization the number of'
     &           'atoms must be greater,',/,10X,'than 1 '
     &           'so RUNTYP has been set equal to GRAD, not OPTGEO')
!-----------------------------------------------------------------------
      STOP
      END

!======================================================================!
!                                                                      !
!   PARCOM: Parameters and Common Blocks used in DoNOF Program         !
!   RUNNOFHEADER: Write header on the output file                      !
!   SETORBSPACE: Define the orbital space (NDOC,NSOC,NCWO,NVIR,...)    !
!                Write the orbital space                               !
!   POINTERS: Define Pointers of the USER array for the CG subroutine  !
!   ENERGRAD: Calculate Energy and Gradient (RUNTYP=1,2)               !
!   DQONuclear: Nuclear Dipole, Quadrupole, Octupole Elec. Moments     !
!                                                                      !
!======================================================================!

C PARCOM
      MODULE PARCOM
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C-----------------------------------------------------------------------
       DOUBLE PRECISION,PARAMETER::DFAC=2.54174D0    ! Debye
       DOUBLE PRECISION,PARAMETER::QFAC=1.345044D0   ! Buckinham
       DOUBLE PRECISION,PARAMETER::OFAC=7.117668D-01 ! X10**34 ESU-CM**3
C-----------------------------------------------------------------------
       CHARACTER(80) :: TITLE
       COMMON/TIT/TITLE
       COMMON/INPNOF_GENERALINF/ICOEF,MAXIT,IECP
       COMMON/INPNOF_PNOF/IPNOF,NTWOPAR
       COMMON/INPNOF_ORBSPACE0/NO1,NDOC,NCO,NCWO,NVIR,NAC,NO0
       LOGICAL HighSpin
       COMMON/INPNOF_ORBSPACE_1/HighSpin
       COMMON/INPNOF_ORBSPACE_2/NSOC,NDNS,MSpin
       COMMON/INPNOF_STATIC/Ista
       LOGICAL DIAGLAG
       COMMON/INPNOF_DIAGELAG/DIAGLAG
       LOGICAL HFID
       COMMON/INPNOF_INPUT_0/HFID
       COMMON/INPNOF_INPUT_1/IEINI,NTHRESHEID,MAXITID,KOOPMANS
       LOGICAL RESTART
       COMMON/INPNOF_INPUT_2/RESTART
       COMMON/INPNOF_INPUT_3/INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ
       COMMON/INPNOF_NTHRESH/NTHRESHL,NTHRESHE,NTHRESHEC,NTHRESHEN
       COMMON/INPNOF_THRESH/THRESHEID,THRESHL,THRESHE,THRESHEC,THRESHEN
       LOGICAL PRINTLAG
       COMMON/INPNOF_OUTPUT_1/PRINTLAG
       COMMON/INPNOF_OUTPUT_2/NPRINT,IWRITEC,IMULPOP,IAIMPAC
       COMMON/INPNOF_OUTPUT_3/IEKT
       COMMON/INPNOF_OUTPUT_4/NOUTRDM,NTHRESHDM,NSQT
       COMMON/INPNOF_OUTPUT_5/THRESHDM,THRESHCJK,THRESHTijab
       COMMON/INPNOF_OUTPUT_6/NOUTCJK,NTHRESHCJK
       COMMON/INPNOF_OUTPUT_7/NOUTTijab,NTHRESHTijab
       LOGICAL APSG
       COMMON/INPNOF_OUTPUT_8/APSG
       COMMON/INPNOF_OUTPUT_9/THAPSG
       COMMON/INPNOF_COEFOPT/THFMIUG0,MAXLOOP,LOOP
       COMMON/INPNOF_LIMITS/NOPTORB
       LOGICAL SCALING
       COMMON/INPNOF_SCALING_1/SCALING
       COMMON/INPNOF_SCALING_2/NZEROS,NZEROSm,NZEROSr,ITZITER
       LOGICAL DIIS,PERDIIS       
       COMMON/INPNOF_DIIS_1/DIIS,PERDIIS
       COMMON/INPNOF_DIIS_2/NDIIS,NTHDIIS,THDIIS
       LOGICAL SC2MCPT
       COMMON/INPNOF_SC2MCPT/SC2MCPT
       LOGICAL OIMP2
       COMMON/INPNOF_OIMP2/OIMP2
       LOGICAL MBPT,TUNEMBPT,TDHF,MBPTMEM
       COMMON/INPNOF_MBPT/MBPT,TUNEMBPT,TDHF,MBPTMEM
       COMMON/INPNOF_CGM/ICGMETHOD
       LOGICAL CHKORTHO,ORTHO
       COMMON/INPNOF_ORTHOGONALITY/CHKORTHO,ORTHO
       LOGICAL FROZEN
       COMMON/INPNOF_FROZEN_1/FROZEN
       COMMON/INPNOF_FROZEN_2/IFROZEN(200)
C-----------------------------------------------------------------------
       LOGICAL EFIELDL
       COMMON/INPFILE_0/NATOMS,ICH,MUL,NBF,NQMT,NE,NA,NB,NSHELL
       COMMON/INPFILE_1/NPRIMI,NBFT,NSQ
       COMMON/INPFILE_2/EX,EY,EZ,EFIELDL
       COMMON/INPFILE_3/NBF5,NBFT5,NSQ5
       COMMON/INPFILE_4/NO1PT2,NEX
       COMMON/INPFILE_5/IEMOM
       COMMON/INPFILE_6/NINTMX,NIJKL,NINTCR,NSTORE
C-----------------------------------------------------------------------
       COMMON/INPFILE_FRAG_1/NO1f,NDOCf,NCWOf,NO0f,NCOf,NACf
       COMMON/INPFILE_FRAG_2/NBFf,NBFTf,NSQf,NBF5f,NBFT5f,NSQ5f
C-----------------------------------------------------------------------
       COMMON/EHFEN/EHF,EN,EMP2,EMP3
       COMMON/ENERGIAS/EELEC_OLD,EELEC,DIF_EELEC,EELEC_MIN
       COMMON/CorrNonDynamic/ECnd,ECndl,ECndHF,ECndInter
       COMMON/MCPT2/Ecorr,OCCLIM
C-----------------------------------------------------------------------
       LOGICAL CONVGDELAG
       COMMON/CONVERGENCE_1/CONVGDELAG
       COMMON/CONVERGENCE_2/DUMEL,PCONV
       COMMON/CONVERGESUM/SUMDIF_OLD,SUMDIF
C-----------------------------------------------------------------------
       COMMON/PUNTEROSUSER/N1,N2,N3,N4,N5,N6,N7,N8,N9,N10,N11,N12,N13,
     &                     N14,N15,N16,N17,N18,N19,N20,N21,N22,N23,N24,
     &                     N25,N26,N27,N28,N29,N30,N31,N32,N33,N34,N35,
     &                     N36,N37,N38,N39,N40,N41,N42,N43,N44,N45,N46,
     &                     N47,N48,N49,N50,N51,NUSER
       COMMON/SUMSZ/SUMS,SUMF
C-----------------------------------------------------------------------
      END MODULE PARCOM

C RUNNOFHEADER
      SUBROUTINE RUNNOFHEADER(NATOMSn,ICHn,MULn,NBFn,NQMTn,NEn,NAn,NBn,
     &                        EXn,EYn,EZn,NSHELLn,NPRIMIn,IAN,IEMOMn,
     &                        IECPn,IRUNTYP,Cxyz,ZNUC)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      INTEGER,DIMENSION(NATOMSn) :: IAN
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IZCORE
      DOUBLE PRECISION,DIMENSION(3,NATOMSn) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NATOMSn) :: ZNUC
      CHARACTER*4 ATMNAME(NATOMSn)
C-----------------------------------------------------------------------
C     Basic information
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NATOMS: Number of Atoms             
C        ICH: Charge of Molecule
C        MUL: State Multiplicity
C        NBF: Number of Basis Functions (NSQ=NBF*NBF,NBFT=NBF(NBF+1)/2)   
C       NQMT: Number of linearly independent orbitals  
C         NE: Number of Electrons
C         NA >= NB
C         NA: Number of Alpha electrons
C         NB: Number of Beta electrons
C       EVEC: Electric Field components (EX,EY,EZ)
C     NSHELL: Total number of shells
C     NPRIMI: Total number of primitive exponents
C-----------------------------------------------------------------------
      NATOMS = NATOMSn
      ICH    = ICHn
      MUL    = MULn
      NBF    = NBFn
      NQMT   = NQMTn
      NE     = NEn
      NA     = NAn
      NB     = NBn
      EX     = EXn
      EY     = EYn
      EZ     = EZn
      NSHELL = NSHELLn
      NPRIMI = NPRIMIn
      IEMOM  = IEMOMn
      IECP   = IECPn
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NBFT: Dimension for symmetric matices
C      NSQ: Dimension for square matices
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NSQ = NBF*NBF
      NBFT = NBF*(NBF+1)/2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Input namelist variables: ICOEF, MAXIT, ...
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL NAMELIST_NOFINP(IRUNTYP)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Write Header of NOF Calculation on the output file 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OUTPUTHEADER
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Open files (GCF,BFST,GCFe,WFN,APSG,FRAG,CGGRAD)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OPENFILES(IRUNTYP)
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
C     INPUTCXYZ=0: Read geometry from input file
C     INPUTCXYZ=1: Read geometry from GCF file
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTCXYZ==1) THEN
       CALL READCXYZ(ZNUC,Cxyz,NATOMS,NBF,NSQ)
       WRITE(6,2)
       ALLOCATE(IZCORE(NATOMS))
       IZCORE(:) = 0 ! For the time no ECP is used
       CALL ATOMNAMES(NATOMS,ZNUC,IZCORE,ATMNAME,Cxyz,1,1)
       DEALLOCATE(IZCORE)
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Output Basic
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OUTPUTBASIC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     If NO1 = -1 calculate NO1 according to true nuclear charges (IAN)
C     NO1: Natural Orbitals with Occupation Numbers equal to one.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NO1==-1)THEN
C      If using ECPotentials (IECP/=0): NO1=0, NO1PT2=0
       IF(IECP/=0)THEN
        NO1 = 0
        NO1PT2 = 0
        WRITE(6,1)
       ELSE
        CALL SETNO1(IAN)
       ENDIF 
      ENDIF 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NO1:  Number of inactive doubly occupied orbitals (OCC=1)         
C     NDOC: Number of strongly doubly occupied MOs                      
C     NSOC: Number of strongly singly occupied MOs                      
C     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)                        
C     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
C     NCWO*NDOC: Active orbitals in the virtual subspace                
C     NO0:  Empty orbitals  (OCC=0)                                      
C     NVIR: Number of weakly occupied MOs + empty MOs                   
C                                                                     
C           NO1 | NDOC + NSOC  |   NCWO*NDOC + NO0  = NBF               
C           NO1 |     NDNS     |          NVIR      = NBF               
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL SETORBSPACE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Define Pointers of the USER array for the external CG subroutine
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL POINTERS
C-----------------------------------------------------------------------
    1 FORMAT(/1X,'You are using an ECP: Core Orbitals have been already'
     &,1X,'excluded.',/1X,'NO1 and NO1PT2 = 0.')
    2 FORMAT(/1X,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
     *       /1X,'WARNING! READING NUCLEAR COORDINATES FROM GCF'
     *       /1X,'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
      RETURN
      END

C SETORBSPACE
      SUBROUTINE SETORBSPACE
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,10)
      WRITE(6,11)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     If NBF < NE -> More orbitals have to be excluded in NO1 or NO1PT2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NBF<NE)THEN
       NDIF = NE-NBF
       IF(NO1<NDIF)THEN
        NO1 = NDIF
        WRITE(6,1)
       ENDIF
       IF(NO1PT2<NDIF)THEN
        NO1PT2 = NDIF
        WRITE(6,2)
       ENDIF
       IF(NO1==NBF)THEN
        WRITE(6,3)
        STOP
       ENDIF
       IF(NO1PT2==NBF)THEN
        WRITE(6,31)
        STOP
       ENDIF
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
C     Frozen orbitals in perturbative calculations
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
      IF(NO1PT2==-1)NO1PT2 = NO1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                         Set Orbital Space
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NO1:  Number of inactive doubly occupied orbitals (OCC=1)         
C     NDOC: Number of strongly doubly occupied MOs                      
C     NSOC: Number of strongly singly occupied MOs                      
C     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)                        
C     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
C     NCWO*NDOC: Active orbitals in the virtual subspace                
C     NO0:  Empty orbitals  (OCC=0)                                      
C     NVIR: Number of weakly occupied MOs + empty MOs                   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C           NO1 | NDOC  + NSOC  |   NCWO*NDOC + NO0  = NBF               
C           NO1 |      NDNS     |          NVIR      = NBF 
C               | -NAC- |       |  -   NAC  - |
C                      NB      NA            NBF5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                               !  CLOSED (NB=NA=NCO,NSOC=0)
      NDOC = NB - NO1           !  NDOC = NCO - NO1, NO1 <= NCO
      NDNS = NDOC + NSOC        !  NDNS = NDOC      
      NA   = NO1 + NDNS         !  NA = NB = NCO
      NVIR = NBF - NA           !  NBF - NCO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NDNS/=0)THEN
       if(NDOC>0)then
        IF(NCWO/=1)THEN                      ! Extended PNOF (NCWO>1)
C- - - - - - - - - - - - - - - - - -       
         if(NCWO<-1)then
          write(6,4)NCWO
          stop
         else if(NCWO==-1)then
          NCWO = NVIR/NDOC
         else if(NCWO>NVIR/NDOC)then
          write(6,5)NCWO
          NCWO = NVIR/NDOC
         endif
C- - - - - - - - - - - - - - - - - -        
        ELSE                                 ! perfect pairing (NCWO=1)
C- - - - - - - - - - - - - - - - - -       
         write(6,6)                           
C- - - - - - - - - - - - - - - - - -        
        ENDIF
       else
        NCWO = 0
       end if
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NAC: Dimension of the active natural orbital subspace
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NAC = NDOC * ( 1 + NCWO )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NBF5: Occupied Orbitals (ON /= 0), NBFT5, NSQ5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NBF5 = NO1 + NAC + NSOC                ! NBF5 = NA  + NDOC*NCWO
      IF(NBF5>NBF)NBF5 = NBF
      NBFT5 = NBF5*(NBF5+1)/2
      NSQ5 = NBF5*NBF5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NO0: Empty orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NO0 = NBF - NBF5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,7)NO1,NDOC,NSOC,NCWO,NAC,NO0      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NOPTORB: Number of Optimized Orbitals
C              IF(NOPTORB==-1)NOPTORB=NBF (OUTPUTBASIC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOPTORB<1)THEN
       WRITE(6,8)NOPTORB
       STOP
      ELSE IF(NOPTORB<NBF5)THEN
       NOPTORB = NBF5
      ELSE IF(NOPTORB>NBF)THEN
       NOPTORB = NBF
      ENDIF
      WRITE(6,9)NOPTORB
      WRITE(6,10)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN
C-----------------------------------------------------------------------
C     Format definitions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(/1X,'Note NBF < NE: More orbitals have to be excluded.'
     &,1X,'NO1 has been set equal to NE-NBF')
    2 FORMAT(/1X,'Note NBF < NE: More orbitals have to be excluded.'
     &,1X,'NO1PT2 has been set equal to NE-NBF')
    3 FORMAT(/1X,'Stop: all orbitals are full occupied (NO1=NBF)')
   31 FORMAT(/1X,'Stop: all orbitals are full occupied (NO1PT2=NBF)')    
    4 FORMAT(/1X,' Stop Program: Incorrect number of NCWO =',I5)
    5 FORMAT(/1X,'Your NCWO =',I5,' exceeds the maximum possible value')
    6 FORMAT(/1X,'You are doing a perfect pairing calculation: NCWO=1')
    7 FORMAT(/1X,'Inactive Doubly occupied orbitals up to NO1  =',I5,
     *       /1X,'No. considered Strongly Doubly occupied MOs  =',I5,
     *       /1X,'No. considered Strongly Singly occupied MOs  =',I5,     
     *       /1X,'NO. of Weakly occ. per St. Doubly occ.  MOs  =',I5,
     *       /1X,'Dimension of the Active Nat. Orb. subspace   =',I5,
     *       /1X,'Secondary Empty orbitals                     =',I5)
    8 FORMAT(/1X,'Stop Program: Incorrect number of NOPTORB =',I5)
    9 FORMAT(/1X,'Number of Optimized Orbitals                 =',I5)
   10 FORMAT(/72('-'))
   11 FORMAT(/,' Orbital Space',/,
     *         ' -------------')
C-----------------------------------------------------------------------
      END

C POINTERS
      SUBROUTINE POINTERS
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     Define Pointers of the USER array
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      N1  = 1                    ! USER( N1) = RO(NBF5)
      N2  = N1  + NBF5           ! USER( N2) = CJ12(NBF5,NBF5)
      N3  = N2  + NSQ5           ! USER( N3) = CK12(NBF5,NBF5)
      N4  = N3  + NSQ5           ! USER( N4) = DR(NBF5,NBF5) 
      N5  = N4  + NSQ5           ! USER( N5) = DCJ12r(NBF5,NBF5,NBF5)
      N6  = N5  + NSQ5*NBF5      ! USER( N6) = DCK12r(NBF5,NBF5,NBF5)
      N7  = N6  + NSQ5*NBF5      ! USER( N7) = QD(NBF,NBF,NBF)
      N8  = N7  + NBF*NSQ        ! USER( N8) = HCORE(NBF5)
      N9  = N8  + NBF5           ! USER( N9) = QJ(NBFT5)
      N10 = N9  + NBFT5          ! USER(N10) = QK(NBFT5)
      N11 = N10 + NBFT5          ! USER(N11) = DIPN(3)
      N12 = N11 + 3              ! USER(N12) = ADIPx(NSQ)
      N13 = N12 + NSQ            ! USER(N13) = ADIPy(NSQ)
      N14 = N13 + NSQ            ! USER(N14) = ADIPz(NSQ)
      N15 = N14 + NSQ            ! USER(N15) = DIPx(NSQ5)
      N16 = N15 + NSQ5           ! USER(N16) = DIPy(NSQ5)
      N17 = N16 + NSQ5           ! USER(N17) = DIPz(NSQ5)
      N18 = N17 + NSQ5           ! USER(N18) = QUADN(6)
      N19 = N18 + 6              ! USER(N19) = AQUADxx(NSQ)
      N20 = N19 + NSQ            ! USER(N20) = AQUADyy(NSQ)
      N21 = N20 + NSQ            ! USER(N21) = AQUADzz(NSQ)
      N22 = N21 + NSQ            ! USER(N22) = AQUADxy(NSQ)
      N23 = N22 + NSQ            ! USER(N23) = AQUADxz(NSQ)
      N24 = N23 + NSQ            ! USER(N24) = AQUADyz(NSQ)
      N25 = N24 + NSQ            ! USER(N25) = QUADxx(NSQ5)
      N26 = N25 + NSQ5           ! USER(N26) = QUADyy(NSQ5)
      N27 = N26 + NSQ5           ! USER(N27) = QUADzz(NSQ5)
      N28 = N27 + NSQ5           ! USER(N28) = QUADxy(NSQ5)
      N29 = N28 + NSQ5           ! USER(N29) = QUADxz(NSQ5)
      N30 = N29 + NSQ5           ! USER(N30) = QUADyz(NSQ5)
      N31 = N30 + NSQ5           ! USER(N31) = OCTUN(10)
      N32 = N31 + 10             ! USER(N32) = AOCTxxx(NSQ)
      N33 = N32 + NSQ            ! USER(N33) = AOCTyyy(NSQ)
      N34 = N33 + NSQ            ! USER(N34) = AOCTzzz(NSQ)
      N35 = N34 + NSQ            ! USER(N35) = AOCTxxy(NSQ)
      N36 = N35 + NSQ            ! USER(N36) = AOCTxxz(NSQ)
      N37 = N36 + NSQ            ! USER(N37) = AOCTxyy(NSQ)
      N38 = N37 + NSQ            ! USER(N38) = AOCTyyz(NSQ)
      N39 = N38 + NSQ            ! USER(N39) = AOCTxzz(NSQ)
      N40 = N39 + NSQ            ! USER(N40) = AOCTyzz(NSQ)
      N41 = N40 + NSQ            ! USER(N41) = AOCTxyz(NSQ)
      N42 = N41 + NSQ            ! USER(N42) = OCTXXX(NSQ5)
      N43 = N42 + NSQ5           ! USER(N43) = OCTYYY(NSQ5)
      N44 = N43 + NSQ5           ! USER(N44) = OCTZZZ(NSQ5)
      N45 = N44 + NSQ5           ! USER(N45) = OCTXXY(NSQ5)
      N46 = N45 + NSQ5           ! USER(N46) = OCTXXZ(NSQ5)
      N47 = N46 + NSQ5           ! USER(N47) = OCTXYY(NSQ5)
      N48 = N47 + NSQ5           ! USER(N48) = OCTYYZ(NSQ5)
      N49 = N48 + NSQ5           ! USER(N49) = OCTXZZ(NSQ5)
      N50 = N49 + NSQ5           ! USER(N50) = OCTYZZ(NSQ5)
      N51 = N50 + NSQ5           ! USER(N51) = OCTXYZ(NSQ5)
      NUSER = N51 - N1 + NSQ5
C-----------------------------------------------------------------------
      RETURN
      END
      
C ENERGRAD
      SUBROUTINE ENERGRAD(NINTEG,IDONTW,IEMOM,NAT,NBF,NSHELL,NPRIMI,
     &                    ZAN,Cxyz,IAN,IMIN,IMAX,KSTART,KATOM,
     &                    KTYPE,KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,
     &                    C1,C2,EX,CS,CP,CD,CF,CG,CH,CI,GRADS,IRUNTYP,
     &                    DIPS,NOPTCG,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL RESTART
      COMMON/INPNOF_INPUT_2/RESTART
      COMMON/INPNOF_INPUT_3/INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ      
#include "mpip.h"
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      INTEGER,DIMENSION(NAT):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI) :: ISH,ITYP
      INTEGER :: IPRINTOPT,NOPTCG
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: C1,C2,EX
      DOUBLE PRECISION,DIMENSION(NPRIMI) :: CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(3*NAT) :: GRADS
      DOUBLE PRECISION,DIMENSION(3) :: DIPS
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE :: XINTS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IBUF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: H,S,EiHF,CHF,BUF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DIPN,QUADN,OCTUN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DQOInt,AUX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AHCORE,OVERLAP
C-----------------------------------------------------------------------
C     Allocate necessary arrays for 1e- and 2e- integrals + Guess
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NSQ = NBF*NBF
      NBFT = (NBF*NBF+NBF)/2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     1e Integrals: H, S ; Initial Orbitals: CHF, EiHF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(H(NBFT),S(NBFT),EiHF(NBF),CHF(NSQ))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     2e- Integrals (BUF,IBUF)
C     NINTEGtm: Maximum numbers of distinct two-electron integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IDONTW==1)THEN
       NINTEGtm = NBF*(NBF+1)*(NBF*NBF+NBF+2)/8
      ELSE
       NINTEGtm = NINTEG
      ENDIF
      ALLOCATE(BUF(NINTEGtm),IBUF(NINTEGtm),STAT=IER)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Integrals and Guess
C     Note: NINTEGt < NINTEGtm due to the CUTOFF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
      ALLOCATE(XINTS(NSH2))
      CALL GuessHJK(Cxyz,H,S,EiHF,CHF,BUF,IBUF,NAT,NBF,NSQ,NBFT,
     & NINTEGtm,NINTEGt,NREC,XINTS,NSH2,IDONTW,INPUTC,IPRINTOPT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Preparing for RunNOF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IDONTW==0)REWIND(1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Square Matrices AHCORE, OVERLAP
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(AHCORE(NBF,NBF),OVERLAP(NBF,NBF))
      CALL CPYTSQ(H,AHCORE,NBF)
      CALL CPYTSQ(S,OVERLAP,NBF)            
      DEALLOCATE(H,S)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Multipole Moment Integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DIPN(3),QUADN(6),OCTUN(10))
      CALL DQONuclear(DIPN,QUADN,OCTUN,Cxyz,ZAN,NAT)
C
      IF(IEMOM==1)THEN
       NVAL=3                                             
      ELSE IF(IEMOM==2)THEN
       NVAL=3+6                                             
      ELSE IF(IEMOM==3)THEN
       NVAL=3+6+10                                            
      END IF                                                            
      ALLOCATE(DQOInt(NVAL*NBFT),AUX(NVAL*784))
      CALL PRCALC(DQOInt,AUX,NVAL,NBFT) 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     PNOF Calculation
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL RunNOF(NAT,NBF,NBFT,NSHELL,NPRIMI,ZAN,Cxyz,IAN,
     &            IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,
     &            KMIN,KMAX,ISH,ITYP,C1,C2,EX,CS,CP,CD,CF,CG,CH,
     &            CI,AHCORE,OVERLAP,CHF,EiHF,DIPN,QUADN,OCTUN,
     &            NVAL,DQOInt,NINTEG,NREC,IBUF,BUF,NINTEGt,IDONTW,
     &            GRADS,IRUNTYP,DIPS,XINTS,IPRINTOPT)
      DEALLOCATE(AHCORE,OVERLAP,CHF,EiHF,DIPN,QUADN,OCTUN,DQOInt,AUX)
      DEALLOCATE(IBUF,BUF,XINTS)
      NOPTCGMPI = NOPTCG
#ifdef MPI
      DO I=1,NPROCS-1
       K=0
       CALL MPI_SEND(K,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NOPTCGMPI,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif      
C-----------------------------------------------------------------------
      RETURN
      END

C DQONuclear
      SUBROUTINE DQONuclear(DIPN,QUADN,OCTUN,Cxyz,ZAN,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(3) :: DIPN
      DOUBLE PRECISION,DIMENSION(6) :: QUADN
      DOUBLE PRECISION,DIMENSION(10):: OCTUN
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz
      DOUBLE PRECISION,DIMENSION(NAT) :: ZAN
C-----------------------------------------------------------------------
      DIPN  = 0.0d0                                                     
      QUADN = 0.0d0                                                       
      OCTUN = 0.0d0
      DO I=1,NAT
       XN = Cxyz(1,I) 
       YN = Cxyz(2,I) 
       ZN = Cxyz(3,I) 
       DIPN(1)   = DIPN(1)   + ZAN(I)*XN                                        
       DIPN(2)   = DIPN(2)   + ZAN(I)*YN                                        
       DIPN(3)   = DIPN(3)   + ZAN(I)*ZN                                        
       QUADN(1)  = QUADN(1)  + ZAN(I)*XN*XN                               
       QUADN(2)  = QUADN(2)  + ZAN(I)*YN*YN                               
       QUADN(3)  = QUADN(3)  + ZAN(I)*ZN*ZN                               
       QUADN(4)  = QUADN(4)  + ZAN(I)*XN*YN                               
       QUADN(5)  = QUADN(5)  + ZAN(I)*XN*ZN                               
       QUADN(6)  = QUADN(6)  + ZAN(I)*YN*ZN                               
       OCTUN(1)  = OCTUN(1)  + ZAN(I)*XN*XN*XN                            
       OCTUN(2)  = OCTUN(2)  + ZAN(I)*YN*YN*YN                            
       OCTUN(3)  = OCTUN(3)  + ZAN(I)*ZN*ZN*ZN                            
       OCTUN(4)  = OCTUN(4)  + ZAN(I)*XN*XN*YN                            
       OCTUN(5)  = OCTUN(5)  + ZAN(I)*XN*XN*ZN                            
       OCTUN(6)  = OCTUN(6)  + ZAN(I)*XN*YN*YN                            
       OCTUN(7)  = OCTUN(7)  + ZAN(I)*YN*YN*ZN                            
       OCTUN(8)  = OCTUN(8)  + ZAN(I)*XN*ZN*ZN                            
       OCTUN(9)  = OCTUN(9)  + ZAN(I)*YN*ZN*ZN                            
       OCTUN(10) = OCTUN(10) + ZAN(I)*XN*YN*ZN                          
      END DO                                                            
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                 S C F - N O F   S U B R O U T I N E S                !
!                                                                      !
!======================================================================!

C RunNOF
      SUBROUTINE RunNOF(NATOMSn,NBFn,NBFTn,NSHELLn,NPRIMIn,ZAN,Cxyz,IAN,
     &                 IMIN,IMAX,KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,  
     &                 KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP,CD,CF,CG,CH,
     &                 CI,AHCORE,OVERLAP,CHF,EiHF,DIPN,QUADN,OCTUN,NVAL,
     &                 DQOInt,NINTMXn,NREC,IX2,BUFP2,NINTEGt,IDONTW,
     &                 GRADS,IRUNTYP,DIPS,XINTS,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NATOMSn):: ZAN
      DOUBLE PRECISION,DIMENSION(3,NATOMSn):: Cxyz
      INTEGER,DIMENSION(NATOMSn):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELLn):: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELLn):: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMIn):: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMIn):: C1,C2,EX1
      DOUBLE PRECISION,DIMENSION(NPRIMIn):: CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBFn):: EiHF
      DOUBLE PRECISION,DIMENSION(NBFn,NBFn):: AHCORE,OVERLAP,CHF
      DOUBLE PRECISION,DIMENSION(3):: DIPN
      DOUBLE PRECISION,DIMENSION(6):: QUADN
      DOUBLE PRECISION,DIMENSION(10):: OCTUN
      DOUBLE PRECISION,DIMENSION(NVAL*NBFTn):: DQOInt
      INTEGER,DIMENSION(NINTEGt) :: IX2
      INTEGER:: IPRINTOPT
      DOUBLE PRECISION,DIMENSION(NINTEGt) :: BUFP2
      DOUBLE PRECISION,DIMENSION(3*NATOMSn) :: GRADS
      DOUBLE PRECISION,DIMENSION((NSHELL*NSHELL+NSHELL)/2) :: XINTS
      DOUBLE PRECISION,DIMENSION(3):: DIPS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: COEF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: XIJKL,USER
      CHARACTER*4,ALLOCATABLE,DIMENSION(:)::ATMNAME
      INTEGER,ALLOCATABLE,DIMENSION(:)::IZCORE,LIMLOW,LIMSUP,IJKL
C
      LOGICAL CONVG
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: GAMMA,FMIUG0
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::   ELAGN,RON
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: ELAG,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AQUADxx,AQUADyy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AQUADzz,AQUADxy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AQUADxz,AQUADyz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTxxx,AOCTyyy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTzzz,AOCTxxz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTxyy,AOCTyyz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTxzz,AOCTxxy
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AOCTyzz,AOCTxyz
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: XATOM,YATOM,ZATOM
C-----------------------------------------------------------------------
      ALLOCATE(XATOM(NATOMS),YATOM(NATOMS),ZATOM(NATOMS))
      XATOM(1:NATOMS) = Cxyz(1,1:NATOMS)
      YATOM(1:NATOMS) = Cxyz(2,1:NATOMS)
      ZATOM(1:NATOMS) = Cxyz(3,1:NATOMS)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(COEF(NBF,NBF),STAT=IER)
      COEF = CHF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calculate Nuclear Energy (EN)
C     ZAN: Nuclear charge array (1,NATOMS)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL NUCLEARm(NATOMS,ZAN,Cxyz,EN)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Determine the number of electrons removed from each atom (IZCORE)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(IZCORE(NATOMS),STAT=IER)
C     IAN: True Nuclear Charges
      CALL COREPOTENTIAL(IECP,NATOMS,IAN,IZCORE)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Name of Atoms
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ATMNAME(NATOMS),STAT=IER)
      CALL ATOMNAMES(NATOMS,ZAN,IZCORE,ATMNAME,Cxyz,NPRINT,0)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Atomic Basis Set
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       IMIN: Index of minimal primitive for atom
C       IMAX: Index of maximal primitive for atom
C     KSTART: Tells the location of the first exponent and the first
C             contraction coefficient contained in a particular shell
C      KATOM: Tells which atom the shell is centered on
C      KTYPE: is 1,2,3,4,5,6,7 for S,P,D,F,G,H,I. For L shell is 2
C       KLOC: Gives the location of the shell in the total AO basis 
C      INTYP: Index for the type of the shell
C        KNG: Number of Gaussians in the shell
C       KMIN: Starting index of the shell
C       KMAX: Ending index of the shell
C        ISH: Shell for the primitive
C       ITYP: Index for the type of the primitive
C         EX: Gaussian exponents
C         C1: S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.
C         C2: Extra L CONTRACTION COEFFICIENTS.
C      CS-CI: S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IPRINTATOMBASIS=0
      IF(NPRINT==1.and.IPRINTATOMBASIS==1.and.IPRINTOPT==1)
     *CALL ATOMBASIS(NATOMS,ATMNAME,IMIN,IMAX,NPRIMI,ITYP,ISH,EX1,C1,C2)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Create the basis function symbol table
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(LIMLOW(NATOMS),LIMSUP(NATOMS),STAT=IER)
      CALL SYMBOLTABLE(KATOM,ATMNAME,INTYP,KLOC,LIMLOW,LIMSUP)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NINTMX:  Number of 2e-integrals (ERIs) per record (15000)
C     NINTCHK: Integral of NINTMX in each core
C     NPROCS:  Number of cores
C     NCHUNKS: Number of chunks
C     NINTCR:  Space needed to allocate 2e- integrals in Slaves
C     NSTORE:  Space needed to allocate 2e- integrals in Master
C              NIJKL if serial, NINTCR if parallel
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NINTMX = NINTMXn
      NIJKL  = NINTEGt
      CALL DISTRIBUTION(IPRINTOPT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Read two-electron Repulsion Integrals in AO basis (ERI)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(IJKL(NSTORE),XIJKL(NSTORE),STAT=IER)
      CALL READERIs(IJKL,XIJKL,IX2,BUFP2,NINTEGt,IDONTW,NREC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Allocate User array
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(USER(NUSER),STAT=IER)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Pass atomic dipole, quadrupole and octupole matrices to USER array
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IEMOM>=1)THEN
       ALLOCATE(ADIPx(NSQ),ADIPy(NSQ),ADIPz(NSQ),STAT=IER)
       CALL CPYTSQ(DQOInt(1       ),ADIPx,NBF)
       CALL CPYTSQ(DQOInt(1+  NBFT),ADIPy,NBF)
       CALL CPYTSQ(DQOInt(1+2*NBFT),ADIPz,NBF)
       CALL PASSDIPUSER(DIPN,ADIPx,ADIPy,ADIPz,USER)
       DEALLOCATE(ADIPx,ADIPy,ADIPz)
      END IF
C
      IF(IEMOM>=2)THEN
       ALLOCATE(AQUADxx(NSQ),AQUADyy(NSQ),AQUADzz(NSQ),
     &          AQUADxy(NSQ),AQUADxz(NSQ),AQUADyz(NSQ),STAT=IER)
       CALL CPYTSQ(DQOInt(1+3*NBFT),AQUADxx,NBF)
       CALL CPYTSQ(DQOInt(1+4*NBFT),AQUADyy,NBF)
       CALL CPYTSQ(DQOInt(1+5*NBFT),AQUADzz,NBF)
       CALL CPYTSQ(DQOInt(1+6*NBFT),AQUADxy,NBF)
       CALL CPYTSQ(DQOInt(1+7*NBFT),AQUADxz,NBF)
       CALL CPYTSQ(DQOInt(1+8*NBFT),AQUADyz,NBF)
       CALL PASSQUADUSER(QUADN,AQUADxx,AQUADyy,AQUADzz,
     &                  AQUADxy,AQUADxz,AQUADyz,USER)
       DEALLOCATE(AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,AQUADyz)
      END IF
C
      IF(IEMOM==3)THEN
       ALLOCATE(AOCTxxx(NSQ),AOCTyyy(NSQ),AOCTzzz(NSQ),AOCTxxy(NSQ),
     &          AOCTxxz(NSQ),AOCTxyy(NSQ),AOCTyyz(NSQ),AOCTxzz(NSQ),
     &          AOCTyzz(NSQ),AOCTxyz(NSQ),STAT=IER)
       CALL CPYTSQ(DQOInt(1+ 9*NBFT),AOCTxxx,NBF)
       CALL CPYTSQ(DQOInt(1+10*NBFT),AOCTyyy,NBF)
       CALL CPYTSQ(DQOInt(1+11*NBFT),AOCTzzz,NBF)
       CALL CPYTSQ(DQOInt(1+12*NBFT),AOCTxxy,NBF)
       CALL CPYTSQ(DQOInt(1+13*NBFT),AOCTxxz,NBF)
       CALL CPYTSQ(DQOInt(1+14*NBFT),AOCTxyy,NBF)
       CALL CPYTSQ(DQOInt(1+15*NBFT),AOCTyyz,NBF)
       CALL CPYTSQ(DQOInt(1+16*NBFT),AOCTxzz,NBF)
       CALL CPYTSQ(DQOInt(1+17*NBFT),AOCTyzz,NBF)
       CALL CPYTSQ(DQOInt(1+18*NBFT),AOCTxyz,NBF)
       CALL PASSOCTUSER(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,
     &                  AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,USER)
       DEALLOCATE(AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxz,AOCTxyy)
       DEALLOCATE(AOCTyyz,AOCTxzz,AOCTxxy,AOCTyzz,AOCTxyz)
      END IF
C***********************************************************************
C     FIRSTCALL: Initialize variables    COEF,      GAMMA,     FMIUG0
C                         according to INPUTC, INPUTGAMMA, INPUTFMUIG
C***********************************************************************
      ALLOCATE(GAMMA(NBF5),FMIUG0(NBF),STAT=IER)
      CALL INITr(COEF,OVERLAP,GAMMA,FMIUG0,IPRINTOPT)
C======================================================================C      
C     Restricted Hartree-Fock (RHF)
C     Use the Iterative Diagonalization Method to generate the HF MOs
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(HFID)THEN
       if(INPUTC==1)CHF = COEF
       CALL HFIDr(AHCORE,IJKL,XIJKL,CHF,EiHF,USER,IPRINTOPT)
       if(INPUTC==0)COEF = CHF
       if(INPUTFMIUG==0)FMIUG0 = EiHF
      ELSE
       if(INPUTC==0.and.IPRINTOPT==1)
     &  WRITE(6,'(/A32)')' Input for Coefficients is HCORE'
      ENDIF
C======================================================================C      
C     INITIALIZE LOCAL VARIABLES
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IT=0
      ILOOP=0
      ITTOTAL=0
      IFIRSTCALL=0
      CONVG=.FALSE.
C======================================================================C
C               OPTIMIZATION WITH RESPECT TO THE OCCUPATIONS           C
C======================================================================C
      ALLOCATE(ELAG(NBF,NBF),ELAGN(NBF),COEFN(NBF,NBF),RON(NBF),
     &         STAT=IER)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Note: CONVGDELAG is the fundamental criterion in the optimization, 
C           so it must be FALSE before minimizing respect to GAMMAs and 
C           being able to call the CG subroutine. Its value is 
C           determined in the orbital optimization subroutine.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CONVGDELAG=.FALSE.
      IF(IRUNTYP/=3) EELEC_MIN = 1.0d20 ! GLOBAL FIRST CALL
      CALL OCCOPTr(IFIRSTCALL,CONVG,ATMNAME,ZAN,OVERLAP,LIMLOW,
     &             LIMSUP,COEF,GAMMA,FMIUG0,AHCORE,IJKL,XIJKL,
     &             ELAG,USER,IZCORE,XATOM,YATOM,ZATOM,
     &             KSTART,KNG,KMIN,KMAX,KATOM,KTYPE,
     &             KLOC,EX1,CS,CP,CD,CF,CG,CH,CI,ELAGN,COEFN,RON,
     &             IT,ITTOTAL,DIPS,IPRINTOPT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     END SINGLE-POINT CALCULATION (ICOEF=0)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==0)THEN
C      Orbital-Invariant MP2 Perturbative Corrections
       IF(OIMP2) THEN
        CALL ORBINVMP2(ELAG,COEF,USER(N1),USER(N2),USER(N3),
     &          AHCORE,IJKL,XIJKL,USER(N12),USER(N13),USER(N14))
       ENDIF
C      MBPT Perturbative Corrections
       IF(MBPT) THEN
        CALL MBPTCALC(ELAG,COEF,USER(N1),USER(N2),USER(N3),
     &           AHCORE,USER(N12),USER(N13),USER(N14),IJKL,XIJKL)
       ENDIF
C      SC2-MCPT (Hartree-Fock Partition)
       IF(SC2MCPT.and.NSOC==0)CALL SC2MCPThf(USER(N1),COEF,
     &                        AHCORE,IJKL,XIJKL,USER(N10))
C      Analytical Gradient Calculation for PNOF
       IF(IRUNTYP==2.or.IRUNTYP==3)THEN
        IF(.not.HighSpin)THEN
         CALL PNOFGRAD(COEF,USER(N7),USER(N1),ELAG,GRADS,ATMNAME,KATOM,
     &                 KTYPE,KLOC,KMIN,KMAX,KSTART,KNG,XATOM,
     &                 YATOM,ZATOM,ZAN,EX1,CS,CP,CD,CF,CG,
     &                 USER(N2),USER(N3),XINTS,IPRINTOPT) 
        ELSE
         WRITE(6,*)'Sorry: GRADIENT is not implemented for High Spin'
         STOP
        END IF
       END IF
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       IF(IPRINTOPT==1)WRITE(6,2)IT
       GOTO 10
      ENDIF
C======================================================================C
C     SINGLE-POINT CALCULATION: FULL OPTIMIZATION FOR A GIVEN GEOMETRY C
C     Optimization with respect to the Occupations and Orbitals (COEF) C
C     using the iterative diagonalization method                       C
C======================================================================C
      IFIRSTCALL=1
      ITLIM=1
      DO WHILE(IT<=MAXIT)
       IT=IT+1
C      Orbital Optimization
       IF(ICOEF==1.or.ICOEF==2)THEN
        CALL ORBOPTr(IT,ITLIM,AHCORE,IJKL,XIJKL,USER(N7),COEF,
     &               USER(N1),USER(N2),USER(N3),ELAG,FMIUG0,USER(N11),
     &               USER(N12),USER(N13),USER(N14),ILOOP,IPRINTOPT)
C      Core-Fragment Orbital Optimization
       ELSEIF(ICOEF==3)THEN
        IF(MSpin>0)STOP          ! To be implemented        
        CALL ORBOPTFrc(IT,ITLIM,AHCORE,IJKL,XIJKL,USER(N7),COEF,
     &                 USER(N1),USER(N2),USER(N3),ELAG,FMIUG0,
     &                 USER(N11),USER(N12),USER(N13),USER(N14),ILOOP)
       ENDIF
C      Occupation Optimization
       ITTOTAL=ITTOTAL+ILOOP
       CALL OCCOPTr(IFIRSTCALL,CONVG,ATMNAME,ZAN,OVERLAP,LIMLOW,LIMSUP,
     &              COEF,GAMMA,FMIUG0,AHCORE,IJKL,XIJKL,ELAG,
     &              USER,IZCORE,XATOM,YATOM,ZATOM,
     &              KSTART,KNG,KMIN,KMAX,KATOM,KTYPE,
     &              KLOC,EX1,CS,CP,CD,CF,CG,CH,CI,ELAGN,COEFN,RON,
     &              IT,ITTOTAL,DIPS,IPRINTOPT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      END SINGLE-POINT CALCULATION (CONVG=TRUE)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(CONVG)THEN
C       Orbital-Invariant MP2 Perturbative Corrections
        IF(OIMP2) THEN
         CALL ORBINVMP2(ELAG,COEF,USER(N1),USER(N2),USER(N3),
     &           AHCORE,IJKL,XIJKL,USER(N12),USER(N13),USER(N14))
        END IF
C       MBPT Perturbative Corrections
        IF(MBPT) THEN
        CALL MBPTCALC(ELAG,COEF,USER(N1),USER(N2),USER(N3),
     &           AHCORE,USER(N12),USER(N13),USER(N14),IJKL,XIJKL)
        END IF
C       SC2-MCPT (Hartree-Fock Partition)
        IF(SC2MCPT.and.NSOC==0)CALL SC2MCPThf(USER(N1),COEF,
     &                          AHCORE,IJKL,XIJKL,USER(N10))
C       Analytical Gradient Calculation for PNOF
        IF((IRUNTYP==2.or.IRUNTYP==3).and.(.not.HighSpin))THEN
         CALL PNOFGRAD(COEF,USER(N7),USER(N1),ELAG,GRADS,ATMNAME,KATOM,
     &                 KTYPE,KLOC,KMIN,KMAX,KSTART,KNG,XATOM,
     &                 YATOM,ZATOM,ZAN,EX1,CS,CP,CD,CF,CG,
     &                 USER(N2),USER(N3),XINTS,IPRINTOPT)
        END IF
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        IF(IPRINTOPT==0)GOTO 10
        WRITE(6,4)
        WRITE(6,5)IT,ITTOTAL
        GOTO 10
       ENDIF
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     EXCESSIVE NUMBER OF ITERATIONS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IT>MAXIT)THEN
       WRITE(6,3)
       WRITE(6,5)IT,ITTOTAL
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     STOP PROGRAM, DEALLOCATE MEMORY, GIVES ELAPSED TIME if IT > MAXIT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   10 CONTINUE 
      DEALLOCATE(COEF,IZCORE,ATMNAME,LIMLOW,LIMSUP,XATOM,YATOM,ZATOM)
      DEALLOCATE(GAMMA,FMIUG0,ELAG,ELAGN,RON,USER,COEFN)
      DEALLOCATE(IJKL,XIJKL)
C-----------------------------------------------------------------------
C    1 FORMAT(/,'  ELAPSED REAL TIME :',F10.2,'  (SECONDS)')
    2 FORMAT(//2X,'**************************************************',
     *        /2X,'*                                                *',
     *        /2x,'*       SINGLE-POINT DoNOF CALCULATION           *',
     *        /2X,'*                                                *',
     *        /2X,'*            No.ITER =',I6,'                     *',
     *        /2X,'*         (Occupation Optimization)              *',
     *        /2X,'*                                                *',
     *        /2x,'*  FINAL RESULTS   FINAL RESULTS  FINAL RESULTS  *',
     *        /2X,'*                                                *',
     *        /2X,'**************************************************')
    3 FORMAT(/,10X,30(1H-),/,10X,'EXCESSIVE NUMBER OF ITERATIONS',
     *       /,10X,30(1H-))
    4 FORMAT(//2X,'**************************************************',
     *        /2X,'*                                                *',
     *        /2x,'*       SINGLE-POINT DoNOF CALCULATION           *',
     *        /2X,'*                                                *',
     *        /2X,'*             FULL OPTIMIZATION                  *',
     *        /2X,'*                                                *',
     *        /2x,'*  FINAL RESULTS   FINAL RESULTS  FINAL RESULTS  *',
     *        /2X,'*                                                *',
     *        /2X,'**************************************************')
    5 FORMAT(/2X,'**************************************************',
     *       /2X,'*         No. EXTERNAL ITER =',I6,'              *',
     *       /2X,'*         No. of TOTAL ITER =',I6,'              *',
     *       /2X,'**************************************************')
C-----------------------------------------------------------------------
      RETURN
      END

! ==================================================================== !
!                                                                      !
!   HFIDr Iterative Diagonalization method for the RHF using           !
!         the Iterative Diagonalization method (HFID=T) proposed       !
!         in the J. Comp. Chem. 131, 021102, 2009.                     !
!                                                                      !
! ==================================================================== !
      
C HFIDr
      SUBROUTINE HFIDr(AHCORE,IJKL,XIJKL,CHF,EIHF,USER,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,CHF
      DOUBLE PRECISION,DIMENSION(NBF)::EIHF
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::RO10,EVA,TEMP,FMIUG0
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::CJ12HF,CK12HF,ELAG
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::G,FMIUG,W,CHFNEW
      INTEGER:: IPRINTOPT
C-----------------------------------------------------------------------
C     Initial Values
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INPUTFMIUG_ORI = INPUTFMIUG
      INPUTFMIUG = 0
      NO1_ORI = NO1
      NO1 = NB
      ILOOP = 0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(RO10(NBF5),CJ12HF(NBF5,NBF5),CK12HF(NBF5,NBF5))
c      
      RO10 = 0.0d0
      DO i=1,NB
       RO10(i) = 1.0d0      
      ENDDO
      IF(NSOC>0)THEN
       DO i=NB+1,NA
        RO10(i) = 0.5d0
       ENDDO
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12HF(j,i) = 2.0d0*RO10(j)*RO10(i)
        CK12HF(j,i) = RO10(j)*RO10(i)
       ENDDO
      ENDDO
      if(MSpin==0.and.NSOC>1)then                     
       DO j=NB+1,NA
        DO i=NB+1,NA
         CK12HF(j,i) = 2.0d0*RO10(j)*RO10(i)
        ENDDO      
       ENDDO
      end if
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPRINTOPT==1)WRITE(6,1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calculate Initial HF Electronic Energy
C     ( QD=USER(N7), DIPN=USER(N11), ADIP=USER[N12-N14] )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ELAG(NBF,NBF),G(NBF,NBF5))
      CALL ENERGY1r(AHCORE,IJKL,XIJKL,USER(N7),CHF,RO10,CJ12HF,CK12HF,
     &              ELAG,USER(N11),USER(N12),USER(N13),USER(N14),G)
      EHF = EELEC
      CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Itermediate Output of the external iteration
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NPRINT==1.and.IPRINTOPT==1)THEN
       WRITE(6,10)ILOOP,EHF,EHF+EN,0.0,DUMEL
      ENDIF
C-----------------------------------------------------------------------
C                       START SCF-ITERATION CYCLE
C-----------------------------------------------------------------------
      ALLOCATE (FMIUG(NBF,NBF),W(NBF,NBF),EVA(NBF),TEMP(NBF))
      ALLOCATE (CHFNEW(NBF,NBF),FMIUG0(NBF))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO LOOPEXT=1,MAXITID
       IF(LOOPEXT==1)THEN
        MAXLP = 1
       ELSE
        MAXLP = MAXLOOP
       ENDIF
C-----------------------------------------------------------------------
       DO LOOP=1,MAXLP
        ILOOP=ILOOP+1
        EHF_OLD = EHF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Generalized Fock Matrix (FMIUG)
C
C       Convergent technique:
C
C       SCALING:   Decrease FMIUG using a scaling factor.
C                  The scaling factor varies until the number of
C                  ZEROS (.000##) is equal for all elements Fij
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(SCALING)CALL FFMIUG_SCALING(FMIUG,ELAG,FMIUG0,LOOPEXT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       DIAGONALIZE SQUARE MATRIX (FMIUG) FOR REAL SYMMETRIC CASE
C       W - EIGENVECTORS, EVA-EIGENVALUES IN ALGEBRAIC DESCENDING ORDER
C       HOUSEHOLDER METHOD
C       NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL DIAG(NBF,FMIUG,W,EVA,TEMP)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Move EVA -> FMIUG0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        FMIUG0 = EVA
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       New Coefficients (CHFNEW=CHF*W), Move CHFNEW -> CHF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL COEFW(NBF,NBF,CHFNEW,CHF,W)
        CHF = CHFNEW
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Lagrangian Multipliers (ELAG) and one-energies (E)
C       Calculate HF Electronic Energy (EHF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL ENERGY1r(AHCORE,IJKL,XIJKL,USER(N7),CHF,RO10,CJ12HF,CK12HF,
     &                ELAG,USER(N11),USER(N12),USER(N13),USER(N14),G)
        EHF = EELEC 
        DIF_EHF = EHF - EHF_OLD
        CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
C       Intermediate Output at each interation (Nprint=2)
        IF(NPRINT==2.and.IPRINTOPT==1)THEN
         WRITE(6,10)ILOOP,EHF,EHF+EN,DIF_EHF,DUMEL
        ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Check for energy convergent solution
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF( ABS(DIF_EHF) < THRESHEID )THEN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C        One-particle HF energies
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         DO i=1,NBF
          EIHF(i) = ELAG(i,i)
         ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C        Dipole Moment (QD = USER(N7), DIPN = USER(N11), 
C                       ADIP = USER[N12-N14], DIP = USER[N15-N17] ) 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         CALL DIPMOMr(USER(N11),USER(N12),USER(N13),USER(N14),USER(N15),
     &                USER(N16),USER(N17),USER(N7),RO10,DMXe,DMYe,DMZe,
     &                DTx,DTy,DTz,DT)     
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C        Quadrupole Moment ( QUADN = USER(N18), AQUAD = USER[N19-N24]
C                            QUAD = USER[N25-N30], QD = USER(N7) )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         IF(IEMOM>=2)THEN
          CALL QUADMOMr(USER(N18),USER(N19),USER(N20),USER(N21),
     &                  USER(N22),USER(N23),USER(N24),USER(N25),
     &                  USER(N26),USER(N27),USER(N28),USER(N29),
     &                  USER(N30),USER(N7),RO10,
     &                  QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,
     &                  QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)
         ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C        Octupole Moment  ( OCTUN = USER(N31), AOCT = USER[N32-N41] )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         IF(IEMOM==3)THEN
          CALL OCTMOMr(USER(N31),USER(N32),USER(N33),USER(N34),
     &                 USER(N35),USER(N36),USER(N37),USER(N38),
     &                 USER(N39),USER(N40),USER(N41),USER(N42),
     &                 USER(N43),USER(N44),USER(N45),USER(N46),
     &                 USER(N47),USER(N48),USER(N49),USER(N50),
     &                 USER(N51),USER(N7),RO10,
     &                 OMXXXe,OMYYYe,OMZZZe,OMXXYe,OMXXZe,
     &                 OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,
     &                 OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,
     &                 OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)
         ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C        Output
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         INPUTFMIUG = INPUTFMIUG_ORI
         NO1 = NO1_ORI
         IF(IPRINTOPT==0)RETURN
         WRITE(6,10)LOOPEXT,EHF,EHF+EN,DIF_EHF,DUMEL
         CALL PRINTEiHF(EiHF,NA,NBF)
         IF(KOOPMANS==1.and.MSpin==0)THEN
          CALL DIAGELAGHF(ELAG,CHF,RO10,EiHF,CHFNEW,TEMP)
         ENDIF
         WRITE(6,2)EHF
         WRITE(6,3)EHF+EN
         IF(EFIELDL)WRITE(6,4)EX,EY,EZ
         WRITE(6,5)DT*DFAC,DT,DTx,DTy,DTz
         IF(IEMOM>=2)WRITE(6,6)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,
     &             QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,
     &             QTxx,QTyy,QTzz,QTxy,QTxz,QTyz
         IF(IEMOM==3)WRITE(6,7)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,
     &                         OTXXY*OFAC,OTXXZ*OFAC,OTXYY*OFAC,
     &                         OTYYZ*OFAC,OTXZZ*OFAC,OTYZZ*OFAC,
     &                         OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,OTXXY,
     &                         OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
         RETURN
        ENDIF
C-----------------------------------------------------------------------
C                       LOOP-END OF SCF-ITERATION
C-----------------------------------------------------------------------
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Final Output
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NPRINT<2.and.IPRINTOPT==1)THEN
        WRITE(6,10)LOOPEXT,EHF,EHF+EN,DIF_EHF,DUMEL
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDDO
C-----------------------------------------------------------------------
C     FORMAT STATEMENTS
C-----------------------------------------------------------------------
    1 FORMAT(//,
     *  1X,' HARTREE-FOCK ',/,
     *  1X,'==============',//,
     * 2X,'ITER',5X,'ELECTRONIC ENERGY',6X,'TOTAL ENERGY',
     * 3X,'ENERGY CONVERGENCY',4X,'MAX MUL-LAG DIFF',/)
    2 FORMAT(/,4X,'ELECTRONIC HF ENERGY =',F20.10)
    3 FORMAT(/,8X,' HF TOTAL ENERGY =',F20.10)
    4 FORMAT(/,6X,'ELECTRIC FIELD (',D8.1,',',D8.1,',',D8.1,')')
    5 FORMAT(/,2X,'------------------',
     *        /2X,' HF Dipole Moment',
     *        /2X,'------------------',
     *      //,3X,F9.4,' Debye',' [',F9.4,
     *         2X,'(',F9.4,',',F9.4,',',F9.4,')',' ]')
    6 FORMAT(/,2X,'----------------------',
     *        /2X,' HF Quadrupole Moment',
     *        /2X,'----------------------',
     *       //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',
     *       //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')
    7 FORMAT(/,2X,'--------------------',
     *        /2X,' HF Octupole Moment',
     *        /2X,'--------------------',
     *       //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',
     *         5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',
     *       //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',
     *       //1X,'[',10F9.4,1X,']')
   10 FORMAT(2X,I3,'.',3X,F17.6,4X,F15.6,6X,F13.8,8X,F11.6)
C-----------------------------------------------------------------------
      DEALLOCATE(RO10,CJ12HF,CK12HF)
      DEALLOCATE(FMIUG,W,EVA,TEMP,CHFNEW,ELAG,G,FMIUG0)
      INPUTFMIUG = INPUTFMIUG_ORI
      NO1 = NO1_ORI
      RETURN
      END
      
C PRINTEiHF
      SUBROUTINE PRINTEiHF(EIHF,NA,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF)::EIHF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::E1
C-----------------------------------------------------------------------
C     ORDERING ENERGIES
C-----------------------------------------------------------------------
      ALLOCATE(E1(NBF))
      DO I=1,NBF
       E1(I)=EIHF(I)
      ENDDO
      DO IM=1,NBF
       DUM1= E1(IM)
       MIN = IM
       DO I=IM,NBF
        IF(E1(I)<DUM1)THEN
         DUM1= E1(I)
         MIN = I
        ENDIF
       ENDDO
       IF(MIN/=IM)THEN
        DUM1   = E1(IM)
        E1(IM) = E1(MIN)
        E1(MIN)= DUM1
       ENDIF
      ENDDO
C-----------------------------------------------------------------------
C     WRITE ENERGIES ON THE OUTPUT FILE
C-----------------------------------------------------------------------
      WRITE(6,100)
      DO I=1,NA
       WRITE(6,101)I,E1(I),E1(I)*27.21138386
      ENDDO
C-----------------------------------------------------------------------
  100 FORMAT(/2X,'-------------',
     *       /2X,' HF Energies ',
     *       /2X,'-------------',//19X,'(aU)',14X,'(eV)',20X)
  101 FORMAT(2X,I4,4X,F15.6,4X,F15.6)
C-----------------------------------------------------------------------
      DEALLOCATE(E1)
      RETURN
      END

C DIAGELAGHF
      SUBROUTINE DIAGELAGHF(ELAG,COEF,RO,ELAGN,COEFN,RON)
C=======================================================================
C     DIAGONALIZATION OF LAGRANGE MULTIPLIERS (ELAG)
C=======================================================================
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF)::ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::TEMP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,DENMAT
C-----------------------------------------------------------------------
C     INTERMEDIATE MATRICES
C-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF,NBF),W(NBF,NBF),TEMP(NBF))
C-----------------------------------------------------------------------
C     DIAGONALIZATION OF THE LAGRANGE MULTIPLIERS (ELAG)
C-----------------------------------------------------------------------
C     ELAG -> SQUARE MATRIX (AUX)
C-----------------------------------------------------------------------
      DO I=1,NBF
       DO J=1,I
        AUX(I,J)=ELAG(I,J)
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     DIAGONALIZE SQUARE MATRIX (AUX) FOR REAL SYMMETRIC CASE
C     NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
C     W - EIGENVECTORS, ELAGN - EIGENVALUES 
C-----------------------------------------------------------------------
      CALL DIAG(NBF,AUX,W,ELAGN,TEMP)
C-----------------------------------------------------------------------
C     New Density Matrix (D=Wt*RO*W)
C-----------------------------------------------------------------------
      ALLOCATE(DENMAT(NBF,NBF))
      DO IP=1,NBF
       DO IQ=1,NBF
        DENMAT(IP,IQ)=0.0d0
        do i=1,nbf5
         DENMAT(IP,IQ)=DENMAT(IP,IQ)+W(i,IP)*RO(i)*W(i,IQ)
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     WRITE ONE-PARTICLE ENERGIES and NEW AVERAGE OCCUPATIONS (OUTPUT)
C-----------------------------------------------------------------------
      WRITE(6,1)
      DO I=1,NBF
       RON(I)=2.0d0*DENMAT(I,I)
       IF(RON(I)>1.0d-1)THEN
        WRITE(6,2)I,-ELAGN(I),-ELAGN(I)*27.21138386,RON(I)
       ENDIF
      ENDDO
      CALL DMATMAX(DENMAT,NBF,MAXI,MAXJ,DUM)
      WRITE(6,3)DUM,MAXI,MAXJ
C-----------------------------------------------------------------------
C     Coefficients of Canonical Orbitals (COEFN=COEF*W)
C-----------------------------------------------------------------------
      COEFN = MATMUL(COEF,W)
      ICANHF=0
      IF(ICANHF==1)THEN
       WRITE(6,4)
       CALL PRINTVERO(6,COEFN,ELAGN,RON,NBF,NBF5)
      ENDIF
C-----------------------------------------------------------------------
    1 FORMAT(/2X,42('-'),/3X,'Canonical Representation: Koopmans Theo.',
     &       /2X,42('-'),//20X,'Ionization Potentials',11X,'1RDM Diag',
     &       //19X,'(aU)',14X,'(eV)')
    2 FORMAT(2X,I4,4X,F15.6,4X,F15.6,9X,F8.6)
    3 FORMAT(/,15X,'Maximum 1RDM off-diagonal element:',F12.6,
     &         1X,'(',I3,',',I3,')')    
    4 FORMAT(/,
     & 18X,'-----------------------',/,
     & 18X,' Canonical HF Orbitals ',/,
     & 18X,'-----------------------')
C-----------------------------------------------------------------------
      DEALLOCATE (AUX,W,TEMP,DENMAT)
      RETURN
      END
      
!======================================================================!
!                                                                      !
!                    Nuclear related Subroutines                       !
!                                                                      !
!    NUCLEARm: Calculate the nuclear energy                            !
!    COREPOTENTIAL: Determine the # electrons removed from each atom   !
!    ATOMNAMES: Write atom name-coordinates                            !
!                                                                      !
!======================================================================!

C NUCLEARm
      SUBROUTINE NUCLEARm(NATOMS,ZNUC,Cxyz,Enuc)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NATOMS) :: ZNUC
      DOUBLE PRECISION,DIMENSION(3,NATOMS) :: Cxyz
C-----------------------------------------------------------------------
      Enuc = 0.0
      DO I=1,NATOMS-1
       DO J=I+1,NATOMS
        DISTNUC = (Cxyz(1,I)-Cxyz(1,J))**2
     &          + (Cxyz(2,I)-Cxyz(2,J))**2 + (Cxyz(3,I)-Cxyz(3,J))**2
        Enuc = Enuc + ZNUC(I)*ZNUC(J)/SQRT(DISTNUC)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C COREPOTENTIAL
      SUBROUTINE COREPOTENTIAL(IECP,NATOMS,IAN,IZCORE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NATOMS)::IAN,IZCORE
C-----------------------------------------------------------------------
C     IZCORE: Number of electrons removed from each atom (ECP)
C-----------------------------------------------------------------------
      IF(IECP==0)THEN
C      ALL ELECTRON (NO CORE POTENTIAL) ATOM
       IZCORE=0
      ELSEIF(IECP==1)THEN
       DO I=1,NATOMS
        NUCZ=IAN(I)
        IF( 1<=NUCZ.and.NUCZ<= 2)IZCORE(I)= 0
        IF( 3<=NUCZ.and.NUCZ<=10)IZCORE(I)= 2
        IF(11<=NUCZ.and.NUCZ<=18)IZCORE(I)=10
        IF(19<=NUCZ.and.NUCZ<=20)IZCORE(I)=18
        IF(21<=NUCZ.and.NUCZ<=31)IZCORE(I)=10
        IF(32<=NUCZ.and.NUCZ<=36)IZCORE(I)=28
        IF(37<=NUCZ.and.NUCZ<=38)IZCORE(I)=36
        IF(39<=NUCZ.and.NUCZ<=49)IZCORE(I)=28
        IF(50<=NUCZ.and.NUCZ<=54)IZCORE(I)=46
        IF(55<=NUCZ.and.NUCZ<=71)IZCORE(I)=54
        IF(72<=NUCZ.and.NUCZ<=81)IZCORE(I)=60
        IF(82<=NUCZ.and.NUCZ<=86)IZCORE(I)=78
        IF(NUCZ>86)THEN
         WRITE(6,*)'NO BUILT IN EC POTENTIALS, PAST RN!'
         STOP
        ENDIF
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C ATOMNAMES
      SUBROUTINE ATOMNAMES(NATOMS,ZNUC,IZCORE,ATMNAME,Cxyz,NPRINT,
     &                     IWRITECXYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER:: IWRITECXYZ      
      CHARACTER*4 ATMNAME(NATOMS)
      DIMENSION ZNUC(NATOMS),IZCORE(NATOMS)
      DIMENSION Cxyz(3,NATOMS)
      CHARACTER*4 ATMLAB(106)
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',
     *            'N   ','O   ','F   ','NE  ','NA  ','MG  ',
     *            'AL  ','SI  ','P   ','S   ','CL  ','AR  ',
     *            'K   ','CA  ','SC  ','TI  ','V   ','CR  ',
     *            'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',
     *            'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',
     *            'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',
     *            'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',
     *            'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',
     *            'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',
     *            'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',
     *            'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',
     *            'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',
     *            'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',
     *            'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',
     *            'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',
     *            'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',
     *            'LR  ','RF  ','X   ','BQ  '/
C-----------------------------------------------------------------------
      DO I=1,NATOMS
       IZNUC = INT(ZNUC(I))+IZCORE(I)
       ATMNAME(I)=ATMLAB(IZNUC)
      ENDDO
      IF(NPRINT==1.and.IWRITECXYZ==1)THEN
       WRITE(6,1)
       DO I=1,NATOMS
        WRITE(6,2)ATMNAME(I),ZNUC(I)+IZCORE(I),
     &            Cxyz(1,I),Cxyz(2,I),Cxyz(3,I)
       ENDDO
      END IF
C-----------------------------------------------------------------------
    1 FORMAT(/1X,'ATOM',6X,'ATOMIC',22X,'COORDINATES (BOHR)'
     *       /11X,'CHARGE',9X,'X',19X,'Y',19X,'Z')
    2 FORMAT(1X,A4,6X,F5.1,F17.10,2F20.10)
C-----------------------------------------------------------------------
      RETURN
      END

C ATOMBASIS
      SUBROUTINE ATOMBASIS(NATOMS,ATMNAME,IMIN,IMAX,NPRIMI,ITYP,ISH,
     &                     EX1,C1,C2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4 ATMNAME(NATOMS)
      DIMENSION IMIN(NATOMS),IMAX(NATOMS),ITYP(NPRIMI),ISH(NPRIMI)
      DIMENSION EX1(NPRIMI),C1(NPRIMI),C2(NPRIMI)
      CHARACTER*2 LABEL(8)
      DATA LABEL/'S ','P ','D ','F ','G ','H ','I ','L'/
C-----------------------------------------------------------------------
      WRITE(6,1)
C-----------------------------------------------------------------------
C     Atomic Basis Set
C
C     NSHELL: THE TOTAL NUMBER OF SHELLS.  
C             P SHELL MEANS X,Y,Z,
C             D SHELL MEANS XX,YY,ZZ,XY,XY,YZ, AND SO ON FOR F,G,H,I.
C     NPRIMI: TOTAL NUMBER OF PRIMITIVE EXPONENTS
C       IMIN: INDEX OF MINIMAL PRIMITIVE for ATOM
C       IMAX: INDEX OF MAXIMAL PRIMITIVE for ATOM
C       ITYP: INDEX for the TYPE of the PRIMITIVE
C        ISH: SHELL for the PRIMITIVE
C        EX1: GAUSSIAN EXPONENTS, FOR EVERY SYMMETRY UNIQUE PRIMITIVE.
C         C1: S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.
C         C2: NORMALLY ONLY C1 ARRAYS WILL BE NON-ZERO,
C             THE EXCEPTION IS "L" SHELLS,
C             WHERE BOTH C1 AND C2 WILL HAVE DIFFERENT VALUES.
C-----------------------------------------------------------------------
      DO I=1,NATOMS
       WRITE(6,2)ATMNAME(I)
       DO J=IMIN(I),IMAX(I)
        IF(ITYP(J)<8)THEN
         WRITE(6,3)ISH(J),LABEL(ITYP(J)),J,EX1(J),C1(J)
        ELSE
         WRITE(6,3)ISH(J),LABEL(ITYP(J)),J,EX1(J),C1(J),C2(J)
        ENDIF
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
    1 FORMAT(//5X,'Atomic Basis Set'/5X,16(1H-),//,2X,
     * 'THE CONTRACTED BASIS FUNCTIONS ARE NORMALIZED TO UNITY',
     * //2X,'SHELL TYPE',2X,'PRIMITIVE',8X,'EXPONENT',6X,
     * 'CONTRACTION COEFFICIENT(S)')
    2 FORMAT(/1X,A4,/)
    3 FORMAT(1X,I6,3X,A2,I7,F22.7,2F18.12)
C-----------------------------------------------------------------------
      RETURN
      END

C SYMBOLTABLE
      SUBROUTINE SYMBOLTABLE(KATOM,ATMNAME,INTYP,KLOC,LIMLOW,LIMSUP)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4 LABELAT,ATMNAME(NATOMS),BFNAM1(35)
      CHARACTER*6 BFNAM2(49)
      DIMENSION KATOM(NSHELL),INTYP(NSHELL),KLOC(NSHELL)
      DIMENSION LIMLOW(NATOMS),LIMSUP(NATOMS),KMIN(8),KMAX(8)
      DIMENSION INTYPS(8,NATOMS)
      DATA KMIN /1,2, 5,11,21,34,57,1/
      DATA KMAX /1,4,10,20,35,56,84,4/
      DATA BFNAM1/'  S ','  X ','  Y ','  Z ',
     *            ' XX ',' YY ',' ZZ ',' XY ',' XZ ',' YZ ',
     *            ' XXX',' YYY',' ZZZ',' XXY',' XXZ',
     *            ' YYX',' YYZ',' ZZX',' ZZY',' XYZ',
     *            'XXXX','YYYY','ZZZZ','XXXY','XXXZ',
     *            'YYYX','YYYZ','ZZZX','ZZZY','XXYY',
     *            'XXZZ','YYZZ','XXYZ','YYXZ','ZZXY'/
      DATA BFNAM2/' XXXXX',' YYYYY',' ZZZZZ',' XXXXY',' XXXXZ',
     *            ' YYYYX',' YYYYZ',' ZZZZX',' ZZZZY',' XXXYY',
     *            ' XXXZZ',' YYYXX',' YYYZZ',' ZZZXX',' ZZZYY',
     *            ' XXXYZ',' YYYXZ',' ZZZXY',' XXYYZ',' XXZZY',
     *            ' YYZZX',
     *            '    X6','    Y6','    Z6','   X5Y','   X5Z',
     *            '   Y5X','   Y5Z','   Z5X','   Z5Y','  X4Y2',
     *            '  X4Z2','  Y4X2','  Y4Z2','  Z4X2','  Z4Y2',
     *            '  X4YZ','  Y4XZ','  Z4XY','  X3Y3','  X3Z3',
     *            '  Y3Z3',' X3Y2Z',' X3Z2Y',' Y3X2Z',' Y3Z2X',
     *            ' Z3X2Y',' Z3Y2X','X2Y2Z2'/
C-----------------------------------------------------------------------
C         ----- BASIS FUNCTION SYMBOL TABLE -----
C         S,  X,Y,Z,  XX,YY,ZZ,XY,XZ,YZ,
C         1   2 3 4    5  6  7  8  9 10
C         XXX,YYY,ZZZ,XXY,XXZ,YYX,YYZ,ZZX,ZZY,XYZ, ... G,H,I
C         11  12  13,  14  15  16  17  18  19  20, ... G,H,I
C
C      KATOM: TELLS WHICH ATOM THE SHELL IS CENTERED ON,
C             NORMALLY MORE THAN ONE SHELL EXISTS ON EVERY ATOM.
C
C      KLOC: Gives the location of the shell in the total AO basis 
C
C      INTYP: INDEX for the TYPE of the SHELL
C
C     KMIN AND KMAX ARE THE STARTING AND ENDING INDICES OF THE SHELL.  
C     THESE ARE DEFINED AS
C                    S    P    D    F   G   H   I   L
C             KMIN   1    2    5   11  21  34  57   1
C             KMAX   1    4   10   20  35  56  84   4
C-----------------------------------------------------------------------
      WRITE(4,'(I5)')NBF
      DO J = 1,NSHELL
       IAT = KATOM(J)
       LABELAT = ATMNAME(IAT)
       MINI = KMIN(INTYP(J))
       MAXI = KMAX(INTYP(J))
       DO I = MINI,MAXI
        IF(I<=35)THEN
         WRITE(4,'(A2,I2,A4)')LABELAT,MOD(IAT,100),BFNAM1(I)
        ELSE
         WRITE(4,'(A2,A6)')LABELAT,BFNAM2(I-35)
        END IF
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     INTYPS: 8xNATOMS matrix containing the dimension of each shell
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INTYPS = 0
      LAT = 1
      ISUMTYP = 0
      ITYP0 = INTYP(1)
      NTYP = 1
c
      DO J = 1,NSHELL
       IAT = KATOM(J)
       IF(IAT==LAT)THEN
        IF(INTYP(J)==ITYP0)THEN
         ISUMTYP = ISUMTYP + 1
        ELSE
         ISUMTYP = 1
         ITYP0 = INTYP(J)
        ENDIF
       ELSE
        LAT = IAT
        ISUMTYP = 1
        ITYP0 = INTYP(J)
       ENDIF       
       INTYPS(ITYP0,LAT) = ISUMTYP
      ENDDO
c
      DO J = 1,NATOMS
       WRITE(4,'(9I5)')J,(INTYPS(I,J),I=1,8)
      ENDDO
C-----------------------------------------------------------------------
C     NUMBER OF BASIS FUNCTIONS PER ATOM: LIMLOW(iat) ... LIMSUP(iat)
C-----------------------------------------------------------------------
      IF(NATOMS>100)THEN
       WRITE(6,*)'Stop, NATOMS>100, enlarge the dimensions of limlow'
       STOP
      ENDIF
      LAT=1
      J=1
C - - - - - - - - - - - - - -  
      LIMLOW(1)=1  
      DO I=1,NSHELL
       IAT=KATOM(I)
       IF(LAT/=IAT)THEN
        LAT=IAT
        LIMSUP(J)=KLOC(I)-1
        J=J+1
        LIMLOW(J)=KLOC(I)
       ENDIF
      ENDDO
C - - - - - - - - - - - - - -      
      LIMSUP(J)=NBF
      IF(J<NATOMS)THEN
       JP1=J+1
       DO J=JP1,NATOMS
        LIMLOW(J)=NBF
        LIMSUP(J)=1
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                   I N P U T   S U B R O U T I N E S                  !
!                                                                      !
!======================================================================!

C NAMELIST_INPRUN
      SUBROUTINE NAMELIST_INPRUN(ITYPRUN,ICHARG,MULT,NINTEG,IDONTW,
     &                           IEMOMENTS,EVECTOR,IECPO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA /NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,ZAN(100),C(3,100),
     *              IAN(100)
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/INFO  /IUNTRD            
      COMMON/INTFIL/NINTMX           
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      COMMON/ELPROP/IEMOM      
      CHARACTER(8):: UNITS
      COMMON/CONTROL/UNITS
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/RUNTYPE/IRUNTYP            
#include "mpip.h"
      LOGICAL DONTW
      DOUBLE PRECISION,DIMENSION(3) :: EVECTOR
      CHARACTER(6) :: RUNTYP,ENERGY,GRAD,OPTGEO
      DATA ENERGY,GRAD,OPTGEO /'ENERGY','GRAD  ','OPTGEO'/
      CHARACTER(8) :: ANGS,BOHR
      DATA ANGS, BOHR /'ANGS    ','BOHR    '/
C-----------------------------------------------------------------------
C                     --- NAMELIST VARIABLES ---
C-----------------------------------------------------------------------
C
C RUNTYP            specifies the run calculation
C       = ENERGY    1) single-point energy calculation (Default)
C       = GRAD      2) energy + gradients with respect to nuclear coord.
C       = OPTGEO    3) optimize the molecular geometry
C
C MULT              Multiplicity of the electronic state
C       = 1         singlet (Default)
C       = 2,3,...   doublet, triplet, and so on
C
C ICHARG            Molecular charge  
C       = 0         Neutral Molecule (Default)
C
C IECP              Effective Core Potentials (to be implemented)
C       = 0         (Default) All electron calculation 
C       = 1         Read ECP potentials in the $ECP group
C
C IEMOM             Electrostatic moments calculation
C       = 1         calculate dipole moments (Default)
C         2         also calculate quadrupole moments
C         3         also calculate octopole moments
C
C UNITS             Distance units (any angles must be in degrees)
C       = ANGS      Angstroms (Default)
C       = BOHR      Bohr atomic units
C
C EVEC              An array of the three x,y,z components of
C                   the applied electric field, in a.u.
C                   (1 a.u. = 1 Hartree/e*bohr = 5.1422082(15)d+11 V/m)
C       = 0.0D0     (Default)
C
C DONTW             Do not write 2e- integrals on the disk (Unit=1)
C       = T         (Default)
C
C-----------------------------------------------------------------------
      NAMELIST/INPRUN/RUNTYP,MULT,ICHARG,IECP,IEMOM,UNITS,EVEC,DONTW
C-----------------------------------------------------------------------
      TI = 0.0D0                                                           
      TX = 0.0D0                                                           
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Initial Values for the namelist variables
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RUNTYP = ENERGY
      MULT   = 1                                                        
      ICHARG = 0                                                        
      IECP   = 0
      IEMOM  = 1
      UNITS  = ANGS
      EVEC   = 0.0D0     ! EVEC(1,2,3)=0
      DONTW   = .TRUE.
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C                            Read Namelist
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
#ifdef MPI
      CONTINUE
#else
      REWIND(5)
#endif
      READ(5,INPRUN,ERR=1,END=1)
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C     Stop if IECP>0 to use Effective Core Potentials (ECP)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IECP>0)THEN
       WRITE(6,*)
       WRITE(6,*)'Stop: Effective Core Potentials are not implemented'
       STOP
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Determine IRUNTYP
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                   
      IF(RUNTYP==ENERGY)THEN
       IRUNTYP = 1
      ELSE IF(RUNTYP==GRAD)THEN
       IRUNTYP = 2
      ELSE IF(RUNTYP==OPTGEO)THEN
       IRUNTYP = 3
      END IF
      IF(DONTW)THEN
       IDONTW = 1
      ELSE 
       IDONTW = 0
      END IF
      ITYPRUN = IRUNTYP 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                   
C     Electric Field
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF((EVEC(1)==0.0D0).and.(EVEC(2)==0.0D0).and.(EVEC(3)==0.0D0))THEN
       EFLDL = .FALSE.
      ELSE
       EFLDL = .TRUE.
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Integral Options (TRFOPT common block)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ISCHWZ  = 0         ! Schwarz inequality off 
      NINTMX = 15000
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C     Errors in the Input Namelist
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(UNITS==ANGS)THEN
       IUNTRD = 1                
      ELSEIF(UNITS==BOHR)THEN
       IUNTRD = -1
      ELSE
       WRITE(6,2)'UNITS ',UNITS                      
       CALL ABRT                                                      
      ENDIF                                                            
      IF(IECP<0.or.IECP>3)THEN
       WRITE(6,3)IECP                        
       CALL ABRT                                                      
      END IF
      IF(IEMOM<1.or.IEMOM>3)THEN
       WRITE(6,4)IEMOM                       
       CALL ABRT                                                      
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ICH = ICHARG                                                      
      MUL = MULT
      IEMOMENTS = IEMOM
      EVECTOR = EVEC
      NINTEG = NINTMX
      IECPO = IECP                                                   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                        
      RETURN
C-----------------------------------------------------------------------
    1 WRITE(6,'(/2X,27A)')'Stop: Wrong Namelist Variable'
      STOP
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    2 FORMAT(/1X,'Stop: $CONTRL KEYWORD ',A6,                          
     *          ' was given an illegal value ',A8,'.'/)
    3 FORMAT(/1X,'Stop: IECP   must be between  0 and 3, not',I8)
    4 FORMAT(/1X,'Stop: IEMOM  must be between  1 and 3, not',I8)                                                                                                
C-----------------------------------------------------------------------
      END

C INIINTQUAD
      SUBROUTINE INIINTQUAD
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DOUBLE PRECISION,PARAMETER :: SQRT3 = 1.73205080756887729353D0
      DOUBLE PRECISION,PARAMETER :: SQRT5 = 2.23606797749978969641D0
      DOUBLE PRECISION,PARAMETER :: SQRT7 = 2.64575131106459059050D0
      DOUBLE PRECISION,PARAMETER :: SQRT9 = 3.00000000000000000000D0
      DOUBLE PRECISION,PARAMETER :: SQRT11 = 3.31662479035539984911D0
      DOUBLE PRECISION,PARAMETER :: PI = 3.141592653589793238D0      
      COMMON/HERMIT/H1(55),W1(55)
      COMMON/RYSPAR/XASYMP(13),RTSASY(13,13),WTSASY(13,13),
     *              NAUXS(13),MAPRYS(13),RTSAUX(55,8),WTSAUX(55,8)
      COMMON/SHLNRM/PNRM(84)     
      DOUBLE PRECISION,DIMENSION(55)::RTS,WTS,WRK
      DOUBLE PRECISION,DIMENSION(0:54)::ALPHA1,BETA1
C-----------------------------------------------------------------------
C     Set up the primitive factors for the 1e- integrals.
C     Initialize for the integral quadratures.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SQRT53 = SQRT5/SQRT3
      SQRT73 = SQRT7/SQRT3
      SQRT75 = SQRT7/SQRT5
      SQRT753 = SQRT75/SQRT3
      do i=1,84
       if(i==1.or.i==2.or.i==5.or.i==11.or.i==21.or.i==36.or.i==57)then
        PNRMi = 1.0D0
       elseif(i==8.or.i==20.or.i==33)then
        PNRMi = PNRMi*SQRT3
       elseif(i==14)then
        PNRMi = PNRMi*SQRT5
       elseif(i==24)then
        PNRMi = PNRMi*SQRT7
       elseif(i==30)then
        PNRMi = PNRMi*SQRT53
       elseif(i==39)then
        PNRMi = PNRMi*SQRT9
       elseif(i==45)then
        PNRMi = PNRMi*SQRT73
       elseif(i==51)then
        PNRMi = PNRMi*SQRT3
       elseif(i==54)then
        PNRMi = PNRMi*SQRT53
       elseif(i==60)then
        PNRMi = PNRMi*SQRT11
       elseif(i==66)then
        PNRMi = PNRMi*SQRT3
       elseif(i==72)then
        PNRMi = PNRMi*SQRT3
       elseif(i==75)then
        PNRMi = PNRMi*SQRT753
       elseif(i==78)then
        PNRMi = PNRMi*SQRT5
       elseif(i==84)then
        PNRMi = PNRMi*SQRT53
       endif
       PNRM(i) = PNRMi
      enddo
C-----------------------------------------------------------------------
C     Initialize the RYS quadrature procedure
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      QUART = 0.25D0
      EPS   = 1.0D-14
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Roots of the Hermite Polynomials of order 2n
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XASYMP( 1)=29.0D0
      XASYMP( 2)=37.0D0
      XASYMP( 3)=43.0D0
      XASYMP( 4)=49.0D0
      XASYMP( 5)=55.0D0
      XASYMP( 6)=60.0D0
      XASYMP( 7)=65.0D0
      XASYMP( 8)=71.0D0
      XASYMP( 9)=76.0D0
      XASYMP(10)=81.0D0
      XASYMP(11)=86.0D0
      XASYMP(12)=91.0D0
      XASYMP(13)=96.0D0
C
      DO I=1,13
       N=2*I
       DO J=0,N-1
        ALPHA1(J) = 0.0D0
       ENDDO
       BETA1(0)=SQRT(PI)
       DO J=1,N-1
        BETA1(J) = J/2.0D0
       END DO
C      QL Procedure
       CALL RYSGW(N,ALPHA1,BETA1,EPS,RTS,WTS,IERR,WRK)
       DO J=1,I
        RTSASY(J,I) = RTS(I+J)*RTS(I+J)
        WTSASY(J,I) = WTS(I+J)
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Auxiliary Grids
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NAUXS( 1)=20
      NAUXS( 2)=25
      NAUXS( 3)=30
      NAUXS( 4)=30
      NAUXS( 5)=35
      NAUXS( 6)=40
      NAUXS( 7)=40
      NAUXS( 8)=40
      NAUXS( 9)=45
      NAUXS(10)=50
      NAUXS(11)=50
      NAUXS(12)=55
      NAUXS(13)=55
C
      MAPRYS( 1)=1
      MAPRYS( 2)=2
      MAPRYS( 3)=3
      MAPRYS( 4)=3
      MAPRYS( 5)=4
      MAPRYS( 6)=5
      MAPRYS( 7)=5
      MAPRYS( 8)=5
      MAPRYS( 9)=6
      MAPRYS(10)=7
      MAPRYS(11)=7
      MAPRYS(12)=8
      MAPRYS(13)=8
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Auxiliary Quadrature = Shifted Legendre
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NAUXSV=0
      IGRID=0
      DO 1 M=1,13
       NAUX=NAUXS(M)
       IF(NAUX==NAUXSV)GOTO 1
       IGRID=IGRID+1
       NAUXSV=NAUX
       DO I=0,NAUX-1
        ALPHA1(I) = 0.5D0
       ENDDO
       BETA1(0)= 1.0D0
       DO I=1,NAUX-1
        BETA1(I) = QUART/(4.0D0-(1.0D0/(I*I)))
       END DO
C      QL Procedure
       CALL RYSGW(NAUX,ALPHA1,BETA1,EPS,RTS,WTS,IERR,WRK)
       DO I=1,NAUX
        RTSAUX(I,IGRID) = RTS(I)
        WTSAUX(I,IGRID) = WTS(I)
       ENDDO
    1 CONTINUE
C-----------------------------------------------------------------------
C     Initialize Roots and Weights for Gauss-Hermite quadrature
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL SETHERMITE(H1,W1)
C-----------------------------------------------------------------------
      RETURN
      END
      
C SETHERMITE
      SUBROUTINE SETHERMITE(HTOTAL,WTOTAL)                                             
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION,DIMENSION(55),INTENT(OUT)::HTOTAL,WTOTAL
!                                                                       
      HTOTAL(1)=  0.0D0
!                                                                       
      HTOTAL(2)= -0.70710678118654752440D0                                  
      HTOTAL(3)=  0.70710678118654752440D0                                  
!                                                                       
      HTOTAL(4)= -1.22474487139158904910D0                                  
      HTOTAL(5)=  0.0D0                                                        
      HTOTAL(6)=  1.22474487139158904910D0                                  
!                                                                       
      HTOTAL(7)= -1.65068012388578455588D0                                  
      HTOTAL(8)= -0.52464762327529031788D0                                  
      HTOTAL(9)=  0.52464762327529031788D0                                  
      HTOTAL(10)=  1.65068012388578455588D0                                  
!                                                                       
      HTOTAL(11)= -2.02018287045608563293D0                                  
      HTOTAL(12)= -0.95857246461381850711D0                                  
      HTOTAL(13)=  0.0D0                                                        
      HTOTAL(14)=  0.95857246461381850711D0                                  
      HTOTAL(15)=  2.02018287045608563293D0                                  
!                                                                       
      HTOTAL(16)= -2.35060497367449222283D0                                  
      HTOTAL(17)= -1.33584907401369694971D0                                  
      HTOTAL(18)= -0.43607741192761650868D0                                  
      HTOTAL(19)=  0.43607741192761650868D0                                  
      HTOTAL(20)=  1.33584907401369694971D0                                  
      HTOTAL(21)=  2.35060497367449222283D0                                  
!                                                                       
      HTOTAL(22)= -2.65196135683523349245D0                                  
      HTOTAL(23)= -1.67355162876747144503D0                                  
      HTOTAL(24)= -0.81628788285896466304D0                                  
      HTOTAL(25)= 0.0D0                                                         
      HTOTAL(26)=  0.81628788285896466304D0                                  
      HTOTAL(27)=  1.67355162876747144503D0                                  
      HTOTAL(28)=  2.65196135683523349245D0                                  
!                                                                       
      HTOTAL(29)= -2.93063742025724401922D0                                  
      HTOTAL(30)= -1.98165675669584292585D0                                  
      HTOTAL(31)= -1.15719371244678019472D0                                  
      HTOTAL(32)= -0.38118699020732211685D0                                  
      HTOTAL(33)=  0.38118699020732211685D0                                  
      HTOTAL(34)=  1.15719371244678019472D0                                  
      HTOTAL(35)=  1.98165675669584292585D0                                  
      HTOTAL(36)=  2.93063742025724401922D0                                  
!
      HTOTAL(37)= -3.19099320178152760723D0                                  
      HTOTAL(38)= -2.26658058453184311180D0                                  
      HTOTAL(39)= -1.46855328921666793167D0                                  
      HTOTAL(40)= -0.72355101875283757332D0                                  
      HTOTAL(41)= 0.0D0                                                         
      HTOTAL(42)=  0.72355101875283757332D0                                  
      HTOTAL(43)=  1.46855328921666793167D0                                  
      HTOTAL(44)=  2.26658058453184311180D0                                  
      HTOTAL(45)=  3.19099320178152760723D0                                  
!                                                                       
      HTOTAL(46)=  -3.43615911883773760333D0                                
      HTOTAL(47)=  -2.53273167423278979641D0                                
      HTOTAL(48)=  -1.75668364929988177345D0                                
      HTOTAL(49)=  -1.03661082978951365418D0                                
      HTOTAL(50)=  -0.34290132722370460879D0                                
      HTOTAL(51)=   0.34290132722370460879D0                                
      HTOTAL(52)=   1.03661082978951365418D0                                
      HTOTAL(53)=   1.75668364929988177345D0                                
      HTOTAL(54)=   2.53273167423278979641D0                                
      HTOTAL(55)=  3.43615911883773760333D0                                
!                                                                       
      WTOTAL(1)= 1.77245385090551602730D0  ! SQRT(PI)                       
!                                                                       
      WTOTAL(2)= 8.86226925452758013649D-01                                   
      WTOTAL(3)= 8.86226925452758013649D-01                                   
!                                                                       
      WTOTAL(4)= 2.95408975150919337883D-01                                   
      WTOTAL(5)= 1.18163590060367735153D0                                   
      WTOTAL(6)= 2.95408975150919337883D-01                                   
!                                                                       
      WTOTAL(7)= 8.13128354472451771430D-02                                   
      WTOTAL(8)= 8.04914090005512836506D-01                                   
      WTOTAL(9)= 8.04914090005512836506D-01                                   
      WTOTAL(10)= 8.13128354472451771430D-02                                   
!                                                                       
      WTOTAL(11)= 1.99532420590459132077D-02                                   
      WTOTAL(12)= 3.93619323152241159828D-01                                   
      WTOTAL(13)= 9.45308720482941881226D-01                                   
      WTOTAL(14)= 3.93619323152241159828D-01                                   
      WTOTAL(15)= 1.99532420590459132077D-02                                   
!                                                                       
      WTOTAL(16)= 4.53000990550884564086D-03                                   
      WTOTAL(17)= 1.57067320322856643916D-01                                   
      WTOTAL(18)= 7.24629595224392524092D-01                                   
      WTOTAL(19)= 7.24629595224392524092D-01                                   
      WTOTAL(20)= 1.57067320322856643916D-01                                   
      WTOTAL(21)= 4.53000990550884564086D-03                                   
!                                                                       
      WTOTAL(22)= 9.71781245099519154149D-04                                   
      WTOTAL(23)= 5.45155828191270305922D-02                                   
      WTOTAL(24)= 4.25607252610127800520D-01                                   
      WTOTAL(25)= 8.10264617556807326765D-01                                   
      WTOTAL(26)= 4.25607252610127800520D-01                                   
      WTOTAL(27)= 5.45155828191270305922D-02                                   
      WTOTAL(28)= 9.71781245099519154149D-04                                   
!                                                                      
      WTOTAL(29)= 1.99604072211367619206D-04                                   
      WTOTAL(30)= 1.70779830074134754562D-02                                   
      WTOTAL(31)= 2.07802325814891879543D-01                                   
      WTOTAL(32)= 6.61147012558241291030D-01                                   
      WTOTAL(33)= 6.61147012558241291030D-01                                   
      WTOTAL(34)= 2.07802325814891879543D-01                                   
      WTOTAL(35)= 1.70779830074134754562D-02                                   
      WTOTAL(36)= 1.99604072211367619206D-04                                   
!                                                                       
      WTOTAL(37)= 3.96069772632643819046D-05                                   
      WTOTAL(38)= 4.94362427553694721722D-03                                   
      WTOTAL(39)= 8.84745273943765732880D-02                                   
      WTOTAL(40)= 4.32651559002555750200D-01                                   
      WTOTAL(41)= 7.20235215606050957124D-01                                   
      WTOTAL(42)= 4.32651559002555750200D-01                                   
      WTOTAL(43)= 8.84745273943765732880D-02                                   
      WTOTAL(44)= 4.94362427553694721722D-03                                   
      WTOTAL(45)= 3.96069772632643819046D-05                                   
!                                                                       
      WTOTAL(46)= 7.64043285523262062916D-06                                 
      WTOTAL(47)= 1.34364574678123269220D-03                                 
      WTOTAL(48)= 3.38743944554810631362D-02                                 
      WTOTAL(49)= 2.40138611082314686417D-01                                 
      WTOTAL(50)= 6.10862633735325798784D-01                                 
      WTOTAL(51)= 6.10862633735325798784D-01                                 
      WTOTAL(52)= 2.40138611082314686417D-01                                 
      WTOTAL(53)= 3.38743944554810631362D-02                                 
      WTOTAL(54)= 1.34364574678123269220D-03                                 
      WTOTAL(55)= 7.64043285523262062916D-06                                 
!-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END        

C START                                            
      SUBROUTINE START(NATOMS,NBF,NUQMT,NELEC,NALP,NBET,NSHELLS,
     &                 NPRIMIT,ZNUC,COORD,IANUC,IMIN,IMAX,ZMASA,KSTAR,
     &                 KATOMO,KTIPO,KLO,INTIPO,KNUG,KMINI,KMAXI,ISHE,
     &                 ITIPO,C1,C2,EXn,CSn,CPn,CDn,CFn,CGn,CHn,CIn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA /NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,ZAN(100),C(3,100),
     *              IAN(100)
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      COMMON/ELPROP/IEMOM      
      CHARACTER(8):: UNITS
      COMMON/CONTROL/UNITS  
      LOGICAL       LINEAR
      COMMON/ZMAT  /LINEAR 
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/RUNTYPE/IRUNTYP            
      COMMON/MASSES/ZMASS(100)                                                  
      COMMON/BASISPIRIS1/INTYPPIR(500),NPRIMI,IMINPIR(100),          
     *                   IMAXPIR(100),ISHPIR(2000),ITYPPIR(2000) 
      COMMON/BASISPIRIS2/C1PIR(2000),C2PIR(2000)                          
      INTEGER,DIMENSION(100) :: IANUC,IMIN,IMAX
      INTEGER,DIMENSION(500) :: KSTAR,KATOMO,KTIPO,KLO,INTIPO,KNUG
      INTEGER,DIMENSION(500) :: KMINI,KMAXI
      INTEGER,DIMENSION(2000) :: ISHE,ITIPO
      DOUBLE PRECISION, DIMENSION(2000) :: C1,C2,EXn
      DOUBLE PRECISION, DIMENSION(2000) :: CSn,CPn,CDn,CFn,CGn,CHn,CIn
      DOUBLE PRECISION, DIMENSION(3) :: VMOI
      DOUBLE PRECISION, DIMENSION(100) :: ZNUC,ZMASA
      DOUBLE PRECISION, DIMENSION(3,100) :: COORD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: COM
C-----------------------------------------------------------------------
C     System                                   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      MWORDS = 0                                                        
      JRET = 0   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Read the Molecule and its normal basis set
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MOLECULE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     True Nuclear Charges
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,NAT                                                      
       IAN(I) = INT(ZAN(I)+0.001D0)                             
      ENDDO
      IANUC = IAN                                                             
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Atomic Mass Table  ( ZMASS: normal masses )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL AMT(ZAN,ZMASS,NAT)
      ZMASA = ZMASS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check for Linear Molecule
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(COM(3,NAT))
      CALL VCLR(VMOI,1,3)                                               
      IF(NAT>0)CALL INRTIA(C,COM,ZMASS,VMOI,NAT)                    
      LINEAR = .FALSE.                                                    
      IF(VMOI(1)<1.0D-04)LINEAR = .TRUE. 
      IF(NAT==1)LINEAR = .FALSE.               
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Print Input Run Options
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
cecp      WRITE(6,1)IRUNTYP,MUL,ICH,IECP,IEMOM,UNITS
      WRITE(6,1)IRUNTYP,MUL,ICH,IEMOM,UNITS      
      if(EFLDL)then
       WRITE(6,'(/1X,A15,3F10.5)')'Electric Field:',(EVEC(I),I=1,3)
      end if
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     ECP Input
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
cecp      CALL ECPPAR                                                       
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Schwarz inequality on if NAT > 5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NAT>5)ISCHWZ = 1                                                    
      WRITE(6,2)1.0D-09,ISCHWZ  ! Integrals < 10.0**(-9) aren't used
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Abort Program if LMAXIMA > 5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      IF(LMAXIMA>5)THEN                                                
        WRITE(6,'(35A)')'Functions with LMAX > 5 not allowed'           
       CALL ABRT                                                      
      END IF                                                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NBF = NUM
      NATOMS = NAT
      NUQMT = NQMT
      NELEC = NE
      NALP = NA
      NBET = NB
      NSHELLS = NSHELL
      NPRIMIT = NPRIMI
      ZNUC = ZAN
      COORD = C
      IMIN = IMINPIR
      IMAX = IMAXPIR
      KSTAR = KSTART
      KATOMO = KATOM
      KTIPO = KTYPE
      KLO = KLOC
      INTIPO = INTYPPIR
      KNUG = KNG
      KMINI = KMIN
      KMAXI = KMAX
      ISHE = ISHPIR
      ITIPO = ITYPPIR
      C1 = C1PIR
      C2 = C2PIR
      EXn = EX
      CSn = CS
      CPn = CP
      CDn = CD
      CFn = CF
      CGn = CG
      CHn = CH
      CIn = CI
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(COM)
      RETURN                                                            
C-----------------------------------------------------------------------
cecp    1 FORMAT(/1X,'Input Run Options',/,
cecp     *        1X,'-----------------',/,
cecp     * 1X,'IRUNTYP =',I2,2X,'MULT =',I2,2X,'ICHARG =',I2,
cecp     *                   2X,'IECP =',I2,2X,'IEMOM =',I2,
cecp     *                   2X,'UNITS = ',A8)
    1 FORMAT(/1X,'Input Run Options',/,
     *        1X,'-----------------',/,
     * 1X,'IRUNTYP =',I2,2X,'MULT =',I2,2X,'ICHARG =',I2,
     *                   2X,'IEMOM =',I2,2X,'UNITS = ',A8)     
    2 FORMAT(/1X,'Integral Options'/,1X,16(1H-)/                                               
     *        1X,'CUTOFF =',1P,E8.1,3X,'ISCHWZ =',I2)                                          
C-----------------------------------------------------------------------
      END                                                               

C BASCHK                                           
      SUBROUTINE BASCHK(LMAXIMA,KTYPE,NSHELL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(500) :: KTYPE
C-----------------------------------------------------------------------
C     Return the highest angular momentum in the basis
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      KANG = 0                                                          
      DO N=1,NSHELL                                                 
       IF(KTYPE(N)>KANG)KANG = KTYPE(N)                          
      ENDDO
      LMAXIMA = KANG-1
C-----------------------------------------------------------------------                                                     
      RETURN                                                            
      END                                                               
      
C MOLECULE
      SUBROUTINE MOLECULE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/FRAME /U1,U2,U3,V1,V2,V3,WW1,WW2,WW3,X0,Y0,Z0     ! PTGRP            
      COMMON/MAPSHEL/MAPSHL(500,48),NT      
      CHARACTER(80) :: TITLE 
      COMMON/TIT/TITLE       
#include "mpip.h"
C-----------------------------------------------------------------------
C     Read Atom Coordinates and Basis from the Input File ($DATA)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CONTINUE
#else
      REWIND(5)
#endif
      CALL FNDGRP(' $DATA  ',IEOF)
      IF(IEOF/=0)THEN
        WRITE(6,1)' $DATA  '
       CALL ABRT
      ENDIF
      CALL OPNCRD
      READ (5,'(A80)')TITLE
      WRITE(6,2)TITLE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     No symmetry point group - > C1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NT = 1
C
      U1 = 1.0D0
      U2 = 0.0D0
      U3 = 0.0D0
      V1 = 0.0D0
      V2 = 1.0D0
      V3 = 0.0D0
      WW1 = 0.0D0
      WW2 = 0.0D0
      WW3 = 1.0D0
      X0 = 0.0D0
      Y0 = 0.0D0
      Z0 = 0.0D0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Read Atoms
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ATOMS
      CALL SETLAB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
C-----------------------------------------------------------------------
    1 FORMAT(1X,'**** ERROR, NO ',A8,' GROUP WAS FOUND')
    2 FORMAT(/1X,'Run Title',/1X,9(1H-)/1X,A80)
C-----------------------------------------------------------------------
      END

C ATOMS                                            
      SUBROUTINE ATOMS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)            
      DOUBLE PRECISION,PARAMETER :: PT2953=29.53125D0
      DOUBLE PRECISION,PARAMETER :: PT1624=162.421875D0
      DOUBLE PRECISION,PARAMETER :: PT75=0.75D0
      DOUBLE PRECISION,PARAMETER :: PT187=1.875D0
      DOUBLE PRECISION,PARAMETER :: TM10=1.0D-10
      DOUBLE PRECISION,PARAMETER :: PT6562=6.5625D0
      DOUBLE PRECISION,PARAMETER :: UNIT=0.52917724924D0
      CHARACTER(8), DIMENSION(103,7) :: ABASIS
      INTEGER, DIMENSION(103,7) :: IAGAUS      
      COMMON/INTNAL/NATIN 
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/INFOA /NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,ZAN(100),C(3,100),
     *              IAN(100)
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/MAPSHEL/MAPSHL(500,48),NT
      COMMON/TRANSF/XP,YP,ZP 
      COMMON/BASISPIRIS1/INTYPPIR(500),NPRIMI,IMINPIR(100),          
     *                   IMAXPIR(100),ISHPIR(2000),ITYPPIR(2000) 
      COMMON/BASISPIRIS2/C1PIR(2000),C2PIR(2000)                          
      INTEGER,DIMENSION(100,48) :: MAPCTR
      DOUBLE PRECISION,DIMENSION(100) :: ANAM,BNAM
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CSINP,CPINP,CDINP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CFINP,CGINP,CHINP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CIINP,EXX,CSS
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CPP,CDD,SCFAC
      INTEGER,ALLOCATABLE,DIMENSION(:) :: INTYP,NS,KS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   
      CHARACTER(8) :: BLANK
      DATA BLANK /'        '/
      CHARACTER(8) :: CBASIS                       
      CHARACTER(8),DIMENSION(8) :: LABEL
      DATA LABEL/'S       ','P       ','D       ','F       ',           
     *           'G       ','H       ','I       ','L       '/
      INTEGER,DIMENSION(8) :: NBFS,MINF,MAXF,NANGM
      DATA NBFS / 1, 3,  6, 10, 15, 21, 28, 4/                 
      DATA MINF / 1, 2,  5, 11, 21, 36, 57, 1/                 
      DATA MAXF / 1, 4, 10, 20, 35, 56, 84, 4/                 
      DATA NANGM/ 1, 2,  3,  4,  5,  6, 7,  2/                 
      CHARACTER(8) :: LETK
      DATA LETK/'K       '/ 
      CHARACTER(8) :: BASIS
      CHARACTER(10) :: ATOMNM,ENDWRD
      DATA ENDWRD /'$END      '/                                        
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      LOGICAL :: SPRKLE,QMCHKA,QMCHKB
C-----------------------------------------------------------------------
      ALLOCATE(INTYP(500),NS(100),KS(100))
      ALLOCATE(EXX(6),CSS(6),CPP(6),CDD(6),SCFAC(4))
      ALLOCATE(CSINP(2000),CPINP(2000),CDINP(2000),CFINP(2000))
      ALLOCATE(CGINP(2000),CHINP(2000),CIINP(2000))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      PI = 2.0d0*DASIN(1.0d0)
      PI32 = PI*SQRT(PI)                                              
      CBASIS = BLANK                                                 
      BASIS  = BLANK
      IDUM   = 0                                                          
      IGAUSS = 0                                                        
      NAT    = 0                                                           
      NATIN  = 0                                                         
      NE     = 0                                                            
      NSHELL = 0                                                        
      LOC    = 0                                                           
      NGAUSS = 0                                                        
      DO I = 1,2000                                               
       EX(I) = 0.0D0                                                   
       CS(I) = 0.0D0                                                   
       CP(I) = 0.0D0                                                   
       CD(I) = 0.0D0                                                   
       CF(I) = 0.0D0                                                   
       CG(I) = 0.0D0                                                   
       CH(I) = 0.0D0                                                   
       CI(I) = 0.0D0                                                   
       CSINP(I) = 0.0D0                                                
       CPINP(I) = 0.0D0                                                
       CDINP(I) = 0.0D0                                                
       CFINP(I) = 0.0D0                                                
       CGINP(I) = 0.0D0                                                
       CHINP(I) = 0.0D0                                                
       CIINP(I) = 0.0D0                                                
      END DO
      ZNUC = 0.0D0                                                       
      X = 0.0D0                                                          
      Y = 0.0D0                                                          
      Z = 0.0D0                                                          
      SCFAC(1) = 0.0D0                                                   
      SCFAC(2) = 0.0D0                                                   
      SCFAC(3) = 0.0D0                                                   
      SCFAC(4) = 0.0D0                                                   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                               Read Atoms
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      INPATM = 0                                                                       
    1 CONTINUE                                                          
      INPATM = INPATM + 1                                                   
      CALL READAT(ATOMNM,ZNUC,X,Y,Z)             
C
      IF(ATOMNM/=ENDWRD)THEN
       NAT = NAT+1                                                       
       IF(NAT>100)THEN
        WRITE(6,'(/,1X,A15,I6)')'Stop: NAT > 100',NAT                                 
        CALL ABRT                                                         
       ENDIF
       READ(UNIT=ATOMNM,FMT='(A8,A2)')ANAM(NAT),BNAM(NAT) 
       NS(NAT) = 0                                                       
       KS(NAT) = NSHELL+1  
       X = X / UNIT
       Y = Y / UNIT                                                     
       Z = Z / UNIT                                                     
       C(1,NAT) = X                                                      
       C(2,NAT) = Y                                                      
       C(3,NAT) = Z                                                      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ZEXTRA = ABS(ZNUC) - INT(ABS(ZNUC))                               
       SPRKLE = ZEXTRA>1.0D-05                                        
       IF(.NOT.SPRKLE)THEN                                              
        IF(ZNUC>0.0D0)THEN                                          
         ZAN(NAT) = ZNUC                                             
         NE = NE + INT(ZNUC)                                         
        ELSE                                                           
         ZAN(NAT) = 0.0D0                                             
         ZNUC = ABS(ZNUC)                                            
        END IF                                                         
       ELSE                                                              
        ZAN(NAT) = ZNUC                                                
       END IF                                                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ICNT = 0                                                          
    2  CONTINUE                                                          
       ICNT = ICNT + 1                                                   
       NUCZ = INT(ZNUC)                                                  
       MPCORE = 0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                        
C      Basis in the Input File
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IEOF = 0                                                       
       IERR = 0
       CALL RDCARD('$DATA 6U',IEOF)                                   
       KSIZE = -8                                                     
       CALL GSTRNG(CBASIS,KSIZE)                                      
       READ(UNIT=CBASIS,FMT='(A8)')BASIS                             
       IF (BASIS==LETK) BASIS=LABEL(1)                           
       IGAUSS = IFIND('NGAUSS  ',IERR)                             
       DO I=1,4                                                   
        SCFAC(I) = RFIND('SCFAC   ',IERR)                           
        IF(IERR/=0)CALL ABRT                          
       END DO
       IF(ICNT==1)THEN                            
        ABASIS(NUCZ,1) = BASIS                                         
        IAGAUS(NUCZ,1) = IGAUSS                                        
       END IF                                                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      A blank string means this Atom is done
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
       IF(BASIS==BLANK)THEN                                           
        XS = X                                                            
        YS = Y                                                            
        ZS = Z                                                            
        NAT0 = NAT                                                        
        QMCHKA = .FALSE.                                                  
        QMCHKB = .FALSE.                                                  
        GOTO 1                                                         
       END IF                                                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
       IF(IGAUSS>30)THEN                                        
        WRITE(6,'(/,1X,A17,I6)')'Stop: IGAUSS > 30',IGAUSS                                                                                
        WRITE(6,100) NAT,INPATM,ATOMNM,ZNUC,X*UNIT,Y*UNIT,Z*UNIT                      
        CALL ABRT                                                      
       END IF                                                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        
       ITYP = 0                                                          
       DO I=1,8                                                         
        IF(BASIS==LABEL(I))ITYP=I                                   
       ENDDO                                                             
       IF(ITYP==0)THEN
C       Stop: Basis is unrecognized
        WRITE(6,'(/1X,A33,A8,1X,A9,I4)')
     *  'Stop: Illegal basis function type',BASIS,'IGAUSS = ',IGAUSS
        WRITE(6,100) NAT,INPATM,ATOMNM,ZNUC,X/UNIT,Y/UNIT,Z/UNIT                         
        CALL BERROR(4)                                                    
        CALL ABRT                                                         
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C      General Basis Set: Information in COMMON/NSHEL/
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C      NSHELL- IS THE TOTAL NUMBER OF SHELLS.  A P SHELL MEANS X,Y,Z,
C       D SHELL MEANS XX,YY,ZZ,XY,XY,YZ, AND SO ON FOR F,G,H,I.      
C       CARTESIAN GAUSSIAN SHELLS CONTAIN ALL X**L Y**M Z**N         
C       PRODUCTS WITH L+M+N= CONSTANT, I.E. L+M+N=3 FOR F SHELL.     
C      EX- GAUSSIAN EXPONENTS, FOR EVERY SYMMETRY UNIQUE PRIMITIVE.  
C      CS- THROUGH -CI- ARE S,P,D,F,G,H,I CONTRACTION COEFFICIENTS.  
C       NORMALLY ONLY ONE OF THE -CX- ARRAYS WILL BE NON-ZERO,       
C       FOR ANY GIVEN EXPONENT IN -EX-.  THE EXCEPTION IS "L" SHELLS,
C       WHERE BOTH -CS- AND -CP- WILL HAVE (DIFFERENT) VALUES.       
C                                                                    
C            THE VARIOUS "K"S DEFINE EACH SHELL'S CONTENTS:          
C                                                                    
C      KATOM- TELLS WHICH ATOM THE SHELL IS CENTERED ON, NORMALLY    
C       MORE THAN ONE SHELL EXISTS ON EVERY ATOM.                    
C      KLOC- GIVES THE LOCATION OF THIS SHELL IN THE TOTAL AO BASIS, 
C       PLEASE READ THE EXAMPLE.                                     
C      KSTART- IS THE LOCATION OF THE FIRST EXPONENT AND THE FIRST   
C       CONTRACTION COEFFICIENT CONTAINED IN A PARTICULAR SHELL.     
C       THUS, -KLOC- IS AN AO COUNTER, -KSTART- A PRIMITIVE COUNTER. 
C      KNG- IS THE NUMBER OF GAUSSIANS IN THIS SHELL.  THEIR DATA    
C       ARE STORED CONSECUTIVELY BEGINNING AT THE -KSTART- VALUE.    
C      KTYPE- IS 1,2,3,4,5,6,7 FOR S,P,D,F,G,H,I.  NOTE THAT THE     
C       VALUE STORED IN -KTYPE- FOR AN "L" SHELL IS A 2, SO THAT     
C       BY ITSELF, -KTYPE- CANNOT DISTINGUISH A "P" FROM A "L".      
C       THUS, KTYPE IS ONE HIGHER THAN THE TRUE ANGULAR MOMENTUM.    
C      KMIN- AND -KMAX- ARE THE STARTING AND ENDING INDICES OF THE   
C       SHELL.  THESE ARE DEFINED AS                                 
C                 S    P    D    F   G   H   I   L                   
C          KMIN   1    2    5   11  21  34  57   1                   
C          KMAX   1    4   10   20  35  56  84   4                   
C       SO YOU CAN TELL AN "L" SHELL BY ITS RUNNING FROM 1 TO 4,     
C       NAMELY S,X,Y,Z, WHEREAS A "P" SHELL RUNS 2,3,4 FOR X,Y,Z.    
C       THE TABLE ABOVE IS GENERATED BY WRITING ALL CARTESIAN        
C       PRODUCTS, "MAXIMUM POWERS FIRST", BACK TO BACK:              
C          S,  X,Y,Z,  XX,YY,ZZ,XY,XZ,YZ,                            
C          1   2 3 4    5  6  7  8  9 10                             
C          XXX,YYY,ZZZ,XXY,XXZ,YYX,YYZ,ZZX,ZZY,XYZ, ... G,H,I        
C          11  12  13,  14  15  16  17  18  19  20, ... G,H,I        
C                                                                    
C      AN EXAMPLE, TO TRY TO MAKE THIS CONCRETE, IS A 6-311G(D,P) BASIS 
C      FOR THE MOLECULE CSIH.  JUST THOSE THREE ATOMS, IN THAT ORDER:   
C              S  L  L  L  D    S  L  L  L  L  D    S  S  S  P          
C      KATOM   1  1  1  1  1    2  2  2  2  2  2    3  3  3  3          
C      KNG     6  3  1  1  1    6  6  3  1  1  1    3  1  1  1          
C      KTYPE   1  2  2  2  3    1  2  2  2  2  3    1  1  1  2          
C      KMIN    1  1  1  1  5    1  1  1  1  1  5    1  1  1  2          
C      KMAX    1  4  4  4 10    1  4  4  4  4 10    1  1  1  4          
C      KSTART  1  7 10 11 12   13 19 25 28 29 30   31 34 35 36 (SUM KNG)
C      KLOC    1  2  6 10 14   20 21 25 29 33 37   43 44 45 46          
C                                                                       
C      KLOC- HELPS POINT TO THE RIGHT AO INDEX, E.G. THE D SHELL       
C      OF THE SI ATOM CONTAINS AOS NUMBERED 37,38,39,40,41,42.          
C      KLOC(I) = KLOC(I-1) + KMAX(I) - KMIN(I) + 1                      
C      TOTAL NUMBER OF AOS (NUM IN COMMON -INFOA-) IN THIS EXAMPLE      
C      IS 48, FROM THE HYPOTHETICAL NEXT KLOC OF 46 + 4 - 2 + 1.        
C      CLEARLY -NSHELL- IS 15, THE NUMBER OF COLUMNS GIVEN HERE.        
C                                                                       
C      NOTE THAT THIS EXAMPLE SHOWS YOU HOW TO TELL A -P- FROM A -L-,   
C      EVEN THOUGH -KTYPE- IS 2 FOR EACH.                               
C                                                                       
C      NOTE THAT D SHELLS ALWAYS HAVE 6 MEMBERS, FOR SPHERICAL          
C      HARMONICS ARE NOT TAKEN CARE OF IN THE BASIS (ALWAYS A           
C      CARTESIAN GAUSSIAN BASIS IS SET UP) BUT RATHER AT THE TIME       
C      OF VARYING THE MOS       
C                                                                       
C      IF OUR MOLECULE WAS REALLY CSIH3, WITH C3V SYMMETRY, SO THAT     
C      THE INPUT GAVE ONLY ONE OF THE HYDROGENS, HOW DOES -NSHEL-       
C      CHANGE?  IT WOULD BE EXTENDED BY TWO MORE ATOMS,                 
C              S  S  S  P      S  S  S  P                               
C      KATOM   4  4  4  4      5  5  5  5                               
C      KNG     3  1  1  1      3  1  1  1                               
C      KTYPE   1  1  1  2      1  1  1  2                               
C      KMIN    1  1  1  2      1  1  1  2                               
C      KMAX    1  1  1  4      1  1  1  4                               
C      KSTART 31 34 35 36     31 34 35 36                               
C      KLOC   49 50 51 52     55 56 57 58                               
C                                                                       
C      NOTE THAT SINCE THESE ARE SYMMETRY EQUIVALENT, -KSTART-          
C      POINTS TO THE ORIGINAL GAUSSIAN DETAILS IN -EX- AND -CX-,        
C      BUT THESE ARE ADDITIONAL AOS, SO -KLOC- DOES GO UP.              
C      NSHELL- IS NOW 24, AND -NUM- IS NOW 60.                         
C                                                                       
C      A MOLECULE MAY VERY WELL HAVE MANY HYDROGENS, PERHAPS USING      
C      IDENTICAL BASIS SETS, BUT EVERY DIFFERENT SET OF EQUIVALENT      
C      HYDROGENS GETS SEPARATE STORAGE OF ITS EXPONENTS/CONTRACTION     
C      COEFFICIENTS (STORED AT DIFFERENT -KSTART- VALUES).              
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       NSHELL = NSHELL + 1                                               
       IF(NSHELL>500)THEN
        WRITE(6,'(1X,A18,I6,A15)')
     *   'Stop: No more than',500,' shells allowed'                                  
        CALL ABRT
       ENDIF                                                         
C
       KMIN(NSHELL)  = MINF(ITYP)                                         
       KMAX(NSHELL)  = MAXF(ITYP)                                         
       KSTART(NSHELL)= NGAUSS+1                                         
       KATOM(NSHELL) = NAT                                               
       KTYPE(NSHELL) = NANGM(ITYP)                                       
       INTYP(NSHELL) = ITYP                                              
       KNG(NSHELL)   = IGAUSS                                              
       KLOC(NSHELL)  = LOC+1                                              
       NGAUSS = NGAUSS + IGAUSS                                            
       IF(NGAUSS>2000)THEN
        WRITE(6,'(1X,A18,I6,A18)')
     *   'Stop: No more than',2000,' Gaussians allowed'                                  
        CALL ABRT
       ENDIF                                                         
C                                   
       LOC = LOC + NBFS(ITYP)
       IF(LOC>8192)THEN                                      
        WRITE(6,'(1X,A18,I6,A24)')
     *  'Stop: No more than',8192,' basis functions allowed'                                  
        CALL ABRT
       END IF                                                         
       K1 = KSTART(NSHELL)                                               
       K2 = K1 + KNG(NSHELL) - 1                                             
       NS(NAT) = NS(NAT) + 1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     
C      S, P, D, F, G, H, I, or L Basis Sets
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(ITYP<=8)THEN
        IF(SCFAC(1) <= 0.0D0) SCFAC(1) = 1.0D0                             
        IDUM=0                                                            
        DO K = K1,K2                                                  
         C1 = 0.0D0                                                      
         C2 = 0.0D0                                                      
         IEOF = 0                                                    
         IERR = 0                                                    
         CALL RDCARD('$DATA 7U',IEOF)                                
         IDUM = IFIND('IDUM    ',IERR)                               
         IF(IERR/=0)CALL ABRT                           
         EX(K) = RFIND('ZETA    ',IERR)                               
         IF(IERR/=0) CALL ABRT                           
         IF(EX(K)==0.0D0) THEN                            
          WRITE(6,'(1X,A10,I4,A39,A4)')'Stop: Atom',NATIN,
     *          ' has 0 exponent for basis function type',LABEL(ITYP)
          CALL ABRT                                      
         END IF                                            
         C1 = RFIND('C1      ',IERR)                                  
         IF(IERR/=0) CALL ABRT                           
         C2 = RFIND('C2      ',IERR)                                  
         IF(IERR/=0) CALL ABRT                           
         IF(C1==0.0D0.and.EX(K)==1.0D0) THEN                    
          WRITE(6,*)'Stop: Contraction Coefficient not found'      
          WRITE(6,100)NAT,INPATM,ATOMNM,ZNUC,X*UNIT,Y*UNIT,Z*UNIT                
          CALL ABRT                                                
         END IF                                                      
         IF(IGAUSS==1)C1=1.0D0                                      
         IF(IGAUSS==1)C2=1.0D0                                      
         EX(K) = EX(K)*SCFAC(1)**2                                    
         IF(ITYP==1) CSINP(K) = C1                                    
         IF(ITYP==2) CPINP(K) = C1                                    
         IF(ITYP==3) CDINP(K) = C1                                    
         IF(ITYP==4) CFINP(K) = C1                                    
         IF(ITYP==5) CGINP(K) = C1                                    
         IF(ITYP==6) CHINP(K) = C1                                    
         IF(ITYP==7) CIINP(K) = C1                                    
         IF(ITYP==8) CSINP(K) = C1                                    
         IF(ITYP==8) CPINP(K) = C2                                    
         CS(K) = CSINP(K)                                               
         CP(K) = CPINP(K)                                               
         CD(K) = CDINP(K)                                               
         CF(K) = CFINP(K)                                               
         CG(K) = CGINP(K)                                               
         CH(K) = CHINP(K)                                               
         CI(K) = CIINP(K)                                               
        END DO
       END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
C      Normalize Primitive Basis Functions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
       DO IG = K1,K2                                                 
        EE = EX(IG)+EX(IG)                                             
        FACS = PI32/(EE*SQRT(EE))                                      
        FACP = 0.5D0*FACS/EE                                          
        FACD = PT75  *FACS/(EE*EE)                                     
        FACF = PT187 *FACS/(EE**3)                                     
        FACG = PT6562*FACS/(EE**4)                                     
        FACH = PT2953*FACS/(EE**5)                                     
        FACI = PT1624*FACS/(EE**6)                                     
        CS(IG) = CS(IG)/SQRT(FACS)                                     
        CP(IG) = CP(IG)/SQRT(FACP)                                     
        CD(IG) = CD(IG)/SQRT(FACD)                                     
        CF(IG) = CF(IG)/SQRT(FACF)                                     
        CG(IG) = CG(IG)/SQRT(FACG)                                     
        CH(IG) = CH(IG)/SQRT(FACH)                                     
        CI(IG) = CI(IG)/SQRT(FACI)                                     
       END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
C      Normalize the contracted basis functions to Unity
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                          
       FACS = 0.0D0                                                       
       FACP = 0.0D0                                                       
       FACD = 0.0D0                                                       
       FACF = 0.0D0                                                       
       FACG = 0.0D0                                                       
       FACH = 0.0D0                                                       
       FACI = 0.0D0                                                       
       DO IG = K1,K2                                                 
        DO JG = K1,IG                                              
         EE = EX(IG)+EX(JG)                                          
         FAC = EE*SQRT(EE)                                           
         DUMS = CS(IG)*CS(JG)/FAC                                    
         DUMP = 0.5D0*CP(IG)*CP(JG)/(EE*FAC)                        
         DUMD = PT75  *CD(IG)*CD(JG)/(EE*EE*FAC)                     
         DUMF = PT187 *CF(IG)*CF(JG)/(EE**3*FAC)                     
         DUMG = PT6562*CG(IG)*CG(JG)/(EE**4*FAC)                     
         DUMH = PT2953*CH(IG)*CH(JG)/(EE**5*FAC)                     
         DUMI = PT1624*CI(IG)*CI(JG)/(EE**6*FAC)                     
         IF(IG /= JG) THEN                                         
          DUMS = DUMS+DUMS                                         
          DUMP = DUMP+DUMP                                         
          DUMD = DUMD+DUMD                                         
          DUMF = DUMF+DUMF                                         
          DUMG = DUMG+DUMG                                         
          DUMH = DUMH+DUMH                                         
          DUMI = DUMI+DUMI                                         
         END IF                                                      
         FACS = FACS+DUMS                                            
         FACP = FACP+DUMP                                            
         FACD = FACD+DUMD                                            
         FACF = FACF+DUMF                                            
         FACG = FACG+DUMG                                            
         FACH = FACH+DUMH                                            
         FACI = FACI+DUMI                                            
        END DO
       END DO
       IF(FACS < TM10) THEN                                           
        FACS = 0.0D0                                                      
       ELSE                                                              
        FACS = 1.0D0/SQRT(FACS*PI32)                                     
       END IF                                                            
       IF(FACP < TM10) THEN                                           
        FACP=0.0D0                                                      
       ELSE                                                              
        FACP = 1.0D0/SQRT(FACP*PI32)                                     
       END IF                                                            
       IF(FACD < TM10) THEN                                           
        FACD=0.0D0                                                      
       ELSE                                                              
        FACD = 1.0D0/SQRT(FACD*PI32)                                     
       END IF                                                            
       IF(FACF < TM10) THEN                                           
        FACF=0.0D0                                                      
       ELSE                                                              
        FACF = 1.0D0/SQRT(FACF*PI32)                                     
       END IF                                                            
       IF(FACG < TM10) THEN                                           
        FACG=0.0D0                                                      
       ELSE                                                              
        FACG = 1.0D0/SQRT(FACG*PI32)                                     
       END IF                                                            
       IF(FACH < TM10) THEN                                           
        FACH=0.0D0                                                      
       ELSE                                                              
        FACH = 1.0D0/SQRT(FACH*PI32)                                     
       END IF                                                            
       IF(FACI < TM10) THEN                                           
        FACI=0.0D0                                                      
       ELSE                                                              
        FACI = 1.0D0/SQRT(FACI*PI32)                                     
       END IF                                                            
       DO IG = K1,K2                                                 
        CS(IG) = CS(IG) * FACS                                         
        CP(IG) = CP(IG) * FACP                                         
        CD(IG) = CD(IG) * FACD                                         
        CF(IG) = CF(IG) * FACF                                         
        CG(IG) = CG(IG) * FACG                                         
        CH(IG) = CH(IG) * FACH                                         
        CI(IG) = CI(IG) * FACI                                         
        CSINP(IG) = CSINP(IG) * FACS                                   
        CPINP(IG) = CPINP(IG) * FACP                                   
        CDINP(IG) = CDINP(IG) * FACD                                   
        CFINP(IG) = CFINP(IG) * FACF                                   
        CGINP(IG) = CGINP(IG) * FACG                                   
        CHINP(IG) = CHINP(IG) * FACH                                   
        CIINP(IG) = CIINP(IG) * FACI                                   
       END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       GO TO 2                                                         
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C      Generate equivalent Atoms
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       XS = X                                                            
       YS = Y                                                            
       ZS = Z                                                            
       NAT0 = NAT                                                        
       QMCHKA = .FALSE.                                                  
       QMCHKB = .FALSE.                                                  
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
       GO TO 1                                                         
      END IF      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NGAUSS==0.or.NSHELL==0)THEN    
       WRITE(6,'(32A)')'Stop: No basis functions defined' 
       CALL ABRT                                                      
      END IF                                                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C             Form Transformation Tables for Atoms and Shells
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO IAT = 1,NAT                                               
       NS1 = KS(IAT)-1                                                
       NS2 = NS(IAT)                                                  
       X = C(1,IAT)                                                   
       Y = C(2,IAT)                                                   
       Z = C(3,IAT)                                                   
       XS = X                                                         
       YS = Y                                                         
       ZS = Z                                                         
       DO IT = 1,NT                                              
        NN = 9*(IT-1)                                               
        XP = XS
        YP = YS
        ZP = ZS
        ICTR = -2**20                                               
        DO 1010 I = 1,NAT                                           
         TEST = (XP-C(1,I))**2+(YP-C(2,I))**2+(ZP-C(3,I))**2      
         IF(TEST>TM10 .OR. (QMCHKA.NEQV.QMCHKB)) GO TO 1010
         ICTR = I                                                 
         GO TO 1020                                               
 1010   CONTINUE                                                    
 1020   MAPCTR(IAT,IT) = ICTR                                       
        NS3 = KS(ICTR)-1                                            
        DO ISH = 1,NS2                                         
         MAPSHL(NS1+ISH,IT) = NS3+ISH                             
        END DO
       END DO
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Print atomic coordinates
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE (6,200)                                             
      DO IAT = 1,NAT                                         
       WRITE(6,300)ANAM(IAT),BNAM(IAT),ZAN(IAT),
     &              C(1,IAT),C(2,IAT),C(3,IAT)
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Print Basis Functions
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --                                                   
      WRITE(6,'(/1X,A16,/1X,16(1H-))')'Atomic Basis Set'                                                 
      WRITE(6,'(1X,A52)')
     * 'The contracted primitive functions were unnormalized'                                        
      WRITE(6,'(1X,A58)') 
     * 'The contracted basis functions are now normalized to unity'      
      WRITE(6,'(/2X,A21,9X,A33)')'Shell Type  Primitive',
     *                           'Exponent  Contraction Coefficient'                          
      MLDUDF=0                                                          
      MLDNDA=0
C-----------------------------------------------------------------------
      IMINPIR(1)=1                                                      
C-----------------------------------------------------------------------
      DO IAT = 1,NAT                                               
       DO IT = 1,NT                                              
        IF(MAPCTR(IAT,IT) > IAT) GO TO 20                      
       END DO
       WRITE(6,'(/1X,A8,A2)')ANAM(IAT),BNAM(IAT)                                  
       NS1 = KS(IAT)                                                  
       NS2 = NS1+NS(IAT)-1                                            
       MLDNDA=MLDNDA+1                                                
       DO ISH = NS1,NS2                                          
        WRITE(6,*)                                             
        I1 = KSTART(ISH)                                            
        I2 = I1+KNG(ISH)-1                                          
        ITYP = INTYP(ISH)                                           
        DO IG = I1,I2                                          
         GOTO(11,12,13,14,15,16,17,18)ITYP                   
   11    CONTINUE                                                 
         C1=CSINP(IG)                                             
C--------S--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   12    CONTINUE                                                 
         C1=CPINP(IG)                                             
C--------P--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   13    CONTINUE                                                 
         C1=CDINP(IG)                                             
C--------D--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   14    CONTINUE                                                 
         C1=CFINP(IG)                                             
C--------F--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   15    CONTINUE                                                 
         C1=CGINP(IG)                                             
C--------G--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   16    CONTINUE                                                 
         C1=CHINP(IG)                                             
C--------H--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   17    CONTINUE                                                 
         C1=CIINP(IG)                                             
C--------I--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE(6,400) ISH,LABEL(ITYP),IG,EX(IG),C1              
         GO TO 19                                               
   18    CONTINUE                                                 
         C1=CSINP(IG)                                             
         C2=CPINP(IG)                                             
C--------L--------------------------------------------------------------
         ISHPIR(IG)=ISH                                           
         ITYPPIR(IG)=ITYP                                         
         C1PIR(IG)=C1                                             
         C2PIR(IG)=C2                                             
         NPRIMI=IG                                                
C-----------------------------------------------------------------------
         WRITE (6,400) ISH,LABEL(ITYP),IG,EX(IG),C1,C2          
         GO TO 19                                               
          WRITE(6,*) 'These shells do not exist'     
         CALL ABRT                                                
   19    CONTINUE                                                    
        END DO
       END DO
C-----------------------------------------------------------------------
       IMAXPIR(IAT)=I2                                                  
       IMINPIR(IAT+1)=IMAXPIR(IAT)+1                                    
C-----------------------------------------------------------------------
   20  CONTINUE
      END DO
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --                                                          
C     NE: Number of Electrons
C     NA: Number of Alpha Electrons
C     NB: Number of Beta Electrons
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      NUM  = LOC                                                        
      NQMT = LOC                                                        
      NE = NE-ICH                                                       
      NA = (NE+MUL-1)/2                                                 
      NB = (NE-MUL+1)/2 
      IF(NA+NB/=NE)THEN
       WRITE(6,'(/,1X,19A)')'Number of Electrons'      
       WRITE(6,'(/,1X,I6)')NE
       WRITE(6,'(/,1X,34A)')'Check your Charge and Multiplicity'
       WRITE(6,'(/,1X,2I3,/)')ICH,MUL 
       CALL ABRT                                                   
      END IF
      IMULNE=MUL+NE                                                    
      IF(MUL>NE+1 .or. MUL<0 .or. 2*INT(IMULNE/2)==IMULNE)THEN  
       WRITE(6,'(28A)')'Impossible Spin Multiplicity'     
       CALL ABRT                                                    
      END IF                                                         
C-----------------------------------------------------------------------
      DO I=1,NSHELL                                                     
       INTYPPIR(I)=INTYP(I)                                             
      ENDDO                                                             
C-----------------------------------------------------------------------
      WRITE(6,500)NSHELL,NUM                                      
      WRITE(6,600)NE,ICH,MUL,NA,NB,NAT                         
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Nuclear Energy with true nuclear charges
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      EN = ENUC(NAT,ZAN,C)                                          
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     IECP /=0 -> Write a warning with respect to NE and ENUC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IECP/=0)WRITE(6,'(/1X,A59,/1X,A63)')
     *'Note: This calculation is using an effective core potential',
     *'so NE and ENUC will be adjusted later after removal of the Core'
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(CSINP,CPINP,CDINP,CFINP,CGINP,CHINP,CIINP)
      DEALLOCATE(INTYP,NS,KS,EXX,CSS,CPP,CDD,SCFAC)
C-----------------------------------------------------------------------                                                                       
  100 FORMAT(1X,'ERROR OCCURED READING ATOM NO.',I4,                    
     *          ', INPUT ATOM NO.',I5,', NAME=',A10/                    
     *       1X,'CHARGE=',F5.1,' X,Y,Z=',3F15.8)                        
  200 FORMAT(/1X,'Atom',6X,'Charge',16X,'Coordinates (Bohr)'/           
     *         27X,'x',13X,'y',13X,'z')                     
  300 FORMAT(1X,A8,A2,F5.1,3F14.4)                              
  400 FORMAT(1X,I6,3X,A2,I7,F22.7,2F18.12)                              
  500 FORMAT(/1X,'Total Number of Basis Set Shells             =',I5/   
     *        1X,'Number of Cartesian Gaussian Basis Functions =',I5)   
  600 FORMAT( 1X,'Number of Electrons                          =',I5/   
     *        1X,'Charge of Molecule                           =',I5/   
     *        1X,'Spin Multiplicity                            =',I5/   
     *        1X,'Number of Occupied Orbitals (Alpha)          =',I5/   
     *        1X,'Number of Occupied Orbitals (Beta )          =',I5/   
     *        1X,'Total Number of Atoms                        =',I5) 
C-----------------------------------------------------------------------  
      RETURN                                                            
      END                                                               

C BERROR
      SUBROUTINE BERROR(K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER(8), DIMENSION(4) :: BASIS
      DATA BASIS /'MINIMAL ','EXTENDED','GENERAL ','        '/
C-----------------------------------------------------------------------
      WRITE(6,1)BASIS(K)
      CALL ABRT
      RETURN
C-----------------------------------------------------------------------
    1 FORMAT(/2X,'Stop: illegal ',A8,' basis function')
C-----------------------------------------------------------------------
      END

C READAT                                           
      SUBROUTINE READAT(ATOMNM,ZNUC,X,Y,Z)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      COMMON/INFO  /IUNTRD            
      COMMON/INTNAL/NATIN            
      CHARACTER*10 ATOMNM,ENDWRD,BLANK10                                  
      DATA ENDWRD,BLANK10/'$END      ','          '/
C-----------------------------------------------------------------------
C     Read Cartesian Coordinates: READ(5,*) ATOMNM,ZNUC,X,Y,Z                                      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      DFACT = 1.0D0                                                       
      IF(IUNTRD==-1)DFACT = 0.52917724924D0                                     
C                                         
      IEOF = 0                                                          
      IERR = 0                                                          
      CALL RDCARD('$DATA 5U',IEOF)                                      
         IF(IEOF==1) CALL ABRT                                        
C                                                                       
      KSIZE = -10                                                       
      CALL GSTRNG(ATOMNM,KSIZE)                                         
      IF (ATOMNM==ENDWRD) RETURN                                      
C                                                                       
      NATIN = NATIN+1                                                   
      IF (ATOMNM==BLANK10) THEN                                         
         WRITE(6,1) NATIN                               
         CALL ABRT                                                      
      END IF                                                            
C                                                                       
      ZNUC = RFIND('ZNUC    ',IERR)                                     
             IF(IERR/=0) CALL ABRT                                    
      X = DFACT*RFIND('X       ',IERR)                                  
             IF(IERR/=0) CALL ABRT                                    
      Y = DFACT*RFIND('Y       ',IERR)                                  
             IF(IERR/=0) CALL ABRT                                    
      Z = DFACT*RFIND('Z       ',IERR)                                  
             IF(IERR/=0) CALL ABRT
C-----------------------------------------------------------------------
    1 FORMAT(//1X,'*** ERROR!'/                                         
     *    1X,'BLANK CARD FOUND WHILE TRYING TO READ INPUT ATOM',I5/     
     *    1X,'POSSIBLE ERRORS INCLUDE:'/                                
     *    1X,'1. C1 GROUP SHOULD NOT HAVE A BLANK CARD AFTER IT.'/      
     *    1X,'2. BOTH $BASIS GROUP AND BASIS SET IN $DATA GIVEN?'/      
     *    1X,'3. EXTRANEOUS BLANK CARDS IN $DATA?')                     
C-----------------------------------------------------------------------                                    
      RETURN                                                            
      END                                                               

C SETLAB
      SUBROUTINE SETLAB
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA /NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,ZAN(100),C(3,100),
     *              IAN(100)
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/RUNLAB/BFLAB(8192)            
      CHARACTER(4) :: LABEL
      CHARACTER(8) :: BFL
      CHARACTER(4), DIMENSION(35) :: BFNAM1
      DATA BFNAM1/'  S ','  X ','  Y ','  Z ',
     *            ' XX ',' YY ',' ZZ ',' XY ',' XZ ',' YZ ',
     *            ' XXX',' YYY',' ZZZ',' XXY',' XXZ',
     *            ' YYX',' YYZ',' ZZX',' ZZY',' XYZ',
     *            'XXXX','YYYY','ZZZZ','XXXY','XXXZ',
     *            'YYYX','YYYZ','ZZZX','ZZZY','XXYY',
     *            'XXZZ','YYZZ','XXYZ','YYXZ','ZZXY'/
      CHARACTER(6), DIMENSION(49) :: BFNAM2
      DATA BFNAM2/' XXXXX',' YYYYY',' ZZZZZ',' XXXXY',' XXXXZ',
     *            ' YYYYX',' YYYYZ',' ZZZZX',' ZZZZY',' XXXYY',
     *            ' XXXZZ',' YYYXX',' YYYZZ',' ZZZXX',' ZZZYY',
     *            ' XXXYZ',' YYYXZ',' ZZZXY',' XXYYZ',' XXZZY',
     *            ' YYZZX',
     *            '    X6','    Y6','    Z6','   X5Y','   X5Z',
     *            '   Y5X','   Y5Z','   Z5X','   Z5Y','  X4Y2',
     *            '  X4Z2','  Y4X2','  Y4Z2','  Z4X2','  Z4Y2',
     *            '  X4YZ','  Y4XZ','  Z4XY','  X3Y3','  X3Z3',
     *            '  Y3Z3',' X3Y2Z',' X3Z2Y',' Y3X2Z',' Y3Z2X',
     *            ' Z3X2Y',' Z3Y2X','X2Y2Z2'/
      CHARACTER(4) :: BONDF
      DATA BONDF/' BF '/
      CHARACTER(4), DIMENSION(106) :: ATMLAB
      DATA ATMLAB/'H   ','HE  ','LI  ','BE  ','B   ','C   ',
     *            'N   ','O   ','F   ','NE  ','NA  ','MG  ',
     *            'AL  ','SI  ','P   ','S   ','CL  ','AR  ',
     *            'K   ','CA  ','SC  ','TI  ','V   ','CR  ',
     *            'MN  ','FE  ','CO  ','NI  ','CU  ','ZN  ',
     *            'GA  ','GE  ','AS  ','SE  ','BR  ','KR  ',
     *            'RB  ','SR  ','Y   ','ZR  ','NB  ','MO  ',
     *            'TC  ','RU  ','RH  ','PD  ','AG  ','CD  ',
     *            'IN  ','SN  ','SB  ','TE  ','I   ','XE  ',
     *            'CS  ','BA  ','LA  ','CE  ','PR  ','ND  ',
     *            'PM  ','SM  ','EU  ','GD  ','TB  ','DY  ',
     *            'HO  ','ER  ','TM  ','YB  ','LU  ','HF  ',
     *            'TA  ','W   ','RE  ','OS  ','IR  ','PT  ',
     *            'AU  ','HG  ','TL  ','PB  ','BI  ','PO  ',
     *            'AT  ','RN  ','FR  ','RA  ','AC  ','TH  ',
     *            'PA  ','U   ','NP  ','PU  ','AM  ','CM  ',
     *            'BK  ','CF  ','ES  ','FM  ','MD  ','NO  ',
     *            'LR  ','RF  ','X   ','BQ  '/
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Basis Function Table
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      N = 0
      DO III = 1,NSHELL
       IAT = KATOM(III)
       J = INT(ZAN(IAT))
       IF(J<=0)THEN
        LABEL = BONDF
       ELSE
        IF(J>106)J = 106
        LABEL = ATMLAB(J)
       ENDIF
       MINI = KMIN(III)
       MAXI = KMAX(III)
       DO I = MINI,MAXI
        N = N+1
        IF(I<=35) THEN
         WRITE(UNIT=BFL,FMT='(A2,I2,A4)')LABEL,MOD(IAT,100),BFNAM1(I)
        ELSE
         WRITE(UNIT=BFL,FMT='(A2,A6)')LABEL,BFNAM2(I-35)
        END IF
        READ(UNIT=BFL,FMT='(A8)')BFLAB(N)
       END DO
      END DO
C-----------------------------------------------------------------------
      RETURN
      END

C AMT
      SUBROUTINE AMT(ZAN,ZMASS,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION, DIMENSION(106) :: AMS
      DOUBLE PRECISION, DIMENSION(NAT) :: ZAN,ZMASS,AMASS
C-----------------------------------------------------------------------
C     Mass of most abundant Isotopes
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DATA (AMS(I),I=1,106)  /
     *   1.007825D0,4.0026D0,7.01600D0,9.01218D0,11.00931D0,
     *   12.0D0,14.00307D0,15.99491D0,18.99840D0,19.99244D0,
     *   22.9898D0,23.98504D0,26.98153D0,27.97693D0,
     *   30.97376D0,31.97207D0,34.96885D0,39.948D0,
     *   38.96371D0,39.96259D0,44.95592D0,47.90D0,50.9440D0,
     *   51.9405D0,54.9381D0,55.9349D0,58.9332D0,57.9353D0,
     *   62.9298D0,63.9291D0,68.9257D0,73.9219D0,74.9216D0,
     *   79.9165D0,78.9183D0,83.9115D0,
     *   84.9117D0,87.9056D0,89.9054D0,89.9043D0,92.9060D0,
     *   97.9055D0,97.0D0,101.9037D0,102.9048D0,105.9032D0,
     *   106.9041D0,113.9036D0,114.9041D0,119.9022D0,
     *   120.9038D0,129.9067D0,126.9044D0,131.9042D0,
     *   132.9054D0,137.9052D0,138.9063D0,139.9054D0,
     *   140.9076D0,141.9077D0,144.9127D0,151.9197D0,
     *   152.9212D0,157.9241D0,158.9253D0,163.9292D0,
     *   164.9303D0,165.9303D0,168.9342D0,173.9389D0,
     *   174.9408D0,179.9465D0,180.9480D0,183.9509D0,
     *   186.9557D0,191.9615D0,192.9629D0,194.9648D0,
     *   196.9665D0,201.9706D0,
     *   204.9744D0,207.9766D0,208.9804D0,208.9824D0,
     *   209.9871D0,222.0176D0,
     *   223.0197D0,226.0254D0,
     *   227.0278D0,232.0381D0,231.0359D0,238.0508D0,
     *   237.0482D0,244.0642D0,243.0614D0,247.0703D0,
     *   247.0703D0,251.0796D0,252.0829D0,257.0751D0,
     *   258.0986D0,259.1009D0,260.1053D0,261.1087D0,
     *   2*0.0D0/
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Note: ZAN is the True Charge because this input is before ECP
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO IAT = 1,NAT
       ZNUC = ZAN(IAT)
       NUCZ = INT(ZNUC)
       IF(NUCZ>=1.and.NUCZ<=106)THEN
        AMASS(IAT) = AMS(NUCZ)
       ELSE
        AMASS(IAT) = 0.0D0
       END IF
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Returns Normal Masses
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,NAT
       ZMASS(I) = AMASS(I)
      END DO
C-----------------------------------------------------------------------
      RETURN
      END

C INRTIA
      SUBROUTINE INRTIA(C,COM,ZMASS,VMOI,NPART)
      IMPLICIT NONE
C     ARGUMENTS
      INTEGER,INTENT(IN) :: NPART
      DOUBLE PRECISION,DIMENSION(3,NPART),INTENT(IN) :: C
      DOUBLE PRECISION,DIMENSION(3,NPART),INTENT(OUT) :: COM
      DOUBLE PRECISION,DIMENSION(3),INTENT(OUT) :: VMOI
      DOUBLE PRECISION,DIMENSION(NPART),INTENT(IN) :: ZMASS
C     VARIABLES
      DOUBLE PRECISION,DIMENSION(3):: CMASS,WRK
      DOUBLE PRECISION,DIMENSION(3,3):: TROT,TMOIsq
      DOUBLE PRECISION,DIMENSION(6):: TMOI
      DOUBLE PRECISION :: XX,YY,ZZ,XY,XZ,YZ,WEIGHT,TOTWT,XC,YC,ZC
      INTEGER :: I,J
C-----------------------------------------------------------------------
C     C: Nuclear Coordinates
C     ZMASS: Nuclear Masses
C     COM: Center of Mass Coordinates
C     VMOI: Products of Inertia (Eigenvalues)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Center of Mass
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TOTWT=0.0D0
      CMASS(1)=0.0D0
      CMASS(2)=0.0D0
      CMASS(3)=0.0D0
      DO I=1,NPART
       WEIGHT=ZMASS(I)
       TOTWT=TOTWT+WEIGHT
       DO J=1,3
        CMASS(J)=CMASS(J)+WEIGHT*C(J,I)
       END DO
      END DO
      DO I=1,3
       CMASS(I)=CMASS(I)/TOTWT
      END DO
      DO I=1,NPART
       DO J=1,3
        COM(J,I) = C(J,I)-CMASS(J)
       END DO
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Moment of Inertia Tensor
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XX=0.0D0
      YY=0.0D0
      ZZ=0.0D0
      XY=0.0D0
      XZ=0.0D0
      YZ=0.0D0
      DO I=1,NPART
       WEIGHT=ZMASS(I)
       XC = COM(1,I)
       YC = COM(2,I)
       ZC = COM(3,I)
       XX = XX + WEIGHT*(YC*YC+ZC*ZC)
       YY = YY + WEIGHT*(XC*XC+ZC*ZC)
       ZZ = ZZ + WEIGHT*(XC*XC+YC*YC)
       XY = XY - WEIGHT*XC*YC
       XZ = XZ - WEIGHT*XC*ZC
       YZ = YZ - WEIGHT*YC*ZC
      END DO
      TMOI(1) = XX
      TMOI(2) = XY
      TMOI(3) = YY
      TMOI(4) = XZ
      TMOI(5) = YZ
      TMOI(6) = ZZ
C
      CALL CPYTSQ(TMOI,TMOIsq,3)            
      CALL DIAG(3,TMOIsq,TROT,VMOI,WRK)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C ENUC                                             
      DOUBLE PRECISION FUNCTION ENUC(N,Z,COORD)  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      DIMENSION Z(N),COORD(3,N)                                             
C-----------------------------------------------------------------------                                                        
      REPNUC = 0.0d0                                                     
C                                                        
      IF(N/=1)THEN
       DO I = 2,N                                             
        NI = I-1                                                    
        DO J = 1,NI                                         
         RR = 0.0d0                                                
         DO K = 1,3                                           
          RR = RR+(COORD(K,I)-COORD(K,J))**2                            
         END DO
         IF(RR/=0.0d0) REPNUC = REPNUC + Z(I)*Z(J)/SQRT(RR)        
        END DO
       END DO
      END IF                                                        
C
      IF(EFLDL)THEN                                                   
       ANUCF = 0.0d0                                                   
       DO J = 1,N                                                 
        DO I = 1,3                                              
         ANUCF = ANUCF - EVEC(I)*COORD(I,J)*Z(J)                      
        END DO
       END DO
       REPNUC = REPNUC + ANUCF                                        
      END IF 
C                                                           
      ENUC = REPNUC 
C-----------------------------------------------------------------------                                                                                                            
      RETURN                                                            
      END                                                               
      
!======================================================================!

C FNDGRP
      SUBROUTINE FNDGRP(GRPNAM,IEOF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*8 WORD,GRPNAM
      IEOF = 0
    1 CONTINUE
      READ(5,'(A8)',END=2)WORD
      CALL UPRCAS(WORD,8)
      IF(WORD==GRPNAM)GO TO 3
      GOTO 1
    2 CONTINUE
      IEOF = 1
    3 CONTINUE
      RETURN
      END

C UPRCAS
      SUBROUTINE UPRCAS(STRING,LENSTR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*(*) STRING
      CHARACTER*26 UCASE,LCASE
      DATA UCASE /'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA LCASE /'abcdefghijklmnopqrstuvwxyz'/
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Lower Case -> Upper Case
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,LENSTR
       IC = INDEX(LCASE,STRING(I:I))
       IF (IC>0) STRING(I:I) = UCASE(IC:IC)
      END DO
      RETURN
      END

C OPNCRD
      SUBROUTINE OPNCRD
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*1 LCONT,LEOD,LEOC
      CHARACTER*80 CARD
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUIN,LUOUT,
     *                LUERR,KOLSV
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Free format: Read from 5, output to 6
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      MAXCOL= 80
      KEOF  = 0
      KERR  = 0
      LUIN  = 5
      LUOUT = 6
      LUERR = 6
      LCONT = '>'
      LEOD  = '!'
      LEOC  = ';'
      RETURN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      END

C RDCARD
      SUBROUTINE RDCARD(ROUTIN,IEOF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL FIRST
      CHARACTER*8 ROUTIN,ROUTNE,STAR,STARS
      CHARACTER*4 KEYWRD,KCOL,KSET,KEOD,KEOC
      CHARACTER*1 LCONT,LEOD,LEOC
      CHARACTER*80 CARD
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUIN,LUOUT,
     *                LUERR,KOLSV
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC
      DATA FIRST/.TRUE./
      SAVE FIRST,MORE,STAR,STARS,KCOL,KSET,KEOD,KEOC,LASTC
C-----------------------------------------------------------------------
      IZERO = 0
      IONE = 1
      KEOF = IEOF
      IF(FIRST) THEN
       MORE=0
       STAR='   *    '
       STARS='   **   '
       KCOL='COL '
       KSET='SET '
       KEOD='EOD '
       KEOC='EOC '
       FIRST=.FALSE.
      END IF
C
      IF(MAXCOL<=0 .OR. MAXCOL>80) CALL OPNCRD
      IF(LUIN<=0 .OR. LUIN>99) CALL OPNCRD
      IF(KEOF==1) GO TO 170
         ROUTNE=ROUTIN
         KPRNT=1
         IF(KEOF==(-1)) GO TO 160
            KPRNT=2
            IF(MORE==1) GO TO 120
  105          KPRNT=0
               NSTART=MAXCOL+1
               LSTCOL=MAXCOL
               KEOF=1
               READ(LUIN,900,END=180) CARD
c               IF(LUOUT>0)WRITE(LUOUT,901) ROUTNE,CARD
               IF(ROUTNE==STAR) GO TO 118
C
C                   RECURSIVE CALLS TO GSTRNG AND DECODN WILL BE AVOIDED
C
                  NSET=0
                  NCOL=1
  112             CONTINUE
                  KEYWRD='   *'
                  LGSTR=-4
                  CALL GSTRNG(KEYWRD,LGSTR)
                  IF(KEYWRD/=KSET) GO TO 117
                     LGSTR=-4
                     CALL GSTRNG(KEYWRD,LGSTR)
                     IF(KEYWRD/=KCOL) GO TO 113
                        IERR=0
                        MAXCOL=IFIND('MAXCOL  ',IERR)
                        NSET=NSET+1
                        GO TO 112
C
  113                IF(KEYWRD/=KEOD) GO TO 114
                        LGSTR=-4
                        CALL GSTRNG(LEOD,LGSTR)
                        NSET=NSET+1
                        GO TO 112
C
  114                IF(KEYWRD/=KEOC) GO TO 115
                        LGSTR=-4
                        CALL GSTRNG(LEOC,LGSTR)
                        NSET=NSET+1
                        GO TO 112
C
  115                IF(KEYWRD/=LCONT) GO TO 117
                        LGSTR=-4
                        CALL GSTRNG(LCONT,LGSTR)
                        NSET=NSET+1
                        GO TO 112
C
  117             IF(NSET==0) GO TO 118
                     IF(LUOUT>0) WRITE(LUOUT,904)
     *                  NSET,MAXCOL,LEOD,LEOC,LCONT
                     ROUTNE=STARS
                     GO TO 105
C
  118          CONTINUE
               LASTC=0
  120       CONTINUE
C
C              CHECK FOR DATA FIELD TERMINATION
C
            MORE=1
            NSTART=LASTC+1
            LASTC=MAXCOL+1
            DO 130 N=NSTART,MAXCOL
               IF(CARD(N:N)==LEOD) LASTC=N
               IF(CARD(N:N)==LEOC) GO TO 150
  130       CONTINUE
            N=LASTC
            MORE=0
  150       LSTCOL=MIN(LASTC,N)-1
            LASTC=N
  160    CONTINUE
         IF(KPRNT==1 .AND. LUOUT>0)
     *      WRITE(LUOUT,902) ROUTNE
         IF(KPRNT==2 .AND. LUOUT>0)
     *      WRITE(LUOUT,903) NSTART,LSTCOL,ROUTNE
         KEOF=0
  170 CONTINUE
      NCOL=NSTART
      KOLSV=NCOL
      IEOF = KEOF
      RETURN
  180 CONTINUE
      NCOL=NSTART
      KOLSV=NCOL
      IEOF = KEOF
      RETURN
C
  900 FORMAT(A80)
  902 FORMAT(10X,10HREREAD AT ,A8)
  903 FORMAT(10X,8HCOLUMNS ,I2,3H - ,I2,1X,8HREAD AT ,A8)
  904 FORMAT(/6X,I2,' CARD PARAMETERS HAVE BEEN RESET --'/1X,
     *       7H  COL =,I3,3X,7H EOD = ,A4,7H EOC = ,A4,8H CONT = ,A4/)
      END

C RFIND
      FUNCTION RFIND(VARABL,IERR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*8 VARABL
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUIN,LUOUT,
     *                LUERR,KOLSV
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      KOLSV = NCOL
      KERR = IERR
      CALL DECODN(VARABL,VALUE,ISIGN,FIXPNT,FRACT,IEXPFR,ISIGNE,IEXP)
      RFIND = VALUE
      IERR = KERR
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN
      END

C DECODN
      SUBROUTINE DECODN(VARABL,VALUE,ISIGN,FIXPNT,FRACT,IEXPFR,ISIGNE
     *                 ,IEXP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL FIRST
      CHARACTER*8 VARABL
      CHARACTER*1 BLANK,PLUS,DECPT,SLASH,COMMA,EQUALS,RPAREN,TAB,
     *            MINUS,LPAREN,LETE,LETD,LETS,LETQ,LETR,LETT,
     *            NUM(10),LETTER
      CHARACTER*1 LCONT,LEOD,LEOC
      CHARACTER*80 CARD
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUIN,LUOUT,
     *                LUERR,KOLSV
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC
      DATA FIRST/.TRUE./
      SAVE FIRST,TAB,NUM,BLANK,PLUS,MINUS,DECPT,SLASH,COMMA,EQUALS,
     *     LPAREN,RPAREN,LETE,LETD,LETS,LETQ,LETR,LETT
C-----------------------------------------------------------------------
      IF(FIRST) THEN
       TAB = CHAR(9)
       NUM(1) = '0'
       NUM(2) = '1'
       NUM(3) = '2'
       NUM(4) = '3'
       NUM(5) = '4'
       NUM(6) = '5'
       NUM(7) = '6'
       NUM(8) = '7'
       NUM(9) = '8'
       NUM(10)= '9'
       BLANK = ' '
       PLUS =  '+'
       MINUS = '-'
       DECPT = '.'
       SLASH = '/'
       COMMA = ','
       EQUALS= '='
       LPAREN= '('
       RPAREN= ')'
       LETE =  'E'
       LETD  = 'D'
       LETS  = 'S'
       LETQ  = 'Q'
       LETR  = 'R'
       LETT  = 'T'
       FIRST = .FALSE.
      END IF
      TNUM=0.0D0
      ISQRT=0
  110 LSIGN=1
      ICOMMA=0
      NEWCRD=0
      X=0.0D0
      LSTERR=KERR
      KERR = 0
      NDECPT=0
      KINDST=1
      ISIGN=1
      ISIGNE=1
      VALUE=0.0D0
      FIXPNT=0.0D0
      FRACT=0.0D0
      IEXPFR=0
      IEXP=0
      LEND=0
      LAST=KOLSV
C
  120 LFIRST=0
  130 IF (NCOL>LSTCOL) GO TO 240
      LETTER=CARD(NCOL:NCOL)
      CALL UPRCAS(LETTER,1)
      IF(LETTER==PLUS  ) GO TO 170
      IF(LETTER==MINUS ) GO TO 190
      IF((LFIRST==0  .AND.  LAST<=KOLSV)  .AND.
     *   (LETTER==LETD  .OR.  LETTER==LETE)) GO TO 290
      IF(LETTER==LETE  ) GO TO 200
      IF(LETTER==LETD  ) GO TO 200
      IF(LETTER==LCONT ) GO TO 208
      IF(LETTER==COMMA ) GO TO 210
      IF(LETTER==LPAREN) GO TO 210
      IF(LETTER==RPAREN) GO TO 210
      IF(LETTER==DECPT ) GO TO 220
      IF(LETTER==SLASH ) GO TO 230
      IF(LETTER==BLANK ) GO TO 250
      IF(LETTER==TAB  ) GO TO 250
      IF(LETTER==EQUALS) GO TO 250
      DO 140 J=1,10
      IF(LETTER==NUM(J)) GO TO 150
  140 CONTINUE
      LAST=NCOL
      IF(LETTER/=LETS) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LETQ) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LETR) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LETT) GO TO 290
      LAST=LAST+1
      IF(CARD(LAST:LAST)/=LPAREN) GO TO 290
      NCOL=LAST+1
      ISQRT=1
      GO TO 130
C
  150 IF (LFIRST==0) LFIRST=NCOL
      IF(NCOL==MAXCOL) NEWCRD=1
  160 LEND=1
  170 NCOL=NCOL+1
      GO TO 130
C
  180 IF (LEND>0) GO TO 350
      GO TO 170
C
  190 LSIGN=-1
      GO TO 170
C
  200 IF (LFIRST/=0) GO TO 260
      IF (LEND==0) FIXPNT=1.0D0
      IF (CARD(NCOL+1:NCOL+1)==BLANK) NCOL=NCOL+1
      LSIGN=1
      KINDST=3
      GO TO 160
C
  208 NEWCRD=1
      IF(LFIRST/=0) GO TO 260
      IF(LEND>0) GO TO 350
      CALL RDCARD('   *    ',KEOF)
      NEWCRD=0
      GO TO 130
C
  210 ICOMMA=1
      IF(LFIRST/=0) GO TO 260
      GO TO 350
C
  220 CONTINUE
      IF(NDECPT>1) GO TO 290
      NDECPT=NDECPT+1
      IF (LFIRST/=0) GO TO 260
      ISIGN=LSIGN
      KINDST=2
      GO TO 160
C
  230 IF(LFIRST/=0) GO TO 260
      TNUM=(FIXPNT+FRACT*(10.0D0**IEXPFR))*(10.0D0**(ISIGNE*IEXP))
      IF(ISIGN<0) TNUM=-TNUM
      NCOL=NCOL+1
      GO TO 110
C
  240 IF (LEND==0) NCOL=LSTCOL+1
      LEND=1
  250 IF (LFIRST==0) GO TO 180
C                  DECODE DIGIT STRING AND STORE IN X
  260 LAST=NCOL-1
      X=0.0D0
      FAC=1.0D0
  270 CONTINUE
      DO 280 J=1,10
         IF (CARD(LAST:LAST)==NUM(J)) GO TO 300
  280 CONTINUE
C
  290 CONTINUE
      IF(LSTERR/=30 .AND. LUOUT>0) THEN
            WRITE(LUOUT,900) VARABL,LAST
            WRITE(LUOUT,910) CARD,(I,I=1,8)
      END IF
      IF(LSTERR/=30 .AND. LUERR>0 .AND. LUOUT<0)THEN
            WRITE(LUERR,900) VARABL,LAST
            WRITE(LUERR,910) CARD,(I,I=1,8)
      END IF
      KERR = 1
      RETURN
C
  300 X=X+FAC*(J-1)
      IF (LAST==LFIRST) GO TO 310
      LAST=LAST-1
      FAC = 10.0D0 * FAC
      GO TO 270
C
  310 CONTINUE
      IF(KINDST==3) GO TO 340
         IF(KINDST==2) GO TO 330
            FIXPNT=X
            ISIGN=LSIGN
            GO TO 120
C
  330    FRACT=X
         IEXPFR=LFIRST-NCOL
         GO TO 120
C
  340 IEXP=INT(X)
      ISIGNE=LSIGN
      GO TO 120
C
  350 CONTINUE
      VALUE=(FIXPNT+FRACT*(10.0D0**IEXPFR))*(10.0D0**(ISIGNE*IEXP))
      IF(TNUM/=0.0D0) VALUE=TNUM/VALUE
      IF(ISQRT==1) VALUE=SQRT(VALUE)
      IF(ISIGN<0) VALUE=-VALUE
      NCOL=NCOL+ICOMMA
      IF(NEWCRD==1) CALL RDCARD('   *    ',KEOF)
      RETURN
C
  900 FORMAT(1X,'**** ERROR READING VARIABLE ',A8,' CHECK COLUMN',I3)
  910 FORMAT(1X,A80/1X,8('....V....',I1))
      END

C GSTRNG
      SUBROUTINE GSTRNG(STRING,LENGTH)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL FIRST
      CHARACTER*(*) STRING
      CHARACTER*1 BLANK,TAB,QUOTE,EQUAL,COMMA,LPAREN
      CHARACTER*1 LCONT,LEOD,LEOC
      CHARACTER*80 CARD
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUIN,LUOUT,
     *                LUERR,KOLSV
      COMMON /FREFM2/ CARD,LCONT,LEOD,LEOC
      DATA FIRST/.TRUE./
      SAVE FIRST,BLANK,QUOTE,EQUAL,COMMA,LPAREN,TAB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      KOLSV = NCOL
      IF(FIRST) THEN
       BLANK = ' '
       QUOTE = ''''
       EQUAL = '='
       COMMA = ','
       LPAREN = '('
       TAB= CHAR(9)
       FIRST=.FALSE.
      END IF
C
  100 CONTINUE
      NOCHAR=MAX(IABS(LENGTH),4)
      NCC=0
      NBC=NOCHAR
      IF(NCOL>LSTCOL) GO TO 320
C
      LSTART=NCOL-1
      LSTOP=LSTART+NOCHAR
C
      DO 110 N=NCOL,LSTCOL
         IF(CARD(N:N)==TAB) GO TO 110
         IF(CARD(N:N)/=BLANK) GO TO 120
  110 CONTINUE
      NCOL=LSTCOL+1
      GO TO 300
C
  120 CONTINUE
      IF(CARD(N:N)/=LCONT) GO TO 130
C
         IF(STRING(1:4)=='   *') RETURN
            CALL RDCARD('   *    ',KEOF)
            GO TO 100
C
  130 CONTINUE
      NCOL=LSTOP+1
      IF(LENGTH<0) GO TO 200
      IF(LENGTH>0) GO TO 300
C
      NCOL=N
      IF(CARD(N:N)/=QUOTE) GO TO 300
C
      LSTART=NCOL-1
  140 CONTINUE
      NCOL=NCOL+1
C
      DO 150 N=NCOL,LSTCOL
         CARD(N-1:N-1)=CARD(N:N)
  150 CONTINUE
      CARD(LSTCOL:LSTCOL)=BLANK
C
      DO 160 N=NCOL,LSTCOL
         IF(CARD(N:N)==QUOTE) GO TO 170
  160 CONTINUE
      N=LSTCOL
  170 CONTINUE
      NCOL=N+1
C
      IF(NCOL<LSTCOL .AND. CARD(NCOL:NCOL)==QUOTE) GO TO 140
      LSTOP=N-1
      LENGTH=LSTOP-LSTART
      NOCHAR=MAX(LENGTH,4)
      GO TO 300
C
  200 CONTINUE
      NCOL=N
      LSTART=NCOL-1
C
      DO 210 N=NCOL,LSTCOL
         IF(CARD(N:N)==BLANK) GO TO 220
         IF(CARD(N:N)==EQUAL) GO TO 220
         IF(CARD(N:N)==COMMA) GO TO 220
         IF(CARD(N:N)==LPAREN) GO TO 220
  210 CONTINUE
      N=LSTCOL+1
  220 CONTINUE
      NCOL=N+1
      LSTOP=MIN(LSTART+NOCHAR,N-1)
C
  300 CONTINUE
      NCC=MIN(LSTOP,LSTCOL) - LSTART
      NBC=NOCHAR - NCC
      IF(NCC<=0) GO TO 320
         DO 310 N=1,NCC
            STRING(N:N)=CARD(LSTART+N:LSTART+N)
  310    CONTINUE
  320 CONTINUE
      IF(NBC==0) GO TO 340
C
         DO 330 N=1,NBC
            STRING(NCC+N:NCC+N)=BLANK
  330    CONTINUE
  340 CONTINUE
C
      IF(LENGTH<0) CALL UPRCAS(STRING,IABS(LENGTH))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN
      END

C IFIND
      FUNCTION IFIND(VARABL,IERR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*8 VARABL
      COMMON /FREFM1/ NCOL,LSTCOL,MAXCOL,KEOF,KERR,LUIN,LUOUT,
     *                LUERR,KOLSV
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      KOLSV = NCOL
      KERR = IERR
      CALL DECODN(VARABL,VALUE,ISIGN,FIXPNT,FRACT,IEXPFR,ISIGNE,IEXP)
C
      IFRACT=INT(FRACT)
      INTT=INT(FIXPNT)
      I1=10**IEXP
      I2=IEXPFR+ISIGNE*IEXP
      I3=10**IABS(I2)
      IF (ISIGNE<0) GO TO 130
C
      IF (I2<0) THEN
         I5=IFRACT/I3
      ELSE
         I5=IFRACT*I3
      END IF
C
      IFIND=ISIGN*(INTT*I1+I5)
      IERR = KERR
      RETURN
C
  130 IFIND=ISIGN*INTT/I1
      IERR = KERR
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      RETURN
      END

!======================================================================!
!                                                                      !
!   NAMELIST_NOFINP: Preset values for the NOFINP namelist variables.  !
!   OUTPUTHEADER: Write the Input NOF Options                          !
!   OPENFILES: Open all general working files.                         ! 
!   OUTPUTBASIC: Write the basic info on the output file.              !
!                Determine also other important variables (NBFT,..)    !
!   SETNO1: Determine NO1 according to true nuclear charges if NO1=-1  !
!                                                                      !
!======================================================================!
      
C NAMELIST_NOFINP                                                     
      SUBROUTINE NAMELIST_NOFINP(IRUNTYP)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER:: IRUNTYP
C-----------------------------------------------------------------------
C                     --- NAMELIST VARIABLES ---
C-----------------------------------------------------------------------
C
C.......... MAXIT               Maximum number of OCC-SCF iterations 
C                      = 1000   (DEFAULT)
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Type of Calculation
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... ICOEF               Energy Optimization with respect to NOs

  
C                      = 0      Optimize only with respect to ONs
C                      = 1      Optimize by the ONs and NOs (DEFAULT)
C                      = 2      Optimize only by NOs keeping fixed ONs
C                      = 3      Optimize by all ONs and core-fragment 
C                               orbitals. The rest of fragment orbitals 
C                               remain frozen
C
C.......... IEINI               Calculate only the initial energy
C                      = 0      (DEFAULT)
C
C.......... NO1                 Max. index of NOs with Occupation = 1
C                      = -1     Consider Core NOs (DEFAULT)
C                      = 0      All NOs are considered
C                      = Value  User specifies how many NOs have OCC.=1
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Hartree-Fock
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... HFID                Use the Iterative Diagonalization Method 
C                               to generate the HF Orbitals
C                      = T      (DEFAULT)
C
C.......... NTHRESHEID          Convergence of the TOTAL ENERGY
C                               THRESHEID=10.0**(-NTHRESHEID)
C                      = 8      (DEFAULT)
C
C.......... MAXITID             Maximum number of external iterations 
C                      = 30     (DEFAULT)
C
C.......... KOOPMANS            Calculate IPs using Koopmans' Theorem 
C                      = 0      (DEFAULT)
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C PNOF Selection
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... IPNOF               Type of Natural Orbital Functional (NOF)
C                      = 5      PNOF5
C                      = 6      PNOF6
C                      = 7      PNOF7 (DEFAULT)
C
C.......... Ista                Use Static version of PNOF7 
C                      = 0      PNOF7 (DEFAULT)
C                      = 1      PNOF7s
C
C.......... HighSpin            Spin-uncompensated calculation type
C                      = F      (DEFAULT) Multiplet state (Ms=0)
C                      = T      High-spin uncompensated state (Ms=S)
C
C.......... NCWO                Number of coupled weakly occupied MOs 
C                               per strongly occupied = Nc -> PNOFi(Nc)
C                      = 1      NCWO = 1 (DEFAULT)
C                      = 2,3,...
C                      =-1      NCWO = NVIR/NDOC
C                               NVIR: Number of HF virtual  MOs (OCC=0)
C                               NDOC: Number of strongly occupied MOs
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Convergence Criteria in NOF calculation
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... NTHRESHL            Convergence of the Lagrange Multipliers
C                               THRESHL=10.0**(-NTHRESHL)
C                      = 4      (DEFAULT)
C
C.......... NTHRESHE            Convergence of the total energy
C                               THRESHE=10.0**(-NTHRESHE)
C                      = 8      (DEFAULT)
C
C.......... NTHRESHEC           Convergence of the total energy (ORBOPT)
C                               THRESHEC=10.0**(-NTHRESHEC)
C                      = 10     (DEFAULT)
C
C.......... NTHRESHEN           Convergence of the total energy (OCCOPT)
C                               THRESHEN=10.0**(-NTHRESHEN)
C                      = 10     (DEFAULT)
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Options for the Orbital Optimization Program (ID Method)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... NOPTORB             Number of the optimized orbitals
C                      = NBF    (DEFAULT)
C
C.......... MAXLOOP             Maximum Iteration Number for the SCF-
C                               iteration cycle in each ITCALLs 
C                      = 30     (DEFAULT)
C
C     The straightforward iterative scheme fails to converge very 
C     often due to the values of some off-diagonal elements Fki. The 
C     latters must be suffciently small and of the same order of 
C     magnitude. A variable factor scales Fki. We establish an upper
C     bound B, in such a way that when the absolute value of the 
C     matrix element Fki is greater than B, it is scaled by a factor 
C     Cki (F'ki = Cki*Fki ), as to satisfy ABS(Fki) <= B.
C
C.......... SCALING             A variable factor scales Fki
C                      = T      (DEFAULT)
C
C.......... NZEROS              B = 10.0**(1-NZEROS). 
C                               Initial number of ZEROS in Fij. The 
C                               scaling factor varies until the number 
C                               of ZEROS (.000##) is equal for all 
C                               elements Fij.
C                      = 0      B = 10.0 (DEFAULT)
C
C.......... NZEROSm             B = 10.0**(1-NZEROSm)
C                               Maximum number of zeros in Fij.
C                      = 4      B = 10.0 (DEFAULT)
C
C.......... NZEROSr             B = 10.0**(1-NZEROSr)
C                               Number of zeros in Fij to restart 
C                               automatically the calculation.
C                      = 2      B = 10.0 (DEFAULT)
C
C.......... ITZITER             Number of Iterations for constant scaling
C                      = 10     (DEFAULT)
C
C.......... DIIS                Direct Inversion in the Iterative 
C                               Subspace in the orbital optimization if 
C                               DUMEL < THDIIS every NDIIS loops
C                      = T      (DEFAULT)
C
C.......... NTHDIIS             Energy threshold to begin DIIS
C                      = 3      THDIIS = 10.0**(-NTHDIIS) (DEFAULT)
C
C.......... NDIIS               Number of considered loops to interpolate
C                               the generalized Fock matrix in the DIIS
C                      = 5      (DEFAULT)
C
C.......... PERDIIS             Periodic DIIS
C                      = T      Apply DIIS every NDIIS (DEFAULT)
C                      = F      DIIS is always applied after NDIIS
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Options for pertubative calculations
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... OIMP2               NOF - Orbital Invariant MP2
C                     = F       (DEFAULT)
C
C.......... MBPT                NOF - X (X=RPA, GW, SOSEX, etc.) MBPT 
C                     = F       (DEFAULT)
C
C.......... TUNEMBPT            NOF - X (X=RPA, GW, SOSEX, etc.) use tune Cinter and Cintra
C                     = F       (DEFAULT)
C
C.......... TDHF                True will use TD-HF instead of TD-H
C                     = F       (DEFAULT)
C
C.......... MBPTMEM             Use MBPT with large memory allocation for ERIs
C                     = T       (DEFAULT)
C
C.......... NO1PT2              Frozen MOs in perturbative calculations
C                               Maximum index of NOs with Occupation = 1
C                      = -1     = NO1 (DEFAULT)
C                      = 0      All NOs are considered
C                      = Value  User specifies how many NOs are frozen
C
C.......... SC2MCPT             SC2-MCPT perturbation theory is used to
C                               correct the PNOF5 Energy. 
C                               2 outputs: PNOF5-SC2-MCPT and PNOF5-PT2
C                     = F       (DEFAULT)
C
C.......... NEX                 Number of excluded coupled orbitals 
C                               in the PNOF5-PT2 calculation
C                      = 0      All NOs are included (DEFAULT)
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Input Options for Gamma (Occ), C and Diagonal F
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C                     --- Restart Options ---
C
C.......... RESTART             Restart from GCF file (DEFAULT=F)
C                      = F      INPUTGAMMA=0,INPUTC=0,INPUTFMIUG=0
C                      = T      INPUTGAMMA=1,INPUTC=1,INPUTFMIUG=1
C
C.......... INPUTGAMMA          Guess for GAMMA variables (ONs)
C                      = 0      Close Fermi-Dirac Distribution (DEFAULT)
C                      = 1      Input from file GCF
C
C.......... INPUTC              Guess for Coefficient matrix (NOs)
C                      = 0      Use HCORE or HF Eigenvectors (DEFAULT)
C                      = 1      Input from file GCF
C
C.......... INPUTFMIUG          Guess for Diagonal elements (FMIUG0)
C                      = 0      Use single diag. of Lagragian (DEFAULT)
C                      = 1      Input from file GCF
C
C.......... INPUTCXYZ           Nuclear Coordinates (CXYZ)
C                      = 0      Input from input file (*.inp) (DEFAULT)
C                      = 1      Input from file GCF (only if RESTART=T)
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Output Options
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... NPRINT              Output Option (DEFAULT VALUE: 0)
C                      = 0      Short Printing (Occ,Emom,Energies)
C                      = 1      Output at initial and final iterations
C                               including MOs,Pop,APSG,Lag,IPs,DMs,CJK
C                      = 2      Output everything in each iteration
C
C.......... IWRITEC             Output Option for the Coefficient matrix
C                      = 0      No output (DEFAULT)
C                      = 1      Output the Coefficient Matrix (NOs)
C
C.......... IMULPOP             Mulliken Population Analysis
C                      = 0      Not do it (DEFAULT)
C                      = 1      Do it 
C
C.......... PRINTLAG            Output Option for Lagrange Multipliers
C                      = F      No Output (DEFAULT)
C
C.......... DIAGLAG             Diagonalize Lagrange Multipliers
C                               Print new 1e- Energies, Canonical MOs, 
C                               and new diagonal elements of the 1RDM
C                      = F      Not do it (DEFAULT)
C
C.......... IEKT                IPs by Ext. Koopmans' Theorem (EKT)
C                      = 0      Not calculate the IPs
C                      = 1      Calculate ionization potentials (IPs) 
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... IAIMPAC             Write information into WFN file (UNIT 7)
C                               for THE AIMPAC PROGRAM
C                      = 0      DO NOT DO 
C                      = 1      Write INTO WFN file (DEFAULT)
C
C.......... NOUTRDM             Print OPTION for ATOMIC RDMs 
C                      = 0      NO Output (DEFAULT)
C                      = 1      Print ATOMIC RDMs IN 1DM and 2DM files
C
C.......... NTHRESHDM           THRESHDM=10.0**(-NTHRESHDM)
C                      = 6      (DEFAULT)
C
C.......... NSQT                Print OPTION for 2DM file
C                      = 1      UNforMATTED (DEFAULT)
C                      = 0      forMATTED (SEE SUBROUTINE OUTPUTRDMrc)
C
C.......... NOUTCJK             Print OPTION for CJ12 and CK12
C                      = 0      NO Output (DEFAULT)
C                      = 1      Print CJ12 and CK12 in file 'CJK'
C
C.......... NTHRESHCJK          THRESHCJK=10.0**(-NTHRESHCJK)
C                      = 6      (DEFAULT)
C
C.......... NOUTTijab           Print OPTION for Tijab
C                      = 0      NO Output (DEFAULT)
C                      = 1      Print Tijab in file 'Tijab'
C
C.......... NTHRESHTijab        THRESHTijab=10.0**(-NTHRESHTijab)
C                      = 6      (DEFAULT)
C
C.......... APSG                Open an APSG file for printing the 
C                               coefficient matrix ($VEC-$END) and the
C                               expansion coefficients of the APSG
C                               generating wavefunction.
C                      = F      Output (DEFAULT)
C
C.......... NTHAPSG             Threshold for APSG expansion coefficient
C                               THAPSG = 10.0**(-NTHAPSG)
C                      = 10     (DEFAULT)
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Optional Options
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... ORTHO               Orthogonalize the initial orbitals
C                      = F      No 
C                      = T      Yes (DEFAULT)
C
C.......... CHKORTHO            Check the Orthonormality of the MOs
C                      = F      No (DEFAULT)
C                      = T      Yes
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C Options related to Frozen coordinates in gradient computation
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... FROZEN              Is there any fixed coordinate
C                      = F      (DEFAULT)
C
C.......... IFROZEN             By pairs, what coordinate of which atom,
C                               e.g. 2,5,1,1 means "y" coordinate of
C                               atom 5 and "x" coor of atom 1 to freeze.
C                               MAXIMUM of frozen coordinates = 10
C                      = 0      (DEFAULT)
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C.......... ICGMETHOD           Define the Conjugate Gradient Method in
C                               OCCOPTr, CALTijabIsym and OPTIMIZE
C                      = 1      (DEFAULT)
C                               SUMSL: CGOCUPSUMSLr,OPTSUMSL
C                               SparseSymLinearSystem_CG
C                      = 2      Use NAG subroutines:
C                               E04DGF: OPTCGNAG,CGOCUPNAGr
C                               F11JEF: SparseSymLinearSystem_NAG
C                      = 3      LBFGS: OPTLBFGS, LBFGSOCUPr
C
C-----------------------------------------------------------------------
      NAMELIST/NOFINP/MAXIT,ICOEF,IEINI,NO1,HFID,NTHRESHEID,MAXITID,
     &                KOOPMANS,IPNOF,Ista,HighSpin,NCWO,NTHRESHL,
     &                NTHRESHE,NTHRESHEC,NTHRESHEN,NOPTORB,MAXLOOP,
     &                SCALING,NZEROS,NZEROSm,NZEROSr,ITZITER,DIIS,
     &                NTHDIIS,NDIIS,PERDIIS,SC2MCPT,NO1PT2,NEX,OIMP2,
     &                RESTART,INPUTGAMMA,INPUTC,INPUTFMIUG,INPUTCXYZ,
     &                NPRINT,IWRITEC,IMULPOP,APSG,NTHAPSG,PRINTLAG,
     &                DIAGLAG,IAIMPAC,IEKT,NOUTRDM,NTHRESHDM,NSQT,
     &                NOUTCJK,NTHRESHCJK,NOUTTijab,NTHRESHTijab,
     &                ORTHO,CHKORTHO,FROZEN,IFROZEN,ICGMETHOD,
     &                MBPT,TUNEMBPT,TDHF,MBPTMEM
C-----------------------------------------------------------------------
C     Preset values to namelist variables
C-----------------------------------------------------------------------
      MAXIT=1000

C     Type of Calculation
      ICOEF=1
      IEINI=0
      NO1=-1

C     Hartree-Fock
      HFID=.TRUE.
      NTHRESHEID=8      
      MAXITID=30
      KOOPMANS=0

C     PNOF Selection
      IPNOF=7
      Ista=0                                      ! PNOF7n            
      HighSpin=.FALSE.                            ! Multiplet      
      NCWO=1                                      ! Perfect Pairing

C     Convergence Criteria in NOF calculation
      NTHRESHL=4
      NTHRESHE=8
      NTHRESHEC=10
      NTHRESHEN=10

C     Options for the Orbital Optimization Program (ID Method)
      NOPTORB=-1                                 ! NOPTORB=NBF
      MAXLOOP=30
      SCALING=.TRUE.
      NZEROS=0
      NZEROSr=2
      NZEROSm=NTHRESHL                           ! NTHRESHL
      ITZITER=10
      DIIS=.TRUE.
      NTHDIIS=3
      NDIIS=5
      PERDIIS=.TRUE.

C     Options for pertubative calculations
      SC2MCPT=.FALSE.
      NEX=0
      NO1PT2=-1            
      OIMP2=.FALSE.
      MBPT=.FALSE.
      TUNEMBPT=.FALSE.
      MBPTMEM=.TRUE.
      TDHF=.FALSE.

C     Input Options for Gamma (Occ), C and Diagonal F
      RESTART=.FALSE.
      INPUTGAMMA=0
      INPUTC=0
      INPUTFMIUG=0
      INPUTCXYZ=0

C     Output Options
      NPRINT=0

C     for NPRINT>0
      IWRITEC=0
      IMULPOP=0
      APSG=.FALSE.
      NTHAPSG=10
      PRINTLAG=.FALSE.
      DIAGLAG=.FALSE.  ! Only in the final Output
      IAIMPAC=1
      IEKT=0           ! Only in the final Output
C
      NOUTRDM=0
      NTHRESHDM=6
      NSQT=1
C      
      NOUTCJK=0
      NTHRESHCJK=6
      NOUTTijab=0
      NTHRESHTijab=6

C     Optional Options
      ORTHO=.TRUE.
      CHKORTHO=.FALSE.

C     Frozen coordinates
      FROZEN=.FALSE.
      IFROZEN=0

C     Options for the Conjugate Gradient Method
      ICGMETHOD=1    
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     READ NAMELIST VARIABLES
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CONTINUE
#else
      REWIND(5)
#endif
      READ(5,NOFINP,END=1,ERR=1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NVWO=-1 if NE=2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NE==2.and.NCWO/=-1)THEN
       WRITE(6,3)
       NCWO=-1
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Convergence Criteria
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      THRESHEID   = 10.0**(-NTHRESHEID)
      THRESHL     = 10.0**(-NTHRESHL)
      THRESHE     = 10.0**(-NTHRESHE)
      THRESHEC    = 10.0**(-NTHRESHEC)
      THRESHEN    = 10.0**(-NTHRESHEN)
      THRESHDM    = 10.0**(-NTHRESHDM)
      THRESHCJK   = 10.0**(-NTHRESHCJK)
      THRESHTijab = 10.0**(-NTHRESHTijab)      
      THDIIS      = 10.0**(-NTHDIIS)
      THAPSG      = 10.0**(-NTHAPSG)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Force THRESHEC=1.0d-08 if larger than this value
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(THRESHEC>1.0d-08)THRESHEC=1.0d-08
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Mandatory Options with RUNTYP=OPTGEO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IRUNTYP==3)THEN
       if(HFID)then
        HFID = .FALSE.
        WRITE(6,'(/,1X,37A,/)')'!OPTGEO: HFID has been set equal FALSE'
       end if
       if(OIMP2.OR.MBPT)then      
        OIMP2 = .FALSE.
        NOUTTijab = 0
        WRITE(6,'(/,1X,50A,/)')'!OPTGEO: OIMP2 or MBPT 
     &  has been set equal FALSE'
       end if
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Restart Options
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(RESTART)THEN
       INPUTGAMMA=1
       INPUTC=1
       INPUTFMIUG=1
       INPUTCXYZ=1
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Stop if ICGMETHOD=2 to use NAG library (E04DKF,E04DGF,F11JEF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICGMETHOD==2)THEN
       WRITE(6,*)
       WRITE(6,*)'Stop: To use the NAG library you must uncomment the ',
     &           'calls to relevant routines'
       STOP
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Stop if ICOEF=2 to evaluate only the initial energy
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==2)THEN
       if(IEINI==1)then
        WRITE(6,*)'STOP: Choose ICOEF/=2 to evaluate the initial energy'
        STOP
       else
        IEINI=1          ! IEINI=1 if ICOEF=2 without stopping the code
       endif
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     STOP if ICOEF > 3
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF>3)THEN
       WRITE(6,*)'STOP: ICOEF must be 0,1,2 or 3'
       STOP
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     STOP options if IPNOF/=5 and APSG or SC2MCPT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPNOF/=5)THEN
       IF(APSG)THEN
        WRITE(6,*)'STOP: APSG=T is only valid for PNOF5'
        STOP
       ENDIF
       IF(SC2MCPT)THEN
        WRITE(6,*)'STOP: SC2-MCPT is only valid for PNOF5'
        STOP
       ENDIF
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
C-----------------------------------------------------------------------
C     Namelist Stop errors
C-----------------------------------------------------------------------
    1 WRITE(6,2)
      STOP
C-----------------------------------------------------------------------
C     Format definitions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    2 FORMAT(/2X,'**************************************',
     *       /2X,'*                                    *',
     *       /2X,'*            SORRY,                  *',
     *       /2X,'*   ERROR IN NAMELIST PARAMETERS     *',
     *       /2X,'*                                    *',
     *       /2X,'**************************************')
    3 FORMAT(/1X,'!!! Warning: In the case of two electrons,'
     &       /5X,'there is only one electron pair.',
     &       /5X,'To avoid spurious interpair contributions', 
     &       /5X,'NCWO has been set equal to -1 !!! ')
C-----------------------------------------------------------------------
      END

C OUTPUTHEADER
      SUBROUTINE OUTPUTHEADER
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     Set NZEROSm equul to NTHRESHL if NZEROSm < NTHRESHL
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SCALING)THEN
       IF(NZEROSm<NTHRESHL)THEN
        NZEROSm = NTHRESHL
        WRITE(6,'(/,6X,38A,/)')'NZEROSm has been set equal to NTHRESHL'
       ENDIF
      ENDIF
C-----------------------------------------------------------------------
C     Write NAMELIST parameters on the Output file
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,3)
      IF(ICOEF==0)THEN
       WRITE(6,4)ICOEF
      ELSEIF(ICOEF==1)THEN
       WRITE(6,51)ICOEF
       WRITE(6,6)MAXIT
      ELSEIF(ICOEF==2)THEN
       WRITE(6,52)ICOEF
       WRITE(6,6)MAXIT
      ELSEIF(ICOEF==3)THEN
       WRITE(6,53)ICOEF
       WRITE(6,6)MAXIT
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Write the Functional used
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(3<=IPNOF.and.IPNOF<=7)THEN
       WRITE(6,7)IPNOF
       if(IPNOF==7)THEN
        if(Ista==1)WRITE(6,*)
     &'Static Version of Functional PNOF7s:    (Ista)          1'
       end if
      ELSE
       WRITE(6,*)'Stop Program: Select IPNOF between 3 and 8'
       STOP
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - -
      IF(MUL>1)THEN
       IF(.NOT.(IPNOF==5.or.IPNOF==7))THEN
        WRITE(6,'(/A44)')' Stop: IPNOF must be equal 5 or 7 for MULT>1'
        STOP
       ENDIF
       IF(HighSpin)THEN
        WRITE(6,*)
     &'High-Spin State calculation Option:     (HighSpin)      T'
       ELSE
        WRITE(6,*)
     &'Spin-Multiplet, High-Spin State Option: (HighSpin)      F'
       ENDIF
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - 
      WRITE(6,*)
      IF(RESTART)THEN
       WRITE(6,*)
     &'Restart calculation Option:             (RESTART)       T'
      ELSE
       WRITE(6,*)
     &'Restart calculation Option:             (RESTART)       F'
      ENDIF
      IF(.NOT.RESTART)WRITE(6,8)INPUTGAMMA,INPUTC,INPUTFMIUG
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(HFID)THEN
       WRITE(6,85)NTHRESHEID,MAXITID,KOOPMANS
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1)THEN
       WRITE(6,9)NTHRESHL,NTHRESHE,NTHRESHEC,NTHRESHEN,MAXLOOP
      ELSEIF(ICOEF==2)THEN
       WRITE(6,9)NTHRESHL,NTHRESHE,NTHRESHEC,NTHRESHEN,MAXLOOP
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ORTHO)WRITE(6,*)
     &'Orthogonalize the initial Orbitals:     (ORTHO)         T'
      IF(CHKORTHO)WRITE(6,*)
     &'Check the orthonormality of MOs:        (CHKORTHO)      T'
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1.and.SCALING)THEN
       WRITE(6,10)NZEROS,NZEROSm,NZEROSr,ITZITER
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(.not.SCALING)THEN
       WRITE(6,*)
       WRITE(6,*)'Warning: Scaling Technique is not used !'
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1)THEN
       IF(DIIS)THEN
        WRITE(6,*)
        WRITE(6,*)
     &'DIIS technique is used in Orb. Opt.:    (DIIS)          T'
        WRITE(6,13)NTHDIIS,NDIIS
        IF(PERDIIS)THEN
         WRITE(6,*)
     &'Periodic DIIS every NDIIS:              (PERDIIS)       T'
         ELSE
          WRITE(6,*)
     &'DIIS is always applied after NDIIS      (PERDIIS)       F'
        ENDIF
       ELSE
        WRITE(6,*)
     &'DIIS Technique is not used:             (DIIS)          F'
       ENDIF
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,11)NPRINT,IWRITEC,IMULPOP,IAIMPAC,IEKT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(APSG)THEN
       WRITE(6,*)
     &'Write APSG expansion coefficient file:  (APSG)          T'
       WRITE(6,14)NTHAPSG
      ELSE
       WRITE(6,*)
     &'Write APSG expansion coefficient file:  (APSG)          F'
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==1)THEN
       IF(PRINTLAG)THEN
        WRITE(6,*)
     &'Output option for Lagrange Multipliers: (PRINTLAG)      T'
       ELSE
        WRITE(6,*)
     &'Output option for Lagrange Multipliers: (PRINTLAG)      F'
       ENDIF
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(DIAGLAG)THEN
       WRITE(6,*)
     &'Diagonalize matrix of Lag. Multipliers: (DIAGLAG)       T'
      ELSE
       WRITE(6,*)
     &'Diagonalize matrix of Lag. Multipliers: (DIAGLAG)       F'
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOUTRDM==1)WRITE(6,12)NOUTRDM,NTHRESHDM
      IF(NOUTCJK==1)WRITE(6,15)NOUTCJK,NTHRESHCJK
      IF(NOUTTijab==1)WRITE(6,16)NOUTTijab,NTHRESHTijab
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
C-----------------------------------------------------------------------
C     Format definitions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    3 FORMAT(/,' Input NOF Options',/,
     *         ' -----------------')
    4 FORMAT(
     * /1X,'Type of calculation = No Coeff. Opt.:   (ICOEF)     ',I5)
   51 FORMAT(
     * /1X,'Type of calculation = Iter-Diag-Method: (ICOEF)     ',I5)
   52 FORMAT(
     * /1X,'Type of calculation = No Occup. Opt.:   (ICOEF)     ',I5)
   53 FORMAT(
     * /1X,'Type of calculation = Fragment Calc.:   (ICOEF)     ',I5)
    6 FORMAT(
     *  1X,'Maximum Number of Occ-Coef Outer Iter.: (MAXIT)     ',I5)
    7 FORMAT(
     *  1X,'Natural Orbital Functional Selected:    (IPNOF)     ',I5)
    8 FORMAT(
     *  1X,'Guess for Gamma Matrix:                 (INPUTGAMMA)',I5,
     * /1X,'Guess for Coefficient Matrix:           (INPUTC)    ',I5,
     * /1X,'Guess for Diagonal Elements:            (INPUTFMIUG)',I5)
   85 FORMAT(
     * /1X,'Hartree-Fock Calc. using ID Method:     (HFID)', 10X,'T',
     * /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHEID)',I5,
     * /1X,'Max. Number of External Iterations:     (MAXITID)   ',I5,
     * /1X,'Ion. Potentials by Koopmans Theorem:    (KOOPMANS)  ',I5)
    9 FORMAT(
     * /1X,'Threshold Lambda Convergence=10**(-N):  (NTHRESHL)  ',I5,
     * /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHE)  ',I5,
     * /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHEC) ',I5,
     * /1X,'Threshold Energy Convergence=10**(-N):  (NTHRESHEN) ',I5,
     *//1X,'Max. Number of Inner Coef. Iterations:  (MAXLOOP)   ',I5)
   10 FORMAT(
     * /1X,'Scaling Parameters:',
     * /1X,'Initial Number of Zeros IN Fij:         (NZEROS)    ',I5,
     * /1X,'Maximum Number of Zeros IN Fij:         (NZEROSm)   ',I5,
     * /1X,'Restart Number of Zeros IN Fij:         (NZEROSr)   ',I5,
     * /1X,'Number of Iter with constant Scaling:   (ITZITER)   ',I5)
   11 FORMAT(
     * /1X,'Output Option:                          (NPRINT)    ',I5,
     * /1X,'Output the Coefficient Matrix:          (IWRITEC)   ',I5,
     * /1X,'Do a Mulliken Population Analysis:      (IMULPOP)   ',I5,
     * /1X,'Write Information into a WFN file:      (IAIMPAC)   ',I5,
     * /1X,'Calculate IPs using Ext. Koopmans Theo: (IEKT)      ',I5)
   12 FORMAT(
     * /1X,'Print atomic RDMs to files 1DM and 2DM: (NOUTRDM)   ',I5,
     * /1X,'Threshold DMs = 10.0**(-NTHRESHDM):     (NTHRESHDM) ',I5)
   13 FORMAT(
     *  1X,'Threshold to begin DIIS = 10**(-N):     (NTHDIIS)   ',I5,
     * /1X,'Number of considered Loops in DIIS:     (NDIIS)     ',I5)
   14 FORMAT(
     *  1X,'Threshold APSG Exp. Coef. = 10**(-N):   (NTHAPSG)   ',I5)
   15 FORMAT(
     * /1X,'Print CJ12 and CK12 to file CJK:        (NOUTCJK)   ',I5,
     * /1X,'Threshold CJKs = 10.0**(-NTHRESHCJK):   (NTHRESHCJK)',I5)
   16 FORMAT(
     * /1X,'Print OIMP2 Ampl. Tijab to file Tijab:  (NOUTTijab) ',I5,
     * /1X,'Threshold Tijab=10.0**(-NTHRESHTijab):  (NTHRESHTijab)',I3)
C-----------------------------------------------------------------------
      END

C OPENFILES
      SUBROUTINE OPENFILES(IRUNTYP)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     NOF Files    CONTENTS
C     ------------------------------------------------------------------
C      1  (ERI)    2e-Integrals File for 1/r12 interaction (DONTW=F)
C      2  (CGM)    Output File for CGM routines (ICGMETHOD=1,2,3)
C      3  (GCF)    GAMMA, Coefficient Matrix (C), Energies (E), FMIUG0
C      4  (BFST)   Basis Function Symbol Table
C      5           Input File
C      6           Output File
C      7  (WFN)    WFN File for AIMPAC Program
C      8  (GCFe)   GCF file corresponding to the minimum energy
C      9  (APSG)   Coefficient Matrix (C) and APSG Wavefunction of PNOF5
C     10  (FRAG)   FRAG file containing the fragment information
C     11  (CGGRAD) Output File for Optimization
C     12  (CJK)    Output File for CJ12 and CK12 (NOUTCJK)
C     13  (CND)    Output File for Non-Dynamic CK12 and MP2 amplitudes
C     14  (2DM)    Output File for atomic 2RDM (NOUTRDM)
C     15  (1DM)    Output File for atomic 1RDM (NOUTRDM)
C     16  (N2DM)   Output File for Record Number if NSQT=1
C-----------------------------------------------------------------------
C                    Open general working files
C-----------------------------------------------------------------------
      OPEN(2,FILE='CGM',STATUS='UNKNOWN',FORM='FORMATTED',
     &       ACCESS='SEQUENTIAL')
      OPEN(3,FILE='GCF',STATUS='UNKNOWN',FORM='FORMATTED',
     &       ACCESS='SEQUENTIAL')
      OPEN(4,FILE='BFST',STATUS='UNKNOWN',FORM='FORMATTED',
     &       ACCESS='SEQUENTIAL')
      IF(IAIMPAC==1)OPEN(7,FILE='WFN',STATUS='UNKNOWN',
     &                     FORM='FORMATTED',ACCESS='SEQUENTIAL')
      OPEN(8,FILE='GCFe',STATUS='UNKNOWN',FORM='FORMATTED',
     &       ACCESS='SEQUENTIAL')
      IF(APSG)OPEN(9,FILE='APSG' ,STATUS='UNKNOWN',
     &               FORM='FORMATTED',ACCESS='SEQUENTIAL')
      IF(ICOEF==3)OPEN(10,FILE='FRAG' ,STATUS='OLD',
     &                    FORM='FORMATTED',ACCESS='SEQUENTIAL')
      IF(IRUNTYP==3)OPEN(11,FILE='CGGRAD',STATUS='UNKNOWN',
     &                      FORM='FORMATTED',ACCESS='SEQUENTIAL')
      IF(NOUTCJK==1)OPEN(12,FILE='CJK',STATUS='UNKNOWN',
     &                      FORM='UNFORMATTED')
      IF(NOUTTijab==1)OPEN(13,FILE='CND',STATUS='UNKNOWN',
     &                        FORM='UNFORMATTED')
      IF(NOUTRDM==1)THEN
       if(NSQT==0)then
        OPEN(14,FILE='2DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     &          FORM='FORMATTED')
        OPEN(15,FILE='1DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     &          FORM='FORMATTED')     
       else if(NSQT==1)then
        OPEN(14,FILE='2DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     &          FORM='UNFORMATTED')
        OPEN(15,FILE='1DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     &          FORM='FORMATTED')
        OPEN(16,FILE='N2DM',STATUS='UNKNOWN',ACCESS='SEQUENTIAL',
     &          FORM='FORMATTED')
       end if
      END IF
C-----------------------------------------------------------------------
      RETURN
      END

C OUTPUTBASIC
      SUBROUTINE OUTPUTBASIC
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     NE: Number of Electrons
C     MUL: State Multiplicity
C     NCO: Number of doubly filled molecular orbitals in HF (CLOSED)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NCO = NB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NSOC: Number of strongly singly occupied MOs                      
C     NTWOPAR: 1 => Two-particle case
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NTWOPAR = 0
C     Spin-compensated
      IF( NB==(NE+MUL-1)/2 .and. NA==(NE-MUL+1)/2 )THEN
       NSOC=0  
       MSpin=0
C      Two-particle case
       IF(NB==1)NTWOPAR=1
       IF(NA/=NB)THEN
        WRITE(6,2)NA,NB
        STOP
       ENDIF
C     Spin-uncompensated [ NA = NB+MUL-1 ]
      ELSEIF( NB==(NE-MUL+1)/2. and. NA==(NE+MUL-1)/2 )THEN
       NSOC=NA-NB
       if(HighSpin)then
        MSpin=NSOC
       else
        MSpin=0
       endif
       IF(NB==0.and.NA==2)NTWOPAR=1
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
C     Number of the optimized orbitals
C     NBF: Number of Basis Functions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOPTORB==-1)NOPTORB=NBF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NO1: Number of doubly filled NOs with occupancies equal to one
C     NO1PT2: Number of doubly filled NOs in perturbative calculations
C     Stop Program if NO1 > NB or NO1PT2 >= NB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NO1>NB)THEN
       WRITE(6,3)
       STOP
      ENDIF
      IF(NO1PT2>=NB)THEN
       write(6,4)
       STOP
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     EVEC: Electric Field components
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EX.ne.0.0d0.or.EY.ne.0.0d0.or.EZ.ne.0.0d0)THEN
       EFIELDL=.TRUE.
      ELSE
       EFIELDL=.FALSE.
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
C-----------------------------------------------------------------------
C     Format definitions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c    1 FORMAT(/1X,72('-'),
c     *      //1X,'Total Number of Atoms                        =',I5,
c     *       /1X,'Total Number of Electrons                    =',I5,
c     *       /1X,'CHARGE of the Molecule                       =',I5,
c     *       /1X,'STATE Multiplicity                           =',I5,
c     *       /1X,'Total Number of Basis Set Shells             =',I5,
c     *       /1X,'Total Number of Primitive Exponents          =',I5,
c     *       /1X,'Number of Cartesian Gaussian Basis Functions =',I5,
c     *      //1X,72('-'))
    2 FORMAT(/'Spin compensated but NA (',I3,') not equal NB (',I3,')' 
     *       /' JOB ABANDONED'/)
    3 FORMAT(/,' Error: NO1 > NB (doubly filled NOs) -> Stop Program')
    4 FORMAT(/,' Error: NO1PT2 >= NB (doubly filled NOs)->Stop Program')    
C-----------------------------------------------------------------------
      END

C SETNO1
      SUBROUTINE SETNO1(IAN)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NATOMS)::IAN
C-----------------------------------------------------------------------
C     Determine NO1 (NOs with ONs equal to 1, according to the true 
C     nuclear charges if NO1=-1.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NO1= 0
      DO I=1,NATOMS
       NUCZ=IAN(I)
       IF( 1<=NUCZ.and.NUCZ<=  2)NO1i =  0          ! H-He
       IF( 3<=NUCZ.and.NUCZ<= 10)NO1i =  1          ! Li-Ne
       IF(11<=NUCZ.and.NUCZ<= 18)NO1i =  5          ! Na-Ar
       IF(19<=NUCZ.and.NUCZ<= 36)NO1i =  9          ! K-Kr
       IF(37<=NUCZ.and.NUCZ<= 49)NO1i = 18          ! Rb-In
       IF(50<=NUCZ.and.NUCZ<= 54)NO1i = 23          ! Sn-Xe
       IF(55<=NUCZ.and.NUCZ<= 71)NO1i = 27          ! Cs-Lu
       IF(72<=NUCZ.and.NUCZ<= 81)NO1i = 30          ! Hf-Tl
       IF(82<=NUCZ.and.NUCZ<= 86)NO1i = 39          ! Pb-Rn
       IF(87<=NUCZ.and.NUCZ<=109)NO1i = 43          ! Fr-Mt
       NO1 = NO1 + NO1i
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END
      
!======================================================================!
!                                                                      !
!                     Initialize Variables in RunNOF                   !
!                                                                      !
!======================================================================!

C INITr
      SUBROUTINE INITr(COEF,OVERLAP,GAMMA,FMIUG0,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA
      INTEGER::IPRINTOPT
C-----------------------------------------------------------------------
C     INPUTGAMMA=0: Initial Values for GAMMA close to Fermi-Dirac dist.
C     INPUTGAMMA=1: Read ONs on file 3 (GCF) and transform to GAMMA
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTGAMMA==0)THEN
       do i=1,ndoc
        GAMMA(i)= DACOS(DSQRT(2.0d0*0.999d0-1.0d0))
        do iw=1,ncwo-1
         ig = ndoc+(i-1)*(ncwo-1)+iw
         GAMMA(ig) = dasin(dsqrt(1.0d0/dfloat(ncwo-iw+1)))
        enddo
       enddo
      ELSEIF(INPUTGAMMA==1)THEN
       CALL READGAMMAr(GAMMA)
      ENDIF
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
C     INPUTC=0: HF Coeffcient Matrix (COEF=CHF) from HFIDr or HCORE
C     INPUTC=1: Reading on file GCF (3)
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTC==1)THEN
       CALL READCOEFMr(COEF,NSQ,NBF)
C      Orthonormalization of the input orbitals (ORTHO=T)
       if(ORTHO)then
C       Check the orthonormality of the input orbitals
        CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
C       Orthonormalize input orbitals if necessary
        if(IVIOORTHO/=0)then
         IF(IPRINTOPT==1)WRITE(6,'(A27)')' Orthogonalize the orbitals'
         CALL ORTHONORMAL(NBF,NBF,NBFT,OVERLAP,COEF,1,IPRINTOPT)
        endif
C      Check the Orthonormality of the input orbitals (CHKORTHO=T)
       elseif(CHKORTHO)then
        CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
       endif
      ENDIF
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
C     INPUTFMIUG=0: Diagonal Elements of F (FMIUG0) = Eigenvalues (E)
C     INPUTFMIUG=1: Read Diagonal Elements of F on file GCF (3)
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      IF(INPUTFMIUG==1)CALL READFMIUG0(FMIUG0,NBF,NSQ)
C-----------------------------------------------------------------------
      RETURN
      END
      
C READGAMMAr
      SUBROUTINE READGAMMAr(GAMMA)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::RO,HR
      ALLOCATE (RO(NBF5),HR(ndoc*(ncwo-1)))
C-----------------------------------------------------------------------
C     Read Occupations from the GCF file
C-----------------------------------------------------------------------
      REWIND(3)
      DO I=1,NBF5
       READ(3,'(I6,F30.16)')II,RO(I)
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Obtain GAMMAs (i=1,ndoc*ncwo=nv) from the Occupation Numbers (RO)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      do i=1,NDOC
       in = NO1+i                                     ! in=no1+1,nb
       GAMMA(i) = dacos(dsqrt(2.0d0*RO(in)-1.0d0))
       IF(NCWO/=1)THEN
        ici = (ncwo-1)*(i-1)+1
        icf = (ncwo-1)*i
        HRin = 1.0d0 - RO(in)
        HR(ici:icf) = HRin
        do iw=1,ncwo-1
         ic = (ncwo-1)*(i-1)+iw              ! ic=1,ndoc*(ncwo-1)
         ig = ndoc+ic                        ! ig=ndoc+1,ndoc*ncwo
         in = na+ncwo*(ndoc-i)+iw            ! in=na+1,na+ncwo*ndoc-1         
         if(HR(ic)>0.0d0)then
          ARGUM=sqrt(RO(in)/HR(ic))
          if(ARGUM>1.0d0)ARGUM=1.0d0
          GAMMA(ig)=asin(ARGUM)
         else 
          GAMMA(ig) = 0.0d0
         endif
         if(iw<ncwo-1)then
          do ix=1,ncwo-1-iw
           ic1 = ic+ix                       !ic < ic1 < i*(ncwo-1)
           HR(ic1) = HR(ic1) - RO(in)
          enddo
         endif
        enddo
       ENDIF
      enddo
C-----------------------------------------------------------------------
      DEALLOCATE (RO,HR)
      RETURN
      END

C READCOEFMr
      SUBROUTINE READCOEFMr(C,NSQ,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NSQ)::C
C-----------------------------------------------------------------------
      REWIND(3)
      DO I=1,NBF
       READ(3,'(I6,F30.16)')II,ROI
      ENDDO
      READ(3,'(F30.16)')SS
      DO I = 1,NSQ
       READ(3,'(I6,F30.16)')II,C(I)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C READFMIUG0
      SUBROUTINE READFMIUG0(F,NBF,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF)::F
C-----------------------------------------------------------------------
C     Read diagonal elements of the Gen Fock Operator (FMIUG)
C-----------------------------------------------------------------------
      REWIND(3)
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,ROI
      ENDDO
      READ(3,'(F30.16)')SS
      DO I = 1,NSQ+NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,F(I)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C READCXYZ
      SUBROUTINE READCXYZ(ZNUC,C,NAT,NBF,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NAT):: IZNUC
      DOUBLE PRECISION,DIMENSION(NAT):: ZNUC
      DOUBLE PRECISION,DIMENSION(3,NAT):: C
      DOUBLE PRECISION,PARAMETER:: BOHR = 0.52917724924D+00
C-----------------------------------------------------------------------
C     Read diagonal elements of the Gen Fock Operator (FMIUG)
C-----------------------------------------------------------------------
      REWIND(3)
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      READ(3,'(F30.16)')SS
      DO I = 1,NSQ+NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      DO I = 1,NBF
       READ(3,'(I6,F30.16)')II,AA
      ENDDO
      READ(3,'(I6,F30.16)')IT,AA
      READ(3,'(I6,F30.16)')IT,AA
      DO I = 1,NAT
       READ(3,'(I6,F30.16,F30.16,F30.16)')
     &  IZNUC(I),C(1,I),C(2,I),C(3,I)
      ENDDO
      C = C / BOHR
      ZNUC = REAL(IZNUC)
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                    G U E S S    S U B R O U T I N E S                !
!                                                                      !
!======================================================================!

C GuessHJK
      SUBROUTINE GuessHJK(Cxyz,H,S,EIG,VEC,BUF,IBUF,NAT,NBF,NSQ,NBFT,
     &                    NINTEGtm,NINTEGt,NREC,XINTS,NSH2,IDONTW,
     &                    INPUTC,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz                                                         
      DOUBLE PRECISION,DIMENSION(NBF) :: EIG
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUF
      INTEGER,DIMENSION(NINTEGtm) :: IBUF
      DOUBLE PRECISION,DIMENSION(NSH2) :: XINTS
      INTEGER :: IPRINTOPT
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: TKIN,DipoInt,Q
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: OCCa,OCCb,DENa,DENb
C-----------------------------------------------------------------------
C     1e Integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(TKIN(NBFT),DipoInt(3*NBFT))
      CALL OneElecInt(Cxyz,H,S,TKIN,DipoInt,NBFT,IPRINTOPT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Initial Orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(OCCa(NBF),OCCb(NBF),DENa(NBFT),DENb(NBFT),Q(NSQ))
      if(INPUTC==0)then
       CALL GuessCore(OCCa,OCCb,DENa,DENb,EIG,VEC,Q,H,S,NBF,NSQ,NBFT,
     &                IPRINTOPT)
      endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     2e- Integrals
C     NINTEGtm: Maximum numbers of distinct two-electron integrals
C     Note: NINTEGt < NINTEGtm due to the CUTOFF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL JandK(BUF,IBUF,NINTEGtm,NINTEGt,NREC,XINTS,NSH2,IDONTW,
     &           IPRINTOPT)
C-----------------------------------------------------------------------
      DEALLOCATE(TKIN,DipoInt,OCCa,OCCb,DENa,DENb,Q)
      RETURN
      END

C GuessCore
      SUBROUTINE GuessCore(OCCa,OCCb,DENa,DENb,EIG,VEC,
     &                     Q,H,S,NBF,NSQ,NBFT,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER:: IPRINTOPT
      LOGICAL HFID
      COMMON/INPNOF_INPUT_0/HFID
      COMMON/INPNOF_INPUT_1/IEINI,NTHRESHEID,MAXITID,KOOPMANS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,DIMENSION(NBF) :: OCCa,OCCb,EIG
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC,Q
      DOUBLE PRECISION,DIMENSION(NBFT) :: DENa,DENb,H,S
      DOUBLE PRECISION, ALLOCATABLE,DIMENSION(:,:) :: OVERLAP
C-----------------------------------------------------------------------
C     Initial Molecular Orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPRINTOPT==1)WRITE(6,'(A22)')' Guess for MOs = HCORE'
      CALL HCORE(EIG,H,S,VEC,Q,NBF,NBFT,NSQ)
      CALL CLENMO(VEC,NBF,NBF,1.0D-08,1.0D-05,IPRINTOPT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Orthonormalize initial MOs if necessary
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(HFID)then
       ALLOCATE(OVERLAP(NBF,NBF))
       CALL CPYTSQ(S,OVERLAP,NBF)       
       CALL CHECKORTHO(VEC,OVERLAP,IVIOORTHO,IPRINTOPT)
       if(IVIOORTHO/=0)then
        IF(IPRINTOPT==1)WRITE(6,'(A27)')' Orthogonalize the orbitals'
        CALL ORTHONORMAL(NBF,NBF,NBFT,OVERLAP,VEC,1,IPRINTOPT)
       endif
       DEALLOCATE(OVERLAP)
      endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Initial Density Matrix
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL INIDEN(VEC,OCCa,OCCb,DENa,DENb,NBF,NBFT,NSQ)
C-----------------------------------------------------------------------
      RETURN
      END

C HCORE
      SUBROUTINE HCORE(EIG,H,S,VEC,Q,NBF,NBFT,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA /NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,ZAN(100),C(3,100),
     *              IAN(100)
C-----------------------------------------------------------------------
      DOUBLE PRECISION,DIMENSION(NBF) :: EIG
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S
      DOUBLE PRECISION,DIMENSION(NSQ) :: VEC,Q
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: H0,HH,W
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: SCR,Hsq
      ALLOCATE(H0(NBFT),HH(NBFT),SCR(NBF,NBF))
C-----------------------------------------------------------------------
C         Initial orbitals by diagonalization of 1e Hamiltonian
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Q-matrix and NQMT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      H0 = S
      CALL QMTSYM(H0,VEC,Q,EIG,SCR,NBF,NBFT,NSQ) 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     HH = Q*H0*Q (H0=HCORE)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      H0 = H
      CALL TFTRI(HH,H0,Q,SCR,NQMT,NBF,NBF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Diagonalize HH (HH->Hsq)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(Hsq(NBF,NBF),W(NBF))
      CALL CPYTSQ(HH,Hsq,NBF)      
      CALL DIAG(NBF,Hsq,VEC,EIG,W)
      DEALLOCATE(Hsq,W)      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Back Transform
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL TFSQB(VEC,Q,SCR,NQMT,NBF,NBF)          
C-----------------------------------------------------------------------
      DEALLOCATE(H0,HH,SCR)
      RETURN
      END

C CLENMO                                           
      SUBROUTINE CLENMO(VEC,NAO,NMO,TOLZ,TOLE,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION VEC(NAO,NMO)                                            
      INTEGER :: IPRINTOPT
C-----------------------------------------------------------------------
      NZER = 0                                                            
      NEQU = 0                                                            
      DO J=1,NMO                                                    
       DO 1 I=1,NAO                                                 
        VAL1 = ABS(VEC(I,J))                                          
        IF(VAL1==0.0D0)GO TO 1                                  
C       Zero teeny MOs
        IF(VAL1<=TOLZ)THEN
         VEC(I,J)=0.0D0                                            
         NZER = NZER+1                                              
         GO TO 1                                                
        END IF
C       equal magnitudes for nonzero orbitals
        IF(I==NAO)GO TO 1                                      
        KMIN = I+1                                                    
        DO K=KMIN,NAO                                           
         VAL2 = ABS(VEC(K,J))                                       
         TEST = ABS(1.0d0-VAL2/VAL1)                                
         IF(TEST<=TOLE)THEN
          VEC(K,J) = SIGN(VAL1,VEC(K,J))                        
          NEQU = NEQU+1                                           
         END IF
        END DO                                                    
    1  CONTINUE                                                       
      END DO
      IF(IPRINTOPT==1)WRITE(6,10)NEQU,NZER
   10 FORMAT(I10,' MOs were matched and',I10,' equalized to zero')
C-----------------------------------------------------------------------       
      RETURN                                                            
      END                                                               
      
C INIDEN
      SUBROUTINE INIDEN(V,OCCa,OCCb,DENa,DENb,NBF,NBFT,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INFOA /NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,ZAN(100),C(3,100),
     *              IAN(100)
      CHARACTER*4,ALLOCATABLE,DIMENSION(:) :: RLABMO
      DOUBLE PRECISION,DIMENSION(NBF) :: OCCa,OCCb
      DOUBLE PRECISION,DIMENSION(NSQ) :: V
      DOUBLE PRECISION,DIMENSION(NBFT) :: DENa,DENb
      ALLOCATE(RLABMO(NBF))
C-----------------------------------------------------------------------
      IF(NA>NBF)THEN
       WRITE(6,*)'Stop: NA > NBF for initial density matrix'
       CALL ABRT
       STOP
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF( NB==(NE+MUL-1)/2 .and. NA==(NE-MUL+1)/2 )THEN     ! Closed
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL VCLR(OCCa,1,NBF)
       DO I=1,NA
        OCCa(I) = 2.0D+00      ! Occupation Numbers
       END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Symmetry (C1)
       CALL SYMMOS(RLABMO,V,NBF,NQMT,NBF)
       CALL DMTX(DENa,V,OCCa,NA,NBF,NBF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE IF( NB==(NE-MUL+1)/2. and. NA==(NE+MUL-1)/2 )THEN   ! Open
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Alpha Orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL VCLR(OCCa,1,NBF)
       DO I=1,NA
        OCCa(I) = 1.0D+00
       END DO
C      Symmetry (C1)
       CALL SYMMOS(RLABMO,V,NBF,NQMT,NBF)
       CALL DMTX(DENa,V,OCCa,NA,NBF,NBF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Beta Orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL VCLR(OCCb,1,NBF)
       DO I=1,NB
        OCCb(I) = 1.0D+00
       END DO
C      Symmetry (C1)
       CALL SYMMOS(RLABMO,V,NBF,NQMT,NBF)
       CALL DMTX(DENb,V,OCCb,NB,NBF,NBF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - -       
      END IF
C-----------------------------------------------------------------------
      DEALLOCATE(RLABMO)
      RETURN
      END

C DMTX                                             
      SUBROUTINE DMTX(D,V,X,M,N,NDIM)                                   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION D(*),V(NDIM,M),X(M)                                     
C-----------------------------------------------------------------------
      DO I = 1,N                                                    
       IJ = I*(I-1)/2                                                 
       DO J = 1,I                                                 
        IJ = IJ + 1                                                 
        DUM = 0.0D+00                                                  
        DO K = 1,M                                              
         DUM = DUM + X(K)*V(I,K)*V(J,K)                             
        END DO
        D(IJ) = DUM                                                 
       END DO
      END DO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               
     
C QMTSYM
      SUBROUTINE QMTSYM(S,WRK,Q,EE,SCR,NBF,NBFT,NSQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF) :: EE
      DOUBLE PRECISION,DIMENSION(NBFT) :: S
      DOUBLE PRECISION,DIMENSION(NSQ) :: WRK
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: Q,SCR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: WRKq
C-----------------------------------------------------------------------
C     Symmetry Adapted Orthonormal Orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      Q = 0.0D+00
      DO I=1,NBF
       Q(I,I) = 1.0D+00
      END DO
      CALL TFTRI(WRK,S,Q,SCR,NBF,NBF,NBF)
C      
      ALLOCATE(WRKq(NBF,NBF))
      CALL CPYTSQ(WRK,WRKq,NBF)            
      CALL DIAG(NBF,WRKq,Q,EE,SCR)
      DEALLOCATE(WRKq)      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Small Eigenvalues -> Eliminate eigenvectors
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      EWARN  = 1.0D-05
      QMTTOL = 1.0D-06                !  Linear Dependence Threshhold
      IRPZER=0
      DO ISALC=1,NBF
       IF(EE(ISALC)<QMTTOL)IRPZER=IRPZER+1
      END DO
C
      ESMALL= 1.0D+09
      NSMALL= 0
      NWARN = 0
      JSALC =0
      DO ISALC=1,NBF
       IF(EE(ISALC)<ESMALL)ESMALL=EE(ISALC)
       IF(EE(ISALC)<EWARN) NWARN = NWARN+1
       IF(EE(ISALC)>=QMTTOL)THEN
        JSALC=JSALC+1
        EE(JSALC)=1.0D+00/SQRT(EE(ISALC))
        DO I=1,NBF
         Q(I,JSALC)=Q(I,ISALC)
        END DO
       ELSE
        NSMALL=NSMALL+1
       END IF
      END DO
      NQMT = NBF-NSMALL
      NWARN = NWARN-NSMALL
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Canonical Orthonormal Orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO J=1,NBF
       DO I=1,NBF
        IF(J>NQMT)Q(I,J) = 0.0D+00
        Q(I,J) = Q(I,J)*EE(J)
       END DO
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Back Transform to AO Space
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRK = 0.0D+00
      DO I=1,NBF
       IDIAG = I + (I-1)*NBF
       WRK(IDIAG) = 1.0D+00
      END DO
      CALL TFSQB(Q,WRK,SCR,NBF,NBF,NBF)
C-----------------------------------------------------------------------
      RETURN
      END

C TFTRI                                            
      SUBROUTINE TFTRI(H,FMAT,TMAT,WRK,M,N,LDT) 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      DIMENSION H(*),FMAT(*),TMAT(LDT,M),WRK(N)                               
C-----------------------------------------------------------------------
C     Transform triangular matrix FMAT: H = TMAT+ * FMAT * TMAT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IJ = 0                                                            
      DO J = 1,M,5                                             
       JJMAX = MIN(M,J+4)                                      
       DO JJ=J,JJMAX                                              
        IK = 0                                                      
        DO I = 1,N                                              
         IM1 = I-1                                                
         DUM = 0.0D+00                                               
         TDUM = TMAT(I,JJ)                                           
         IF(IM1>0)THEN                                       
          DO K = 1,IM1                                      
           IK = IK+1                                          
           WRK(K) = WRK(K)+FMAT(IK)*TDUM                         
           DUM = DUM+FMAT(IK)*TMAT(K,JJ)                            
          END DO
         END IF                                                   
         IK = IK+1                                                
         WRK(I) = DUM+FMAT(IK)*TDUM                                  
        END DO
        DO I = 1,JJ                                             
         IJ = IJ+1                                                
         HIJ = DDOT(N,TMAT(1,I),1,WRK,1)                             
         IF(ABS(HIJ)<1.0D-11) HIJ = 0.0D+00                           
         H(IJ) = HIJ                                                
        END DO
       END DO
      END DO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

C TFSQB                                            
      SUBROUTINE TFSQB(V,Q,WRK,M,N,LDQV)  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION V(LDQV,M),Q(LDQV,M),WRK(N)  
C-----------------------------------------------------------------------
C     Back Transform: V = Q*V                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO J = 1,M,5
       JJMAX = MIN(M,J+4)                                      
       DO JJ=J,JJMAX                                              
        DO I = 1,N                                              
         W = DDOT(M,Q(I,1),LDQV,V(1,JJ),1)                        
         IF(ABS(W)<1.0D-11)W = 0.0D+00                               
         WRK(I)=W                                                 
        END DO
        DO I = 1,N                                              
         V(I,JJ) = WRK(I)                                         
        END DO
       END DO
      END DO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

C SYMMOS
      SUBROUTINE SYMMOS(RLABMO,V,NAO,NMO,LDQV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION V(LDQV,NMO)
      CHARACTER*4,DIMENSION(NMO) :: RLABMO
C-----------------------------------------------------------------------
      CALL STFASEd(V,LDQV,NAO,NMO)
      DO I=1,NMO
       RLABMO(I) = 'A   '
      END DO
C-----------------------------------------------------------------------
      RETURN
      END
      
C STFASEd        
      SUBROUTINE STFASEd(A,LDA,N,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,INTENT(IN) :: LDA,M,N
      DOUBLE PRECISION,DIMENSION(LDA,M),INTENT(INOUT):: A
      INTEGER:: I,J
C-----------------------------------------------------------------------      
C     SET THE PHASE OF EACH COLUMN OF A MATRIX SO THE LARGEST
C     ELEMENT IS POSITIVE
C-----------------------------------------------------------------------
      DO I = 1,M
       LARGE = IDAMAX(N,A(1,I),1)
       IF(LARGE<=0)LARGE=1
       IF(LARGE>N)LARGE=1
       IF(A(LARGE,I)<0.0D+00)THEN
        DO J = 1,N
         A(J,I) = -A(J,I)
        END DO
       END IF
      END DO
C-----------------------------------------------------------------------            
      RETURN
      END

C CPYTSQ                                           
      SUBROUTINE CPYTSQ(A,B,NA)                                    
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(*),B(NA,NA)                                           
C-----------------------------------------------------------------------    
C     ---- COPY TRIANGULAR A TO SQUARE B (NA BY NA) ----                
C-----------------------------------------------------------------------    
      IJ=1                                                              
      DO I=1,NA                                                     
       DO J=1,I                                                   
        B(I,J) = A(IJ)                                              
        B(J,I) = A(IJ)                                              
        IJ = IJ + 1                                              
       END DO
      END DO
C-----------------------------------------------------------------------    
      RETURN                                                            
      END                                                               

C VCLR                                             
      SUBROUTINE VCLR(A,INCA,N)                                         
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION A(*)                                                    
C-----------------------------------------------------------------------
C     ZERO OUT VECTOR -A-, USING INCREMENT -INCA- 
C-----------------------------------------------------------------------
      IF(INCA==1)THEN
       DO L=1,N                                                      
        A(L) = 0.0d0                                                    
       ENDDO
       RETURN                                                            
      ENDIF
      LA = 1-INCA                                                         
      DO L=1,N                                                      
       LA = LA+INCA                                                     
       A(LA) = 0.0d0                                                   
      ENDDO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               
      
!======================================================================!
!                                                                      !
!                I N T E G R A L   S U B R O U T I N E S               !
!                                                                      !
!======================================================================!

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!
!                                                                      !
!                       One Electron Integrals                         !
!                                                                      !
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!

C OneElecInt                                           
      SUBROUTINE OneElecInt(Cxyz,H,S,TKIN,DInteg,NBFT,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,                    
     *                ZAN(100),C(3,100),IAN(100)                        
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      DOUBLE PRECISION,DIMENSION(3,NAT) :: Cxyz                                                         
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S,TKIN    
      DOUBLE PRECISION,DIMENSION(3*NBFT) :: DInteg
      INTEGER :: IPRINTOPT
C-----------------------------------------------------------------------
      IF(IPRINTOPT==1)WRITE(6,'(/1X,A13/,1X,13(1H-))')'1e- integrals'
      call cpu_time(timestartoneE)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C     Nuclear Coordinates
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      do i=1,3
       C(i,1:nat) = Cxyz(i,1:nat)
      end do
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C     H, S & T integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL HSandT(H,S,TKIN,NBFT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     ECP integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
cecp      IF(1<=IECP.and.IECP<=3)CALL ECPINT(H,NBFT)  
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Add Electric Field Contribution to 1e Hamiltonian
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EFLDL)THEN
       CALL DipInt(DInteg,NBFT)
       CALL ElecFieldInt(H,DInteg,NBFT)              
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      call cpu_time(timefinishoneE)
      DeltaToneE = timefinishoneE - timestartoneE 
      IF(IPRINTOPT==1)
     & WRITE(6,'(1X,A22,F10.2)')'Time to do integrals =',DeltaToneE                                                                                                    
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

C HSandT                                           
      SUBROUTINE HSandT(H,S,TKIN,NBFT)        
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,PARAMETER :: PI212 = 1.1283791670955D0      
      LOGICAL DOBLE
      DOUBLE PRECISION,DIMENSION(NBFT) :: H,S,TKIN
      INTEGER,DIMENSION(84) :: IX,IY,IZ,JX,JY,JZ
      LOGICAL       LINEAR
      COMMON/ZMAT  /LINEAR      
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,                    
     *             ZAN(100),C(3,100),IAN(100) 
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/HERMIT/H1(55),W1(55)
      COMMON/ROOT/XXROOT,U(13),W(13),NROOTS    ! XX = XXROOT
      COMMON/SHLNRM/PNRM(84) 
      COMMON/STV   /XINTT,YINTT,ZINTT,TAA,X0X0,Y0Y0,Z0Z0,                      
     *              XIXI,YIYI,ZIZI,XJXJ,YJYJ,ZJZJ,NINI,NJNJ 
      LOGICAL                                         IIANDJJ
      COMMON/SYMIND/II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IIANDJJ            
      INTEGER,ALLOCATABLE,DIMENSION(:)::IJX,IJY,IJZ
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: Z,ESP1E,SBLK,TBLK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: VBLK,ZBLK,FT
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DIJ,XIN,YIN,ZIN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: CONI,CONJ
      ALLOCATE(IJX(784),IJY(784),IJZ(784))
      ALLOCATE(Z(NBFT),ESP1E(NBFT))
      ALLOCATE(SBLK(784),TBLK(784),VBLK(784),ZBLK(784),FT(784),DIJ(784))
      ALLOCATE(XIN(343),YIN(343),ZIN(343),CONI(84),CONJ(84))
C-----------------------------------------------------------------------
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,                           
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,                           
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,                           
     *         15, 1,15, 8, 8,                                          
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,                           
     *         22,15, 1,15, 1,22, 8, 8,15,15,                           
     *          8,                                                      
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,                           
     *         29,15, 1,15, 1,29, 8, 8,22,22,                           
     *          1,22,22,15, 8,15, 8,15/                                 
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,                           
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,                           
     *          1,29, 1, 8, 1,22,22, 1, 8,15,                           
     *          1,15, 8,15, 8,                                          
     *          1,36, 1, 8, 1,29,29, 1, 8,15,                           
     *          1,22,22, 1,15, 8,22, 8,15, 8,                           
     *         15,                                                      
     *          1,43, 1, 8, 1,36,36, 1, 8,15,                           
     *          1,29,29, 1,15, 8,29, 8,22, 1,                           
     *         22,15, 8,22,22, 8,15,15/                                 
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,                           
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,                           
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,                           
     *         15,15, 8, 8,15,                                          
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,                           
     *         15, 1,15,22,22, 8, 8,22, 8,15,                           
     *         15,                                                      
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,                           
     *         15, 1,15,29,29, 8, 8,29, 1,22,                           
     *         22, 8,15, 8,15,22,22,15/                                 
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,                           
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,                           
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,                           
     *          2, 0, 2, 1, 1,                                          
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,                           
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,                           
     *          1,                                                      
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,                           
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,                           
     *          0, 3, 3, 2, 1, 2, 1, 2/                                 
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,                           
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,                           
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,                           
     *          0, 2, 1, 2, 1,                                          
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,                           
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,                           
     *          2,                                                      
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,                           
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,                           
     *          3, 2, 1, 3, 3, 1, 2, 2/                                 
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,                           
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,                           
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,                           
     *          2, 2, 1, 1, 2,                                          
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,                           
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,                           
     *          2,                                                      
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,                           
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,                           
     *          3, 1, 2, 1, 2, 3, 3, 2/                                 
C-----------------------------------------------------------------------
C                      H, S & TKIN integrals
C-----------------------------------------------------------------------
      TOL = 20*2.30258D0     
      ZBLK = 0.0D+00
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     I SHELL                                               
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO III = 1,NSHELL                                           
       I = KATOM(III)                                                  
       XIXI = C(1,I)                                                    
       YIYI = C(2,I)                                                    
       ZIZI = C(3,I)                                                    
       I1 = KSTART(III)                                                
       I2 = I1+KNG(III)-1                                              
       LIT = KTYPE(III)                                                
       MINI = KMIN(III)                                                
       MAXI = KMAX(III)                                                
       LOCI = KLOC(III)-MINI                                     
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      J SHELL                                               
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO JJ = 1,III                                          
        J = KATOM(JJ)                                               
        XJXJ = C(1,J)                                                 
        YJYJ = C(2,J)                                                 
        ZJZJ = C(3,J)                                                 
        J1 = KSTART(JJ)                                             
        J2 = J1+KNG(JJ)-1                                           
        LJT = KTYPE(JJ)                                             
        MINJ = KMIN(JJ)                                             
        MAXJ = KMAX(JJ)                                             
        LOCJ = KLOC(JJ)-MINJ                                  
        NROOTS = (LIT+LJT-2)/2+1                                    
        RR = (XIXI-XJXJ)**2+(YIYI-YJYJ)**2+(ZIZI-ZJZJ)**2                       
        IIANDJJ = III == JJ                                          
        IJ = 0                                                      
        MAX = MAXJ                                                  
        DO I = MINI,MAXI                                        
         NXNX = IX(I)                                               
         NYNY = IY(I)                                               
         NZNZ = IZ(I)                                               
         IF (IIANDJJ) MAX = I                                       
         DO J = MINJ,MAX                                      
          IJ = IJ+1                                             
          IJX(IJ) = NXNX+JX(J)                                    
          IJY(IJ) = NYNY+JY(J)                                    
          IJZ(IJ) = NZNZ+JZ(J)                                    
          FT (IJ) = 2*(JX(J)+JY(J)+JZ(J)) + 3                   
         END DO
        END DO
        CALL VCLR( SBLK,1,IJ)                                       
        CALL VCLR( TBLK,1,IJ)                                       
        CALL VCLR( VBLK,1,IJ)                                       
        JGMAX = J2                                                  
        DO IG = I1,I2                                           
         AI = EX(IG)                                              
         ARRI = AI*RR                                             
         AXI = AI*XIXI                                              
         AYI = AI*YIYI                                              
         AZI = AI*ZIZI                                              
         CALL SETCONI(CONI,IG)                                    
         IF (IIANDJJ) JGMAX = IG                                    
         DO JG = J1,JGMAX                                     
          AJ = EX(JG)                                           
          AA = AI+AJ                                            
          AA1 = 1.0d0/AA                                          
          DUM = AJ*ARRI*AA1                                     
          IF(DUM<=TOL)THEN
           FAC = EXP(-DUM)                                       
           CALL SETCONI(CONJ,JG)                                 
           AX = (AXI+AJ*XJXJ)*AA1                                  
           AY = (AYI+AJ*YJYJ)*AA1                                  
           AZ = (AZI+AJ*ZJZJ)*AA1                                  
           DOBLE = IIANDJJ.and.IG/=JG                             
           MAX = MAXJ                                            
           NN = 0                                                
           DTWO = 1.0d0                                              
           IF(DOBLE)DTWO = 2.0D0                                   
           SPDIJ = CS(IG)*CP(JG)*FAC                               
           DO I = MINI,MAXI                                  
            IF (IIANDJJ) MAX = I                                 
            FACI=FAC*CONI(I)*PNRM(I)*DTWO                      
            NN1=NN+1                                           
            DO J = MINJ,MAX                                
             NN = NN+1                                       
             DIJ(NN)=FACI*CONJ(J)*PNRM(J)                    
            END DO
            IF(MINJ<=1.and.I>1.and.DOBLE)DIJ(NN1)=DIJ(NN1)*0.5D0+SPDIJ
           END DO
            TAA = SQRT(AA1)                                       
            T1 = -2.0D0*AJ*AJ*TAA                                   
            T2 = -0.5D0*TAA                                         
            X0X0 = AX                                               
            Y0Y0 = AY                                               
            Z0Z0 = AZ                                               
            IN = -7                                               
            DO I = 1,LIT                                      
             IN = IN+7                                          
             NINI = I                                             
             DO J = 1,LJT                                   
              JN = IN+J                                       
              NJNJ = J                                          
              CALL STVINT(H1,W1)                                     
              XIN(JN) = XINTT*TAA                              
              YIN(JN) = YINTT*TAA                              
              ZIN(JN) = ZINTT*TAA                              
              NJNJ = J+2                                        
              CALL STVINT(H1,W1)                                     
              XIN(JN+49) = XINTT*T1                            
              YIN(JN+49) = YINTT*T1                            
              ZIN(JN+49) = ZINTT*T1                            
              NJNJ = J-2                                        
              IF (NJNJ > 0) THEN                             
               CALL STVINT(H1,W1)                                  
              ELSE                                            
               XINTT = 0.0D+00                                  
               YINTT = 0.0D+00                                  
               ZINTT = 0.0D+00                                  
              END IF                                          
              N = (J-1)*(J-2)                                 
              DUM = N * T2                                    
              XIN(JN+98) = XINTT*DUM                           
              YIN(JN+98) = YINTT*DUM                           
              ZIN(JN+98) = ZINTT*DUM                           
              IF(LINEAR)THEN                                  
               NJNJ = J+1                                     
               CALL STVINT(H1,W1)                                  
               XIN(JN+147) = XINTT*TAA                       
               YIN(JN+147) = YINTT*TAA                       
               NJNJ = J-1                                     
               IF(NJNJ>0)THEN                          
                CALL STVINT(H1,W1)                               
               ELSE                                         
                XINTT = 0.0D+00                               
                YINTT = 0.0D+00                               
               END IF                                       
               XIN(JN+196) = XINTT*TAA*NJNJ                    
               YIN(JN+196) = YINTT*TAA*NJNJ                    
              END IF                                          
             END DO
            END DO
            DO I = 1,IJ                                       
             NXNX = IJX(I)                                        
             NYNY = IJY(I)                                        
             NZNZ = IJZ(I)                                        
             DUM   = XIN(NXNX)*YIN(NYNY)*ZIN(NZNZ)    
             DUM1X = (XIN(NXNX+49)+XIN(NXNX+98))*YIN(NYNY)*ZIN(NZNZ)    
             DUM1Y = (YIN(NYNY+49)+YIN(NYNY+98))*XIN(NXNX)*ZIN(NZNZ)    
             DUM1Z = (ZIN(NZNZ+49)+ZIN(NZNZ+98))*XIN(NXNX)*YIN(NYNY)    
             DUM1  = DUM1X + DUM1Y + DUM1Z                      
              SBLK(I) =  SBLK(I) + DIJ(I)* DUM                  
              TBLK(I) =  TBLK(I) + DIJ(I)*(DUM*AJ*FT(I)+DUM1) 
             IF(LINEAR)THEN                                     
              DUM2 = XIN(NXNX+147)*YIN(NYNY+196) 
     *             - XIN(NXNX+196)*YIN(NYNY+147)   
              ZBLK(I) = ZBLK(I) + DIJ(I)*DUM2*ZIN(NZNZ)         
             END IF                                             
            END DO
            DUM = PI212*AA1                                    
            DO I = 1,IJ                                    
             DIJ(I) = DIJ(I)*DUM                             
            END DO
           AAX = AA*AX                                           
           AAY = AA*AY                                           
           AAZ = AA*AZ                                           
           DO IC = 1,NAT 
            ZNUC = -ZAN(IC)                                 
            CX = C(1,IC)                                    
            CY = C(2,IC)                                    
            CZ = C(3,IC)                                    
            XXROOT = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)         
            IF (NROOTS<=3) CALL RT123                        
            IF (NROOTS==4) CALL ROOT4                        
            IF (NROOTS==5) CALL ROOT5                        
            IF (NROOTS>=6) CALL ROOT6                        
            MM = 0                                             
            DO K = 1,NROOTS                                
             UU = AA*U(K)                                    
             WW = W(K)*ZNUC                                  
             TT = 1.0d0/(AA+UU)                                
             TAA = SQRT(TT)                                  
             X0X0 = (AAX+UU*CX)*TT                             
             Y0Y0 = (AAY+UU*CY)*TT                             
             Z0Z0 = (AAZ+UU*CZ)*TT                             
             IN = -7+MM                                      
             J0 = 2                                          
             XIN(IN+8) = W1(1)                                  
             YIN(IN+8) = W1(1)
             ZIN(IN+8) = W1(1)*WW                               
             DO I = 1,LIT                                
              IN = IN+7                                    
              NINI = I                                       
              DO J = J0,LJT                            
               JN = IN+J                                 
               NJNJ = J                                    
               CALL STVINT(H1,W1)                               
               XIN(JN) = XINTT                            
               YIN(JN) = YINTT                            
               ZIN(JN) = ZINTT*WW                         
              END DO
              J0 = 1                                       
             END DO
             MM = MM+49                                      
            END DO
            DO I = 1,IJ                                    
              NXNX = IJX(I)                                     
              NYNY = IJY(I)                                     
              NZNZ = IJZ(I)                                     
              DUM = 0.0D+00                                      
              MM = 0                                          
              DO K = 1,NROOTS                             
               DUM = DUM+XIN(NXNX+MM)*YIN(NYNY+MM)*ZIN(NZNZ+MM)   
               MM = MM+49                                   
              END DO
              VBLK(I) = VBLK(I) + DUM*DIJ(I)               
             END DO
           END DO
          END IF                                             
         END DO
        END DO
        MAX = MAXJ                                                  
        NN = 0                                                      
        DO I = MINI,MAXI                                        
         LI = LOCI+I                                              
         IN = (LI*(LI-1))/2                                       
         IF (IIANDJJ) MAX = I                                       
         DO J = MINJ,MAX                                      
          LJ = LOCJ+J                                           
          JN = LJ+IN                                            
          NN = NN+1                                             
          H(JN) =  TBLK(NN) + VBLK(NN)                         
          S(JN) =  SBLK(NN)                                    
          TKIN(JN) =  TBLK(NN)                                    
          IF(LINEAR) Z(JN) = ZBLK(NN)                            
         END DO
        END DO
       END DO
      END DO
C-----------------------------------------------------------------------
      DEALLOCATE(IJX,IJY,IJZ)
      DEALLOCATE(Z,ESP1E,SBLK,TBLK,VBLK,ZBLK,FT)
      DEALLOCATE(DIJ,XIN,YIN,ZIN,CONI,CONJ)              
      RETURN                                                            
      END                                                               
                                                                       
C DipInt                                           
      SUBROUTINE DipInt(DInteg,NBFT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/ELPROP/IEMOM      
      COMMON/TRANSF/XP,YP,ZP      
      DOUBLE PRECISION,DIMENSION(3*NBFT) :: DInteg
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Dipole integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XP = 0.0d0                                                           
      YP = 0.0d0
      ZP = 0.0d0                                                        
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEMSV = IEMOM                                                  
      IEMOM = 1    
      ALLOCATE(AUX(3*784))                                                
      CALL PRCALC(DInteg,AUX,3,NBFT)                   
      IEMOM = IEMSV                                                  
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(AUX)                                                                                  
      RETURN                                                            
      END                                                               

C PRCALC                                           
      SUBROUTINE PRCALC(XVAL,WINT,NVAL,L2)                
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      PARAMETER (SQRT3 = 1.73205080756887729353D+00)
      PARAMETER (SQRT5 = 2.23606797749978969641D+00)
      PARAMETER (SQRT7 = 2.64575131106459059050D+00) 
      PARAMETER (SQRT11= 3.31662479035539984911D+00)
      LOGICAL                                         IIANDJJ
      COMMON/SYMIND/II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IIANDJJ  
      COMMON/XYZORB/TXYZ,X00,Y00,Z00,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,                    
     *             ZAN(100),C(3,100),IAN(100)                        
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      LOGICAL IIIandJJJ,NORMA,DOUBLE                                  
      DIMENSION XVAL(NVAL*L2),WINT(*)                                   
      DIMENSION DIJ(784),IJX(784),IJY(784),IJZ(784)      
      DIMENSION IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,
     *         15, 1,15, 8, 8,
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,
     *         22,15, 1,15, 1,22, 8, 8,15,15,
     *          8,
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,
     *         29,15, 1,15, 1,29, 8, 8,22,22,
     *          1,22,22,15, 8,15, 8,15/
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,
     *          1,29, 1, 8, 1,22,22, 1, 8,15,
     *          1,15, 8,15, 8,
     *          1,36, 1, 8, 1,29,29, 1, 8,15,
     *          1,22,22, 1,15, 8,22, 8,15, 8,
     *         15,
     *          1,43, 1, 8, 1,36,36, 1, 8,15,
     *          1,29,29, 1,15, 8,29, 8,22, 1,
     *         22,15, 8,22,22, 8,15,15/
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,
     *         15,15, 8, 8,15,
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,
     *         15, 1,15,22,22, 8, 8,22, 8,15,
     *         15,
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,
     *         15, 1,15,29,29, 8, 8,29, 1,22,
     *         22, 8,15, 8,15,22,22,15/
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1,
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,
     *          1,
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,
     *          0, 3, 3, 2, 1, 2, 1, 2/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1,
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,
     *          2,
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,
     *          3, 2, 1, 3, 3, 1, 2, 2/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2,
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,
     *          2,
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,
     *          3, 1, 2, 1, 2, 3, 3, 2/
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NIJ = 784*NVAL                                                    
      TOL = 20*2.30258D0
      NORMA = .TRUE.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO III=1,NSHELL                                               
       I    = KATOM(III)                                                  
       XI   = C(1,I)                                                     
       YI   = C(2,I)                                                     
       ZI   = C(3,I)                                                     
       I1   = KSTART(III)                                                 
       I2   = I1 + KNG(III) - 1                                           
       LIT  = KTYPE(III)                                                  
       MINI = KMIN(III)                                                   
       MAXI = KMAX(III)                                                   
       LOCI = KLOC(III) - MINI                                            
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                      
       DO JJ=1,III                                                   
        J    = KATOM(JJ)                                                  
        XJ   = C(1,J)                                                     
        YJ   = C(2,J)                                                     
        ZJ   = C(3,J)                                                     
        J1   = KSTART(JJ)                                                 
        J2   = J1 + KNG(JJ) - 1                                           
        LJT  = KTYPE(JJ)                                                  
        MINJ = KMIN(JJ)                                                   
        MAXJ = KMAX(JJ)                                                   
        LOCJ = KLOC(JJ) - MINJ                                            
        RR = (XI-XJ)**2 + (YI-YJ)**2 + (ZI-ZJ)**2                     
        IIIandJJJ = III==JJ                                                 
        CALL VCLR(WINT,1,NIJ)                                             
        IJ = 0                                                            
        MAX = MAXJ                                                        
        DO I=MINI,MAXI                                               
         NIX = IX(I)                                                     
         NIY = IY(I)                                                     
         NIZ = IZ(I)                                                     
         IF (IIIandJJJ) MAX = I                                             
         DO J=MINJ,MAX                                             
          IJ = IJ+1                                                   
          IJX(IJ) = NIX+JX(J)                                          
          IJY(IJ) = NIY+JY(J)                                          
          IJZ(IJ) = NIZ+JZ(J)                                          
         END DO
        END DO
C
        JGMAX = J2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                        
        DO IG=I1,I2                                                   
         AI  = EX(IG)                                                      
         CSI = CS(IG)                                                      
         CPI = CP(IG)                                                      
         CDI = CD(IG)                                                      
         CFI = CF(IG)                                                      
         CGI = CG(IG)                                                      
         CHI = CH(IG)                                                      
         CII = CI(IG)                                                      
         IF(IIIandJJJ)JGMAX = IG                                             
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         DO JG=J1,JGMAX                                                
          AJ  = EX(JG)                                                      
          CSJ = CS(JG)                                                      
          CPJ = CP(JG)                                                      
          CDJ = CD(JG)                                                      
          CFJ = CF(JG)                                                      
          CGJ = CG(JG)                                                      
          CHJ = CH(JG)                                                      
          CIJ = CI(JG)                                                      
          AA  = AI + AJ                                                     
          AA1 = 1.0d0/AA                                                      
          AX  = (AI*XI + AJ*XJ)*AA1                                         
          AY  = (AI*YI + AJ*YJ)*AA1                                         
          AZ  = (AI*ZI + AJ*ZJ)*AA1                                         
          DUM = AI*AJ*RR*AA1                                                
          IF(DUM<=TOL)THEN
           FAC = EXP(-DUM)                                                   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C          Density Factors
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           DOUBLE = IIIandJJJ.and.IG/=JG                                       
           MAX = MAXJ                                                        
           NN  = 0                                                           
           DUM1 = 0.0D+00                                                       
           DUM2 = 0.0D+00                                                       
           DO I = MINI,MAXI                                              
            IF( I==1)            DUM1 = CSI*FAC                          
            IF( I==2)            DUM1 = CPI*FAC                          
            IF( I==5)            DUM1 = CDI*FAC                          
            IF( I==8  .and.NORMA) DUM1 = DUM1*SQRT3                       
            IF( I==11)           DUM1 = CFI*FAC                          
            IF((I==14).and.NORMA) DUM1 = DUM1*SQRT5                       
            IF((I==20).and.NORMA) DUM1 = DUM1*SQRT3                       
            IF( I==21)           DUM1 = CGI*FAC                          
            IF((I==24).and.NORMA) DUM1 = DUM1*SQRT7                       
            IF((I==30).and.NORMA) DUM1 = DUM1*SQRT5/SQRT3                 
            IF((I==33).and.NORMA) DUM1 = DUM1*SQRT3                       
            IF( I==36)           DUM1 = CHI*FAC                          
            IF((I==39).and.NORMA) DUM1 = DUM1*3.0d0                       
            IF((I==45).and.NORMA) DUM1 = DUM1*SQRT7/SQRT3                 
            IF((I==51).and.NORMA) DUM1 = DUM1*SQRT3                       
            IF((I==54).and.NORMA) DUM1 = DUM1*SQRT5/SQRT3                 
            IF( I==57)           DUM1 = CII*FAC                          
            IF((I==60).and.NORMA) DUM1 = DUM1*SQRT11                      
            IF((I==66).and.NORMA) DUM1 = DUM1*3.0d0/SQRT3                 
            IF((I==72).and.NORMA) DUM1 = DUM1*SQRT3                       
            IF((I==75).and.NORMA) DUM1 = DUM1*SQRT7/(SQRT3*SQRT5)         
            IF((I==78).and.NORMA) DUM1 = DUM1*SQRT5                       
            IF((I==84).and.NORMA) DUM1 = DUM1*SQRT5/SQRT3                 
            IF(IIIandJJJ)MAX = I                                              
C---------------------------------------------------------------
            DO J = MINJ,MAX                                            
             NN = NN+1                                                   
             IF(J==1) THEN                                             
               DUM2 = DUM1*CSJ                                           
               IF(DOUBLE .and. I==1) DUM2 = DUM2 + DUM2                
               IF(DOUBLE .and. I>1) DUM2 = DUM2 + CSI*CPJ*FAC         
             ELSE IF( J==2) THEN                                       
               DUM2 = DUM1*CPJ                                           
               IF(DOUBLE) DUM2 = DUM2 + DUM2                             
             ELSE IF( J==5) THEN                                       
               DUM2 = DUM1*CDJ                                           
               IF(DOUBLE) DUM2 = DUM2 + DUM2                             
             ELSE IF((J==8).and.NORMA) THEN                             
               DUM2 = DUM2*SQRT3                                         
             ELSE IF (J==11) THEN                                      
               DUM2 = DUM1*CFJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==14).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5                                         
             ELSE IF((J==20).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF(J==21) THEN                                       
               DUM2 = DUM1*CGJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==24).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT7                                         
             ELSE IF((J==30).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5/SQRT3                                   
             ELSE IF((J==33).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF( J==36) THEN                                      
               DUM2 = DUM1*CHJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==39).and.NORMA) THEN                            
               DUM2 = DUM2*3.0d0                                         
             ELSE IF((J==45).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT7/SQRT3                                   
             ELSE IF((J==51).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF((J==54).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5/SQRT3                                   
             ELSE IF( J==57) THEN                                      
               DUM2 = DUM1*CIJ                                           
               IF (DOUBLE) DUM2 = DUM2+DUM2                              
             ELSE IF((J==60).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT11                                        
             ELSE IF((J==66).and.NORMA) THEN                            
               DUM2 = DUM2*3.0d0/SQRT3                                   
             ELSE IF((J==72).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT3                                         
             ELSE IF((J==75).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT7/(SQRT3*SQRT5)                           
             ELSE IF((J==78).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5                                         
             ELSE IF((J==84).and.NORMA) THEN                            
               DUM2 = DUM2*SQRT5/SQRT3                                   
             END IF                                                      
             DIJ(NN) = DUM2                                              
            END DO
C---------------------------------------------------------------
           END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C          Integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
           CALL INTMOM(LIT,LJT,IJ,IJX,IJY,IJZ,DIJ,WINT,AA,AX,AY,AZ)        
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
          END IF
         END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        MAX = MAXJ                                                        
        DO K=1,NVAL                                                  
         NL2 = (K-1)*L2                                                 
         NN  = (K-1)*IJ                                                 
         DO I=MINI,MAXI                                            
          LI = LOCI + I                                               
          IN = LI*(LI-1)/2 + NL2                                      
          IF (IIIandJJJ) MAX = I                                          
          DO J=MINJ,MAX                                          
           LJ = LOCJ + J                                            
           JN = LJ + IN                                             
           NN = NN+1                                                
           XVAL(JN) = WINT(NN)                                      
          END DO
         END DO
        END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END DO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               
      
C ElecFieldInt
      SUBROUTINE ElecFieldInt(H,DInteg,NBFT)   
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL EFLDL                                                  
      COMMON/EFLDC_1/EFLDL
      COMMON/EFLDC_2/EVEC(3) 
      DOUBLE PRECISION,DIMENSION(NBFT) :: H
      DOUBLE PRECISION,DIMENSION(3*NBFT) :: DInteg
C-----------------------------------------------------------------------
      WRITE(6,'(1X,A16,3F10.5)')'Electric Field =',(EVEC(I),I=1,3)                     
      IF(EVEC(1)/=0.0d0)CALL DAXPY(NBFT,EVEC(1),DInteg(1       ),1,H,1)              
      IF(EVEC(2)/=0.0d0)CALL DAXPY(NBFT,EVEC(2),DInteg(1+  NBFT),1,H,1)              
      IF(EVEC(3)/=0.0d0)CALL DAXPY(NBFT,EVEC(3),DInteg(1+2*NBFT),1,H,1)              
C----------------------------------------------------------------------- 
      RETURN                                                            
      END                                                               

C STVINT                                           
      SUBROUTINE STVINT(HH,WW)                                                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION HH(28),WW(28),MINIMO(7),MAXIMO(7)  
      COMMON/STV/XINTT,YINTT,ZINTT,TAA,X0X0,Y0Y0,Z0Z0,                      
     *           XIXI,YIYI,ZIZI,XJXJ,YJYJ,ZJZJ,NINI,NJNJ      
      DATA MINIMO /1,2,4,7,11,16,22/                                       
      DATA MAXIMO /1,3,6,10,15,21,28/                                      
C-----------------------------------------------------------------------
C     Gauss-Hermite Quadrature
C-----------------------------------------------------------------------
      XINTT = 0.0D0                                                       
      YINTT = 0.0D0                                                       
      ZINTT = 0.0D0                                                       
      NPTS = (NINI+NJNJ-2)/2+1                                              
      IMIN = MINIMO(NPTS)                                                  
      IMAX = MAXIMO(NPTS)                                                  
      DO I = IMIN,IMAX                                              
       DUM = WW(I)                                                     
       PX = DUM                                                       
       PY = DUM                                                       
       PZ = DUM                                                       
       DUM = HH(I)*TAA                                                   
       IF(NINI>1) THEN                                               
        AX = DUM+X0X0-XIXI                                              
        AY = DUM+Y0Y0-YIYI                                              
        AZ = DUM+Z0Z0-ZIZI                                              
        GO TO (16,15,14,13,12,11,10),NINI                         
   10   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   11   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   12   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   13   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   14   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
   15   PX = PX*AX                                                  
        PY = PY*AY                                                  
        PZ = PZ*AZ                                                  
       END IF                                                         
   16  CONTINUE                                                       
       IF(NJNJ>1) THEN                                               
        BX = DUM+X0X0-XJXJ                                              
        BY = DUM+Y0Y0-YJYJ                                              
        BZ = DUM+Z0Z0-ZJZJ                                              
        GO TO (27,26,25,24,23,22,21,20),NJNJ                  
   20   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   21   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   22   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   23   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   24   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   25   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
   26   PX = PX*BX                                               
        PY = PY*BY                                               
        PZ = PZ*BZ                                               
       END IF                                                         
   27  CONTINUE                                                       
       XINTT = XINTT + PX                                           
       YINTT = YINTT + PY                                           
       ZINTT = ZINTT + PZ                                           
      END DO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

C SETCONI
      SUBROUTINE SETCONI(CONI,IPP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      DIMENSION CONI(*),KARTEN(0:6)
      DATA KARTEN/1,3,6,10,15,21,28/
C-----------------------------------------------------------------------
      CONI(1) = CS(IPP)
      CALL DACOPY(KARTEN(1),CP(IPP),CONI(2),1)
      CALL DACOPY(KARTEN(2),CD(IPP),CONI(5),1)
      CALL DACOPY(KARTEN(3),CF(IPP),CONI(11),1)
      CALL DACOPY(KARTEN(4),CG(IPP),CONI(21),1)
      CALL DACOPY(KARTEN(5),CH(IPP),CONI(36),1)
      CALL DACOPY(KARTEN(6),CI(IPP),CONI(57),1)
C-----------------------------------------------------------------------
      RETURN
      END
      
C DACOPY                                           
      SUBROUTINE DACOPY(N,DA,DX,INCX)                                   
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION DX(*)                                                   
C-----------------------------------------------------------------------
C     INITIALISES A VECTOR WITH A CONSTANT: DX(I) <== DA                                                
C-----------------------------------------------------------------------
      IF(N<=0)RETURN                                                  
      IF(INCX/=1)THEN
       IX = 1                                                            
       IF(INCX<0)IX=(-N+1)*INCX + 1                                 
       DO I = 1,N                                                     
        DX(IX) = DA                                                     
        IX = IX + INCX                                                  
       END DO
       RETURN                                                            
      END IF
      M = MOD(N,7)                                                      
      IF(M/=0)THEN
       DO I = 1,M                                                     
        DX(I)=DA                                                        
       END DO
       IF(N<7)RETURN
      END IF                                             
      MP1 = M + 1                                                       
      DO I = MP1,N,7                                                 
       DX(I)=DA                                                        
       DX(I + 1)=DA                                                    
       DX(I + 2)=DA                                                    
       DX(I + 3)=DA                                                    
       DX(I + 4)=DA                                                    
       DX(I + 5)=DA                                                    
       DX(I + 6)=DA                                                    
      END DO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

Calling by HSandT & ERISPDFGHIL: RT123 (HONDO)
      SUBROUTINE RT123
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROOT  / X,U(13),W(13),NROOTS
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
      DATA R12,PIE4/2.75255128608411D-01, 7.85398163397448D-01/
      DATA R22,W22/ 2.72474487139158D+00, 9.17517095361369D-02/
      DATA R13/     1.90163509193487D-01/
      DATA R23,W23/ 1.78449274854325D+00, 1.77231492083829D-01/
      DATA R33,W33/ 5.52534374226326D+00, 5.11156880411248D-03/
C
      IF (X > 5.0D+00) GO TO 400
      IF (X > 1.0D+00) GO TO 280
      IF (X > 3.0D-07) GO TO 180
C     X IS APPROXIMATELY 0.0d0.         NROOTS=1,2, OR 3
      IF (NROOTS-2) 120,140,160
  120 RT1 = 0.5D+00 -X/5.0D+00
      WW1 = 1.0D+00 -X/3.0D+00
      RETURN
  140 RT1 = 1.30693606237085D-01 -2.90430236082028D-02 *X
      RT2 = 2.86930639376291D+00 -6.37623643058102D-01 *X
      WW1 = 6.52145154862545D-01 -1.22713621927067D-01 *X
      WW2 = 3.47854845137453D-01 -2.10619711404725D-01 *X
      RETURN
  160 RT1 = 6.03769246832797D-02 -9.28875764357368D-03 *X
      RT2 = 7.76823355931043D-01 -1.19511285527878D-01 *X
      RT3 = 6.66279971938567D+00 -1.02504611068957D+00 *X
      WW1 = 4.67913934572691D-01 -5.64876917232519D-02 *X
      WW2 = 3.60761573048137D-01 -1.49077186455208D-01 *X
      WW3 = 1.71324492379169D-01 -1.27768455150979D-01 *X
      RETURN
C     X = 0.0 TO 1.0                   NROOTS=1,2, OR 3
  180 IF (NROOTS == 3) GO TO 220
      F1 = ((((((((-8.36313918003957D-08*X+1.21222603512827D-06 )*X-
     +     1.15662609053481D-05 )*X+9.25197374512647D-05 )*X-
     +     6.40994113129432D-04 )*X+3.78787044215009D-03 )*X-
     +     1.85185172458485D-02 )*X+7.14285713298222D-02 )*X-
     +     1.99999999997023D-01 )*X+3.33333333333318D-01
      WW1 = (X+X)*F1+EXP(-X)
      IF (NROOTS == 2) GO TO 200
      RT1 = F1/(WW1-F1)
      RETURN
  200 RT1 = (((((((-2.35234358048491D-09*X+2.49173650389842D-08)*X-
     +     4.558315364581D-08)*X-2.447252174587D-06)*X+
     +     4.743292959463D-05)*X-5.33184749432408D-04 )*X+
     +     4.44654947116579D-03 )*X-2.90430236084697D-02 )*X+
     +     1.30693606237085D-01
      RT2 = (((((((-2.47404902329170D-08*X+2.36809910635906D-07)*X+
     +     1.835367736310D-06)*X-2.066168802076D-05)*X-
     +     1.345693393936D-04)*X-5.88154362858038D-05 )*X+
     +     5.32735082098139D-02 )*X-6.37623643056745D-01 )*X+
     +     2.86930639376289D+00
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      RETURN
  220 RT1 = ((((((-5.10186691538870D-10*X+2.40134415703450D-08)*X-
     +     5.01081057744427D-07 )*X+7.58291285499256D-06 )*X-
     +     9.55085533670919D-05 )*X+1.02893039315878D-03 )*X-
     +     9.28875764374337D-03 )*X+6.03769246832810D-02
      RT2 = ((((((-1.29646524960555D-08*X+7.74602292865683D-08)*X+
     +     1.56022811158727D-06 )*X-1.58051990661661D-05 )*X-
     +     3.30447806384059D-04 )*X+9.74266885190267D-03 )*X-
     +     1.19511285526388D-01 )*X+7.76823355931033D-01
      RT3 = ((((((-9.28536484109606D-09*X-3.02786290067014D-07)*X-
     +     2.50734477064200D-06 )*X-7.32728109752881D-06 )*X+
     +     2.44217481700129D-04 )*X+4.94758452357327D-02 )*X-
     +     1.02504611065774D+00 )*X+6.66279971938553D+00
      F2 = ((((((((-7.60911486098850D-08*X+1.09552870123182D-06 )*X-
     +     1.03463270693454D-05 )*X+8.16324851790106D-05 )*X-
     +     5.55526624875562D-04 )*X+3.20512054753924D-03 )*X-
     +     1.51515139838540D-02 )*X+5.55555554649585D-02 )*X-
     +     1.42857142854412D-01 )*X+1.99999999999986D-01
  240 E = EXP(-X)
      F1 = ((X+X)*F2+E)/3.0D+00
      WW1 = (X+X)*F1+E
  260 T1 = RT1/(RT1+1.0D+00)
      T2 = RT2/(RT2+1.0D+00)
      T3 = RT3/(RT3+1.0D+00)
      A2 = F2-T1*F1
      A1 = F1-T1*WW1
      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1))
      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1))
      WW1 = WW1-WW2-WW3
      RETURN
  280 IF (X > 3.0D+00) GO TO 340
C     X = 1.0 TO 3.0                   NROOTS=1,2, OR 3
      Y = X-2.0D+00
      IF (NROOTS == 3) GO TO 320
      F1 = ((((((((((-1.61702782425558D-10*Y+1.96215250865776D-09 )*Y-
     +     2.14234468198419D-08 )*Y+2.17216556336318D-07 )*Y-
     +     1.98850171329371D-06 )*Y+1.62429321438911D-05 )*Y-
     +     1.16740298039895D-04 )*Y+7.24888732052332D-04 )*Y-
     +     3.79490003707156D-03 )*Y+1.61723488664661D-02 )*Y-
     +     5.29428148329736D-02 )*Y+1.15702180856167D-01
      WW1 = (X+X)*F1+EXP(-X)
      IF (NROOTS == 2) GO TO 300
      RT1 = F1/(WW1-F1)
      RETURN
  300 RT1 = (((((((((-6.36859636616415D-12*Y+8.47417064776270D-11)*Y-
     +     5.152207846962D-10)*Y-3.846389873308D-10)*Y+
     +     8.472253388380D-08)*Y-1.85306035634293D-06 )*Y+
     +     2.47191693238413D-05 )*Y-2.49018321709815D-04 )*Y+
     +     2.19173220020161D-03 )*Y-1.63329339286794D-02 )*Y+
     +     8.68085688285261D-02
      RT2 = ((((((((( 1.45331350488343D-10*Y+2.07111465297976D-09)*Y-
     +     1.878920917404D-08)*Y-1.725838516261D-07)*Y+
     +     2.247389642339D-06)*Y+9.76783813082564D-06 )*Y-
     +     1.93160765581969D-04 )*Y-1.58064140671893D-03 )*Y+
     +     4.85928174507904D-02 )*Y-4.30761584997596D-01 )*Y+
     +     1.80400974537950D+00
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      RETURN
  320 RT1 = (((((((( 1.44687969563318D-12*Y+4.85300143926755D-12)*Y-
     +     6.55098264095516D-10 )*Y+1.56592951656828D-08 )*Y-
     +     2.60122498274734D-07 )*Y+3.86118485517386D-06 )*Y-
     +     5.13430986707889D-05 )*Y+6.03194524398109D-04 )*Y-
     +     6.11219349825090D-03 )*Y+4.52578254679079D-02
      RT2 = ((((((( 6.95964248788138D-10*Y-5.35281831445517D-09)*Y-
     +     6.745205954533D-08)*Y+1.502366784525D-06)*Y+
     +     9.923326947376D-07)*Y-3.89147469249594D-04 )*Y+
     +     7.51549330892401D-03 )*Y-8.48778120363400D-02 )*Y+
     +     5.73928229597613D-01
      RT3 = ((((((((-2.81496588401439D-10*Y+3.61058041895031D-09)*Y+
     +     4.53631789436255D-08 )*Y-1.40971837780847D-07 )*Y-
     +     6.05865557561067D-06 )*Y-5.15964042227127D-05 )*Y+
     +     3.34761560498171D-05 )*Y+5.04871005319119D-02 )*Y-
     +     8.24708946991557D-01 )*Y+4.81234667357205D+00
      F2 = ((((((((((-1.48044231072140D-10*Y+1.78157031325097D-09 )*Y-
     +     1.92514145088973D-08 )*Y+1.92804632038796D-07 )*Y-
     +     1.73806555021045D-06 )*Y+1.39195169625425D-05 )*Y-
     +     9.74574633246452D-05 )*Y+5.83701488646511D-04 )*Y-
     +     2.89955494844975D-03 )*Y+1.13847001113810D-02 )*Y-
     +     3.23446977320647D-02 )*Y+5.29428148329709D-02
      GO TO 240
C     X = 3.0 TO 5.0                   NROOTS =1,2, OR 3
  340 Y = X-4.0D+00
      IF (NROOTS == 3) GO TO 380
      F1 = ((((((((((-2.62453564772299D-11*Y+3.24031041623823D-10 )*Y-
     +     3.614965656163D-09)*Y+3.760256799971D-08)*Y-
     +     3.553558319675D-07)*Y+3.022556449731D-06)*Y-
     +     2.290098979647D-05)*Y+1.526537461148D-04)*Y-
     +     8.81947375894379D-04 )*Y+4.33207949514611D-03 )*Y-
     +     1.75257821619926D-02 )*Y+5.28406320615584D-02
      WW1 = (X+X)*F1+EXP(-X)
      IF (NROOTS == 2) GO TO 360
      RT1 = F1/(WW1-F1)
      RETURN
  360 RT1 = ((((((((-4.11560117487296D-12*Y+7.10910223886747D-11)*Y-
     +     1.73508862390291D-09 )*Y+5.93066856324744D-08 )*Y-
     +     9.76085576741771D-07 )*Y+1.08484384385679D-05 )*Y-
     +     1.12608004981982D-04 )*Y+1.16210907653515D-03 )*Y-
     +     9.89572595720351D-03 )*Y+6.12589701086408D-02
      RT2 = (((((((((-1.80555625241001D-10*Y+5.44072475994123D-10)*Y+
     +     1.603498045240D-08)*Y-1.497986283037D-07)*Y-
     +     7.017002532106D-07)*Y+1.85882653064034D-05 )*Y-
     +     2.04685420150802D-05 )*Y-2.49327728643089D-03 )*Y+
     +     3.56550690684281D-02 )*Y-2.60417417692375D-01 )*Y+
     +     1.12155283108289D+00
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      RETURN
  380 RT1 = ((((((( 1.44265709189601D-11*Y-4.66622033006074D-10)*Y+
     +     7.649155832025D-09)*Y-1.229940017368D-07)*Y+
     +     2.026002142457D-06)*Y-2.87048671521677D-05 )*Y+
     +     3.70326938096287D-04 )*Y-4.21006346373634D-03 )*Y+
     +     3.50898470729044D-02
      RT2 = ((((((((-2.65526039155651D-11*Y+1.97549041402552D-10)*Y+
     +     2.15971131403034D-09 )*Y-7.95045680685193D-08 )*Y+
     +     5.15021914287057D-07 )*Y+1.11788717230514D-05 )*Y-
     +     3.33739312603632D-04 )*Y+5.30601428208358D-03 )*Y-
     +     5.93483267268959D-02 )*Y+4.31180523260239D-01
      RT3 = ((((((((-3.92833750584041D-10*Y-4.16423229782280D-09)*Y+
     +     4.42413039572867D-08 )*Y+6.40574545989551D-07 )*Y-
     +     3.05512456576552D-06 )*Y-1.05296443527943D-04 )*Y-
     +     6.14120969315617D-04 )*Y+4.89665802767005D-02 )*Y-
     +     6.24498381002855D-01 )*Y+3.36412312243724D+00
      F2 = ((((((((((-2.36788772599074D-11*Y+2.89147476459092D-10 )*Y-
     +     3.18111322308846D-09 )*Y+3.25336816562485D-08 )*Y-
     +     3.00873821471489D-07 )*Y+2.48749160874431D-06 )*Y-
     +     1.81353179793672D-05 )*Y+1.14504948737066D-04 )*Y-
     +     6.10614987696677D-04 )*Y+2.64584212770942D-03 )*Y-
     +     8.66415899015349D-03 )*Y+1.75257821619922D-02
      GO TO 240
  400 IF (X > 15.0D+00) GO TO 560
      E = EXP(-X)
      IF (X > 10.0D+00) GO TO 480
C     X = 5.0 TO 10.0                  NROOTS =1,2, OR 3
      WW1 = (((((( 4.6897511375022D-01/X-6.9955602298985D-01)/X +
     +     5.3689283271887D-01)/X-3.2883030418398D-01)/X +
     +     2.4645596956002D-01)/X-4.9984072848436D-01)/X -
     +     3.1501078774085D-06)*E + SQRT(PIE4/X)
      F1 = (WW1-E)/(X+X)
      IF (NROOTS-2) 420,440,460
  420 RT1 = F1/(WW1-F1)
      RETURN
  440 Y = X-7.5D+00
      RT1 = (((((((((((((-1.43632730148572D-16*Y+2.38198922570405D-16)*
     +     Y+1.358319618800D-14)*Y-7.064522786879D-14)*Y-
     +     7.719300212748D-13)*Y+7.802544789997D-12)*Y+
     +     6.628721099436D-11)*Y-1.775564159743D-09)*Y+
     +     1.713828823990D-08)*Y-1.497500187053D-07)*Y+
     +     2.283485114279D-06)*Y-3.76953869614706D-05 )*Y+
     +     4.74791204651451D-04 )*Y-4.60448960876139D-03 )*Y+
     +     3.72458587837249D-02
      RT2 = (((((((((((( 2.48791622798900D-14*Y-1.36113510175724D-13)*Y-
     +     2.224334349799D-12)*Y+4.190559455515D-11)*Y-
     +     2.222722579924D-10)*Y-2.624183464275D-09)*Y+
     +     6.128153450169D-08)*Y-4.383376014528D-07)*Y-
     +     2.49952200232910D-06 )*Y+1.03236647888320D-04 )*Y-
     +     1.44614664924989D-03 )*Y+1.35094294917224D-02 )*Y-
     +     9.53478510453887D-02 )*Y+5.44765245686790D-01
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      RETURN
  460 F2 = (F1+F1+F1-E)/(X+X)
      Y = X-7.5D+00
      RT1 = ((((((((((( 5.74429401360115D-16*Y+7.11884203790984D-16)*Y-
     +     6.736701449826D-14)*Y-6.264613873998D-13)*Y+
     +     1.315418927040D-11)*Y-4.23879635610964D-11 )*Y+
     +     1.39032379769474D-09 )*Y-4.65449552856856D-08 )*Y+
     +     7.34609900170759D-07 )*Y-1.08656008854077D-05 )*Y+
     +     1.77930381549953D-04 )*Y-2.39864911618015D-03 )*Y+
     +     2.39112249488821D-02
      RT2 = ((((((((((( 1.13464096209120D-14*Y+6.99375313934242D-15)*Y-
     +     8.595618132088D-13)*Y-5.293620408757D-12)*Y-
     +     2.492175211635D-11)*Y+2.73681574882729D-09 )*Y-
     +     1.06656985608482D-08 )*Y-4.40252529648056D-07 )*Y+
     +     9.68100917793911D-06 )*Y-1.68211091755327D-04 )*Y+
     +     2.69443611274173D-03 )*Y-3.23845035189063D-02 )*Y+
     +     2.75969447451882D-01
      RT3 = (((((((((((( 6.66339416996191D-15*Y+1.84955640200794D-13)*Y-
     +     1.985141104444D-12)*Y-2.309293727603D-11)*Y+
     +     3.917984522103D-10)*Y+1.663165279876D-09)*Y-
     +     6.205591993923D-08)*Y+8.769581622041D-09)*Y+
     +     8.97224398620038D-06 )*Y-3.14232666170796D-05 )*Y-
     +     1.83917335649633D-03 )*Y+3.51246831672571D-02 )*Y-
     +     3.22335051270860D-01 )*Y+1.73582831755430D+00
      GO TO 260
C     X = 10.0 TO 15.0                 NROOTS=1,2, OR 3
  480 WW1 = (((-1.8784686463512D-01/X+2.2991849164985D-01)/X -
     +     4.9893752514047D-01)/X-2.1916512131607D-05)*E + SQRT(PIE4/X)
      F1 = (WW1-E)/(X+X)
      IF (NROOTS-2) 500,520,540
  500 RT1 = F1/(WW1-F1)
      RETURN
  520 RT1 = ((((-1.01041157064226D-05*X+1.19483054115173D-03)*X -
     +     6.73760231824074D-02)*X+1.25705571069895D+00)*X + (((-
     +     8.57609422987199D+03/X+5.91005939591842D+03)/X -
     +     1.70807677109425D+03)/X+2.64536689959503D+02)/X -
     +     2.38570496490846D+01)*E + R12/(X-R12)
      RT2 = ((( 3.39024225137123D-04*X-9.34976436343509D-02)*X -
     +     4.22216483306320D+00)*X + (((-2.08457050986847D+03/X -
     +     1.04999071905664D+03)/X+3.39891508992661D+02)/X -
     +     1.56184800325063D+02)/X+8.00839033297501D+00)*E + R22/(X-R22)
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      RETURN
  540 F2 = (F1+F1+F1-E)/(X+X)
      Y = X-12.5D+00
      RT1 = ((((((((((( 4.42133001283090D-16*Y-2.77189767070441D-15)*Y-
     +     4.084026087887D-14)*Y+5.379885121517D-13)*Y+
     +     1.882093066702D-12)*Y-8.67286219861085D-11 )*Y+
     +     7.11372337079797D-10 )*Y-3.55578027040563D-09 )*Y+
     +     1.29454702851936D-07 )*Y-4.14222202791434D-06 )*Y+
     +     8.04427643593792D-05 )*Y-1.18587782909876D-03 )*Y+
     +     1.53435577063174D-02
      RT2 = ((((((((((( 6.85146742119357D-15*Y-1.08257654410279D-14)*Y-
     +     8.579165965128D-13)*Y+6.642452485783D-12)*Y+
     +     4.798806828724D-11)*Y-1.13413908163831D-09 )*Y+
     +     7.08558457182751D-09 )*Y-5.59678576054633D-08 )*Y+
     +     2.51020389884249D-06 )*Y-6.63678914608681D-05 )*Y+
     +     1.11888323089714D-03 )*Y-1.45361636398178D-02 )*Y+
     +     1.65077877454402D-01
      RT3 = (((((((((((( 3.20622388697743D-15*Y-2.73458804864628D-14)*Y-
     +     3.157134329361D-13)*Y+8.654129268056D-12)*Y-
     +     5.625235879301D-11)*Y-7.718080513708D-10)*Y+
     +     2.064664199164D-08)*Y-1.567725007761D-07)*Y-
     +     1.57938204115055D-06 )*Y+6.27436306915967D-05 )*Y-
     +     1.01308723606946D-03 )*Y+1.13901881430697D-02 )*Y-
     +     1.01449652899450D-01 )*Y+7.77203937334739D-01
      GO TO 260
  560 IF (X > 33.0D+00) GO TO 660
C     X = 15.0 TO 33.0                 NROOTS=1,2, OR 3
      E = EXP(-X)
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -
     +     6.0156581186481D-05)*E + SQRT(PIE4/X)
      F1 = (WW1-E)/(X+X)
      IF (NROOTS-2) 580,600,620
  580 RT1 = F1/(WW1-F1)
      RETURN
  600 RT1 = ((((-1.14906395546354D-06*X+1.76003409708332D-04)*X -
     +     1.71984023644904D-02)*X-1.37292644149838D-01)*X + (-
     +     4.75742064274859D+01/X+9.21005186542857D+00)/X -
     +     2.31080873898939D-02)*E + R12/(X-R12)
      RT2 = ((( 3.64921633404158D-04*X-9.71850973831558D-02)*X -
     +     4.02886174850252D+00)*X + (-1.35831002139173D+02/X -
     +     8.66891724287962D+01)/X+2.98011277766958D+00)*E + R22/(X-R22)
      WW2 = ((F1-WW1)*RT1+F1)*(1.0D+00+RT2)/(RT2-RT1)
      WW1 = WW1-WW2
      RETURN
  620 F2 = (F1+F1+F1-E)/(X+X)
      IF (X > 20.0D+00) GO TO 640
      RT1 = ((((((-2.43270989903742D-06*X+3.57901398988359D-04)*X -
     +     2.34112415981143D-02)*X+7.81425144913975D-01)*X -
     +     1.73209218219175D+01)*X+2.43517435690398D+02)*X + (-
     +     1.97611541576986D+04/X+9.82441363463929D+03)/X -
     +     2.07970687843258D+03)*E + R13/(X-R13)
      RT2 = (((((-2.62627010965435D-04*X+3.49187925428138D-02)*X -
     +     3.09337618731880D+00)*X+1.07037141010778D+02)*X -
     +     2.36659637247087D+03)*X + ((-2.91669113681020D+06/X +
     +     1.41129505262758D+06)/X-2.91532335433779D+05)/X +
     +     3.35202872835409D+04)*E + R23/(X-R23)
      RT3 = ((((( 9.31856404738601D-05*X-2.87029400759565D-02)*X -
     +     7.83503697918455D-01)*X-1.84338896480695D+01)*X +
     +     4.04996712650414D+02)*X + (-1.89829509315154D+05/X +
     +     5.11498390849158D+04)/X-6.88145821789955D+03)*E + R33/(X-R33)
      GO TO 260
  640 RT1 = ((((-4.97561537069643D-04*X-5.00929599665316D-02)*X +
     +     1.31099142238996D+00)*X-1.88336409225481D+01)*X -
     +     6.60344754467191D+02 /X+1.64931462413877D+02)*E + R13/(X-R13)
      RT2 = ((((-4.48218898474906D-03*X-5.17373211334924D-01)*X +
     +     1.13691058739678D+01)*X-1.65426392885291D+02)*X -
     +     6.30909125686731D+03 /X+1.52231757709236D+03)*E + R23/(X-R23)
      RT3 = ((((-1.38368602394293D-02*X-1.77293428863008D+00)*X +
     +     1.73639054044562D+01)*X-3.57615122086961D+02)*X -
     +     1.45734701095912D+04 /X+2.69831813951849D+03)*E + R33/(X-R33)
      GO TO 260
C     X = 33.0 TO INFINITY             NROOTS=1,2, OR 3
  660 WW1 = SQRT(PIE4/X)
      IF (NROOTS-2) 680,700,720
  680 RT1 = 0.5D+00/(X-0.5D+00)
      RETURN
  700 IF (X > 40.0D+00) GO TO 740
      E = EXP(-X)
      RT1 = (-8.78947307498880D-01*X+1.09243702330261D+01)*E + R12/(X-
     +     R12)
      RT2 = (-9.28903924275977D+00*X+8.10642367843811D+01)*E + R22/(X-
     +     R22)
      WW2 = ( 4.46857389308400D+00*X-7.79250653461045D+01)*E + W22*WW1
      WW1 = WW1-WW2
      RETURN
  720 IF (X > 47.0D+00) GO TO 760
      E = EXP(-X)
      RT1 = ((-7.39058467995275D+00*X+3.21318352526305D+02)*X -
     +     3.99433696473658D+03)*E + R13/(X-R13)
      RT2 = ((-7.38726243906513D+01*X+3.13569966333873D+03)*X -
     +     3.86862867311321D+04)*E + R23/(X-R23)
      RT3 = ((-2.63750565461336D+02*X+1.04412168692352D+04)*X -
     +     1.28094577915394D+05)*E + R33/(X-R33)
      WW3 = ((( 1.52258947224714D-01*X-8.30661900042651D+00)*X +
     +     1.92977367967984D+02)*X-1.67787926005344D+03)*E + W33*WW1
      WW2 = (( 6.15072615497811D+01*X-2.91980647450269D+03)*X +
     +     3.80794303087338D+04)*E + W23*WW1
      WW1 = WW1-WW2-WW3
      RETURN
  740 RT1 = R12/(X-R12)
      RT2 = R22/(X-R22)
      WW2 = W22*WW1
      WW1 = WW1-WW2
      RETURN
  760 RT1 = R13/(X-R13)
      RT2 = R23/(X-R23)
      RT3 = R33/(X-R33)
      WW2 = W23*WW1
      WW3 = W33*WW1
      WW1 = WW1-WW2-WW3
      RETURN
      END

Calling by HSandT & ERISPDFGHIL: ROOT4 (HONDO)
      SUBROUTINE ROOT4
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROOT  / X,U(13),W(13),NROOTS
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
      DATA R14,PIE4/1.45303521503316D-01, 7.85398163397448D-01/
      DATA R24,W24/ 1.33909728812636D+00, 2.34479815323517D-01/
      DATA R34,W34/ 3.92696350135829D+00, 1.92704402415764D-02/
      DATA R44,W44/ 8.58863568901199D+00, 2.25229076750736D-04/
C
      IF (X > 15.0D+00) GO TO 180
      IF (X > 5.0D+00) GO TO 140
      IF (X > 1.0D+00) GO TO 120
      IF (X > 3.0D-07) GO TO 100
C     X IS APPROXIMATELY 0.0d0.                   NROOTS = 4
      RT1 = 3.48198973061471D-02 -4.09645850660395D-03 *X
      RT2 = 3.81567185080042D-01 -4.48902570656719D-02 *X
      RT3 = 1.73730726945891D+00 -2.04389090547327D-01 *X
      RT4 = 1.18463056481549D+01 -1.39368301742312D+00 *X
      WW1 = 3.62683783378362D-01 -3.13844305713928D-02 *X
      WW2 = 3.13706645877886D-01 -8.98046242557724D-02 *X
      WW3 = 2.22381034453372D-01 -1.29314370958973D-01 *X
      WW4 = 1.01228536290376D-01 -8.28299075414321D-02 *X
      RETURN
C
C     X=0.0 TO 1.0                               NROOTS = 4
  100 RT1 = ((((((-1.95309614628539D-10*X+5.19765728707592D-09)*X-
     +     1.01756452250573D-07 )*X+1.72365935872131D-06 )*X-
     +     2.61203523522184D-05 )*X+3.52921308769880D-04 )*X-
     +     4.09645850658433D-03 )*X+3.48198973061469D-02
      RT2 = (((((-1.89554881382342D-08*X+3.07583114342365D-07)*X+
     +     1.270981734393D-06)*X-1.417298563884D-04)*X+
     +     3.226979163176D-03)*X-4.48902570678178D-02 )*X+
     +     3.81567185080039D-01
      RT3 = (((((( 1.77280535300416D-09*X+3.36524958870615D-08)*X-
     +     2.58341529013893D-07 )*X-1.13644895662320D-05 )*X-
     +     7.91549618884063D-05 )*X+1.03825827346828D-02 )*X-
     +     2.04389090525137D-01 )*X+1.73730726945889D+00
      RT4 = (((((-5.61188882415248D-08*X-2.49480733072460D-07)*X+
     +     3.428685057114D-06)*X+1.679007454539D-04)*X+
     +     4.722855585715D-02)*X-1.39368301737828D+00 )*X+
     +     1.18463056481543D+01
      WW1 = ((((((-1.14649303201279D-08*X+1.88015570196787D-07)*X-
     +     2.33305875372323D-06 )*X+2.68880044371597D-05 )*X-
     +     2.94268428977387D-04 )*X+3.06548909776613D-03 )*X-
     +     3.13844305680096D-02 )*X+3.62683783378335D-01
      WW2 = ((((((((-4.11720483772634D-09*X+6.54963481852134D-08)*X-
     +     7.20045285129626D-07 )*X+6.93779646721723D-06 )*X-
     +     6.05367572016373D-05 )*X+4.74241566251899D-04 )*X-
     +     3.26956188125316D-03 )*X+1.91883866626681D-02 )*X-
     +     8.98046242565811D-02 )*X+3.13706645877886D-01
      WW3 = ((((((((-3.41688436990215D-08*X+5.07238960340773D-07)*X-
     +     5.01675628408220D-06 )*X+4.20363420922845D-05 )*X-
     +     3.08040221166823D-04 )*X+1.94431864731239D-03 )*X-
     +     1.02477820460278D-02 )*X+4.28670143840073D-02 )*X-
     +     1.29314370962569D-01 )*X+2.22381034453369D-01
      WW4 = ((((((((( 4.99660550769508D-09*X-7.94585963310120D-08)*X+
     +     8.359072409485D-07)*X-7.422369210610D-06)*X+
     +     5.763374308160D-05)*X-3.86645606718233D-04 )*X+
     +     2.18417516259781D-03 )*X-9.99791027771119D-03 )*X+
     +     3.48791097377370D-02 )*X-8.28299075413889D-02 )*X+
     +     1.01228536290376D-01
      RETURN
C
C     X= 1.0 TO 5.0                              NROOTS = 4
  120 Y = X-3.0D+00
      RT1 = (((((((((-1.48570633747284D-15*Y-1.33273068108777D-13)*Y+
     +     4.068543696670D-12)*Y-9.163164161821D-11)*Y+
     +     2.046819017845D-09)*Y-4.03076426299031D-08 )*Y+
     +     7.29407420660149D-07 )*Y-1.23118059980833D-05 )*Y+
     +     1.88796581246938D-04 )*Y-2.53262912046853D-03 )*Y+
     +     2.51198234505021D-02
      RT2 = ((((((((( 1.35830583483312D-13*Y-2.29772605964836D-12)*Y-
     +     3.821500128045D-12)*Y+6.844424214735D-10)*Y-
     +     1.048063352259D-08)*Y+1.50083186233363D-08 )*Y+
     +     3.48848942324454D-06 )*Y-1.08694174399193D-04 )*Y+
     +     2.08048885251999D-03 )*Y-2.91205805373793D-02 )*Y+
     +     2.72276489515713D-01
      RT3 = ((((((((( 5.02799392850289D-13*Y+1.07461812944084D-11)*Y-
     +     1.482277886411D-10)*Y-2.153585661215D-09)*Y+
     +     3.654087802817D-08)*Y+5.15929575830120D-07 )*Y-
     +     9.52388379435709D-06 )*Y-2.16552440036426D-04 )*Y+
     +     9.03551469568320D-03 )*Y-1.45505469175613D-01 )*Y+
     +     1.21449092319186D+00
      RT4 = (((((((((-1.08510370291979D-12*Y+6.41492397277798D-11)*Y+
     +     7.542387436125D-10)*Y-2.213111836647D-09)*Y-
     +     1.448228963549D-07)*Y-1.95670833237101D-06 )*Y-
     +     1.07481314670844D-05 )*Y+1.49335941252765D-04 )*Y+
     +     4.87791531990593D-02 )*Y-1.10559909038653D+00 )*Y+
     +     8.09502028611780D+00
      WW1 = ((((((((((-4.65801912689961D-14*Y+7.58669507106800D-13)*Y-
     +     1.186387548048D-11)*Y+1.862334710665D-10)*Y-
     +     2.799399389539D-09)*Y+4.148972684255D-08)*Y-
     +     5.933568079600D-07)*Y+8.168349266115D-06)*Y-
     +     1.08989176177409D-04 )*Y+1.41357961729531D-03 )*Y-
     +     1.87588361833659D-02 )*Y+2.89898651436026D-01
      WW2 = ((((((((((((-1.46345073267549D-14*Y+2.25644205432182D-13)*Y-
     +     3.116258693847D-12)*Y+4.321908756610D-11)*Y-
     +     5.673270062669D-10)*Y+7.006295962960D-09)*Y-
     +     8.120186517000D-08)*Y+8.775294645770D-07)*Y-
     +     8.77829235749024D-06 )*Y+8.04372147732379D-05 )*Y-
     +     6.64149238804153D-04 )*Y+4.81181506827225D-03 )*Y-
     +     2.88982669486183D-02 )*Y+1.56247249979288D-01
      WW3 = ((((((((((((( 9.06812118895365D-15*Y-1.40541322766087D-13)*
     +     Y+1.919270015269D-12)*Y-2.605135739010D-11)*Y+
     +     3.299685839012D-10)*Y-3.86354139348735D-09 )*Y+
     +     4.16265847927498D-08 )*Y-4.09462835471470D-07 )*Y+
     +     3.64018881086111D-06 )*Y-2.88665153269386D-05 )*Y+
     +     2.00515819789028D-04 )*Y-1.18791896897934D-03 )*Y+
     +     5.75223633388589D-03 )*Y-2.09400418772687D-02 )*Y+
     +     4.85368861938873D-02
      WW4 = ((((((((((((((-9.74835552342257D-16*Y+1.57857099317175D-14)*
     +     Y-2.249993780112D-13)*Y+3.173422008953D-12)*Y-
     +     4.161159459680D-11)*Y+5.021343560166D-10)*Y-
     +     5.545047534808D-09)*Y+5.554146993491D-08)*Y-
     +     4.99048696190133D-07 )*Y+3.96650392371311D-06 )*Y-
     +     2.73816413291214D-05 )*Y+1.60106988333186D-04 )*Y-
     +     7.64560567879592D-04 )*Y+2.81330044426892D-03 )*Y-
     +     7.16227030134947D-03 )*Y+9.66077262223353D-03
      RETURN
C
  140 IF (X > 10.0D+00) GO TO 160
C     X=5.0 TO 10.0                              NROOTS = 4
      Y = X-7.5D+00
      RT1 = ((((((((( 4.64217329776215D-15*Y-6.27892383644164D-15)*Y+
     +     3.462236347446D-13)*Y-2.927229355350D-11)*Y+
     +     5.090355371676D-10)*Y-9.97272656345253D-09 )*Y+
     +     2.37835295639281D-07 )*Y-4.60301761310921D-06 )*Y+
     +     8.42824204233222D-05 )*Y-1.37983082233081D-03 )*Y+
     +     1.66630865869375D-02
      RT2 = ((((((((( 2.93981127919047D-14*Y+8.47635639065744D-13)*Y-
     +     1.446314544774D-11)*Y-6.149155555753D-12)*Y+
     +     8.484275604612D-10)*Y-6.10898827887652D-08 )*Y+
     +     2.39156093611106D-06 )*Y-5.35837089462592D-05 )*Y+
     +     1.00967602595557D-03 )*Y-1.57769317127372D-02 )*Y+
     +     1.74853819464285D-01
      RT3 = (((((((((( 2.93523563363000D-14*Y-6.40041776667020D-14)*Y-
     +     2.695740446312D-12)*Y+1.027082960169D-10)*Y-
     +     5.822038656780D-10)*Y-3.159991002539D-08)*Y+
     +     4.327249251331D-07)*Y+4.856768455119D-06)*Y-
     +     2.54617989427762D-04 )*Y+5.54843378106589D-03 )*Y-
     +     7.95013029486684D-02 )*Y+7.20206142703162D-01
      RT4 = (((((((((((-1.62212382394553D-14*Y+7.68943641360593D-13)*Y+
     +     5.764015756615D-12)*Y-1.380635298784D-10)*Y-
     +     1.476849808675D-09)*Y+1.84347052385605D-08 )*Y+
     +     3.34382940759405D-07 )*Y-1.39428366421645D-06 )*Y-
     +     7.50249313713996D-05 )*Y-6.26495899187507D-04 )*Y+
     +     4.69716410901162D-02 )*Y-6.66871297428209D-01 )*Y+
     +     4.11207530217806D+00
      WW1 = ((((((((((-1.65995045235997D-15*Y+6.91838935879598D-14)*Y-
     +     9.131223418888D-13)*Y+1.403341829454D-11)*Y-
     +     3.672235069444D-10)*Y+6.366962546990D-09)*Y-
     +     1.039220021671D-07)*Y+1.959098751715D-06)*Y-
     +     3.33474893152939D-05 )*Y+5.72164211151013D-04 )*Y-
     +     1.05583210553392D-02 )*Y+2.26696066029591D-01
      WW2 = ((((((((((((-3.57248951192047D-16*Y+6.25708409149331D-15)*Y-
     +     9.657033089714D-14)*Y+1.507864898748D-12)*Y-
     +     2.332522256110D-11)*Y+3.428545616603D-10)*Y-
     +     4.698730937661D-09)*Y+6.219977635130D-08)*Y-
     +     7.83008889613661D-07 )*Y+9.08621687041567D-06 )*Y-
     +     9.86368311253873D-05 )*Y+9.69632496710088D-04 )*Y-
     +     8.14594214284187D-03 )*Y+8.50218447733457D-02
      WW3 = ((((((((((((( 1.64742458534277D-16*Y-2.68512265928410D-15)*
     +     Y+3.788890667676D-14)*Y-5.508918529823D-13)*Y+
     +     7.555896810069D-12)*Y-9.69039768312637D-11 )*Y+
     +     1.16034263529672D-09 )*Y-1.28771698573873D-08 )*Y+
     +     1.31949431805798D-07 )*Y-1.23673915616005D-06 )*Y+
     +     1.04189803544936D-05 )*Y-7.79566003744742D-05 )*Y+
     +     5.03162624754434D-04 )*Y-2.55138844587555D-03 )*Y+
     +     1.13250730954014D-02
      WW4 = ((((((((((((((-1.55714130075679D-17*Y+2.57193722698891D-16)*
     +     Y-3.626606654097D-15)*Y+5.234734676175D-14)*Y-
     +     7.067105402134D-13)*Y+8.793512664890D-12)*Y-
     +     1.006088923498D-10)*Y+1.050565098393D-09)*Y-
     +     9.91517881772662D-09 )*Y+8.35835975882941D-08 )*Y-
     +     6.19785782240693D-07 )*Y+3.95841149373135D-06 )*Y-
     +     2.11366761402403D-05 )*Y+9.00474771229507D-05 )*Y-
     +     2.78777909813289D-04 )*Y+5.26543779837487D-04
      RETURN
C
C     X=10.0 TO 15.0                             NROOTS = 4
  160 Y = X-12.5D+00
      RT1 = ((((((((((( 4.94869622744119D-17*Y+8.03568805739160D-16)*Y-
     +     5.599125915431D-15)*Y-1.378685560217D-13)*Y+
     +     7.006511663249D-13)*Y+1.30391406991118D-11 )*Y+
     +     8.06987313467541D-11 )*Y-5.20644072732933D-09 )*Y+
     +     7.72794187755457D-08 )*Y-1.61512612564194D-06 )*Y+
     +     4.15083811185831D-05 )*Y-7.87855975560199D-04 )*Y+
     +     1.14189319050009D-02
      RT2 = ((((((((((( 4.89224285522336D-16*Y+1.06390248099712D-14)*Y-
     +     5.446260182933D-14)*Y-1.613630106295D-12)*Y+
     +     3.910179118937D-12)*Y+1.90712434258806D-10 )*Y+
     +     8.78470199094761D-10 )*Y-5.97332993206797D-08 )*Y+
     +     9.25750831481589D-07 )*Y-2.02362185197088D-05 )*Y+
     +     4.92341968336776D-04 )*Y-8.68438439874703D-03 )*Y+
     +     1.15825965127958D-01
      RT3 = (((((((((( 6.12419396208408D-14*Y+1.12328861406073D-13)*Y-
     +     9.051094103059D-12)*Y-4.781797525341D-11)*Y+
     +     1.660828868694D-09)*Y+4.499058798868D-10)*Y-
     +     2.519549641933D-07)*Y+4.977444040180D-06)*Y-
     +     1.25858350034589D-04 )*Y+2.70279176970044D-03 )*Y-
     +     3.99327850801083D-02 )*Y+4.33467200855434D-01
      RT4 = ((((((((((( 4.63414725924048D-14*Y-4.72757262693062D-14)*Y-
     +     1.001926833832D-11)*Y+6.074107718414D-11)*Y+
     +     1.576976911942D-09)*Y-2.01186401974027D-08 )*Y-
     +     1.84530195217118D-07 )*Y+5.02333087806827D-06 )*Y+
     +     9.66961790843006D-06 )*Y-1.58522208889528D-03 )*Y+
     +     2.80539673938339D-02 )*Y-2.78953904330072D-01 )*Y+
     +     1.82835655238235D+00
      WW4 = ((((((((((((( 2.90401781000996D-18*Y-4.63389683098251D-17)*
     +     Y+6.274018198326D-16)*Y-8.936002188168D-15)*Y+
     +     1.194719074934D-13)*Y-1.45501321259466D-12 )*Y+
     +     1.64090830181013D-11 )*Y-1.71987745310181D-10 )*Y+
     +     1.63738403295718D-09 )*Y-1.39237504892842D-08 )*Y+
     +     1.06527318142151D-07 )*Y-7.27634957230524D-07 )*Y+
     +     4.12159381310339D-06 )*Y-1.74648169719173D-05 )*Y+
     +     8.50290130067818D-05
      WW3 = ((((((((((((-4.19569145459480D-17*Y+5.94344180261644D-16)*Y-
     +     1.148797566469D-14)*Y+1.881303962576D-13)*Y-
     +     2.413554618391D-12)*Y+3.372127423047D-11)*Y-
     +     4.933988617784D-10)*Y+6.116545396281D-09)*Y-
     +     6.69965691739299D-08 )*Y+7.52380085447161D-07 )*Y-
     +     8.08708393262321D-06 )*Y+6.88603417296672D-05 )*Y-
     +     4.67067112993427D-04 )*Y+5.42313365864597D-03
      WW2 = ((((((((((-6.22272689880615D-15*Y+1.04126809657554D-13)*Y-
     +     6.842418230913D-13)*Y+1.576841731919D-11)*Y-
     +     4.203948834175D-10)*Y+6.287255934781D-09)*Y-
     +     8.307159819228D-08)*Y+1.356478091922D-06)*Y-
     +     2.08065576105639D-05 )*Y+2.52396730332340D-04 )*Y-
     +     2.94484050194539D-03 )*Y+6.01396183129168D-02
      WW1 = (((-1.8784686463512D-01/X+2.2991849164985D-01)/X -
     +     4.9893752514047D-01)/X-2.1916512131607D-05)*EXP(-X) +
     +     SQRT(PIE4/X)-WW4-WW3-WW2
      RETURN
C
  180 WW1 = SQRT(PIE4/X)
      IF (X > 35.0D+00) GO TO 220
      IF (X > 20.0D+00) GO TO 200
C     X=15.0 TO 20.0                             NROOTS = 4
      Y = X-17.5D+00
      RT1 = ((((((((((( 4.36701759531398D-17*Y-1.12860600219889D-16)*Y-
     +     6.149849164164D-15)*Y+5.820231579541D-14)*Y+
     +     4.396602872143D-13)*Y-1.24330365320172D-11 )*Y+
     +     6.71083474044549D-11 )*Y+2.43865205376067D-10 )*Y+
     +     1.67559587099969D-08 )*Y-9.32738632357572D-07 )*Y+
     +     2.39030487004977D-05 )*Y-4.68648206591515D-04 )*Y+
     +     8.34977776583956D-03
      RT2 = ((((((((((( 4.98913142288158D-16*Y-2.60732537093612D-16)*Y-
     +     7.775156445127D-14)*Y+5.766105220086D-13)*Y+
     +     6.432696729600D-12)*Y-1.39571683725792D-10 )*Y+
     +     5.95451479522191D-10 )*Y+2.42471442836205D-09 )*Y+
     +     2.47485710143120D-07 )*Y-1.14710398652091D-05 )*Y+
     +     2.71252453754519D-04 )*Y-4.96812745851408D-03 )*Y+
     +     8.26020602026780D-02
      RT3 = ((((((((((( 1.91498302509009D-15*Y+1.48840394311115D-14)*Y-
     +     4.316925145767D-13)*Y+1.186495793471D-12)*Y+
     +     4.615806713055D-11)*Y-5.54336148667141D-10 )*Y+
     +     3.48789978951367D-10 )*Y-2.79188977451042D-09 )*Y+
     +     2.09563208958551D-06 )*Y-6.76512715080324D-05 )*Y+
     +     1.32129867629062D-03 )*Y-2.05062147771513D-02 )*Y+
     +     2.88068671894324D-01
      RT4 = (((((((((((-5.43697691672942D-15*Y-1.12483395714468D-13)*Y+
     +     2.826607936174D-12)*Y-1.266734493280D-11)*Y-
     +     4.258722866437D-10)*Y+9.45486578503261D-09 )*Y-
     +     5.86635622821309D-08 )*Y-1.28835028104639D-06 )*Y+
     +     4.41413815691885D-05 )*Y-7.61738385590776D-04 )*Y+
     +     9.66090902985550D-03 )*Y-1.01410568057649D-01 )*Y+
     +     9.54714798156712D-01
      WW4 = ((((((((((((-7.56882223582704D-19*Y+7.53541779268175D-18)*Y-
     +     1.157318032236D-16)*Y+2.411195002314D-15)*Y-
     +     3.601794386996D-14)*Y+4.082150659615D-13)*Y-
     +     4.289542980767D-12)*Y+5.086829642731D-11)*Y-
     +     6.35435561050807D-10 )*Y+6.82309323251123D-09 )*Y-
     +     5.63374555753167D-08 )*Y+3.57005361100431D-07 )*Y-
     +     2.40050045173721D-06 )*Y+4.94171300536397D-05
      WW3 = (((((((((((-5.54451040921657D-17*Y+2.68748367250999D-16)*Y+
     +     1.349020069254D-14)*Y-2.507452792892D-13)*Y+
     +     1.944339743818D-12)*Y-1.29816917658823D-11 )*Y+
     +     3.49977768819641D-10 )*Y-8.67270669346398D-09 )*Y+
     +     1.31381116840118D-07 )*Y-1.36790720600822D-06 )*Y+
     +     1.19210697673160D-05 )*Y-1.42181943986587D-04 )*Y+
     +     4.12615396191829D-03
      WW2 = (((((((((((-1.86506057729700D-16*Y+1.16661114435809D-15)*Y+
     +     2.563712856363D-14)*Y-4.498350984631D-13)*Y+
     +     1.765194089338D-12)*Y+9.04483676345625D-12 )*Y+
     +     4.98930345609785D-10 )*Y-2.11964170928181D-08 )*Y+
     +     3.98295476005614D-07 )*Y-5.49390160829409D-06 )*Y+
     +     7.74065155353262D-05 )*Y-1.48201933009105D-03 )*Y+
     +     4.97836392625268D-02
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -
     +     6.0156581186481D-05)*EXP(-X)+WW1-WW2-WW3-WW4
      RETURN
C
C     X=20.0 TO 35.0                             NROOTS = 4
  200 E = EXP(-X)
      RT1 = ((((((-4.45711399441838D-05*X+1.27267770241379D-03)*X -
     +     2.36954961381262D-01)*X+1.54330657903756D+01)*X -
     +     5.22799159267808D+02)*X+1.05951216669313D+04)*X + (-
     +     2.51177235556236D+06/X+8.72975373557709D+05)/X -
     +     1.29194382386499D+05)*E + R14/(X-R14)
      RT2 = (((((-7.85617372254488D-02*X+6.35653573484868D+00)*X -
     +     3.38296938763990D+02)*X+1.25120495802096D+04)*X -
     +     3.16847570511637D+05)*X + ((-1.02427466127427D+09/X +
     +     3.70104713293016D+08)/X-5.87119005093822D+07)/X +
     +     5.38614211391604D+06)*E + R24/(X-R24)
      RT3 = (((((-2.37900485051067D-01*X+1.84122184400896D+01)*X -
     +     1.00200731304146D+03)*X+3.75151841595736D+04)*X -
     +     9.50626663390130D+05)*X + ((-2.88139014651985D+09/X +
     +     1.06625915044526D+09)/X-1.72465289687396D+08)/X +
     +     1.60419390230055D+07)*E + R34/(X-R34)
      RT4 = ((((((-6.00691586407385D-04*X-3.64479545338439D-01)*X +
     +     1.57496131755179D+01)*X-6.54944248734901D+02)*X +
     +     1.70830039597097D+04)*X-2.90517939780207D+05)*X + (+
     +     3.49059698304732D+07/X-1.64944522586065D+07)/X +
     +     2.96817940164703D+06)*E + R44/(X-R44)
      IF (X <= 25.0D+00) WW4 = ((((((( 2.33766206773151D-07*X-
     +     3.81542906607063D-05)*X +3.51416601267000D-03)*X-
     +     1.66538571864728D-01)*X +4.80006136831847D+00)*X-
     +     8.73165934223603D+01)*X +9.77683627474638D+02)*X +
     +     1.66000945117640D+04/X -6.14479071209961D+03)*E + W44*WW1
      IF (X > 25.0D+00) WW4 = (((((( 5.74245945342286D-06*X-
     +     7.58735928102351D-05)*X +2.35072857922892D-04)*X-
     +     3.78812134013125D-03)*X +3.09871652785805D-01)*X-
     +     7.11108633061306D+00)*X +5.55297573149528D+01)*E + W44*WW1
      WW3 = (((((( 2.36392855180768D-04*X-9.16785337967013D-03)*X +
     +     4.62186525041313D-01)*X-1.96943786006540D+01)*X +
     +     4.99169195295559D+02)*X-6.21419845845090D+03)*X + ((+
     +     5.21445053212414D+07/X-1.34113464389309D+07)/X +
     +     1.13673298305631D+06)/X-2.81501182042707D+03)*E + W34*WW1
      WW2 = (((((( 7.29841848989391D-04*X-3.53899555749875D-02)*X +
     +     2.07797425718513D+00)*X-1.00464709786287D+02)*X +
     +     3.15206108877819D+03)*X-6.27054715090012D+04)*X + (+
     +     1.54721246264919D+07/X-5.26074391316381D+06)/X +
     +     7.67135400969617D+05)*E + W24*WW1
      WW1 = (( 1.9623264149430D-01/X-4.9695241464490D-01)/X -
     +     6.0156581186481D-05)*E + WW1-WW2-WW3-WW4
      RETURN
C
  220 IF (X > 53.0D+00) GO TO 240
C     X=35.0 TO 53.0                             NROOTS = 4
      E = EXP(-X)*(X*X)**2
      RT4 = ((-2.19135070169653D-03*X-1.19108256987623D-01)*X -
     +     7.50238795695573D-01)*E + R44/(X-R44)
      RT3 = ((-9.65842534508637D-04*X-4.49822013469279D-02)*X +
     +     6.08784033347757D-01)*E + R34/(X-R34)
      RT2 = ((-3.62569791162153D-04*X-9.09231717268466D-03)*X +
     +     1.84336760556262D-01)*E + R24/(X-R24)
      RT1 = ((-4.07557525914600D-05*X-6.88846864931685D-04)*X +
     +     1.74725309199384D-02)*E + R14/(X-R14)
      WW4 = (( 5.76631982000990D-06*X-7.89187283804890D-05)*X +
     +     3.28297971853126D-04)*E + W44*WW1
      WW3 = (( 2.08294969857230D-04*X-3.77489954837361D-03)*X +
     +     2.09857151617436D-02)*E + W34*WW1
      WW2 = (( 6.16374517326469D-04*X-1.26711744680092D-02)*X +
     +     8.14504890732155D-02)*E + W24*WW1
      WW1 = WW1-WW2-WW3-WW4
      RETURN
C
C     X=47.0 TO INFINITY                         NROOTS = 4
  240 RT1 = R14/(X-R14)
      RT2 = R24/(X-R24)
      RT3 = R34/(X-R34)
      RT4 = R44/(X-R44)
      WW4 = W44*WW1
      WW3 = W34*WW1
      WW2 = W24*WW1
      WW1 = WW1-WW2-WW3-WW4
      RETURN
      END

Calling by HSandT & ERISPDFGHIL: ROOT5 (HONDO)
      SUBROUTINE ROOT5
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /ROOT  / X,U(13),W(13),NROOTS
      EQUIVALENCE (U(1),RT1),(U(2),RT2),(U(3),RT3),(U(4),RT4),(U(5),RT5)
      EQUIVALENCE (W(1),WW1),(W(2),WW2),(W(3),WW3),(W(4),WW4),(W(5),WW5)
      DATA R15,PIE4/1.17581320211778D-01, 7.85398163397448D-01/
      DATA R25,W25/ 1.07456201243690D+00, 2.70967405960535D-01/
      DATA R35,W35/ 3.08593744371754D+00, 3.82231610015404D-02/
      DATA R45,W45/ 6.41472973366203D+00, 1.51614186862443D-03/
      DATA R55,W55/ 1.18071894899717D+01, 8.62130526143657D-06/
C
      IF (X > 15.0D+00) GO TO 180
      IF (X > 5.0D+00) GO TO 140
      IF (X > 1.0D+00) GO TO 120
      IF (X > 3.0D-07) GO TO 100
C     X IS APPROXIMATELY 0.0d0.                   NROOTS = 5
      RT1 = 2.26659266316985D-02 -2.15865967920897D-03 *X
      RT2 = 2.31271692140903D-01 -2.20258754389745D-02 *X
      RT3 = 8.57346024118836D-01 -8.16520023025515D-02 *X
      RT4 = 2.97353038120346D+00 -2.83193369647137D-01 *X
      RT5 = 1.84151859759051D+01 -1.75382723579439D+00 *X
      WW1 = 2.95524224714752D-01 -1.96867576909777D-02 *X
      WW2 = 2.69266719309995D-01 -5.61737590184721D-02 *X
      WW3 = 2.19086362515981D-01 -9.71152726793658D-02 *X
      WW4 = 1.49451349150580D-01 -1.02979262193565D-01 *X
      WW5 = 6.66713443086877D-02 -5.73782817488315D-02 *X
      RETURN
C
C     X=0.0 TO 1.0                               NROOTS = 5
  100 RT1 = ((((((-4.46679165328413D-11*X+1.21879111988031D-09)*X-
     +     2.62975022612104D-08 )*X+5.15106194905897D-07 )*X-
     +     9.27933625824749D-06 )*X+1.51794097682482D-04 )*X-
     +     2.15865967920301D-03 )*X+2.26659266316985D-02
      RT2 = (((((( 1.93117331714174D-10*X-4.57267589660699D-09)*X+
     +     2.48339908218932D-08 )*X+1.50716729438474D-06 )*X-
     +     6.07268757707381D-05 )*X+1.37506939145643D-03 )*X-
     +     2.20258754419939D-02 )*X+2.31271692140905D-01
      RT3 = ((((( 4.84989776180094D-09*X+1.31538893944284D-07)*X-
     +     2.766753852879D-06)*X-7.651163510626D-05)*X+
     +     4.033058545972D-03)*X-8.16520022916145D-02 )*X+
     +     8.57346024118779D-01
      RT4 = ((((-2.48581772214623D-07*X-4.34482635782585D-06)*X-
     +     7.46018257987630D-07 )*X+1.01210776517279D-02 )*X-
     +     2.83193369640005D-01 )*X+2.97353038120345D+00
      RT5 = (((((-8.92432153868554D-09*X+1.77288899268988D-08)*X+
     +     3.040754680666D-06)*X+1.058229325071D-04)*X+
     +     4.596379534985D-02)*X-1.75382723579114D+00 )*X+
     +     1.84151859759049D+01
      WW1 = ((((((-2.03822632771791D-09*X+3.89110229133810D-08)*X-
     +     5.84914787904823D-07 )*X+8.30316168666696D-06 )*X-
     +     1.13218402310546D-04 )*X+1.49128888586790D-03 )*X-
     +     1.96867576904816D-02 )*X+2.95524224714749D-01
      WW2 = ((((((( 8.62848118397570D-09*X-1.38975551148989D-07)*X+
     +     1.602894068228D-06)*X-1.646364300836D-05)*X+
     +     1.538445806778D-04)*X-1.28848868034502D-03 )*X+
     +     9.38866933338584D-03 )*X-5.61737590178812D-02 )*X+
     +     2.69266719309991D-01
      WW3 = ((((((((-9.41953204205665D-09*X+1.47452251067755D-07)*X-
     +     1.57456991199322D-06 )*X+1.45098401798393D-05 )*X-
     +     1.18858834181513D-04 )*X+8.53697675984210D-04 )*X-
     +     5.22877807397165D-03 )*X+2.60854524809786D-02 )*X-
     +     9.71152726809059D-02 )*X+2.19086362515979D-01
      WW4 = ((((((((-3.84961617022042D-08*X+5.66595396544470D-07)*X-
     +     5.52351805403748D-06 )*X+4.53160377546073D-05 )*X-
     +     3.22542784865557D-04 )*X+1.95682017370967D-03 )*X-
     +     9.77232537679229D-03 )*X+3.79455945268632D-02 )*X-
     +     1.02979262192227D-01 )*X+1.49451349150573D-01
      WW5 = ((((((((( 4.09594812521430D-09*X-6.47097874264417D-08)*X+
     +     6.743541482689D-07)*X-5.917993920224D-06)*X+
     +     4.531969237381D-05)*X-2.99102856679638D-04 )*X+
     +     1.65695765202643D-03 )*X-7.40671222520653D-03 )*X+
     +     2.50889946832192D-02 )*X-5.73782817487958D-02 )*X+
     +     6.66713443086877D-02
      RETURN
C
C     X=1.0 TO 5.0                               NROOTS = 5
  120 Y = X-3.0D+00
      RT1 = ((((((((-2.58163897135138D-14*Y+8.14127461488273D-13)*Y-
     +     2.11414838976129D-11 )*Y+5.09822003260014D-10 )*Y-
     +     1.16002134438663D-08 )*Y+2.46810694414540D-07 )*Y-
     +     4.92556826124502D-06 )*Y+9.02580687971053D-05 )*Y-
     +     1.45190025120726D-03 )*Y+1.73416786387475D-02
      RT2 = ((((((((( 1.04525287289788D-14*Y+5.44611782010773D-14)*Y-
     +     4.831059411392D-12)*Y+1.136643908832D-10)*Y-
     +     1.104373076913D-09)*Y-2.35346740649916D-08 )*Y+
     +     1.43772622028764D-06 )*Y-4.23405023015273D-05 )*Y+
     +     9.12034574793379D-04 )*Y-1.52479441718739D-02 )*Y+
     +     1.76055265928744D-01
      RT3 = (((((((((-6.89693150857911D-14*Y+5.92064260918861D-13)*Y+
     +     1.847170956043D-11)*Y-3.390752744265D-10)*Y-
     +     2.995532064116D-09)*Y+1.57456141058535D-07 )*Y-
     +     3.95859409711346D-07 )*Y-9.58924580919747D-05 )*Y+
     +     3.23551502557785D-03 )*Y-5.97587007636479D-02 )*Y+
     +     6.46432853383057D-01
      RT4 = ((((((((-3.61293809667763D-12*Y-2.70803518291085D-11)*Y+
     +     8.83758848468769D-10 )*Y+1.59166632851267D-08 )*Y-
     +     1.32581997983422D-07 )*Y-7.60223407443995D-06 )*Y-
     +     7.41019244900952D-05 )*Y+9.81432631743423D-03 )*Y-
     +     2.23055570487771D-01 )*Y+2.21460798080643D+00
      RT5 = ((((((((( 7.12332088345321D-13*Y+3.16578501501894D-12)*Y-
     +     8.776668218053D-11)*Y-2.342817613343D-09)*Y-
     +     3.496962018025D-08)*Y-3.03172870136802D-07 )*Y+
     +     1.50511293969805D-06 )*Y+1.37704919387696D-04 )*Y+
     +     4.70723869619745D-02 )*Y-1.47486623003693D+00 )*Y+
     +     1.35704792175847D+01
      WW1 = ((((((((( 1.04348658616398D-13*Y-1.94147461891055D-12)*Y+
     +     3.485512360993D-11)*Y-6.277497362235D-10)*Y+
     +     1.100758247388D-08)*Y-1.88329804969573D-07 )*Y+
     +     3.12338120839468D-06 )*Y-5.04404167403568D-05 )*Y+
     +     8.00338056610995D-04 )*Y-1.30892406559521D-02 )*Y+
     +     2.47383140241103D-01
      WW2 = ((((((((((( 3.23496149760478D-14*Y-5.24314473469311D-13)*Y+
     +     7.743219385056D-12)*Y-1.146022750992D-10)*Y+
     +     1.615238462197D-09)*Y-2.15479017572233D-08 )*Y+
     +     2.70933462557631D-07 )*Y-3.18750295288531D-06 )*Y+
     +     3.47425221210099D-05 )*Y-3.45558237388223D-04 )*Y+
     +     3.05779768191621D-03 )*Y-2.29118251223003D-02 )*Y+
     +     1.59834227924213D-01
      WW3 = ((((((((((((-3.42790561802876D-14*Y+5.26475736681542D-13)*Y-
     +     7.184330797139D-12)*Y+9.763932908544D-11)*Y-
     +     1.244014559219D-09)*Y+1.472744068942D-08)*Y-
     +     1.611749975234D-07)*Y+1.616487851917D-06)*Y-
     +     1.46852359124154D-05 )*Y+1.18900349101069D-04 )*Y-
     +     8.37562373221756D-04 )*Y+4.93752683045845D-03 )*Y-
     +     2.25514728915673D-02 )*Y+6.95211812453929D-02
      WW4 = ((((((((((((( 1.04072340345039D-14*Y-1.60808044529211D-13)*
     +     Y+2.183534866798D-12)*Y-2.939403008391D-11)*Y+
     +     3.679254029085D-10)*Y-4.23775673047899D-09 )*Y+
     +     4.46559231067006D-08 )*Y-4.26488836563267D-07 )*Y+
     +     3.64721335274973D-06 )*Y-2.74868382777722D-05 )*Y+
     +     1.78586118867488D-04 )*Y-9.68428981886534D-04 )*Y+
     +     4.16002324339929D-03 )*Y-1.28290192663141D-02 )*Y+
     +     2.22353727685016D-02
      WW5 = ((((((((((((((-8.16770412525963D-16*Y+1.31376515047977D-14)*
     +     Y-1.856950818865D-13)*Y+2.596836515749D-12)*Y-
     +     3.372639523006D-11)*Y+4.025371849467D-10)*Y-
     +     4.389453269417D-09)*Y+4.332753856271D-08)*Y-
     +     3.82673275931962D-07 )*Y+2.98006900751543D-06 )*Y-
     +     2.00718990300052D-05 )*Y+1.13876001386361D-04 )*Y-
     +     5.23627942443563D-04 )*Y+1.83524565118203D-03 )*Y-
     +     4.37785737450783D-03 )*Y+5.36963805223095D-03
      RETURN
C
  140 IF (X > 10.0D+00) GO TO 160
C     X=5.0 TO 10.0                              NROOTS = 5
      Y = X-7.5D+00
      RT1 = ((((((((-1.13825201010775D-14*Y+1.89737681670375D-13)*Y-
     +     4.81561201185876D-12 )*Y+1.56666512163407D-10 )*Y-
     +     3.73782213255083D-09 )*Y+9.15858355075147D-08 )*Y-
     +     2.13775073585629D-06 )*Y+4.56547356365536D-05 )*Y-
     +     8.68003909323740D-04 )*Y+1.22703754069176D-02
      RT2 = (((((((((-3.67160504428358D-15*Y+1.27876280158297D-14)*Y-
     +     1.296476623788D-12)*Y+1.477175434354D-11)*Y+
     +     5.464102147892D-10)*Y-2.42538340602723D-08 )*Y+
     +     8.20460740637617D-07 )*Y-2.20379304598661D-05 )*Y+
     +     4.90295372978785D-04 )*Y-9.14294111576119D-03 )*Y+
     +     1.22590403403690D-01
      RT3 = ((((((((( 1.39017367502123D-14*Y-6.96391385426890D-13)*Y+
     +     1.176946020731D-12)*Y+1.725627235645D-10)*Y-
     +     3.686383856300D-09)*Y+2.87495324207095D-08 )*Y+
     +     1.71307311000282D-06 )*Y-7.94273603184629D-05 )*Y+
     +     2.00938064965897D-03 )*Y-3.63329491677178D-02 )*Y+
     +     4.34393683888443D-01
      RT4 = ((((((((((-1.27815158195209D-14*Y+1.99910415869821D-14)*Y+
     +     3.753542914426D-12)*Y-2.708018219579D-11)*Y-
     +     1.190574776587D-09)*Y+1.106696436509D-08)*Y+
     +     3.954955671326D-07)*Y-4.398596059588D-06)*Y-
     +     2.01087998907735D-04 )*Y+7.89092425542937D-03 )*Y-
     +     1.42056749162695D-01 )*Y+1.39964149420683D+00
      RT5 = ((((((((((-1.19442341030461D-13*Y-2.34074833275956D-12)*Y+
     +     6.861649627426D-12)*Y+6.082671496226D-10)*Y+
     +     5.381160105420D-09)*Y-6.253297138700D-08)*Y-
     +     2.135966835050D-06)*Y-2.373394341886D-05)*Y+
     +     2.88711171412814D-06 )*Y+4.85221195290753D-02 )*Y-
     +     1.04346091985269D+00 )*Y+7.89901551676692D+00
      WW1 = ((((((((( 7.95526040108997D-15*Y-2.48593096128045D-13)*Y+
     +     4.761246208720D-12)*Y-9.535763686605D-11)*Y+
     +     2.225273630974D-09)*Y-4.49796778054865D-08 )*Y+
     +     9.17812870287386D-07 )*Y-1.86764236490502D-05 )*Y+
     +     3.76807779068053D-04 )*Y-8.10456360143408D-03 )*Y+
     +     2.01097936411496D-01
      WW2 = ((((((((((( 1.25678686624734D-15*Y-2.34266248891173D-14)*Y+
     +     3.973252415832D-13)*Y-6.830539401049D-12)*Y+
     +     1.140771033372D-10)*Y-1.82546185762009D-09 )*Y+
     +     2.77209637550134D-08 )*Y-4.01726946190383D-07 )*Y+
     +     5.48227244014763D-06 )*Y-6.95676245982121D-05 )*Y+
     +     8.05193921815776D-04 )*Y-8.15528438784469D-03 )*Y+
     +     9.71769901268114D-02
      WW3 = ((((((((((((-8.20929494859896D-16*Y+1.37356038393016D-14)*Y-
     +     2.022863065220D-13)*Y+3.058055403795D-12)*Y-
     +     4.387890955243D-11)*Y+5.923946274445D-10)*Y-
     +     7.503659964159D-09)*Y+8.851599803902D-08)*Y-
     +     9.65561998415038D-07 )*Y+9.60884622778092D-06 )*Y-
     +     8.56551787594404D-05 )*Y+6.66057194311179D-04 )*Y-
     +     4.17753183902198D-03 )*Y+2.25443826852447D-02
      WW4 = ((((((((((((((-1.08764612488790D-17*Y+1.85299909689937D-16)*
     +     Y-2.730195628655D-15)*Y+4.127368817265D-14)*Y-
     +     5.881379088074D-13)*Y+7.805245193391D-12)*Y-
     +     9.632707991704D-11)*Y+1.099047050624D-09)*Y-
     +     1.15042731790748D-08 )*Y+1.09415155268932D-07 )*Y-
     +     9.33687124875935D-07 )*Y+7.02338477986218D-06 )*Y-
     +     4.53759748787756D-05 )*Y+2.41722511389146D-04 )*Y-
     +     9.75935943447037D-04 )*Y+2.57520532789644D-03
      WW5 = ((((((((((((((( 7.28996979748849D-19*Y-1.26518146195173D-17)
     +     *Y+1.886145834486D-16)*Y-2.876728287383D-15)*Y+
     +     4.114588668138D-14)*Y-5.44436631413933D-13 )*Y+
     +     6.64976446790959D-12 )*Y-7.44560069974940D-11 )*Y+
     +     7.57553198166848D-10 )*Y-6.92956101109829D-09 )*Y+
     +     5.62222859033624D-08 )*Y-3.97500114084351D-07 )*Y+
     +     2.39039126138140D-06 )*Y-1.18023950002105D-05 )*Y+
     +     4.52254031046244D-05 )*Y-1.21113782150370D-04 )*Y+
     +     1.75013126731224D-04
      RETURN
C
C     X=10.0 TO 15.0                             NROOTS = 5
  160 Y = X-12.5D+00
      RT1 = ((((((((((-4.16387977337393D-17*Y+7.20872997373860D-16)*Y+
     +     1.395993802064D-14)*Y+3.660484641252D-14)*Y-
     +     4.154857548139D-12)*Y+2.301379846544D-11)*Y-
     +     1.033307012866D-09)*Y+3.997777641049D-08)*Y-
     +     9.35118186333939D-07 )*Y+2.38589932752937D-05 )*Y-
     +     5.35185183652937D-04 )*Y+8.85218988709735D-03
      RT2 = ((((((((((-4.56279214732217D-16*Y+6.24941647247927D-15)*Y+
     +     1.737896339191D-13)*Y+8.964205979517D-14)*Y-
     +     3.538906780633D-11)*Y+9.561341254948D-11)*Y-
     +     9.772831891310D-09)*Y+4.240340194620D-07)*Y-
     +     1.02384302866534D-05 )*Y+2.57987709704822D-04 )*Y-
     +     5.54735977651677D-03 )*Y+8.68245143991948D-02
      RT3 = ((((((((((-2.52879337929239D-15*Y+2.13925810087833D-14)*Y+
     +     7.884307667104D-13)*Y-9.023398159510D-13)*Y-
     +     5.814101544957D-11)*Y-1.333480437968D-09)*Y-
     +     2.217064940373D-08)*Y+1.643290788086D-06)*Y-
     +     4.39602147345028D-05 )*Y+1.08648982748911D-03 )*Y-
     +     2.13014521653498D-02 )*Y+2.94150684465425D-01
      RT4 = ((((((((((-6.42391438038888D-15*Y+5.37848223438815D-15)*Y+
     +     8.960828117859D-13)*Y+5.214153461337D-11)*Y-
     +     1.106601744067D-10)*Y-2.007890743962D-08)*Y+
     +     1.543764346501D-07)*Y+4.520749076914D-06)*Y-
     +     1.88893338587047D-04 )*Y+4.73264487389288D-03 )*Y-
     +     7.91197893350253D-02 )*Y+8.60057928514554D-01
      RT5 = (((((((((((-2.24366166957225D-14*Y+4.87224967526081D-14)*Y+
     +     5.587369053655D-12)*Y-3.045253104617D-12)*Y-
     +     1.223983883080D-09)*Y-2.05603889396319D-09 )*Y+
     +     2.58604071603561D-07 )*Y+1.34240904266268D-06 )*Y-
     +     5.72877569731162D-05 )*Y-9.56275105032191D-04 )*Y+
     +     4.23367010370921D-02 )*Y-5.76800927133412D-01 )*Y+
     +     3.87328263873381D+00
      WW1 = ((((((((( 8.98007931950169D-15*Y+7.25673623859497D-14)*Y+
     +     5.851494250405D-14)*Y-4.234204823846D-11)*Y+
     +     3.911507312679D-10)*Y-9.65094802088511D-09 )*Y+
     +     3.42197444235714D-07 )*Y-7.51821178144509D-06 )*Y+
     +     1.94218051498662D-04 )*Y-5.38533819142287D-03 )*Y+
     +     1.68122596736809D-01
      WW2 = ((((((((((-1.05490525395105D-15*Y+1.96855386549388D-14)*Y-
     +     5.500330153548D-13)*Y+1.003849567976D-11)*Y-
     +     1.720997242621D-10)*Y+3.533277061402D-09)*Y-
     +     6.389171736029D-08)*Y+1.046236652393D-06)*Y-
     +     1.73148206795827D-05 )*Y+2.57820531617185D-04 )*Y-
     +     3.46188265338350D-03 )*Y+7.03302497508176D-02
      WW3 = ((((((((((( 3.60020423754545D-16*Y-6.24245825017148D-15)*Y+
     +     9.945311467434D-14)*Y-1.749051512721D-12)*Y+
     +     2.768503957853D-11)*Y-4.08688551136506D-10 )*Y+
     +     6.04189063303610D-09 )*Y-8.23540111024147D-08 )*Y+
     +     1.01503783870262D-06 )*Y-1.20490761741576D-05 )*Y+
     +     1.26928442448148D-04 )*Y-1.05539461930597D-03 )*Y+
     +     1.15543698537013D-02
      WW4 = ((((((((((((( 2.51163533058925D-18*Y-4.31723745510697D-17)*
     +     Y+6.557620865832D-16)*Y-1.016528519495D-14)*Y+
     +     1.491302084832D-13)*Y-2.06638666222265D-12 )*Y+
     +     2.67958697789258D-11 )*Y-3.23322654638336D-10 )*Y+
     +     3.63722952167779D-09 )*Y-3.75484943783021D-08 )*Y+
     +     3.49164261987184D-07 )*Y-2.92658670674908D-06 )*Y+
     +     2.12937256719543D-05 )*Y-1.19434130620929D-04 )*Y+
     +     6.45524336158384D-04
      WW5 = ((((((((((((((-1.29043630202811D-19*Y+2.16234952241296D-18)*
     +     Y-3.107631557965D-17)*Y+4.570804313173D-16)*Y-
     +     6.301348858104D-15)*Y+8.031304476153D-14)*Y-
     +     9.446196472547D-13)*Y+1.018245804339D-11)*Y-
     +     9.96995451348129D-11 )*Y+8.77489010276305D-10 )*Y-
     +     6.84655877575364D-09 )*Y+4.64460857084983D-08 )*Y-
     +     2.66924538268397D-07 )*Y+1.24621276265907D-06 )*Y-
     +     4.30868944351523D-06 )*Y+9.94307982432868D-06
      RETURN
C
  180 IF (X > 25.0D+00) GO TO 220
      IF (X > 20.0D+00) GO TO 200
C     X=15.0 TO 20.0                             NROOTS = 5
      Y = X-17.5D+00
      RT1 = (((((((((( 1.91875764545740D-16*Y+7.8357401095707D-16)*Y-
     +     3.260875931644D-14)*Y-1.186752035569D-13)*Y+
     +     4.275180095653D-12)*Y+3.357056136731D-11)*Y-
     +     1.123776903884D-09)*Y+1.231203269887D-08)*Y-
     +     3.99851421361031D-07 )*Y+1.45418822817771D-05 )*Y-
     +     3.49912254976317D-04 )*Y+6.67768703938812D-03
      RT2 = (((((((((( 2.02778478673555D-15*Y+1.01640716785099D-14)*Y-
     +     3.385363492036D-13)*Y-1.615655871159D-12)*Y+
     +     4.527419140333D-11)*Y+3.853670706486D-10)*Y-
     +     1.184607130107D-08)*Y+1.347873288827D-07)*Y-
     +     4.47788241748377D-06 )*Y+1.54942754358273D-04 )*Y-
     +     3.55524254280266D-03 )*Y+6.44912219301603D-02
      RT3 = (((((((((( 7.79850771456444D-15*Y+6.00464406395001D-14)*Y-
     +     1.249779730869D-12)*Y-1.020720636353D-11)*Y+
     +     1.814709816693D-10)*Y+1.766397336977D-09)*Y-
     +     4.603559449010D-08)*Y+5.863956443581D-07)*Y-
     +     2.03797212506691D-05 )*Y+6.31405161185185D-04 )*Y-
     +     1.30102750145071D-02 )*Y+2.10244289044705D-01
      RT4 = (((((((((((-2.92397030777912D-15*Y+1.94152129078465D-14)*Y+
     +     4.859447665850D-13)*Y-3.217227223463D-12)*Y-
     +     7.484522135512D-11)*Y+7.19101516047753D-10 )*Y+
     +     6.88409355245582D-09 )*Y-1.44374545515769D-07 )*Y+
     +     2.74941013315834D-06 )*Y-1.02790452049013D-04 )*Y+
     +     2.59924221372643D-03 )*Y-4.35712368303551D-02 )*Y+
     +     5.62170709585029D-01
      RT5 = ((((((((((( 1.17976126840060D-14*Y+1.24156229350669D-13)*Y-
     +     3.892741622280D-12)*Y-7.755793199043D-12)*Y+
     +     9.492190032313D-10)*Y-4.98680128123353D-09 )*Y-
     +     1.81502268782664D-07 )*Y+2.69463269394888D-06 )*Y+
     +     2.50032154421640D-05 )*Y-1.33684303917681D-03 )*Y+
     +     2.29121951862538D-02 )*Y-2.45653725061323D-01 )*Y+
     +     1.89999883453047D+00
      WW1 = (((((((((( 1.74841995087592D-15*Y-6.95671892641256D-16)*Y-
     +     3.000659497257D-13)*Y+2.021279817961D-13)*Y+
     +     3.853596935400D-11)*Y+1.461418533652D-10)*Y-
     +     1.014517563435D-08)*Y+1.132736008979D-07)*Y-
     +     2.86605475073259D-06 )*Y+1.21958354908768D-04 )*Y-
     +     3.86293751153466D-03 )*Y+1.45298342081522D-01
      WW2 = ((((((((((-1.11199320525573D-15*Y+1.85007587796671D-15)*Y+
     +     1.220613939709D-13)*Y+1.275068098526D-12)*Y-
     +     5.341838883262D-11)*Y+6.161037256669D-10)*Y-
     +     1.009147879750D-08)*Y+2.907862965346D-07)*Y-
     +     6.12300038720919D-06 )*Y+1.00104454489518D-04 )*Y-
     +     1.80677298502757D-03 )*Y+5.78009914536630D-02
      WW3 = ((((((((((-9.49816486853687D-16*Y+6.67922080354234D-15)*Y+
     +     2.606163540537D-15)*Y+1.983799950150D-12)*Y-
     +     5.400548574357D-11)*Y+6.638043374114D-10)*Y-
     +     8.799518866802D-09)*Y+1.791418482685D-07)*Y-
     +     2.96075397351101D-06 )*Y+3.38028206156144D-05 )*Y-
     +     3.58426847857878D-04 )*Y+8.39213709428516D-03
      WW4 = ((((((((((( 1.33829971060180D-17*Y-3.44841877844140D-16)*Y+
     +     4.745009557656D-15)*Y-6.033814209875D-14)*Y+
     +     1.049256040808D-12)*Y-1.70859789556117D-11 )*Y+
     +     2.15219425727959D-10 )*Y-2.52746574206884D-09 )*Y+
     +     3.27761714422960D-08 )*Y-3.90387662925193D-07 )*Y+
     +     3.46340204593870D-06 )*Y-2.43236345136782D-05 )*Y+
     +     3.54846978585226D-04
      WW5 = ((((((((((((( 2.69412277020887D-20*Y-4.24837886165685D-19)*
     +     Y+6.030500065438D-18)*Y-9.069722758289D-17)*Y+
     +     1.246599177672D-15)*Y-1.56872999797549D-14 )*Y+
     +     1.87305099552692D-13 )*Y-2.09498886675861D-12 )*Y+
     +     2.11630022068394D-11 )*Y-1.92566242323525D-10 )*Y+
     +     1.62012436344069D-09 )*Y-1.23621614171556D-08 )*Y+
     +     7.72165684563049D-08 )*Y-3.59858901591047D-07 )*Y+
     +     2.43682618601000D-06
      RETURN
C
C     X=20.0 TO 25.0                             NROOTS = 5
  200 Y = X-22.5D+00
      RT1 = (((((((((-1.13927848238726D-15*Y+7.39404133595713D-15)*Y+
     +     1.445982921243D-13)*Y-2.676703245252D-12)*Y+
     +     5.823521627177D-12)*Y+2.17264723874381D-10 )*Y+
     +     3.56242145897468D-09 )*Y-3.03763737404491D-07 )*Y+
     +     9.46859114120901D-06 )*Y-2.30896753853196D-04 )*Y+
     +     5.24663913001114D-03
      RT2 = (((((((((( 2.89872355524581D-16*Y-1.22296292045864D-14)*Y+
     +     6.184065097200D-14)*Y+1.649846591230D-12)*Y-
     +     2.729713905266D-11)*Y+3.709913790650D-11)*Y+
     +     2.216486288382D-09)*Y+4.616160236414D-08)*Y-
     +     3.32380270861364D-06 )*Y+9.84635072633776D-05 )*Y-
     +     2.30092118015697D-03 )*Y+5.00845183695073D-02
      RT3 = (((((((((( 1.97068646590923D-15*Y-4.89419270626800D-14)*Y+
     +     1.136466605916D-13)*Y+7.546203883874D-12)*Y-
     +     9.635646767455D-11)*Y-8.295965491209D-11)*Y+
     +     7.534109114453D-09)*Y+2.699970652707D-07)*Y-
     +     1.42982334217081D-05 )*Y+3.78290946669264D-04 )*Y-
     +     8.03133015084373D-03 )*Y+1.58689469640791D-01
      RT4 = (((((((((( 1.33642069941389D-14*Y-1.55850612605745D-13)*Y-
     +     7.522712577474D-13)*Y+3.209520801187D-11)*Y-
     +     2.075594313618D-10)*Y-2.070575894402D-09)*Y+
     +     7.323046997451D-09)*Y+1.851491550417D-06)*Y-
     +     6.37524802411383D-05 )*Y+1.36795464918785D-03 )*Y-
     +     2.42051126993146D-02 )*Y+3.97847167557815D-01
      RT5 = ((((((((((-6.07053986130526D-14*Y+1.04447493138843D-12)*Y-
     +     4.286617818951D-13)*Y-2.632066100073D-10)*Y+
     +     4.804518986559D-09)*Y-1.835675889421D-08)*Y-
     +     1.068175391334D-06)*Y+3.292234974141D-05)*Y-
     +     5.94805357558251D-04 )*Y+8.29382168612791D-03 )*Y-
     +     9.93122509049447D-02 )*Y+1.09857804755042D+00
      WW1 = (((((((((-9.10338640266542D-15*Y+1.00438927627833D-13)*Y+
     +     7.817349237071D-13)*Y-2.547619474232D-11)*Y+
     +     1.479321506529D-10)*Y+1.52314028857627D-09 )*Y+
     +     9.20072040917242D-09 )*Y-2.19427111221848D-06 )*Y+
     +     8.65797782880311D-05 )*Y-2.82718629312875D-03 )*Y+
     +     1.28718310443295D-01
      WW2 = ((((((((( 5.52380927618760D-15*Y-6.43424400204124D-14)*Y-
     +     2.358734508092D-13)*Y+8.261326648131D-12)*Y+
     +     9.229645304956D-11)*Y-5.68108973828949D-09 )*Y+
     +     1.22477891136278D-07 )*Y-2.11919643127927D-06 )*Y+
     +     4.23605032368922D-05 )*Y-1.14423444576221D-03 )*Y+
     +     5.06607252890186D-02
      WW3 = ((((((((( 3.99457454087556D-15*Y-5.11826702824182D-14)*Y-
     +     4.157593182747D-14)*Y+4.214670817758D-12)*Y+
     +     6.705582751532D-11)*Y-3.36086411698418D-09 )*Y+
     +     6.07453633298986D-08 )*Y-7.40736211041247D-07 )*Y+
     +     8.84176371665149D-06 )*Y-1.72559275066834D-04 )*Y+
     +     7.16639814253567D-03
      WW4 = (((((((((((-2.14649508112234D-18*Y-2.45525846412281D-18)*Y+
     +     6.126212599772D-16)*Y-8.526651626939D-15)*Y+
     +     4.826636065733D-14)*Y-3.39554163649740D-13 )*Y+
     +     1.67070784862985D-11 )*Y-4.42671979311163D-10 )*Y+
     +     6.77368055908400D-09 )*Y-7.03520999708859D-08 )*Y+
     +     6.04993294708874D-07 )*Y-7.80555094280483D-06 )*Y+
     +     2.85954806605017D-04
      WW5 = ((((((((((((-5.63938733073804D-21*Y+6.92182516324628D-20)*Y-
     +     1.586937691507D-18)*Y+3.357639744582D-17)*Y-
     +     4.810285046442D-16)*Y+5.386312669975D-15)*Y-
     +     6.117895297439D-14)*Y+8.441808227634D-13)*Y-
     +     1.18527596836592D-11 )*Y+1.36296870441445D-10 )*Y-
     +     1.17842611094141D-09 )*Y+7.80430641995926D-09 )*Y-
     +     5.97767417400540D-08 )*Y+1.65186146094969D-06
      RETURN
C
  220 WW1 = SQRT(PIE4/X)
      IF (X > 40.0D+00) GO TO 240
C     X=25.0 TO 40.0                             NROOTS = 5
      E = EXP(-X)
      RT1 = ((((((((-1.73363958895356D-06*X+1.19921331441483D-04)*X -
     +     1.59437614121125D-02)*X+1.13467897349442D+00)*X -
     +     4.47216460864586D+01)*X+1.06251216612604D+03)*X -
     +     1.52073917378512D+04)*X+1.20662887111273D+05)*X -
     +     4.07186366852475D+05)*E + R15/(X-R15)
      RT2 = ((((((((-1.60102542621710D-05*X+1.10331262112395D-03)*X -
     +     1.50043662589017D-01)*X+1.05563640866077D+01)*X -
     +     4.10468817024806D+02)*X+9.62604416506819D+03)*X -
     +     1.35888069838270D+05)*X+1.06107577038340D+06)*X -
     +     3.51190792816119D+06)*E + R25/(X-R25)
      RT3 = ((((((((-4.48880032128422D-05*X+2.69025112122177D-03)*X -
     +     4.01048115525954D-01)*X+2.78360021977405D+01)*X -
     +     1.04891729356965D+03)*X+2.36985942687423D+04)*X -
     +     3.19504627257548D+05)*X+2.34879693563358D+06)*X -
     +     7.16341568174085D+06)*E + R35/(X-R35)
      RT4 = ((((((((-6.38526371092582D-05*X-2.29263585792626D-03)*X -
     +     7.65735935499627D-02)*X+9.12692349152792D+00)*X -
     +     2.32077034386717D+02)*X+2.81839578728845D+02)*X +
     +     9.59529683876419D+04)*X-1.77638956809518D+06)*X +
     +     1.02489759645410D+07)*E + R45/(X-R45)
      RT5 = ((((((((-3.59049364231569D-05*X-2.25963977930044D-02)*X +
     +     1.12594870794668D+00)*X-4.56752462103909D+01)*X +
     +     1.05804526830637D+03)*X-1.16003199605875D+04)*X -
     +     4.07297627297272D+04)*X+2.22215528319857D+06)*X -
     +     1.61196455032613D+07)*E + R55/(X-R55)
      WW5 = (((((((((-4.61100906133970D-10*X+1.43069932644286D-07)*X -
     +     1.63960915431080D-05)*X+1.15791154612838D-03)*X -
     +     5.30573476742071D-02)*X+1.61156533367153D+00)*X -
     +     3.23248143316007D+01)*X+4.12007318109157D+02)*X -
     +     3.02260070158372D+03)*X+9.71575094154768D+03)*E + W55*WW1
      WW4 = (((((((((-2.40799435809950D-08*X+8.12621667601546D-06)*X -
     +     9.04491430884113D-04)*X+6.37686375770059D-02)*X -
     +     2.96135703135647D+00)*X+9.15142356996330D+01)*X -
     +     1.86971865249111D+03)*X+2.42945528916947D+04)*X -
     +     1.81852473229081D+05)*X+5.96854758661427D+05)*E + W45*WW1
      WW3 = (((((((( 1.83574464457207D-05*X-1.54837969489927D-03)*X +
     +     1.18520453711586D-01)*X-6.69649981309161D+00)*X +
     +     2.44789386487321D+02)*X-5.68832664556359D+03)*X +
     +     8.14507604229357D+04)*X-6.55181056671474D+05)*X +
     +     2.26410896607237D+06)*E + W35*WW1
      WW2 = (((((((( 2.77778345870650D-05*X-2.22835017655890D-03)*X +
     +     1.61077633475573D-01)*X-8.96743743396132D+00)*X +
     +     3.28062687293374D+02)*X-7.65722701219557D+03)*X +
     +     1.10255055017664D+05)*X-8.92528122219324D+05)*X +
     +     3.10638627744347D+06)*E + W25*WW1
      WW1 = WW1-0.01962D+00*E-WW2-WW3-WW4-WW5
      RETURN
C
  240 IF (X > 59.0D+00) GO TO 260
C     X=40.0 TO 59.0                             NROOTS = 5
      XXX = X**3
      E = XXX*EXP(-X)
      RT1 = (((-2.43758528330205D-02*X+2.07301567989771D+00)*X -
     +     6.45964225381113D+01)*X+7.14160088655470D+02)*E + R15/(X-R15)
      RT2 = (((-2.28861955413636D-01*X+1.93190784733691D+01)*X -
     +     5.99774730340912D+02)*X+6.61844165304871D+03)*E + R25/(X-R25)
      RT3 = (((-6.95053039285586D-01*X+5.76874090316016D+01)*X -
     +     1.77704143225520D+03)*X+1.95366082947811D+04)*E + R35/(X-R35)
      RT4 = (((-1.58072809087018D+00*X+1.27050801091948D+02)*X -
     +     3.86687350914280D+03)*X+4.23024828121420D+04)*E + R45/(X-R45)
      RT5 = (((-3.33963830405396D+00*X+2.51830424600204D+02)*X -
     +     7.57728527654961D+03)*X+8.21966816595690D+04)*E + R55/(X-R55)
      E = XXX*E
      WW5 = (( 1.35482430510942D-08*X-3.27722199212781D-07)*X +
     +     2.41522703684296D-06)*E + W55*WW1
      WW4 = (( 1.23464092261605D-06*X-3.55224564275590D-05)*X +
     +     3.03274662192286D-04)*E + W45*WW1
      WW3 = (( 1.34547929260279D-05*X-4.19389884772726D-04)*X +
     +     3.87706687610809D-03)*E + W35*WW1
      WW2 = (( 2.09539509123135D-05*X-6.87646614786982D-04)*X +
     +     6.68743788585688D-03)*E + W25*WW1
      WW1 = WW1-WW2-WW3-WW4-WW5
      RETURN
C
C     X=59.0 TO INFINITY                         NROOTS = 5
  260 RT1 = R15/(X-R15)
      RT2 = R25/(X-R25)
      RT3 = R35/(X-R35)
      RT4 = R45/(X-R45)
      RT5 = R55/(X-R55)
      WW2 = W25*WW1
      WW3 = W35*WW1
      WW4 = W45*WW1
      WW5 = W55*WW1
      WW1 = WW1-WW2-WW3-WW4-WW5
      RETURN
      END

Calling by HSandT & ERISPDFGHIL: ROOT6 (HONDO)
      SUBROUTINE ROOT6
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXAUX=55)
      DIMENSION RGRID(MXAUX),WGRID(MXAUX),
     *          P0(MXAUX),P1(MXAUX),P2(MXAUX),
     *          RTS(13),WTS(13),WRK(13),
     *          ALPHA(0:12),BETA(0:12)
      COMMON /ROOT  / XX,UF(13),WF(13),NROOTS
      COMMON /RYSPAR/ XASYMP(13),RTSASY(13,13),WTSASY(13,13),
     *                NAUXS(13),MAPRYS(13),RTSAUX(55,8),WTSAUX(55,8)
C-----------------------------------------------------------------------
      IF(XX>=XASYMP(NROOTS)) THEN
       FACTR = 1.0d0/XX
       FACTW = SQRT(FACTR)
       DO I=1,NROOTS
         RTS(I)= FACTR * RTSASY(I,NROOTS)
         WTS(I)= FACTW * WTSASY(I,NROOTS)
       ENDDO
      ELSE
       NAUX=NAUXS(NROOTS)
       MAP=MAPRYS(NROOTS)
       DO I=1,NAUX
          T2 = RTSAUX(I,MAP)*RTSAUX(I,MAP)
          RGRID(I) = T2
          WGRID(I) = WTSAUX(I,MAP)*EXP(-XX*T2)
       ENDDO
       EPS = 1.0D-14
       CALL RYSDS(NROOTS,NAUX,RGRID,WGRID,ALPHA,BETA,IERR,P0,P1,P2)
       CALL RYSGW(NROOTS,ALPHA,BETA,EPS,RTS,WTS,IERR,WRK)
      END IF
C
      DO K=1,NROOTS
       DUM  = RTS(K)
       UF(K)= DUM/(1.0d0-DUM)
       WF(K)= WTS(K)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C RYSGW
      SUBROUTINE RYSGW(N,ALPHA,BETA,EPS,ROOTS,WEIGHT,IERR,WRK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION ALPHA(N),BETA(N),ROOTS(N),WEIGHT(N),WRK(N)
C
      IF(N<1) THEN
        IERR=-1
        RETURN
      END IF
C
      IERR=0
      ROOTS(1)=ALPHA(1)
      IF(BETA(1)<0.0D+00) THEN
        IERR=-2
        RETURN
      END IF
      WEIGHT(1)=BETA(1)
      IF (N==1) RETURN
C
      WEIGHT(1)=1.0D+00
      WRK(N)=0.0D+00
      DO 100 K=2,N
        ROOTS(K)=ALPHA(K)
        IF(BETA(K)<0.0D+00) THEN
          IERR=-2
          RETURN
        END IF
        WRK(K-1)=SQRT(BETA(K))
        WEIGHT(K)=0.0D+00
  100 CONTINUE
C
      DO 240 L=1,N
        J=0
C
  105   DO 110 M=L,N
          IF(M==N) GO TO 120
          IF(ABS(WRK(M))<=EPS*(ABS(ROOTS(M))+ABS(ROOTS(M+1))))
     *      GO TO 120
  110   CONTINUE
  120   DP=ROOTS(L)
        IF(M==L) GO TO 240
        IF(J==30) GO TO 400
        J=J+1
C
        DG=(ROOTS(L+1)-DP)/(2.0D+00*WRK(L))
        DR=SQRT(DG*DG+1.0D+00)
        DG=ROOTS(M)-DP+WRK(L)/(DG+SIGN(DR,DG))
        DS=1.0D+00
        DC=1.0D+00
        DP=0.0D+00
        MML=M-L
C
        DO 200 II=1,MML
          I=M-II
          DF=DS*WRK(I)
          DB=DC*WRK(I)
          IF(ABS(DF)<ABS(DG)) GO TO 150
          DC=DG/DF
          DR=SQRT(DC*DC+1.0D+00)
          WRK(I+1)=DF*DR
          DS=1.0D+00/DR
          DC=DC*DS
          GO TO 160
  150     DS=DF/DG
          DR=SQRT(DS*DS+1.0D+00)
          WRK(I+1)=DG*DR
          DC=1.0D+00/DR
          DS=DS*DC
  160     DG=ROOTS(I+1)-DP
          DR=(ROOTS(I)-DG)*DS+2.0D+00*DC*DB
          DP=DS*DR
          ROOTS(I+1)=DG+DP
          DG=DC*DR-DB
C
          DF=WEIGHT(I+1)
          WEIGHT(I+1)=DS*WEIGHT(I)+DC*DF
          WEIGHT(I)=DC*WEIGHT(I)-DS*DF
  200   CONTINUE
        ROOTS(L)=ROOTS(L)-DP
        WRK(L)=DG
        WRK(M)=0.0D+00
        GO TO 105
  240 CONTINUE
C
      DO 300 II=2,N
        I=II-1
        K=I
        DP=ROOTS(I)
        DO 260 J=II,N
          IF(ROOTS(J)>=DP) GO TO 260
          K=J
          DP=ROOTS(J)
  260   CONTINUE
        IF(K==I) GO TO 300
        ROOTS(K)=ROOTS(I)
        ROOTS(I)=DP
        DP=WEIGHT(I)
        WEIGHT(I)=WEIGHT(K)
        WEIGHT(K)=DP
  300 CONTINUE
      DO 310 K=1,N
        WEIGHT(K)=BETA(1)*WEIGHT(K)*WEIGHT(K)
  310 CONTINUE
      RETURN
C
  400 IERR=L
C
      RETURN
      END

C RYSDS
      SUBROUTINE RYSDS(N,NCAP,X,W,ALPHA,BETA,IERR,P0,P1,P2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION X(NCAP),W(NCAP),ALPHA(N),BETA(N),
     *          P0(NCAP),P1(NCAP),P2(NCAP)
C
      TINY = 1.0D-40
      HUGE = 1.0D+40
C
      IERR=0
      IF(N<=0 .or. N>NCAP) THEN
        IERR=1
        RETURN
      END IF
      NM1=N-1
C
      SUM0=0.0D+00
      SUM1=0.0D+00
      DO 10 M=1,NCAP
        SUM0=SUM0+W(M)
        SUM1=SUM1+W(M)*X(M)
   10 CONTINUE
      ALPHA(1)=SUM1/SUM0
      BETA(1)=SUM0
      IF(N==1) RETURN
C
      DO 20 M=1,NCAP
        P1(M)=0.0D+00
        P2(M)=1.0D+00
   20 CONTINUE
      DO 40 K=1,NM1
        SUM1=0.0D+00
        SUM2=0.0D+00
        DO 30 M=1,NCAP
C
          IF(W(M)==0.0D+00) GOTO 30
          P0(M)=P1(M)
          P1(M)=P2(M)
          P2(M)=(X(M)-ALPHA(K))*P1(M)-BETA(K)*P0(M)
C
          IF(ABS(P2(M))>HUGE .or. ABS(SUM2)>HUGE) THEN
            IERR=K
            RETURN
          END IF
          T=W(M)*P2(M)*P2(M)
          SUM1=SUM1+T
          SUM2=SUM2+T*X(M)
   30   CONTINUE
C
        IF(ABS(SUM1)<TINY) THEN
          IERR=-K
          RETURN
        END IF
        ALPHA(K+1)=SUM2/SUM1
        BETA(K+1)=SUM1/SUM0
        SUM0=SUM1
   40 CONTINUE
C
      RETURN
      END

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!
!                                                                      !
!                       Two Electron Integrals                         !
!                                                                      !
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!

C JandK                                            
      SUBROUTINE JandK(BUFP2,IX2,NINTEGtm,NINTEGt,NRECO,XINTS,NSH2,
     &                 IDONTW,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/NSHEL /EX(2000),CS(2000),CP(2000),CD(2000),      
     *              CF(2000),CG(2000),CH(2000),CI(2000),      
     *              KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *              KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/INTFIL/NINTMX           
      COMMON/INTOPT/ISCHWZ,IECP,NECP            
      COMMON/RESTAR/NREC,IST,JST,KST,LST           
      LOGICAL SCHWRZ
      INTEGER,DIMENSION(NINTEGtm) :: IX2
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      DOUBLE PRECISION,DIMENSION(NSH2) :: XINTS
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: BUFP,GHOND
      INTEGER :: IPRINTOPT
C-----------------------------------------------------------------------                                                                       
C     Driver for 2e integrals (HONDO)
C-----------------------------------------------------------------------
      call cpu_time(timestarttwoE)
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      MAXG = 4**4                                                                                  
      IF(LMAXIMA==2)MAXG =  6**4                                                                                  
      IF(LMAXIMA==3)MAXG = 10**4                                                                                  
      IF(LMAXIMA==4)MAXG = 15**4                                                                                  
      IF(LMAXIMA==5)MAXG = 21**4                                                                                  
      IF(LMAXIMA==6)MAXG = 28**4
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Debut
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL Debut(IDONTW,IPRINTOPT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Schwarz inequality
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(GHOND(MAXG))
      SCHWRZ = ISCHWZ>0 
      IF(SCHWRZ)CALL ExchangeInt(XINTS,GHOND,NSH2,MAXG)                          
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     2e integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(BUFP(NINTMX),IX(NINTMX))
      CALL TwoERI(SCHWRZ,NINTEGtm,NINTEGt,NSCHWZ,BUFP,IX,BUFP2,IX2,
     &            XINTS,NSH2,GHOND,MAXG,IDONTW,IPRINTOPT)
      DEALLOCATE(BUFP,IX,GHOND)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NRECO = NREC
      call cpu_time(timefinishtwoE)
      DeltaTtwoE = timefinishtwoE - timestarttwoE                                          
      IF(IPRINTOPT==1)
     & WRITE(6,'(1X,A22,F10.2)')'Time to do integrals =',DeltaTtwoE
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

C Debut                                            
      SUBROUTINE Debut(IDONTW,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INTFIL/NINTMX           
      COMMON/RESTAR/NREC,IST,JST,KST,LST           
      COMMON/INFOA/NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,                    
     *             ZAN(100),C(3,100),IAN(100)
      COMMON/NSHEL/EX(2000),CS(2000),CP(2000),CD(2000),      
     *             CF(2000),CG(2000),CH(2000),CI(2000),      
     *             KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *             KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/SHLT/SHLTOL,CUTOFF,ICOUNT       
      DOUBLE PRECISION,DIMENSION(500,3) :: CO
      INTEGER :: IPRINTOPT
C-----------------------------------------------------------------------
C     Initialize 2e- integral Calculation
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                                                                              
      SHLTOL = 20*2.30258D0   
      CUTOFF = 1.0D-09
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C     ERI Initializations
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
      IF(IPRINTOPT==1)WRITE(6,10)                                              
      NBYTES = 16
      IF(IDONTW==1)THEN
       IF(IPRINTOPT==1)WRITE(6,20)
      ELSE
       IF(IPRINTOPT==1)WRITE(6,30)NINTMX,NBYTES
       REWIND(1)                             
      END IF
      DO I=1,NSHELL                                                 
       ICC = KATOM(I)                                                 
       CO(I,1)= C(1,ICC)                                              
       CO(I,2)= C(2,ICC)                                              
       CO(I,3)= C(3,ICC)                                              
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                                                                              
C     Normal Start
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IST = 1                                              
      JST = 1                                              
      KST = 1                                              
      LST = 1                                              
      NREC   = 1                                                        
      ICOUNT = 1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                                                                               
C     Format Statements
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
   10 FORMAT(/1X,'2e- integrals'/1X,13(1H-))      
   20 FORMAT(' DONTW option skips storage 2e- integrals on Unit 1')      
   30 FORMAT(' Storing',I8,' integrals/record on disk, using',I3,       
     *       ' Bytes/integral')                                        
C-----------------------------------------------------------------------                                       
      RETURN                                                            
      END                                                               

C ExchangeInt                                           
      SUBROUTINE ExchangeInt(XINTS,GHONDO,NSH2,MAXG)             
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER, DIMENSION(4,3) :: IB                                                       
      COMMON/INTDEX1/IJGT(784),KLGT(784)   
      COMMON/NSHEL/EX(2000),CS(2000),CP(2000),CD(2000),      
     *             CF(2000),CG(2000),CH(2000),CI(2000),      
     *             KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *             KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)  
      COMMON/SHLNOS1/QQ4,IJKL                                                                              
      DIMENSION XINTS(NSH2),GHONDO(MAXG)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: DDIJ
      LOGICAL ISHandJSH
C-----------------------------------------------------------------------
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      NANGM =  4                                          
      IF(LMAXIMA==2) NANGM =  6                                          
      IF(LMAXIMA==3) NANGM = 10                                          
      IF(LMAXIMA==4) NANGM = 15                                          
      IF(LMAXIMA==5) NANGM = 21                                          
      IF(LMAXIMA==6) NANGM = 28                                          
      NGTH(4) = 1                                                       
      NGTH(3) = NGTH(4) * NANGM                                         
      NGTH(2) = NGTH(3) * NANGM                                         
      NGTH(1) = NGTH(2) * NANGM                                         
      DO I=1,3                                                       
       NORGSH(I) = 0                                               
       NORGSP(I) = 0                                               
      ENDDO                                                          
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEXCH = 1                                                         
      QQ4   = 1.0d0                                                       
      NINTEG  = 0  
C- - - - - - - - - - - - - - - - - - - - - - - -
                        
      IJIJ = 0                                                          
      DO ISH = 1,NSHELL                                             
       DO JSH = 1,ISH                                             
        IJIJ = IJIJ+1                                               
        ALLOCATE(DDIJ(49*900))                                                      
        CALL SHELLS(1,ISH,JSH,ISH,JSH,.TRUE.)                    
        CALL IJPRIM(DDIJ)                                           
        CALL SHELLS(2,ISH,JSH,ISH,JSH,.TRUE.)                       
        CALL ZQOUT(GHONDO)                                          
        IF(IJKL==1) CALL S0000(GHONDO,DDIJ)                       
        IF(IJKL>1) CALL ERISPDFGHIL(GHONDO,DDIJ)
        DEALLOCATE(DDIJ)
        VMAX = 0.0D+00                                                    
        MINI = KMIN(ISH)                                               
        MINJ = KMIN(JSH)                                               
        MAXI = KMAX(ISH)                                               
        JMAX = KMAX(JSH)                                               
        ISHandJSH=ISH==JSH                                               
        IBB = IB(1,IEXCH)                                              
        JBB = IB(2,IEXCH)                                              
        KBB = IB(3,IEXCH)                                              
        LBB = IB(4,IEXCH)                                              
        IJN = 0                                                        
        DO I=MINI,MAXI                                             
         IF(ISHandJSH) JMAX = I                                          
         DO J=MINJ,JMAX                                          
          IJN = IJN+1                                           
          NN = IJGT(IJN) + KLGT(IJN)                            
          VAL = GHONDO(NN)                                      
          IF(VAL>0.0D+00)NINTEG = NINTEG + 1                              
          IF(VAL>VMAX)VMAX=VAL                                 
         END DO
        END DO
        XINTS(IJIJ) = SQRT(VMAX)                                         
       END DO
      END DO
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

C TwoERI                                            
      SUBROUTINE TwoERI(SCHWRZ,NINTEGtm,NINTEGt,NSCHWZ,BUFP,IX,BUFP2,
     *                  IX2,XINTS,NSH2,GHONDO,MAXG,IDONTW,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/INTFIL/NINTMX           
      COMMON/NSHEL/EX(2000),CS(2000),CP(2000),CD(2000),      
     *             CF(2000),CG(2000),CH(2000),CI(2000),      
     *             KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *             KLOC(500),KMIN(500),KMAX(500),NSHELL   
      COMMON/RESTAR/NREC,IST,JST,KST,LST           
      COMMON/SHLNOS1/QQ4,IJKL                                                                              
      LOGICAL SCHWRZ                        
      LOGICAL SCHSKP,SKIPA,SKIPB,SKIPC,NPSYM                                   
      DIMENSION BUFP(NINTMX),IX(NINTMX),XINTS(NSH2),GHONDO(MAXG)
      INTEGER,DIMENSION(NINTEGtm) :: IX2
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      COMMON/SHLEXC/NORGSH(3),NORGSP(3),IEXCH,NGTH(4)       
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AUX
      INTEGER :: IPRINTOPT
      ALLOCATE(AUX(49*900))                                                   
C-----------------------------------------------------------------------
C     2e- Integrals (S,P,D,F,G & L Shells)
C-----------------------------------------------------------------------
      CALL BASCHK(LMAXIMA,KTYPE,NSHELL)
      NANGM =  4                                          
      IF(LMAXIMA==2) NANGM =  6                                          
      IF(LMAXIMA==3) NANGM = 10                                          
      IF(LMAXIMA==4) NANGM = 15                                          
      IF(LMAXIMA==5) NANGM = 21                                          
      IF(LMAXIMA==6) NANGM = 28                                          
      NGTH(4) = 1                                                       
      NGTH(3) = NGTH(4) * NANGM                                         
      NGTH(2) = NGTH(3) * NANGM                                         
      NGTH(1) = NGTH(2) * NANGM                                         
      DO I=1,3                                                       
       NORGSH(I) = 0                                               
       NORGSP(I) = 0                                               
      ENDDO                                                          
C                                                                       
      NINTEGt  = 0                                                         
      NSCHWZ= 0                                                         
      SCHSKP=.FALSE.                                                    
      DENMAX = 0.0D+00 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO II = IST,NSHELL                            ! II Shell
       J0 = JST                                     ! JJ Shell                                            
       DO JJ = J0,II                                                 
        JST = 1                                                           
        K0 = KST                                                          
        DO KK = K0,JJ                               ! KK Shell                                                 
         KST = 1                                                           
         L0 = LST                                                          
         DO LL = L0,KK                              ! LL Shell
          LST = 1                                                           
          SKIPA =  JJ==KK                                                 
          SKIPB = (II==KK) .or. (JJ==LL)                                
          SKIPC = (II==JJ) .or. (KK==LL)                                
          NPSYM = .FALSE.                                                   
          IF(SKIPA.or.SKIPB.or.SKIPC)GO TO 1                        
          NPSYM = .TRUE.
          IH = II                                                       
          JH = JJ                                                       
          IF(JH<=IH)THEN                                              
           ID = IH                                                     
           JD = JH                                                     
          ELSE                                                           
           ID = JH                                                     
           JD = IH                                                     
          END IF                                                         
          IF(.NOT.SKIPA)
     *    SKIPA = (ID==II .and. JD==KK) .or. (ID==JJ .and. JD==LL)               
          IF(.NOT.SKIPB)
     *    SKIPB = (ID==II .and. JD==LL) .or. (ID==JJ .and. JD==KK)               
          IF(SKIPA .and. SKIPB)GO TO 2                               
          KH = KK
          IF(KH<=IH) THEN                                              
           ID = IH                                                     
           KD = KH                                                     
          ELSE                                                           
           ID = KH                                                     
           KD = IH                                                     
          END IF                                                         
          IF(.NOT.SKIPC)          
     *    SKIPC = (ID==II .and. KD==LL) .or. (ID==JJ .and. KD==KK)               
          IF(SKIPA .and. SKIPC) GO TO 3                                
          IF(SKIPB .and. SKIPC) GO TO 4                                
          GO TO 1                                                         
    2     SKIPC = .TRUE.                                                    
          GO TO 1                                                         
    3     SKIPB = .TRUE.                                                    
          GO TO 1                                                         
    4     SKIPA = .TRUE.                                                    
C- - - - - - - - - - - - - - - - - - - - - - - -
C         (II,JJ//KK,LL)                                        
C- - - - - - - - - - - - - - - - - - - - - - - -                            
    1     CONTINUE                                                          
          IEXCH = 1                                                         
          ISH = II                                                          
          JSH = JJ                                                          
          KSH = KK                                                          
          LSH = LL                                                          
          QQ4 = 1                                                          
          IF(SKIPA .and. NPSYM) QQ4 = QQ4+1                                
          IF(SKIPB .and. NPSYM) QQ4 = QQ4+1                                
          GO TO 5                                                         
C- - - - - - - - - - - - - - - - - - - - - - - -
C         (II,KK//JJ,LL)
C- - - - - - - - - - - - - - - - - - - - - - - -                            
    6     IF (SKIPA)GO TO 7                                              
          IEXCH = 2                                                         
          ISH = II                                                          
          JSH = KK                                                          
          KSH = JJ                                                          
          LSH = LL                                                          
          QQ4 = 1                                                          
          IF (SKIPC .and. NPSYM) QQ4 = QQ4+1                               
          GO TO 5                                                         
C- - - - - - - - - - - - - - - - - - - - - - - -
C         (II,LL//JJ,KK)
C- - - - - - - - - - - - - - - - - - - - - - - -                            
    7     IF(SKIPB .or. SKIPC)GO TO 8                                   
          IEXCH = 3                                                         
          ISH = II                                                          
          JSH = LL                                                          
          KSH = JJ                                                          
          LSH = KK                                                          
          QQ4 = 1                                                          
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C         Compute 2e- Integrals                      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
    5     CONTINUE    
          IF(SCHWRZ)THEN                       ! Schwarz Inequality
           IJIJ = (ISH*ISH-ISH)/2 + JSH                                   
           KLKL = (KSH*KSH-KSH)/2 + LSH                                   
           TEST = QQ4*XINTS(IJIJ)*XINTS(KLKL)                             
           SCHSKP = TEST<CUTOFF                                        
           IF(SCHSKP)NSCHWZ = NSCHWZ + 1                                 
          END IF        
          IF(SCHSKP)GO TO 9                                              
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C         Select integral code for ERI calculation
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          LQSUM = KTYPE(ISH) + KTYPE(JSH) + KTYPE(KSH) + KTYPE(LSH) - 4     
          CALL SHELLS(1,ISH,JSH,KSH,LSH,.TRUE.)                           
          CALL SHELLS(2,ISH,JSH,KSH,LSH,.TRUE.)                           
          CALL IJPRIM(AUX)                                          
          NORGH = NORGSH(IEXCH)                                           
          CALL ZQOUT(GHONDO)                                
          IF(LQSUM==0) THEN                                             
           CALL S0000(GHONDO(1+NORGH),AUX)                        
          ELSE                                                            
           CALL ERISPDFGHIL(GHONDO(1+NORGH),AUX)                       
          END IF                                                          
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C         Write Label & Integral on File 1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          CALL QOUT(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,GHONDO,IDONTW)                     
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    9     CONTINUE                                                          
          GO TO (6,7,8),IEXCH                                         
    8     CONTINUE                                                          
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         END DO
        END DO
       END DO
      END DO
      DEALLOCATE(AUX)                                                                                                   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Write Final Record on File 1. Calculate NINTEGt.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL FINAL(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,NINTEGt,IDONTW,
     &           IPRINTOPT)            
C-----------------------------------------------------------------------
      RETURN                                                            
      END                                                               

C QOUT                                             
      SUBROUTINE QOUT(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,GHONDO,IDONTW)                            
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL IANDJ,KANDL,SAME
      DIMENSION BUFP(NINTMX),IX(NINTMX),GHONDO(*)
      COMMON /ERIOUT/ ISH,JSH,KSH,LSH,LSTRI,LSTRJ,LSTRK,LSTRL           
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /NSHEL / EXX(2000),CS(2000),CP(2000),CD(2000),     
     *                CF(2000),CG(2000),CH(2000),CI(2000),      
     *                KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *                KLOC(500),KMIN(500),KMAX(500),NSHELL           
      COMMON /RESTAR/ NREC,IST,JST,KST,LST 
      INTEGER,DIMENSION(NINTEGtm) :: IX2
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,          
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          
     *                NIJ,IJ,KL                                    
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
      SAVE IJN,KLN                                                      
C-----------------------------------------------------------------------                                                                       
C     Pack 4-indices into 1 word. 
C     Write Label & integral on Unit 1 if DONTW = .False.
C-----------------------------------------------------------------------
      SAME  = ISH == KSH .and. JSH == LSH                           
      IANDJ = ISH == JSH                                              
      KANDL = KSH == LSH                                              
      MINI = KMIN(ISH)                                                  
      MINJ = KMIN(JSH)                                                  
      MINK = KMIN(KSH)                                                  
      MINL = KMIN(LSH)                                                  
      MAXI = KMAX(ISH)                                                  
      MAXJ = KMAX(JSH)                                                  
      MAXK = KMAX(KSH)                                                  
      MAXL = KMAX(LSH)                                                  
      LOCI = KLOC(ISH)-MINI                                             
      LOCJ = KLOC(JSH)-MINJ                                             
      LOCK = KLOC(KSH)-MINK                                             
      LOCL = KLOC(LSH)-MINL          
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                               
      IJN = 0                                                           
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       I_INDEX = (I-MINI)*LSTRI + 1                                   
       IF (IANDJ) JMAX = I                                            
       DO 1 J = MINJ,JMAX                                           
        IJ_INDEX = (J-MINJ)*LSTRJ + I_INDEX                         
        IJN = IJN+1                                                 
        LMAX = MAXL                                                 
        KLN = 0                                                     
        DO K =  MINK,MAXK                                       
         IJK_INDEX = (K-MINK)*LSTRK + IJ_INDEX                    
         IF (KANDL) LMAX = K                                      
         DO L = MINL,LMAX                                     
          KLN = KLN+1                                           
          IF(SAME.and.KLN>IJN)GO TO 1                 
          IJKL_INDEX = (L-MINL)*LSTRL + IJK_INDEX               
          VAL = GHONDO( IJKL_INDEX ) 
          IF(ABS(VAL)>=CUTOFF)THEN
           I1 = LOCI+I                                           
           I2 = LOCJ+J                                           
           I3 = LOCK+K                                           
           I4 = LOCL+L                                           
           IF (I1 >= I2) GO TO 100                             
           N = I1                                                
           I1 = I2                                               
           I2 = N                                                
  100      IF (I3 >= I4) GO TO 120                             
           N = I3                                                
           I3 = I4                                               
           I4 = N                                                
  120      IF (I1-I3) 140,160,180                                
  140      N = I1                                                
           I1 = I3                                               
           I3 = N                                                
           N = I2                                                
           I2 = I4                                               
           I4 = N                                                
           GO TO 180                                             
  160      IF (I2 < I4) GO TO 140                             
  180      CONTINUE                                              
C                                                                
           IF(I1 == I2) VAL = VAL*0.5D0                        
           IF(I3 == I4) VAL = VAL*0.5D0                        
           IF(I1 == I3 .and. I2 == I4) VAL = VAL*0.5D0       
C                                                                
           NPACK = ICOUNT                                        
           IPACK = I1                                            
           JPACK = I2                                            
           KPACK = I3                                            
           LPACK = I4                                            
           LABEL = ISHFT( IPACK, 48 ) + ISHFT( JPACK, 32 ) +  
     *             ISHFT( KPACK, 16 ) + LPACK                 
           IX(NPACK) = LABEL                                  
           BUFP(ICOUNT) = VAL 
           ICOUNT = ICOUNT+1                                     
           IF(ICOUNT > 0) THEN                           
            JCOUNT = ICOUNT                               
            IF(JCOUNT > NINTMX) THEN                        
             NXInteg = NINTMX
             IF(IDONTW==1)THEN
              IJBUFi = (NREC-1)*NINTMX
              do ibuf=1,NINTMX
               IX2  (IJBUFi+ibuf) = IX(ibuf)
               BUFP2(IJBUFi+ibuf) = BUFP(ibuf)
              end do
             ELSE
              WRITE(1)NXInteg,IX,BUFP
             END IF
             ICOUNT = 1                               
             NREC = NREC+1                                   
            END IF
           END IF
          END IF
         END DO
        END DO
    1  CONTINUE                                                       
      END DO
C-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END                                                               

C FINAL                                            
      SUBROUTINE FINAL(BUFP,IX,BUFP2,IX2,NINTEGtm,NINTMX,NINTEGt,
     &                 IDONTW,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION BUFP(NINTMX),IX(NINTMX)
      COMMON /RESTAR/ NREC,IST,JST,KST,LST          
      INTEGER,DIMENSION(NINTEGtm) :: IX2
      DOUBLE PRECISION,DIMENSION(NINTEGtm) :: BUFP2
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
C-----------------------------------------------------------------------                                                                       
      IST = 1                                                           
      JST = 1                                                           
      KST = 1                                                           
      LST = 1                                                           
      NXInteg = ICOUNT-1                                                    
      IF(NXInteg>=0) THEN                                            
       IF(IDONTW==1)THEN
        IJBUFi = (NREC-1)*NINTMX
        do ibuf=1,NXInteg
         IX2  (IJBUFi+ibuf) = IX(ibuf)
         BUFP2(IJBUFi+ibuf) = BUFP(ibuf)
        end do
       ELSE
        NXInteg = -NXInteg 
        WRITE(1)NXInteg,IX,BUFP
       END IF
       NINTEGt = NINTMX*(NREC-1) + ICOUNT-1
      ELSE                                                              
       NINTEGt = NXInteg                                                     
      ENDIF                                                             
      IF(IPRINTOPT==1)WRITE(6,10)NINTEGt,NREC                                 
      RETURN                                                            
C-----------------------------------------------------------------------                                                                       
   10 FORMAT(I20,' 2e- integrals in ',I5,' records')
C-----------------------------------------------------------------------                                                                       
      END                                                               

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!
!                                                                      !
!                        H O N D O  Calculator                         !
!                                                                      !
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!

CHONDO SHELLS                                           
      SUBROUTINE SHELLS(NELEC,ISH,JSH,KSH,LSH,FLIP)                     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL FLIP                                                      
      LOGICAL IANDJ,KANDL,SAME                                          
      DIMENSION IX(84),IY(84),IZ(84),                                   
     *          JX(84),JY(84),JZ(84),                                   
     *          KX(84),KY(84),KZ(84),                                   
     *          LX(84),LY(84),LZ(84)                                    
      COMMON /ERIOUT/ INU,JNU,KNU,LNU,NGTI,NGTJ,NGTK,NGTL               
      COMMON /INTDEX/ IJX(784),IJY(784),IJZ(784),IK(784),     
     *                KLX(784),KLY(784),KLZ(784)              
      COMMON/INTDEX1/IJGT(784),KLGT(784)           
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,                    
     *                ZAN(100),C(3,100),IAN(100)                  
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /NSHEL / EX(2000),CS(2000),CP(2000),CD(2000),      
     *                CF(2000),CG(2000),CH(2000),CI(2000),      
     *                KSTART(500),KATOM(500),KTYPE(500),KNG(500),   
     *                KLOC(500),KMIN(500),KMAX(500),NSHELL           
      COMMON /ROOT  / XX,U(13),W(13),NROOTS                             
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NGTH(4)           
      COMMON /SHLINF/  GA(30),CSA(30),CPA(30),CDA(30),      
     *                CFA(30),CGA(30),CHA(30),CIA(30),      
     *                 GB(30),CSB(30),CPB(30),CDB(30),      
     *                CFB(30),CGB(30),CHB(30),CIB(30),      
     *                 GC(30),CSC(30),CPC(30),CDC(30),      
     *                CFC(30),CGC(30),CHC(30),CIC(30),      
     *                 GD(30),CSD(30),CPD(30),CDD(30),      
     *                CFD(30),CGD(30),CHD(30),CID(30),      
     *                AX,AY,AZ,BX,BY,BZ,RAB,CX,CY,CZ,DX,DY,DZ,RCD,      
     *                NGA,NGB,NGC,NGD                                   
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,          
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          
     *                NIJ,IJ,KL                                    
      COMMON /SHLNOS1/QQ4,IJKL                         
      DATA LX /   0,   1,   0,   0,   2,   0,   0,   1,   1,   0,       
     *            3,   0,   0,   2,   2,   1,   0,   1,   0,   1,       
     *            4,   0,   0,   3,   3,   1,   0,   1,   0,   2,       
     *            2,   0,   2,   1,   1,                                
     *            5,   0,   0,   4,   4,   1,   0,   1,   0,   3,       
     *            3,   2,   0,   2,   0,   3,   1,   1,   2,   2,       
     *            1,                                                    
     *            6,   0,   0,   5,   5,   1,   0,   1,   0,   4,       
     *            4,   2,   0,   2,   0,   4,   1,   1,   3,   3,       
     *            0,   3,   3,   2,   1,   2,   1,   2/                 
      DATA KX /   0,   7,   0,   0,  14,   0,   0,   7,   7,   0,       
     *           21,   0,   0,  14,  14,   7,   0,   7,   0,   7,       
     *           28,   0,   0,  21,  21,   7,   0,   7,   0,  14,       
     *           14,   0,  14,   7,   7,                                
     *           35,   0,   0,  28,  28,   7,   0,   7,   0,  21,       
     *           21,  14,   0,  14,   0,  21,   7,   7,  14,  14,       
     *            7,                                                    
     *           42,   0,   0,  35,  35,   7,   0,   7,   0,  28,       
     *           28,  14,   0,  14,   0,  28,   7,   7,  21,  21,       
     *            0,  21,  21,  14,   7,  14,   7,  14/                 
      DATA JX /   0,  49,   0,   0,  98,   0,   0,  49,  49,   0,       
     *          147,   0,   0,  98,  98,  49,   0,  49,   0,  49,       
     *          196,   0,   0, 147, 147,  49,   0,  49,   0,  98,       
     *           98,   0,  98,  49,  49,                                
     *          245,   0,   0, 196, 196,  49,   0,  49,   0, 147,       
     *          147,  98,   0,  98,   0, 147,  49,  49,  98,  98,       
     *           49,                                                    
     *          294,   0,   0, 245, 245,  49,   0,  49,   0, 196,       
     *          196,  98,   0,  98,   0, 196,  49,  49, 147, 147,       
     *            0, 147, 147,  98,  49,  98,  49,  98/                 
      DATA IX /   1, 344,   1,   1, 687,   1,   1, 344, 344,   1,       
     *         1030,   1,   1, 687, 687, 344,   1, 344,   1, 344,       
     *         1373,   1,   1,1030,1030, 344,   1, 344,   1, 687,       
     *          687,   1, 687, 344, 344,                                
     *         1716,   1,   1,1373,1373, 344,   1, 344,   1,1030,       
     *         1030, 687,   1, 687,   1,1030, 344, 344, 687, 687,       
     *          344,                                                    
     *         2059,   1,   1,1716,1716, 344,   1, 344,   1,1373,       
     *         1373, 687,   1, 687,   1,1373, 344, 344,1030,1030,       
     *            1,1030,1030, 687, 344, 687, 344, 687/                 
      DATA LY /   0,   0,   1,   0,   0,   2,   0,   1,   0,   1,       
     *            0,   3,   0,   1,   0,   2,   2,   0,   1,   1,       
     *            0,   4,   0,   1,   0,   3,   3,   0,   1,   2,       
     *            0,   2,   1,   2,   1,                                
     *            0,   5,   0,   1,   0,   4,   4,   0,   1,   2,       
     *            0,   3,   3,   0,   2,   1,   3,   1,   2,   1,       
     *            2,                                                    
     *            0,   6,   0,   1,   0,   5,   5,   0,   1,   2,       
     *            0,   4,   4,   0,   2,   1,   4,   1,   3,   0,       
     *            3,   2,   1,   3,   3,   1,   2,   2/                 
      DATA KY /   0,   0,   7,   0,   0,  14,   0,   7,   0,   7,       
     *            0,  21,   0,   7,   0,  14,  14,   0,   7,   7,       
     *            0,  28,   0,   7,   0,  21,  21,   0,   7,  14,       
     *            0,  14,   7,  14,   7,                                
     *            0,  35,   0,   7,   0,  28,  28,   0,   7,  14,       
     *            0,  21,  21,   0,  14,   7,  21,   7,  14,   7,       
     *           14,                                                    
     *            0,  42,   0,   7,   0,  35,  35,   0,   7,  14,       
     *            0,  28,  28,   0,  14,   7,  28,   7,  21,   0,       
     *           21,  14,   7,  21,  21,   7,  14,  14/                 
      DATA JY /   0,   0,  49,   0,   0,  98,   0,  49,   0,  49,       
     *            0, 147,   0,  49,   0,  98,  98,   0,  49,  49,       
     *            0, 196,   0,  49,   0, 147, 147,   0,  49,  98,       
     *            0,  98,  49,  98,  49,                                
     *            0, 245,   0,  49,   0, 196, 196,   0,  49,  98,       
     *            0, 147, 147,   0,  98,  49, 147,  49,  98,  49,       
     *           98,                                                    
     *            0, 294,   0,  49,   0, 245, 245,   0,  49,  98,       
     *            0, 196, 196,   0,  98,  49, 196,  49, 147,   0,       
     *          147,  98,  49, 147, 147,  49,  98,  98/                 
      DATA IY /   1,   1, 344,   1,   1, 687,   1, 344,   1, 344,       
     *            1,1030,   1, 344,   1, 687, 687,   1, 344, 344,       
     *            1,1373,   1, 344,   1,1030,1030,   1, 344, 687,       
     *            1, 687, 344, 687, 344,                                
     *            1,1716,   1, 344,   1,1373,1373,   1, 344, 687,       
     *            1,1030,1030,   1, 687, 344,1030, 344, 687, 344,       
     *          687,                                                    
     *            1,2059,   1, 344,   1,1716,1716,   1, 344, 687,       
     *            1,1373,1373,   1, 687, 344,1373, 344,1030,   1,       
     *         1030, 687, 344,1030,1030, 344, 687, 687/                 
      DATA LZ /   0,   0,   0,   1,   0,   0,   2,   0,   1,   1,       
     *            0,   0,   3,   0,   1,   0,   1,   2,   2,   1,       
     *            0,   0,   4,   0,   1,   0,   1,   3,   3,   0,       
     *            2,   2,   1,   1,   2,                                
     *            0,   0,   5,   0,   1,   0,   1,   4,   4,   0,       
     *            2,   0,   2,   3,   3,   1,   1,   3,   1,   2,       
     *            2,                                                    
     *            0,   0,   6,   0,   1,   0,   1,   5,   5,   0,       
     *            2,   0,   2,   4,   4,   1,   1,   4,   0,   3,       
     *            3,   1,   2,   1,   2,   3,   3,   2/                 
      DATA KZ /   0,   0,   0,   7,   0,   0,  14,   0,   7,   7,       
     *            0,   0,  21,   0,   7,   0,   7,  14,  14,   7,       
     *            0,   0,  28,   0,   7,   0,   7,  21,  21,   0,       
     *           14,  14,   7,   7,  14,                                
     *            0,   0,  35,   0,   7,   0,   7,  28,  28,   0,       
     *           14,   0,  14,  21,  21,   7,   7,  21,   7,  14,       
     *           14,                                                    
     *            0,   0,  42,   0,   7,   0,   7,  35,  35,   0,       
     *           14,   0,  14,  28,  28,   7,   7,  28,   0,  21,       
     *           21,   7,  14,   7,  14,  21,  21,  14/                 
      DATA JZ /   0,   0,   0,  49,   0,   0,  98,   0,  49,  49,       
     *            0,   0, 147,   0,  49,   0,  49,  98,  98,  49,       
     *            0,   0, 196,   0,  49,   0,  49, 147, 147,   0,       
     *           98,  98,  49,  49,  98,                                
     *            0,   0, 245,   0,  49,   0,  49, 196, 196,   0,       
     *           98,   0,  98, 147, 147,  49,  49, 147,  49,  98,       
     *           98,                                                    
     *            0,   0, 294,   0,  49,   0,  49, 245, 245,   0,       
     *           98,   0,  98, 196, 196,  49,  49, 196,   0, 147,       
     *          147,  49,  98,  49,  98, 147, 147,  98/                 
      DATA IZ /   1,   1,   1, 344,   1,   1, 687,   1, 344, 344,       
     *            1,   1,1030,   1, 344,   1, 344, 687, 687, 344,       
     *            1,   1,1373,   1, 344,   1, 344,1030,1030,   1,       
     *          687, 687, 344, 344, 687,                                
     *            1,   1,1716,   1, 344,   1, 344,1373,1373,   1,       
     *          687,   1, 687,1030,1030, 344, 344,1030, 344, 687,       
     *          687,                                                    
     *            1,   1,2059,   1, 344,   1, 344,1716,1716,   1,       
     *          687,   1, 687,1373,1373, 344, 344,1373,   1,1030,       
     *         1030, 344, 687, 344, 687,1030,1030, 687/                 
C-----------------------------------------------------------------------                                                                       
C     PREPARE SHELL INFORMATION/FOR HONDO INTEGRATION                   
      IF(NELEC==2) GO TO 200                                          
C                                                                       
C     ----- PERMUTE ISH AND JSH SHELLS, FOR THEIR TYPE                  
C     THIS IS DONE FOR SPEED REASONS.  THE CODE GETS THE RIGHT ANSWER   
C     WITHOUT THE ANGULAR MOMENTUM FLIPPING, AND THEREFORE A CALLING    
C     ARGUMENT ALLOWS ONE DO EXACTLY THE integral BLOCK AS SPECIFIED,   
C     SHOULD THAT BE DESIRED.                                           
C                                                                       
      IANDJ = ISH == JSH                                              
      IF (KTYPE(ISH) < KTYPE(JSH)  .and.  FLIP) THEN                 
         INU = JSH                                                      
         JNU = ISH                                                      
         NGTI = NGTH(2)                                                 
         NGTJ = NGTH(1)                                                 
      ELSE                                                              
         INU = ISH                                                      
         JNU = JSH                                                      
         NGTI = NGTH(1)                                                 
         NGTJ = NGTH(2)                                                 
      END IF                                                            
C                                                                       
C     ----- ISHELL                                                      
C                                                                       
      I = KATOM(INU)                                                    
      AX = C(1,I)                                                       
      AY = C(2,I)                                                       
      AZ = C(3,I)                                                       
      I1 = KSTART(INU)                                                  
      I2 = I1+KNG(INU)-1                                                
      LIT = KTYPE(INU)                                                  
      MINI = KMIN(INU)                                                  
      MAXI = KMAX(INU)                                                  
      LOCI = KLOC(INU)-MINI                                             
      NGA = 0                                                           
      DO 140 I = I1,I2                                                  
         NGA = NGA+1                                                    
         GA(NGA) = EX(I)                                                
         CSA(NGA) = CS(I)                                               
         CPA(NGA) = CP(I)                                               
         CDA(NGA) = CD(I)                                               
         CFA(NGA) = CF(I)                                               
         CGA(NGA) = CG(I)                                               
         CHA(NGA) = CH(I)                                               
         CIA(NGA) = CI(I)                                               
  140 CONTINUE                                                          
C                                                                       
C     ----- JSHELL                                                      
C                                                                       
      J = KATOM(JNU)                                                    
      BX = C(1,J)                                                       
      BY = C(2,J)                                                       
      BZ = C(3,J)                                                       
      J1 = KSTART(JNU)                                                  
      J2 = J1+KNG(JNU)-1                                                
      LJT = KTYPE(JNU)                                                  
      MINJ = KMIN(JNU)                                                  
      MAXJ = KMAX(JNU)                                                  
      LOCJ = KLOC(JNU)-MINJ                                             
      NGB = 0                                                           
      DO 160 J = J1,J2                                                  
         NGB = NGB+1                                                    
         GB(NGB) = EX(J)                                                
         CSB(NGB) = CS(J)                                               
         CPB(NGB) = CP(J)                                               
         CDB(NGB) = CD(J)                                               
         CFB(NGB) = CF(J)                                               
         CGB(NGB) = CG(J)                                               
         CHB(NGB) = CH(J)                                               
         CIB(NGB) = CI(J)                                               
  160 CONTINUE                                                          
      RAB = ((AX-BX)*(AX-BX) + (AY-BY)*(AY-BY) + (AZ-BZ)*(AZ-BZ))       
C                                                                       
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS                
C                                                                       
      IJ = 0                                                            
      JMAX = MAXJ                                                       
      DO 190 I = MINI,MAXI                                              
         NX = IX(I)                                                     
         NY = IY(I)                                                     
         NZ = IZ(I)                                                     
         IF (IANDJ) JMAX = I                                            
         DO 180 J = MINJ,JMAX                                           
            IJ = IJ+1                                                   
            IJX(IJ) = NX+JX(J)                                          
            IJY(IJ) = NY+JY(J)                                          
            IJZ(IJ) = NZ+JZ(J)                                          
            IJGT(IJ) = NGTI*(I-MINI)+NGTJ*(J-MINJ)+1                    
  180    CONTINUE                                                       
  190 CONTINUE                                                          
      RETURN                                                            
C     ******                                                            
C                                                                       
C        K AND L SHELL                                                  
C                                                                       
  200 CONTINUE                                                          
      KANDL = KSH == LSH                                              
      SAME = ISH == KSH .and. JSH == LSH                            
C                                                                       
C     ----- PERMUTE KSH AND LSH SHELLS, FOR THEIR TYPE                  
C                                                                       
      IF (KTYPE(KSH) < KTYPE(LSH)  .and.  FLIP) THEN                 
         KNU = LSH                                                      
         LNU = KSH                                                      
         NGTK = NGTH(4)                                                 
         NGTL = NGTH(3)                                                 
      ELSE                                                              
         KNU = KSH                                                      
         LNU = LSH                                                      
         NGTK = NGTH(3)                                                 
         NGTL = NGTH(4)                                                 
      END IF                                                            
C                                                                       
C     ----- K SHELL                                                     
C                                                                       
      K = KATOM(KNU)                                                    
      CX = C(1,K)                                                       
      CY = C(2,K)                                                       
      CZ = C(3,K)                                                       
      K1 = KSTART(KNU)                                                  
      K2 = K1+KNG(KNU)-1                                                
      LKT = KTYPE(KNU)                                                  
      MINK = KMIN(KNU)                                                  
      MAXK = KMAX(KNU)                                                  
      LOCK = KLOC(KNU)-MINK                                             
      NGC = 0                                                           
      DO 260 K = K1,K2                                                  
         NGC = NGC+1                                                    
         GC(NGC) = EX(K)                                                
         CSC(NGC) = CS(K)                                               
         CPC(NGC) = CP(K)                                               
         CDC(NGC) = CD(K)                                               
         CFC(NGC) = CF(K)                                               
         CGC(NGC) = CG(K)                                               
         CHC(NGC) = CH(K)                                               
         CIC(NGC) = CI(K)                                               
  260 CONTINUE                                                          
C                                                                       
C     ----- LSHELL                                                      
C                                                                       
      L = KATOM(LNU)                                                    
      DX = C(1,L)                                                       
      DY = C(2,L)                                                       
      DZ = C(3,L)                                                       
      L1 = KSTART(LNU)                                                  
      L2 = L1+KNG(LNU)-1                                                
      LLT = KTYPE(LNU)                                                  
      MINL = KMIN(LNU)                                                  
      MAXL = KMAX(LNU)                                                  
      LOCL = KLOC(LNU)-MINL                                             
      NGD = 0                                                           
      DO 280 L = L1,L2                                                  
         NGD = NGD+1                                                    
         GD(NGD) = EX(L)                                                
         CSD(NGD) = CS(L)                                               
         CPD(NGD) = CP(L)                                               
         CDD(NGD) = CD(L)                                               
         CFD(NGD) = CF(L)                                               
         CGD(NGD) = CG(L)                                               
         CHD(NGD) = CH(L)                                               
         CID(NGD) = CI(L)                                               
  280 CONTINUE                                                          
      NROOTS = (LIT+LJT+LKT+LLT-2)/2                                    
      RCD = ((CX-DX)*(CX-DX) + (CY-DY)*(CY-DY) + (CZ-DZ)*(CZ-DZ))       
C                                                                       
C     ----- PREPARE INDICES FOR PAIRS OF (K,L) FUNCTIONS                
C                                                                       
      KL = 0                                                            
      LMAX = MAXL                                                       
      DO 310 K = MINK,MAXK                                              
         NX = KX(K)                                                     
         NY = KY(K)                                                     
         NZ = KZ(K)                                                     
         IF (KANDL) LMAX = K                                            
         DO 300 L = MINL,LMAX                                           
            KL = KL+1                                                   
            KLX(KL) = NX+LX(L)                                          
            KLY(KL) = NY+LY(L)                                          
            KLZ(KL) = NZ+LZ(L)                                          
            KLGT(KL) = NGTK*(K-MINK)+NGTL*(L-MINL)                      
  300    CONTINUE                                                       
  310 CONTINUE                                                          
      MAX = KL                                                          
      DO 320 I = 1,IJ                                                   
      IF (SAME) MAX = I                                                 
  320 IK(I) = MAX                                                       
      IJKL = IJ*KL                                                      
      IF (SAME) IJKL = IJ*(IJ+1)/2                                      
      RETURN                                                            
      END                                                               

CHONDO IJPRIM                                           
      SUBROUTINE IJPRIM(DDIJ)                                           
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL IANDJ,KANDL,SAME,NORM                                 
      DIMENSION DDIJ(49*900)                                           
      COMMON /IJGNRL/ A(900),R(900),X1(900),Y1(900),Z1(900),       
     *                IJD(784)                                          
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /SHLINF/  AG(30),CSA(30),CPA(30),CDA(30),      
     *                CFA(30),CGA(30),CHA(30),CIA(30),      
     *                 BG(30),CSB(30),CPB(30),CDB(30),      
     *                CFB(30),CGB(30),CHB(30),CIB(30),      
     *                 CG(30),CSC(30),CPC(30),CDC(30),      
     *                CFC(30),CGC(30),CHC(30),CIC(30),      
     *                 DG(30),CSD(30),CPD(30),CDD(30),      
     *                CFD(30),CGD(30),CHD(30),CID(30),      
     *                XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,XL,YL,ZL,RRK,      
     *                NGA,NGB,NGC,NGD                                   
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,          
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          
     *                NIJ,IJ,KL                                    
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
C                                                                       
      PARAMETER (SQRT3=1.73205080756888D0,SQRT5=2.23606797749979D0,                            
     *           SQRT7=2.64575131106459D0,SQRT11=3.3166247903553998D0)                             
C-----------------------------------------------------------------------                                                                       
      NORM = .TRUE.
      MAX = MAXJ                                                        
      N = 0                                                             
      NN = 0                                                            
      NM = -2**20                                                       
      DO 180 I = MINI,MAXI                                              
         GO TO (100,100,120,120,100,120,120,100,120,120,                
     1          100,120,120,100,120,120,120,120,120,100,                
     1          100,120,120,100,120,120,120,120,120,100,                
     1          120,120,100,120,120,                                    
     1          100,120,120,100,120,120,120,120,120,100,                
     1          120,120,120,120,120,100,120,120,100,120,                
     1          120,                                                    
     1          100,120,120,100,120,120,120,120,120,100,                
     1          120,120,120,120,120,100,120,120,100,120,                
     1          120,100,120,120,120,120,120,100),I                      
  100    NM = NN                                                        
  120    NN = NM                                                        
         IF (IANDJ) MAX = I                                             
         DO 170 J = MINJ,MAX                                            
            GO TO (140,140,160,160,140,160,160,140,160,160,             
     1             140,160,160,140,160,160,160,160,160,140,             
     1             140,160,160,140,160,160,160,160,160,140,             
     1             160,160,140,160,160,                                 
     1             140,160,160,140,160,160,160,160,160,140,             
     1             160,160,160,160,160,140,160,160,140,160,             
     1             160,                                                 
     1             140,160,160,140,160,160,160,160,160,140,             
     1             160,160,160,160,160,140,160,160,140,160,             
     1             160,140,160,160,160,160,160,140),J                   
  140       NN = NN+1                                                   
  160       N = N+1                                                     
            IJD(N) = NN                                                 
  170    CONTINUE                                                       
  180 CONTINUE                                                          
C                                                                       
C     ----- I PRIMITIVE                                                 
C                                                                       
      NIJ = 0                                                           
      JBMAX = NGB                                                       
      DO 540 IA = 1,NGA                                                 
         AI = AG(IA)                                                    
         ARRI = AI*RRI                                                  
         AXI = AI*XI                                                    
         AYI = AI*YI                                                    
         AZI = AI*ZI                                                    
         CSI = CSA(IA)                                                  
         CPI = CPA(IA)                                                  
         CDI = CDA(IA)                                                  
         CFI = CFA(IA)                                                  
         CGI = CGA(IA)                                                  
         CHI = CHA(IA)                                                  
         CII = CIA(IA)                                                  
C                                                                       
C        ----- J PRIMITIVE                                              
C                                                                       
         IF (IANDJ) JBMAX = IA                                          
         DO 520 JB = 1,JBMAX                                            
            AJ = BG(JB)                                                 
            AA = AI+AJ                                                  
            AAINV = 1.0d0/AA                                              
            DUM = AJ*ARRI*AAINV                                         
            IF (DUM > SHLTOL) GO TO 520                                 
            CSJ = CSB(JB)                                               
            CPJ = CPB(JB)                                               
            CDJ = CDB(JB)                                               
            CFJ = CFB(JB)                                               
            CGJ = CGB(JB)                                               
            CHJ = CHB(JB)                                               
            CIJ = CIB(JB)                                               
            NM = 49*NIJ                                                 
            NN = NM                                                     
            NIJ = NIJ+1                                                 
            R(NIJ) = DUM                                                
            A(NIJ) = AA                                                 
            X1(NIJ) = (AXI+AJ*XJ)*AAINV                                 
            Y1(NIJ) = (AYI+AJ*YJ)*AAINV                                 
            Z1(NIJ) = (AZI+AJ*ZJ)*AAINV                                 
C                                                                       
C           ----- DENSITY FACTOR                                        
C                                                                       
            DUM1 = 0.0d0                                                 
            DUM2 = 0.0d0                                                 
            DO 420 I = MINI,MAXI                                        
               GO TO (200,220,420,420,240,420,420,260,420,420,          
     1                261,420,420,262,420,420,420,420,420,263,          
     1                264,420,420,265,420,420,420,420,420,266,          
     1                420,420,267,420,420,                              
     1                268,420,420,269,420,420,420,420,420,270,          
     1                420,420,420,420,420,271,420,420,272,420,          
     1                420,                                              
     1                273,420,420,274,420,420,420,420,420,275,          
     1                420,420,420,420,420,276,420,420,277,420,          
     1                420,278,420,420,420,420,420,279),I                
  200          DUM1 = CSI*AAINV                                         
               GO TO 280                                                
  220          DUM1 = CPI*AAINV                                         
               GO TO 280                                                
  240          DUM1 = CDI*AAINV                                         
               GO TO 280                                                
  260          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  261          DUM1 = CFI*AAINV                                         
               GO TO 280                                                
  262          IF (NORM) DUM1 = DUM1*SQRT5                              
               GO TO 280                                                
  263          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  264          DUM1 = CGI*AAINV                                         
               GO TO 280                                                
  265          IF (NORM) DUM1 = DUM1*SQRT7                              
               GO TO 280                                                
  266          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
               GO TO 280                                                
  267          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  268          DUM1 = CHI*AAINV                                         
               GO TO 280                                                
  269          IF (NORM) DUM1 = DUM1*3.0d0                              
               GO TO 280                                                
  270          IF (NORM) DUM1 = DUM1*SQRT7/SQRT3                        
               GO TO 280                                                
  271          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  272          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
               GO TO 280                                                
  273          DUM1 = CII*AAINV                                         
               GO TO 280                                                
  274          IF (NORM) DUM1 = DUM1*SQRT11                             
               GO TO 280                                                
  275          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  276          IF (NORM) DUM1 = DUM1*SQRT3                              
               GO TO 280                                                
  277          IF (NORM) DUM1 = DUM1*SQRT7/(SQRT5*SQRT3)                
               GO TO 280                                                
  278          IF (NORM) DUM1 = DUM1*SQRT5                              
               GO TO 280                                                
  279          IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
C                                                                       
  280          IF (IANDJ) MAX = I                                       
               DO 400 J = MINJ,MAX                                      
                  GO TO (300,320,400,400,340,400,400,360,400,400,       
     1                   361,400,400,362,400,400,400,400,400,363,       
     1                   364,400,400,365,400,400,400,400,400,366,       
     1                   400,400,367,400,400,                           
     1                   368,400,400,369,400,400,400,400,400,370,       
     1                   400,400,400,400,400,371,400,400,372,400,       
     1                   400,                                           
     1                   373,400,400,374,400,400,400,400,400,375,       
     1                   400,400,400,400,400,376,400,400,377,400,       
     1                   400,378,400,400,400,400,400,379),J             
  300             DUM2 = DUM1*CSJ                                       
                  GO TO 380                                             
  320             DUM2 = DUM1*CPJ                                       
                  GO TO 380                                             
  340             DUM2 = DUM1*CDJ                                       
                  GO TO 380                                             
  360             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  361             DUM2 = DUM1*CFJ                                       
                  GO TO 380                                             
  362             IF (NORM) DUM2 = DUM2*SQRT5                           
                  GO TO 380                                             
  363             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  364             DUM2 = DUM1*CGJ                                       
                  GO TO 380                                             
  365             IF (NORM) DUM2 = DUM2*SQRT7                           
                  GO TO 380                                             
  366             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
                  GO TO 380                                             
  367             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  368             DUM2 = DUM1*CHJ                                       
                  GO TO 380                                             
  369             IF (NORM) DUM2 = DUM2*3.0d0                           
                  GO TO 380                                             
  370             IF (NORM) DUM2 = DUM2*SQRT7/SQRT3                     
                  GO TO 380                                             
  371             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  372             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
                  GO TO 380                                             
  373             DUM2 = DUM1*CIJ                                       
                  GO TO 380                                             
  374             IF (NORM) DUM2 = DUM2*SQRT11                          
                  GO TO 380                                             
  375             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  376             IF (NORM) DUM2 = DUM2*SQRT3                           
                  GO TO 380                                             
  377             IF (NORM) DUM2 = DUM2*SQRT7/(SQRT5*SQRT3)             
                  GO TO 380                                             
  378             IF (NORM) DUM2 = DUM2*SQRT5                           
                  GO TO 380                                             
  379             IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
C                                                                       
  380             NN = NN+1                                             
                  DDIJ(NN) = DUM2                                       
  400          CONTINUE                                                 
  420       CONTINUE                                                    
            IF ( .NOT. IANDJ) GO TO 520                                 
            IF (IA == JB) GO TO 520                                   
            GO TO (500,440,460,455,450,445,444),LIT                     
  440       IF (MINI == 2) GO TO 500                                  
            DDIJ(NM+2) = DDIJ(NM+2)+CSI*CPJ*AAINV                       
            GO TO 480                                                   
  444       DDIJ(NM+28) = DDIJ(NM+28)+DDIJ(NM+28)                       
            DDIJ(NM+27) = DDIJ(NM+27)+DDIJ(NM+27)                       
            DDIJ(NM+26) = DDIJ(NM+26)+DDIJ(NM+26)                       
            DDIJ(NM+25) = DDIJ(NM+25)+DDIJ(NM+25)                       
            DDIJ(NM+24) = DDIJ(NM+24)+DDIJ(NM+24)                       
            DDIJ(NM+23) = DDIJ(NM+23)+DDIJ(NM+23)                       
            DDIJ(NM+22) = DDIJ(NM+22)+DDIJ(NM+22)                       
            DDIJ(NM+21) = DDIJ(NM+21)+DDIJ(NM+21)                       
            DDIJ(NM+20) = DDIJ(NM+20)+DDIJ(NM+20)                       
            DDIJ(NM+19) = DDIJ(NM+19)+DDIJ(NM+19)                       
            DDIJ(NM+18) = DDIJ(NM+18)+DDIJ(NM+18)                       
            DDIJ(NM+17) = DDIJ(NM+17)+DDIJ(NM+17)                       
            DDIJ(NM+16) = DDIJ(NM+16)+DDIJ(NM+16)                       
  445       DDIJ(NM+15) = DDIJ(NM+15)+DDIJ(NM+15)                       
            DDIJ(NM+14) = DDIJ(NM+14)+DDIJ(NM+14)                       
            DDIJ(NM+13) = DDIJ(NM+13)+DDIJ(NM+13)                       
            DDIJ(NM+12) = DDIJ(NM+12)+DDIJ(NM+12)                       
            DDIJ(NM+11) = DDIJ(NM+11)+DDIJ(NM+11)                       
  450       DDIJ(NM+10) = DDIJ(NM+10)+DDIJ(NM+10)                       
            DDIJ(NM+9) = DDIJ(NM+9)+DDIJ(NM+9)                          
            DDIJ(NM+8) = DDIJ(NM+8)+DDIJ(NM+8)                          
            DDIJ(NM+7) = DDIJ(NM+7)+DDIJ(NM+7)                          
  455       DDIJ(NM+6) = DDIJ(NM+6)+DDIJ(NM+6)                          
            DDIJ(NM+5) = DDIJ(NM+5)+DDIJ(NM+5)                          
            DDIJ(NM+4) = DDIJ(NM+4)+DDIJ(NM+4)                          
  460       DDIJ(NM+2) = DDIJ(NM+2)+DDIJ(NM+2)                          
  480       DDIJ(NM+3) = DDIJ(NM+3)+DDIJ(NM+3)                          
  500       DDIJ(NM+1) = DDIJ(NM+1)+DDIJ(NM+1)                          
  520    CONTINUE                                                       
  540 CONTINUE
C-----------------------------------------------------------------------                                                          
      RETURN                                                            
      END                                                               

CHONDO S0000                                            
      SUBROUTINE S0000(GHONDO,DDIJ)                                     
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL IANDJ,KANDL,SAME
      DIMENSION GHONDO(*),DDIJ(49*900)                                 
      COMMON /IJGNRL/ A(900),R(900),X1(900),Y1(900),Z1(900),       
     *                IJD(784)                                          
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /SHLINF/  AG(30),CSA(30),CPA(30),CDA(30),      
     *                CFA(30),CGA(30),CHA(30),CIA(30),      
     *                 BG(30),CSB(30),CPB(30),CDB(30),      
     *                CFB(30),CGB(30),CHB(30),CIB(30),      
     *                 CG(30),CSC(30),CPC(30),CDC(30),      
     *                CFC(30),CGC(30),CHC(30),CIC(30),      
     *                 DG(30),CSD(30),CPD(30),CDD(30),      
     *                CFD(30),CGD(30),CHD(30),CID(30),      
     *                XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,XL,YL,ZL,RRK,      
     *                NGA,NGB,NGC,NGD                                   
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,          
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          
     *                NIJ,IJ,KL                                    
      COMMON /SHLNOS1/QQ4,IJKL                         
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
      PARAMETER (PI252=34.986836655250D+00, PIE4=7.85398163397448D-01)                             
C-----------------------------------------------------------------------                                                                       
C     SSSS integral for HONDO integrals          
C-----------------------------------------------------------------------                                                                       
      GGOUT = 0.0d0                                                      
      LGMAX = NGD                                                       
      DO 300 KG = 1,NGC                                                 
      BK = CG(KG)                                                       
      BRRK = BK*RRK                                                     
      BXK = BK*XK                                                       
      BYK = BK*YK                                                       
      BZK = BK*ZK                                                       
      CSK = CSC(KG)                                                     
      IF (KANDL) LGMAX = KG                                             
      DO 280 LG = 1,LGMAX                                               
      BL = DG(LG)                                                       
      BB = BK+BL                                                        
      BBINV = 1.0d0/BB                                                    
      DUM = BL*BRRK*BBINV                                               
      IF (DUM > SHLTOL) GO TO 280                                       
      BBRRK = DUM                                                       
      D2 = CSD(LG)*CSK*BBINV                                            
      IF (KANDL .and. LG /= KG) D2 = D2+D2                            
      BBX = (BXK+BL*XL)*BBINV                                           
      BBY = (BYK+BL*YL)*BBINV                                           
      BBZ = (BZK+BL*ZL)*BBINV                                           
      SUM = 0.0d0                                                        
      NN = 1                                                            
      DO 260 N = 1,NIJ                                                  
      DUM = BBRRK+R(N)                                                  
      IF (DUM > SHLTOL) GO TO 260                                       
      EXPE = EXP(-DUM)                                                  
      AA = A(N)                                                         
      AB = AA+BB                                                        
      DUM = X1(N)-BBX                                                   
      XX = DUM*DUM                                                      
      DUM = Y1(N)-BBY                                                   
      XX = DUM*DUM+XX                                                   
      DUM = Z1(N)-BBZ                                                   
      XX = DUM*DUM+XX                                                   
      X = XX*AA*BB/AB                                                   
C                                                                       
      IF (X > 5.0D+00) GO TO 160                                     
      IF (X > 1.0D+00) GO TO 120                                     
      IF (X > 3.0D-07) GO TO 100                                     
      WW1 = 1.0D+00-X/3.0D+00                                           
      GO TO 240                                                         
C                                                                       
  100 CONTINUE                                                          
      F1 = ((((((((-8.36313918003957D-08*X+1.21222603512827D-06 )*X-    
     +     1.15662609053481D-05 )*X+9.25197374512647D-05 )*X-           
     +     6.40994113129432D-04 )*X+3.78787044215009D-03 )*X-           
     +     1.85185172458485D-02 )*X+7.14285713298222D-02 )*X-           
     +     1.99999999997023D-01 )*X+3.33333333333318D-01                
      WW1 = (X+X)*F1+EXP(-X)                                            
      GO TO 240                                                         
C                                                                       
  120 CONTINUE                                                          
      IF (X > 3.0D+00) GO TO 140                                     
      Y = X-2.0D+00                                                     
      F1 = ((((((((((-1.61702782425558D-10*Y+1.96215250865776D-09 )*Y-  
     +     2.14234468198419D-08 )*Y+2.17216556336318D-07 )*Y-           
     +     1.98850171329371D-06 )*Y+1.62429321438911D-05 )*Y-           
     +     1.16740298039895D-04 )*Y+7.24888732052332D-04 )*Y-           
     +     3.79490003707156D-03 )*Y+1.61723488664661D-02 )*Y-           
     +     5.29428148329736D-02 )*Y+1.15702180856167D-01                
      WW1 = (X+X)*F1+EXP(-X)                                            
      GO TO 240                                                         
C                                                                       
  140 CONTINUE                                                          
      Y = X-4.0D+00                                                     
      F1 = ((((((((((-2.62453564772299D-11*Y+3.24031041623823D-10 )*Y-  
     +     3.614965656163D-09)*Y+3.760256799971D-08)*Y-                 
     +     3.553558319675D-07)*Y+3.022556449731D-06)*Y-                 
     +     2.290098979647D-05)*Y+1.526537461148D-04)*Y-                 
     +     8.81947375894379D-04 )*Y+4.33207949514611D-03 )*Y-           
     +     1.75257821619926D-02 )*Y+5.28406320615584D-02                
      WW1 = (X+X)*F1+EXP(-X)                                            
      GO TO 240                                                         
C                                                                       
  160 CONTINUE                                                          
      IF (X > 15.0D+00) GO TO 200                                    
      E = EXP(-X)                                                       
      IF (X > 10.0D+00) GO TO 180                                    
      XINV = 1.0d0/X                                                      
      WW1 = (((((( 4.6897511375022D-01*XINV-6.9955602298985D-01)*XINV + 
     +     5.3689283271887D-01)*XINV-3.2883030418398D-01)*XINV +        
     +     2.4645596956002D-01)*XINV-4.9984072848436D-01)*XINV -        
     +     3.1501078774085D-06)*E + SQRT(PIE4*XINV)                     
      GO TO 240                                                         
C                                                                       
  180 CONTINUE                                                          
      XINV = 1.0d0/X                                                      
      WW1 = (((-1.8784686463512D-01*XINV+2.2991849164985D-01)*XINV      
     +         -4.9893752514047D-01)*XINV-2.1916512131607D-05)*E        
     +         + SQRT(PIE4*XINV)                                        
      GO TO 240                                                         
C                                                                       
  200 CONTINUE                                                          
      IF (X > 33.0D+00) GO TO 220                                    
      XINV = 1.0d0/X                                                      
      E = EXP(-X)                                                       
      WW1 = (( 1.9623264149430D-01*XINV-4.9695241464490D-01)*XINV -     
     +     6.0156581186481D-05)*E + SQRT(PIE4*XINV)                     
      GO TO 240                                                         
C                                                                       
  220 WW1 = SQRT(PIE4/X)                                                
C                                                                       
  240 CONTINUE                                                          
      SUM = SUM+DDIJ(NN)*WW1*EXPE/SQRT(AB)                
  260 NN = NN+49                                                        
      GGOUT = GGOUT+D2*SUM                                              
  280 CONTINUE                                                          
  300 CONTINUE                                                          
      GHONDO(1) = GGOUT*PI252*QQ4                                       
      RETURN                                                            
      END                                                               

CHONDO ERISPDFGHIL                                           
      SUBROUTINE ERISPDFGHIL(GHONDO,DDIJ)                                    
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION GHONDO(*),DDIJ(*)                                       
      LOGICAL IANDJ,KANDL,SAME,NORM,DOUBLE                          
      COMMON /DENS  / DKL(784),DIJ(784)                                 
      COMMON /IJGNRL/ AA(900),R(900),X1(900),Y1(900),Z1(900),      
     *                IJD(784)                                          
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /ROOT  / XX,U(13),W(13),NROOTS                             
      COMMON /SETINT/ IN(13),KN(13),NI,NJ,NK,NL,NMAX,MMAX,              
     +                BP01,B00,B10,XCP00,XC00,YCP00,YC00,ZCP00,ZC00,F00,
     +                DXIJ,DYIJ,DZIJ,DXKL,DYKL,DZKL                     
      COMMON /SHLINF/  AG(30),CSA(30),CPA(30),CDA(30),      
     *                CFA(30),CGA(30),CHA(30),CIA(30),      
     *                 BG(30),CSB(30),CPB(30),CDB(30),      
     *                CFB(30),CGB(30),CHB(30),CIB(30),      
     *                 CG(30),CSC(30),CPC(30),CDC(30),      
     *                CFC(30),CGC(30),CHC(30),CIC(30),      
     *                 DG(30),CSD(30),CPD(30),CDD(30),      
     *                CFD(30),CGD(30),CHD(30),CID(30),      
     *                XI,YI,ZI,XJ,YJ,ZJ,RRI,XK,YK,ZK,XL,YL,ZL,RRK,      
     *                NGA,NGB,NGC,NGD                                   
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,          
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          
     *                NIJ,IJ,KL                                    
      COMMON /SHLNOS1/QQ4,IJKL                         
      COMMON /SHLT  / SHLTOL,CUTOFF,ICOUNT
      DIMENSION IN1(13)                                                 
      PARAMETER (SQRT3=1.73205080756888D0,SQRT5=2.23606797749979D0,
     *           SQRT7=2.64575131106459D0,PI252=34.986836655250D0, 
     *           SQRT11=3.3166247903553998D0)               
C-----------------------------------------------------------------------
      FACTOR = PI252*QQ4                                                
      NORM = .TRUE.
      NI = LIT-1                                                        
      NJ = LJT-1                                                        
      NK = LKT-1                                                        
      NL = LLT-1                                                        
      DXIJ = XI-XJ                                                      
      DYIJ = YI-YJ                                                      
      DZIJ = ZI-ZJ                                                      
      DXKL = XK-XL                                                      
      DYKL = YK-YL                                                      
      DZKL = ZK-ZL                                                      
      NMAX = NI+NJ                                                      
      MMAX = NK+NL                                                      
      MAX = NMAX+1                                                      
      DO I = 1,MAX                                                  
       N = I-1                                                        
       IF (N <= NI) IN1(I) = 343*N+1                                
       IF (N > NI) IN1(I) = 343*NI+49*(N-NI)+1                     
      END DO
      MAX = MMAX+1                                                      
      DO K = 1,MAX                                                  
       N = K-1                                                        
       IF (N <= NK) KN(K) = 7*N                                     
       IF (N > NK) KN(K) = 7*NK+N-NK                               
      END DO
      LGMAX = NGD                                                       
      DO KG = 1,NGC                        !      K Primitive                                                 
       AK = CG(KG)                                                    
       BRRK = AK*RRK                                                  
       AKXK = AK*XK                                                   
       AKYK = AK*YK                                                   
       AKZK = AK*ZK                                                   
       CSK = CSC(KG)*FACTOR                                           
       CPK = CPC(KG)*FACTOR                                           
       CDK = CDC(KG)*FACTOR                                           
       CFK = CFC(KG)*FACTOR                                           
       CGK = CGC(KG)*FACTOR                                           
       CHK = CHC(KG)*FACTOR                                           
       CIK = CIC(KG)*FACTOR                                           
       IF (KANDL) LGMAX = KG                                          
       DO LG = 1,LGMAX                     !      L Primitive
        AL = DG(LG)                                                 
        B = AK+AL                                                   
        BINV = 1.0d0/B                                                
        BBRRK = AL*BRRK*BINV                                        
        IF(BBRRK<=SHLTOL)THEN
         CSL = CSD(LG)                                               
         CPL = CPD(LG)                                               
         CDL = CDD(LG)                                               
         CFL = CFD(LG)                                               
         CGL = CGD(LG)                                               
         CHL = CHD(LG)                                               
         CIL = CID(LG)                                               
         XB = (AKXK+AL*XL)*BINV                                      
         YB = (AKYK+AL*YL)*BINV                                      
         ZB = (AKZK+AL*ZL)*BINV                                      
         BXBK = B*(XB-XK)                                            
         BYBK = B*(YB-YK)                                            
         BZBK = B*(ZB-ZK)                                            
         BXBI = B*(XB-XI)                                            
         BYBI = B*(YB-YI)                                            
         BZBI = B*(ZB-ZI)                                            
C        DENSITY FACTOR                                        
         DOUBLE = KANDL.and.KG/=LG                                   
         N = 0                                                       
         MAX = MAXL                                                  
         DUM1 = 0.0d0                                                 
         DUM2 = 0.0d0                                                 
         DO K = MINK,MAXK                                        
          GO TO (140,160,220,220,180,220,220,200,220,220,          
     *           201,220,220,202,220,220,220,220,220,203,          
     *           204,220,220,205,220,220,220,220,220,206,          
     *           220,220,207,220,220,                              
     *           208,220,220,209,220,220,220,220,220,210,          
     *           220,220,220,220,220,211,220,220,212,220,          
     *           220,                                              
     *           213,220,220,214,220,220,220,220,220,215,          
     *           220,220,220,220,220,216,220,220,217,220,          
     *           220,218,220,220,220,220,220,219),K                
  140     DUM1 = CSK*BINV                                          
          GO TO 220                                                
  160     DUM1 = CPK*BINV                                          
          GO TO 220                                                
  180     DUM1 = CDK*BINV                                          
          GO TO 220                                                
  200     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  201     DUM1 = CFK*BINV                                          
          GO TO 220                                                
  202     IF (NORM) DUM1 = DUM1*SQRT5                              
          GO TO 220                                                
  203     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  204     DUM1 = CGK*BINV                                          
          GO TO 220                                                
  205     IF (NORM) DUM1 = DUM1*SQRT7                              
          GO TO 220                                                
  206     IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
          GO TO 220                                                
  207     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  208     DUM1 = CHK*BINV                                          
          GO TO 220                                                
  209     IF (NORM) DUM1 = DUM1*3.0d0                              
          GO TO 220                                                
  210     IF (NORM) DUM1 = DUM1*SQRT7/SQRT3                        
          GO TO 220                                                
  211     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  212     IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
          GO TO 220                                                
  213     DUM1 = CIK*BINV                                          
          GO TO 220                                                
  214     IF (NORM) DUM1 = DUM1*SQRT11                             
          GO TO 220                                                
  215     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  216     IF (NORM) DUM1 = DUM1*SQRT3                              
          GO TO 220                                                
  217     IF (NORM) DUM1 = DUM1*SQRT7/(SQRT5*SQRT3)                
          GO TO 220                                                
  218     IF (NORM) DUM1 = DUM1*SQRT5                              
          GO TO 220                                                
  219     IF (NORM) DUM1 = DUM1*SQRT5/SQRT3                        
C                                                                  
  220     IF (KANDL) MAX = K                                       
          DO L = MINL,MAX                                      
           GO TO (240,280,340,340,300,340,340,320,340,340,       
     *            321,340,340,322,340,340,340,340,340,323,       
     *            324,340,340,325,340,340,340,340,340,326,       
     *            340,340,327,340,340,                           
     *            328,340,340,329,340,340,340,340,340,330,       
     *            340,340,340,340,340,331,340,340,332,340,       
     *            340,                                           
     *            333,340,340,334,340,340,340,340,340,335,       
     *            340,340,340,340,340,336,340,340,337,340,       
     *            340,338,340,340,340,340,340,339),L             
  240      DUM2 = DUM1*CSL                                       
           IF ( .NOT. DOUBLE) GO TO 340                          
           IF (K > 1) GO TO 260                               
           DUM2 = DUM2+DUM2                                      
           GO TO 340                                             
  260      DUM2 = DUM2+CSK*CPL*BINV                              
           GO TO 340                                             
  280      DUM2 = DUM1*CPL                                       
           IF (DOUBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  300      DUM2 = DUM1*CDL                                       
           IF (DOUBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  320      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  321      DUM2 = DUM1*CFL                                       
           IF (DOUBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  322      IF (NORM) DUM2 = DUM2*SQRT5                           
           GO TO 340                                             
  323      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  324      DUM2 = DUM1*CGL                                       
           IF (DOUBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  325      IF (NORM) DUM2 = DUM2*SQRT7                           
           GO TO 340                                             
  326      IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
           GO TO 340                                             
  327      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  328      DUM2 = DUM1*CHL                                       
           IF (DOUBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  329      IF (NORM) DUM2 = DUM2*3.0d0                           
           GO TO 340                                             
  330      IF (NORM) DUM2 = DUM2*SQRT7/SQRT3                     
           GO TO 340                                             
  331      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  332      IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
           GO TO 340                                             
  333      DUM2 = DUM1*CIL                                       
           IF (DOUBLE) DUM2 = DUM2+DUM2                          
           GO TO 340                                             
  334      IF (NORM) DUM2 = DUM2*SQRT11                          
           GO TO 340                                             
  335      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  336      IF (NORM) DUM2 = DUM2*SQRT3                           
           GO TO 340                                             
  337      IF (NORM) DUM2 = DUM2*SQRT7/(SQRT5*SQRT3)             
           GO TO 340                                             
  338      IF (NORM) DUM2 = DUM2*SQRT5                           
           GO TO 340                                             
  339      IF (NORM) DUM2 = DUM2*SQRT5/SQRT3                     
C                                                                
  340      N = N+1                                               
           DKL(N) = DUM2                                         
          END DO
         END DO
C
         NN = 0                                                      
         DO N = 1,NIJ                      !         I,J Primitives                                
          DUM = BBRRK+R(N)                                         
          IF(DUM<=SHLTOL)THEN
           DO I = 1,IJ                                          
            DIJ(I) = DDIJ(IJD(I)+NN)                              
           END DO
           A = AA(N)                                                
           AB = A*B                                                 
           AANDB = A+B                                              
           EXPE = EXP(-DUM)/SQRT(AANDB)                             
           RHO = AB/AANDB                                           
           XA = X1(N)                                               
           YA = Y1(N)                                               
           ZA = Z1(N)                                               
           XX = RHO*((XA-XB)*(XA-XB)+(YA-YB)*(YA-YB)+(ZA-ZB)*(ZA-ZB))             
           AXAK = A*(XA-XK)                                         
           AYAK = A*(YA-YK)                                         
           AZAK = A*(ZA-ZK)                                         
           AXAI = A*(XA-XI)                                         
           AYAI = A*(YA-YI)                                         
           AZAI = A*(ZA-ZI)                                         
           C1X = BXBK+AXAK                                          
           C2X = A*BXBK                                             
           C3X = BXBI+AXAI                                          
           C4X = B*AXAI                                             
           C1Y = BYBK+AYAK                                          
           C2Y = A*BYBK                                             
           C3Y = BYBI+AYAI                                          
           C4Y = B*AYAI                                             
           C1Z = BZBK+AZAK                                          
           C2Z = A*BZBK                                             
           C3Z = BZBI+AZAI                                          
           C4Z = B*AZAI                                             
           IF (NROOTS <= 3) CALL RT123                            
           IF (NROOTS == 4) CALL ROOT4                            
           IF (NROOTS == 5) CALL ROOT5                            
           IF (NROOTS >= 6) CALL ROOT6                            
           MM = 0                                                   
           MAX = NMAX+1                                             
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C          ERI for each root
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           DO M = 1,NROOTS                                      
            U2 = U(M)*RHO                                         
            F00 = EXPE*W(M)                                       
            DO I = 1,MAX                                      
             IN(I) = IN1(I)+MM                                  
            END DO
            DUMINV = 1.0d0/(AB+U2*AANDB)                         
            DM2INV = 0.5D0*DUMINV                               
            BP01 = (A+U2)*DM2INV                               
            B00 = U2*DM2INV                                    
            B10 = (B+U2)*DM2INV                                
            XCP00 = (U2*C1X+C2X)*DUMINV                        
            XC00 = (U2*C3X+C4X)*DUMINV                         
            YCP00 = (U2*C1Y+C2Y)*DUMINV                        
            YC00 = (U2*C3Y+C4Y)*DUMINV                         
            ZCP00 = (U2*C1Z+C2Z)*DUMINV                        
            ZC00 = (U2*C3Z+C4Z)*DUMINV                         
            CALL XYZINT                                           
            MM = MM+2401                                          
           END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C          Form (I,J//K,L) integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
           CALL FormIntegrals(GHONDO)                                       
          END IF
          NN = NN + 49
         END DO
        END IF                                                  
       END DO
      END DO
C                                                                       
      RETURN                                                            
      END                                                               

cccccccccccccccccccccccccccccccccccccccccc

Calling by ERISPDFGHIL XYZINT                                           
      SUBROUTINE XYZINT                                                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      LOGICAL N0,N1,M0,M1,FIRST1,FIRST2,FIRST3,FIRST4                   
      COMMON /SETINT/ I(13),K(13),NIMAX,NJMAX,NKMAX,NLMAX,NMAX,MMAX     
     +               ,BP01,B00,B10,XCP00,XC00,YCP00,YC00,ZCP00,ZC00,F00 
     +               ,DXIJ,DYIJ,DZIJ,DXKL,DYKL,DZKL                     
      COMMON /XYZ   / XINT(31213),YINT(31213),ZINT(31213)               
C                                                                       
      N0 = NMAX == 0                                                  
      N1 = NMAX <= 1                                                  
      M0 = MMAX == 0                                                  
      M1 = MMAX <= 1                                                  
C                                                                       
C     ----- I(0,0) -----                                                
C                                                                       
      I1 = I(1)                                                         
      XINT(I1) = 1.0d0                                                    
      YINT(I1) = 1.0d0                                                    
      ZINT(I1) = F00                                                    
      IF (N0 .and. M0) RETURN                                           
      I2 = I(2)                                                         
      K2 = K(2)                                                         
      CP10 = B00                                                        
C                                                                       
C     ----- I(1,0) -----                                                
C                                                                       
      IF (.NOT. N0) THEN                                                
        XINT(I2) = XC00                                                 
        YINT(I2) = YC00                                                 
        ZINT(I2) = ZC00*F00                                             
        IF (M0) GO TO 120                                               
      END IF                                                            
C                                                                       
C     ----- I(0,1) -----                                                
C                                                                       
      I3 = I1+K2                                                        
      XINT(I3) = XCP00                                                  
      YINT(I3) = YCP00                                                  
      ZINT(I3) = ZCP00*F00                                              
C                                                                       
C     ----- I(1,1) -----                                                
C                                                                       
      IF (.NOT. N0) THEN                                                
        I3 = I2+K2                                                      
        XINT(I3) = XCP00*XINT(I2)+CP10                                  
        YINT(I3) = YCP00*YINT(I2)+CP10                                  
        ZINT(I3) = ZCP00*ZINT(I2)+CP10*F00                              
      END IF                                                            
C                                                                       
  120 CONTINUE                                                          
      IF (.NOT. N1) THEN                                                
        C10 = 0.0d0                                                      
        I3 = I1                                                         
        I4 = I2                                                         
        DO 160 N = 2,NMAX                                               
          C10 = C10+B10                                                 
C                                                                       
C     ----- I(N,0) -----                                                
C                                                                       
          I5 = I(N+1)                                                   
          XINT(I5) = C10*XINT(I3)+XC00*XINT(I4)                         
          YINT(I5) = C10*YINT(I3)+YC00*YINT(I4)                         
          ZINT(I5) = C10*ZINT(I3)+ZC00*ZINT(I4)                         
          IF ( .NOT. M0) THEN                                           
            CP10 = CP10+B00                                             
C                                                                       
C     ----- I(N,1) -----                                                
C                                                                       
            I3 = I5+K2                                                  
            XINT(I3) = XCP00*XINT(I5)+CP10*XINT(I4)                     
            YINT(I3) = YCP00*YINT(I5)+CP10*YINT(I4)                     
            ZINT(I3) = ZCP00*ZINT(I5)+CP10*ZINT(I4)                     
          END IF                                                        
          I3 = I4                                                       
          I4 = I5                                                       
  160     CONTINUE                                                      
      END IF                                                            
      IF ( .NOT. M1) THEN                                               
        CP01 = 0.0d0                                                     
        C01 = B00                                                       
        I3 = I1                                                         
        I4 = I1+K2                                                      
        DO 220 M = 2,MMAX                                               
          CP01 = CP01+BP01                                              
C                                                                       
C     ----- I(0,M) -----                                                
C                                                                       
          I5 = I1+K(M+1)                                                
          XINT(I5) = CP01*XINT(I3)+XCP00*XINT(I4)                       
          YINT(I5) = CP01*YINT(I3)+YCP00*YINT(I4)                       
          ZINT(I5) = CP01*ZINT(I3)+ZCP00*ZINT(I4)                       
C                                                                       
C     ----- I(1,M) -----                                                
C                                                                       
          IF (.NOT. N0) THEN                                            
            C01 = C01+B00                                               
            I3 = I2+K(M+1)                                              
            XINT(I3) = XC00*XINT(I5)+C01*XINT(I4)                       
            YINT(I3) = YC00*YINT(I5)+C01*YINT(I4)                       
            ZINT(I3) = ZC00*ZINT(I5)+C01*ZINT(I4)                       
          END IF                                                        
          I3 = I4                                                       
          I4 = I5                                                       
  220   CONTINUE                                                        
      END IF                                                            
C                                                                       
C     ----- I(N,M) -----                                                
C                                                                       
      IF (.NOT. N1 .and. .NOT. M1) THEN                                 
        C01 = B00                                                       
        K3 = K2                                                         
        DO 280 M = 2,MMAX                                               
          K4 = K(M+1)                                                   
          C01 = C01+B00                                                 
          I3 = I1                                                       
          I4 = I2                                                       
          C10 = B10                                                     
          DO 260 N = 2,NMAX                                             
            I5 = I(N+1)                                                 
            XINT(I5+K4) = C10*XINT(I3+K4)+XC00*XINT(I4+K4)              
     *                    +C01*XINT(I4+K3)                              
            YINT(I5+K4) = C10*YINT(I3+K4)+YC00*YINT(I4+K4)              
     *                    +C01*YINT(I4+K3)                              
            ZINT(I5+K4) = C10*ZINT(I3+K4)+ZC00*ZINT(I4+K4)              
     *                    +C01*ZINT(I4+K3)                              
            C10 = C10+B10                                               
            I3 = I4                                                     
            I4 = I5                                                     
  260     CONTINUE                                                      
          K3 = K4                                                       
  280   CONTINUE                                                        
      END IF                                                            
C                                                                       
C     ----- I(NI,NJ,M) -----                                            
C                                                                       
      IF (NJMAX > 0) THEN                                            
        M = 0                                                           
        I5 = I(NMAX+1)                                                  
        FIRST1 = .TRUE.                                                 
        DO 430 WHILE (FIRST1 .or. M <= MMAX)                          
          MIN = NIMAX                                                   
          KM = K(M+1)                                                   
          FIRST2 = .TRUE.                                               
          DO 360 WHILE (FIRST2 .or. MIN < NMAX)                      
            N = NMAX                                                    
            I3 = I5+KM                                                  
            FIRST3 = .TRUE.                                             
            DO 340 WHILE (FIRST3 .or. N > MIN)                       
              I4 = I(N)+KM                                              
              XINT(I3) = XINT(I3)+DXIJ*XINT(I4)                         
              YINT(I3) = YINT(I3)+DYIJ*YINT(I4)                         
              ZINT(I3) = ZINT(I3)+DZIJ*ZINT(I4)                         
              I3 = I4                                                   
              N = N-1                                                   
              FIRST3 = .FALSE.                                          
  340       END DO                                                      
            MIN = MIN+1                                                 
            FIRST2 = .FALSE.                                            
  360     END DO                                                        
          IF (NIMAX > 0) THEN                                        
            I3 = 49+KM+I1                                               
            DO 400 NJ = 1,NJMAX                                         
              I4 = I3                                                   
              DO 380 NI = 1,NIMAX                                       
                XINT(I4) = XINT(I4+294)+DXIJ*XINT(I4-49)                
                YINT(I4) = YINT(I4+294)+DYIJ*YINT(I4-49)                
                ZINT(I4) = ZINT(I4+294)+DZIJ*ZINT(I4-49)                
                I4 = I4+343                                             
  380         CONTINUE                                                  
              I3 = I3+49                                                
  400       CONTINUE                                                    
          END IF                                                        
          M = M+1                                                       
          FIRST1 = .FALSE.                                              
  430   END DO                                                          
      END IF                                                            
C                                                                       
C     ----- I(NI,NJ,NK,NL) -----                                        
C                                                                       
      IF (NLMAX > 0) THEN                                            
        I5 = K(MMAX+1)                                                  
        IA = I1                                                         
        NI = 0                                                          
        FIRST4 = .TRUE.                                                 
        DO 580 WHILE (FIRST4 .or. NI <= NIMAX)                        
          NJ = 0                                                        
          IB = IA                                                       
          FIRST1 = .TRUE.                                               
          DO 570 WHILE (FIRST1 .or. NJ <= NJMAX)                      
            MIN = NKMAX                                                 
            FIRST2 = .TRUE.                                             
            DO 530 WHILE (FIRST2 .or. MIN < MMAX)                    
              M = MMAX                                                  
              I3 = IB+I5                                                
              FIRST3 = .TRUE.                                           
              DO 520 WHILE (FIRST3 .or. M > MIN)                     
                I4 = IB+K(M)                                            
                XINT(I3) = XINT(I3)+DXKL*XINT(I4)                       
                YINT(I3) = YINT(I3)+DYKL*YINT(I4)                       
                ZINT(I3) = ZINT(I3)+DZKL*ZINT(I4)                       
                I3 = I4                                                 
                M = M-1                                                 
                FIRST3 = .FALSE.                                        
  520         END DO                                                    
              MIN = MIN+1                                               
              FIRST2 = .FALSE.                                          
  530       END DO                                                      
            IF (NKMAX > 0) THEN                                      
              I3 = IB+1                                                 
              DO 560 NL = 1,NLMAX                                       
                I4 = I3                                                 
                DO 540 NK = 1,NKMAX                                     
                  XINT(I4) = XINT(I4+6)+DXKL*XINT(I4-1)                 
                  YINT(I4) = YINT(I4+6)+DYKL*YINT(I4-1)                 
                  ZINT(I4) = ZINT(I4+6)+DZKL*ZINT(I4-1)                 
                  I4 = I4+7                                             
  540           END DO                                                  
              I3 = I3+1                                                 
  560         END DO                                                    
            END IF                                                      
            NJ = NJ+1                                                   
            IB = IB+49                                                  
            FIRST1 = .FALSE.                                            
  570     END DO                                                        
          NI = NI+1                                                     
          IA = IA+343                                                   
          FIRST4 = .FALSE.                                              
  580   END DO                                                          
      END IF                                                            
C                                                                       
      RETURN                                                            
      END                                                               

Calling by ERISPDFGHIL FormIntegrals                                            
      SUBROUTINE FormIntegrals(GHONDO)                                          
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)                               
      DIMENSION GHONDO(*)                                               
      COMMON /DENS  / DKL(784),DIJ(784)                                 
      COMMON /INTDEX/ IJX(784),IJY(784),IJZ(784),IK(784),     
     *                KLX(784),KLY(784),KLZ(784)              
      COMMON/INTDEX1/IJGT(784),KLGT(784)           
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,          
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          
     *                NIJ,IJ,KL                                    
      COMMON /ROOT  / XX,U(13),W(13),NROOTS                             
      COMMON /XYZ   / XIN(31213),YIN(31213),ZIN(31213)                  
C-----------------------------------------------------------------------
      GO TO (10,20,30,40,50,60,70,80,90,100,110,120,130),NROOTS         
C     NROOTS=1                                            
   10 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      ))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=2                                            
   20 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=3                                            
   30 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=4                                            
   40 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=5                                            
   50 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=6                                            
   60 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=7                                            
   70 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           
     *          +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=8                                            
   80 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           
     *          +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           
     *          +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=9                                            
   90 CONTINUE                                                          
      DO I = 1,IJ                                                    
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                   
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           
     *          +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           
     *          +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           
     *          +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=10                                           
  100 CONTINUE                                                          
      DO I = 1,IJ                                                   
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                  
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           
     *          +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           
     *          +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           
     *          +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)           
     *          +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609))          
      END DO
      END DO
      RETURN                                                            
C     NROOTS=11                                           
  110 CONTINUE                                                          
      DO I = 1,IJ                                                   
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                  
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           
     *          +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           
     *          +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           
     *          +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)           
     *          +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609)           
     *          +   XIN(MX+24010)*YIN(MY+24010)*ZIN(MZ+24010))          
     *          *D1*DKL(K)+GHONDO(N)                                    
      END DO
      END DO
      RETURN                                                            
C     NROOTS=12                                           
  120 CONTINUE                                                          
      DO I = 1,IJ                                                   
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                  
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           
     *          +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           
     *          +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           
     *          +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)           
     *          +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609)           
     *          +   XIN(MX+24010)*YIN(MY+24010)*ZIN(MZ+24010)           
     *          +   XIN(MX+26411)*YIN(MY+26411)*ZIN(MZ+26411))          
     *          *D1*DKL(K)+GHONDO(N)                                    
      END DO
      END DO
      RETURN                                                            
C     NROOTS=13                                           
  130 CONTINUE
      DO I = 1,IJ                                                   
      D1 = DIJ(I)                                                       
      NX = IJX(I)                                                       
      NY = IJY(I)                                                       
      NZ = IJZ(I)                                                       
      N1 = IJGT(I)                                                      
      MAX = IK(I)                                                       
      DO K = 1,MAX                                                  
      MX = NX+KLX(K)                                                    
      MY = NY+KLY(K)                                                    
      MZ = NZ+KLZ(K)                                                    
      N = N1+KLGT(K)                                                    
      GHONDO(N) = GHONDO(N) + D1*DKL(K)*                                
     *            ( XIN(MX      )*YIN(MY      )*ZIN(MZ      )           
     *          +   XIN(MX+ 2401)*YIN(MY+ 2401)*ZIN(MZ+ 2401)           
     *          +   XIN(MX+ 4802)*YIN(MY+ 4802)*ZIN(MZ+ 4802)           
     *          +   XIN(MX+ 7203)*YIN(MY+ 7203)*ZIN(MZ+ 7203)           
     *          +   XIN(MX+ 9604)*YIN(MY+ 9604)*ZIN(MZ+ 9604)           
     *          +   XIN(MX+12005)*YIN(MY+12005)*ZIN(MZ+12005)           
     *          +   XIN(MX+14406)*YIN(MY+14406)*ZIN(MZ+14406)           
     *          +   XIN(MX+16807)*YIN(MY+16807)*ZIN(MZ+16807)           
     *          +   XIN(MX+19208)*YIN(MY+19208)*ZIN(MZ+19208)           
     *          +   XIN(MX+21609)*YIN(MY+21609)*ZIN(MZ+21609)           
     *          +   XIN(MX+24010)*YIN(MY+24010)*ZIN(MZ+24010)           
     *          +   XIN(MX+26411)*YIN(MY+26411)*ZIN(MZ+26411)           
     *          +   XIN(MX+28812)*YIN(MY+28812)*ZIN(MZ+28812))          
      END DO
      END DO
      RETURN
C-----------------------------------------------------------------------                                                            
      END                                                               

cccccccccccccccccccccccccccccccccccccccccc

CHONDO ZQOUT                                            
      SUBROUTINE ZQOUT(GHONDO)                                          
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)                                
      DIMENSION GHONDO(*)                                               
      LOGICAL IANDJ,KANDL,SAME                                          
      COMMON /INTDEX/ IJX(784),IJY(784),IJZ(784),IK(784),     
     *                KLX(784),KLY(784),KLZ(784)              
      COMMON/INTDEX1/IJGT(784),KLGT(784)           
      COMMON /MISC  / IANDJ,KANDL,SAME                                  
      COMMON /SHLNOS/ LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,          
     *                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,          
     *                NIJ,IJ,KL                                    
C-----------------------------------------------------------------------                                                                       
C     HONDO Conventional integral Output
C-----------------------------------------------------------------------                                                                       
      IJN = 0                                                           
      JMAX = MAXJ                                                       
      DO I = MINI,MAXI                                              
       IF (IANDJ) JMAX = I                                            
       DO 1 J = MINJ,JMAX                                           
          IJN = IJN+1                                                 
          N1 = IJGT(IJN)                                              
          LMAX = MAXL                                                 
          KLN = 0                                                     
        DO K =  MINK,MAXK                                       
         IF (KANDL) LMAX = K                                      
         DO L = MINL,LMAX                                     
          KLN = KLN+1                                           
          IF (SAME .and. KLN > IJN) GO TO 1                
          NN = N1+KLGT(KLN)                                     
          GHONDO(NN) = 0.0d0                                     
         END DO
        END DO
    1  CONTINUE                                                       
      END DO
C-----------------------------------------------------------------------                                                                       
      RETURN                                                            
      END                                                               

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!
!                                                                      !
!                    Electrostatic Moment Integrals                    !     
!                                                                      !
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!

C INTMOM                                           
      SUBROUTINE INTMOM(LIT1,LJT1,IJ,IJX,IJY,IJZ,DIJ,WINT,AA,AX,AY,AZ)    
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/ELPROP/IEMOM      
      COMMON/PRPINT/XINT0,XINT1,XINT2,XINT3,YINT0,YINT1,YINT2,YINT3,
     *              ZINT0,ZINT1,ZINT2,ZINT3
      COMMON/HERMIT/H1(55),W1(55)
      COMMON/XYZORB/TXYZ,X00,Y00,Z00,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ      
      DIMENSION DIJ(*),WINT(*),IJX(*),IJY(*),IJZ(*)                     
      DIMENSION XIN(49,4),YIN(49,4),ZIN(49,4)                           
C-----------------------------------------------------------------------
C                    Electrostatic Moment Integrals 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TXYZ  = 1.0d0/SQRT(AA)                                                 
      X00 = AX                                                           
      Y00 = AY                                                           
      Z00 = AZ                                                           
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IN = -7                                                           
      DO I=1,LIT1                                                   
       IN = IN+7                                                         
       NI = I                                                            
       DO J=1,LJT1                                                   
        JN = IN+J                                                         
        NJ = J                                                            
        CALL EMOMINT(H1,W1)                                                       
        XIN(JN,1) = XINT0*TXYZ                                               
        YIN(JN,1) = YINT0*TXYZ                                               
        ZIN(JN,1) = ZINT0*TXYZ                                               
        XIN(JN,2) = XINT1*TXYZ                                               
        YIN(JN,2) = YINT1*TXYZ                                               
        ZIN(JN,2) = ZINT1*TXYZ                                               
        IF(IEMOM>=2) THEN                                                  
         XIN(JN,3) = XINT2*TXYZ                                            
         YIN(JN,3) = YINT2*TXYZ                                            
         ZIN(JN,3) = ZINT2*TXYZ                                            
        END IF                                                            
        IF(IEMOM>=3) THEN                                                  
         XIN(JN,4) = XINT3*TXYZ                                            
         YIN(JN,4) = YINT3*TXYZ                                            
         ZIN(JN,4) = ZINT3*TXYZ                                            
        END IF                                                            
       END DO
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I=1,IJ                                                     
       NIX = IJX(I)                                                       
       NIY = IJY(I)                                                       
       NIZ = IJZ(I)                                                       
       DENS = DIJ(I)                                                      
       XIN0 = XIN(NIX,1)                                                  
       YIN0 = YIN(NIY,1)                                                  
       ZIN0 = ZIN(NIZ,1)                                                  
       XIN1 = XIN(NIX,2)                                                   
       YIN1 = YIN(NIY,2)                                                
       ZIN1 = ZIN(NIZ,2)                                                
       INDEX = I                                                       
       WINT(INDEX) = WINT(INDEX) + XIN1 * YIN0 * ZIN0 * DENS              
       INDEX = INDEX + IJ                                                
       WINT(INDEX) = WINT(INDEX) + XIN0 * YIN1 * ZIN0 * DENS             
       INDEX = INDEX + IJ                                                
       WINT(INDEX) = WINT(INDEX) + XIN0 * YIN0 * ZIN1 * DENS             
       IF(IEMOM>=2) THEN                                                  
        XIN2 = XIN(NIX,3)                                        
        YIN2 = YIN(NIY,3)                                                
        ZIN2 = ZIN(NIZ,3)                                                
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN2 * YIN0 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN2 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN0 * ZIN2 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN1 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN0 * ZIN1 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN1 * ZIN1 * DENS           
       END IF                                                            
       IF(IEMOM>=3) THEN                                                  
        XIN3 = XIN(NIX,4)                                                
        YIN3 = YIN(NIY,4)                                                
        ZIN3 = ZIN(NIZ,4)                                                
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN3 * YIN0 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN3 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN0 * ZIN3 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN2 * YIN1 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN2 * YIN0 * ZIN1 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN2 * ZIN0 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN2 * ZIN1 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN0 * ZIN2 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN0 * YIN1 * ZIN2 * DENS           
        INDEX = INDEX + IJ                                              
        WINT(INDEX) = WINT(INDEX) + XIN1 * YIN1 * ZIN1 * DENS           
       END IF                                                            
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN                                                            
      END                                                               

C EMOMINT                                           
      SUBROUTINE EMOMINT(H,WW)                                                 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/ELPROP/IEMOM      
      COMMON/PRPINT/XINT0,XINT1,XINT2,XINT3,YINT0,YINT1,YINT2,YINT3,
     *              ZINT0,ZINT1,ZINT2,ZINT3
      COMMON/XYZORB/TXYZ,X00,Y00,Z00,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ 
      COMMON/XYZPRP/Xcm,Ycm,Zcm,                                         
     *              DIPMX,DIPMY,DIPMZ,                                
     *              QXX,QYY,QZZ,QXY,QXZ,QYZ,                          
     *              QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,                    
     *              OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,                    
     *              OXZZ,OYZZ,OZZZ,OXYZ,                              
     *              OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,                    
     *              OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ                           
      DIMENSION H(36),WW(36),MINARRAY(8),MAXARRAY(8)                               
      DATA MINARRAY /1,2,4, 7,11,16,22,29/                                   
      DATA MAXARRAY /1,3,6,10,15,21,28,36/
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                                                       
C     Gauss-Hermite Quadrature
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      XINT0 = 0.0D+00                                                      
      YINT0 = 0.0D+00                                                      
      ZINT0 = 0.0D+00                                                      
      XINT1 = 0.0D+00                                                      
      YINT1 = 0.0D+00                                                      
      ZINT1 = 0.0D+00                                                      
      XINT2 = 0.0D+00                                                      
      YINT2 = 0.0D+00                                                      
      ZINT2 = 0.0D+00                                                      
      XINT3 = 0.0D+00                                                      
      YINT3 = 0.0D+00                                                      
      ZINT3 = 0.0D+00                                                      
      NPTS = (NI + NJ + IEMOM - 2)/2 + 1                                   
      IMIN = MINARRAY(NPTS)                                                  
      IMAX = MAXARRAY(NPTS)                                                  
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO I = IMIN,IMAX                                              
       DUM = WW(I)                                                     
       PX = DUM                                                       
       PY = DUM                                                       
       PZ = DUM
       DUM = H(I)*TXYZ                                                   
       PTX = DUM + X00                                                 
       PTY = DUM + Y00                                                 
       PTZ = DUM + Z00                                                 
       AX = PTX - XI                                                  
       AY = PTY - YI                                                  
       AZ = PTZ - ZI                                                  
       BX = PTX - XJ                                                  
       BY = PTY - YJ                                                  
       BZ = PTZ - ZJ                                                  
       CX = PTX - Xcm                                                  
       CY = PTY - Ycm                                                  
       CZ = PTZ - Zcm                                                  
C                                                                     
       GO TO (101,102,103,104,105,106,107), NI                        
  107  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  106  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  105  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  104  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  103  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  102  PX = PX*AX                                                     
       PY = PY*AY                                                     
       PZ = PZ*AZ                                                     
  101  CONTINUE                                                       
C                                                                       
       GO TO (201,202,203,204,205,206,207), NJ                        
  207  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  206  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  205  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  204  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  203  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  202  PX = PX*BX                                                     
       PY = PY*BY                                                     
       PZ = PZ*BZ                                                     
  201  CONTINUE                                                       
C                                                                     
       IEMOM1 = IEMOM + 1
       GO TO (301,302,303,304),IEMOM1                                    
  304  XINT3 = XINT3 + PX*CX*CX*CX                                    
       YINT3 = YINT3 + PY*CY*CY*CY                                    
       ZINT3 = ZINT3 + PZ*CZ*CZ*CZ                                    
  303  XINT2 = XINT2 + PX*CX*CX                                       
       YINT2 = YINT2 + PY*CY*CY                                       
       ZINT2 = ZINT2 + PZ*CZ*CZ                                       
  302  XINT1 = XINT1 + PX*CX                                          
       YINT1 = YINT1 + PY*CY                                          
       ZINT1 = ZINT1 + PZ*CZ                                          
  301  XINT0 = XINT0 + PX                                             
       YINT0 = YINT0 + PY                                             
       ZINT0 = ZINT0 + PZ                                             
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN                                                            
      END                                                               

!======================================================================!
!                                                                      !
!            O C C U P A T I O N    O P T I M I Z A T I O N            !
!                                                                      !
!             Spin-compensated Systems (Restricted Shells)             !
!                                                                      !
!    'Restricted Closed' (rc) Case: MSpin=0 [Singlet and Multiplet]    !
!       Singlet States (S=0,Ms=0) and Multiplet States (S>0,Ms=0)      !
!                                                                      !
!        'Restricted Open' (ro) Case: MSpin>0 [High-Spin State]        !
!                                                                      !
!======================================================================!
!                                                                      !
!     NO1:  Number of inactive doubly occupied orbitals (OCC=1)        !
!     NDOC: Number of strongly doubly occupied MOs                     !
!     NSOC: Number of strongly singly occupied MOs                     !
!     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)           !
!     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ. !
!     NCWO*NDOC: Active orbitals in the virtual subspace               !
!     NO0:  Empty orbitals  (OCC=0)                                    !
!     NVIR: Number of weakly occupied MOs + empty MOs                  !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!         NO1 |  NDOC + NSOC  |   NCWO*NDOC + NO0  = NBF               !                                                                
!         NO1 |      NDNS     |          NVIR      = NBF               !
!             | -NAC- |       |  -   NAC  - |                          !
!                    NB      NA            NBF5                        !
!                                                                      !
!**********************************************************************!
!                                                                      !
!   OCCOPTr: Minimize the energy with respect to the occupations (RO)  !
!                                                                      !
!**********************************************************************!

C OCCOPTr
      SUBROUTINE OCCOPTr(IFIRSTCALL,CONVG,ATMNAME,ZNUC,OVERLAP,
     &                   LIMLOW,LIMSUP,COEF,GAMMA,FMIUG0,
     &                   AHCORE,IJKL,XIJKL,ELAG,USER,IZCORE,
     &                   CX0,CY0,CZ0,KSTART,KNG,KKMIN,KKMAX,KATOM,
     &                   KTYPE,KLOC,EX1,CS,CP,CD,CF,CG,CH,CI,ELAGN,
     &                   COEFN,RON,IT,ITTOTAL,DIPS,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      LOGICAL CONVG
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP,IZCORE
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0,ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::OVERLAP,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,ELAG,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::GAMMA_OLD,EAHF,E
      DOUBLE PRECISION,DIMENSION(3)::DIPS
      INTEGER::IPRINTOPT
C-----------------------------------------------------------------------
C     Define the number of variables in the occupation optimization
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NV = NCWO*NDOC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     IFIRSTCALL
C          = 0  First Call to OCCOPTr (Occupation Optimization)
C          = 1  Iterative Procedure for Occupations and Coefficients
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(GAMMA_OLD(NBF5))
      IF(IFIRSTCALL==0)THEN
       GAMMA_OLD = 0.0d0
      ELSEIF(IFIRSTCALL==1)THEN
       CALL XtoX0(GAMMA,GAMMA_OLD,NBF5)      ! Keep GAMMA in GAMMA_OLD
      ENDIF
!----------------------------------------------------------------------!
!                     Pointers of the USER array                       !
!----------------------------------------------------------------------!
!                                                                      !
!     N1  = 1                  ! USER( N1) = RO(NBF5)                  !
!     N2  = N1  + NBF5         ! USER( N2) = CJ12(NBF5,NBF5)           !
!     N3  = N2  + NSQ5         ! USER( N3) = CK12(NBF5,NBF5)           !
!     N4  = N3  + NSQ5         ! USER( N4) = DR(NBF5,NBF5)             !
!     N5  = N4  + NSQ5         ! USER( N5) = DCJ12r(NBF5,NBF5,NBF5)    !
!     N6  = N5  + NSQ5*NBF5    ! USER( N6) = DCK12r(NBF5,NBF5,NBF5)    !
!     N7  = N6  + NSQ5         ! USER( N7) = QD(NBF,NBF,NBF)           !
!     N8  = N7  + NBF*NSQ      ! USER( N8) = HCORE(NBF5)               !
!     N9  = N8  + NBF5         ! USER( N9) = QJ(NBFT5)                 !
!     N10 = N9  + NBFT5        ! USER(N10) = QK(NBFT5)                 !
!     N11 = N10 + NBFT5        ! USER(N11) = DIPN                      !
!     N12 = N11 + 3            ! USER(N12) = ADIPx                     !
!     N13 = N12 + NSQ          ! USER(N13) = ADIPy                     !
!     N14 = N13 + NSQ          ! USER(N14) = ADIPz                     !
!     N15 = N14 + NSQ          ! USER(N15) = DIPx                      !
!     N16 = N15 + NSQ5         ! USER(N16) = DIPy                      !
!     N17 = N16 + NSQ5         ! USER(N17) = DIPz                      !
!     N18 = N17 + NSQ5         ! USER(N18) = QUADN(6)                  !
!     N19 = N18 + 6            ! USER(N19) = AQUADxx(NSQ)              !
!     N20 = N19 + NSQ          ! USER(N20) = AQUADyy(NSQ)              !
!     N21 = N20 + NSQ          ! USER(N21) = AQUADzz(NSQ)              !
!     N22 = N21 + NSQ          ! USER(N22) = AQUADxy(NSQ)              !
!     N23 = N22 + NSQ          ! USER(N23) = AQUADxz(NSQ)              !
!     N24 = N23 + NSQ          ! USER(N24) = AQUADyz(NSQ)              !
!     N25 = N24 + NSQ          ! USER(N25) = QUADxx(NSQ5)              !
!     N26 = N25 + NSQ5         ! USER(N26) = QUADyy(NSQ5)              !
!     N27 = N26 + NSQ5         ! USER(N27) = QUADzz(NSQ5)              !
!     N28 = N27 + NSQ5         ! USER(N28) = QUADxy(NSQ5)              !
!     N29 = N28 + NSQ5         ! USER(N29) = QUADxz(NSQ5)              !
!     N30 = N29 + NSQ5         ! USER(N30) = QUADyz(NSQ5)              !
!     N31 = N30 + NSQ5         ! USER(N31) = OCTUN(10)                 !
!     N32 = N31 + 10           ! USER(N32) = AOCTxxx(NSQ)              !
!     N33 = N32 + NSQ          ! USER(N33) = AOCTyyy(NSQ)              !
!     N34 = N33 + NSQ          ! USER(N34) = AOCTzzz(NSQ)              !
!     N35 = N34 + NSQ          ! USER(N35) = AOCTxxy(NSQ)              !
!     N36 = N35 + NSQ          ! USER(N36) = AOCTxxz(NSQ)              !
!     N37 = N36 + NSQ          ! USER(N37) = AOCTxyy(NSQ)              !
!     N38 = N37 + NSQ          ! USER(N38) = AOCTyyz(NSQ)              !
!     N39 = N38 + NSQ          ! USER(N39) = AOCTxzz(NSQ)              !
!     N40 = N39 + NSQ          ! USER(N40) = AOCTyzz(NSQ)              !
!     N41 = N40 + NSQ          ! USER(N41) = AOCTxyz(NSQ)              !
!     N42 = N41 + NSQ          ! USER(N42) = OCTXXX(NSQ5)              !
!     N43 = N42 + NSQ5         ! USER(N43) = OCTYYY(NSQ5)              !
!     N44 = N43 + NSQ5         ! USER(N44) = OCTZZZ(NSQ5)              !
!     N45 = N44 + NSQ5         ! USER(N45) = OCTXXY(NSQ5)              !
!     N46 = N45 + NSQ5         ! USER(N46) = OCTXXZ(NSQ5)              !
!     N47 = N46 + NSQ5         ! USER(N47) = OCTXYY(NSQ5)              !
!     N48 = N47 + NSQ5         ! USER(N48) = OCTYYZ(NSQ5)              !
!     N49 = N48 + NSQ5         ! USER(N49) = OCTXZZ(NSQ5)              !
!     N50 = N49 + NSQ5         ! USER(N50) = OCTYZZ(NSQ5)              !
!     N51 = N50 + NSQ5         ! USER(N51) = OCTXYZ(NSQ5)              !
!                                                                      !
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Transform atomic integrals using COEF to obtain HCORE, QJ and QK 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL FORMQHJK(COEF,USER(N7),USER(N8),USER(N9),USER(N10),AHCORE,
     &              IJKL,XIJKL)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Output of the MO inter-electronic integrals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NPRINTQJQK = 0
      IF(NPRINTQJQK==1)CALL OUTQJQK(USER(N9),USER(N10))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Output Energy and Properties with the input, and Stop if IEINI=1
c     Note: If ICOEF=2 -> IEINI=1 (see input.f)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IEINI==1.or.NV==0)THEN
       CALL OUTINITIALSr(NV,GAMMA,COEF,
     &      USER(N1),USER(N2),USER(N3),USER(N4),USER(N5),USER(N6),
     &      USER(N7),USER(N8),USER(N9),USER(N10),USER(N11),USER(N12),
     &      USER(N13),USER(N14),USER(N15),USER(N16),USER(N17),
     &      USER(N18),USER(N19),USER(N20),USER(N21),USER(N22),
     &      USER(N23),USER(N24),USER(N25),USER(N26),USER(N27),
     &      USER(N28),USER(N29),USER(N30),USER(N31),USER(N32),
     &      USER(N33),USER(N34),USER(N35),USER(N36),USER(N37),
     &      USER(N38),USER(N39),USER(N40),USER(N41),USER(N42),
     &      USER(N43),USER(N44),USER(N45),USER(N46),USER(N47),
     &      USER(N48),USER(N49),USER(N50),USER(N51),
     &      ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,IT,ITTOTAL,IPRINTOPT)
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Minimization of the total energy with respect to GAMMAs
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF( .NOT.CONVGDELAG.and.ICOEF/=2.and.NV>0 )THEN
       IF(ICGMETHOD==1)THEN
        CALL CGOCUPSUMSLr(NV,GAMMA,USER,EELEC)
       ELSE IF(ICGMETHOD==2)THEN
        CALL CGOCUPNAGr(NV,GAMMA,USER,EELEC)
       ELSE IF(ICGMETHOD==3)THEN       
        CALL LBFGSOCUPr(NV,GAMMA,USER,EELEC)
       ENDIF
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     One-particle Energies
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(EAHF(NBF),E(NBF))
      IF(IFIRSTCALL==0)THEN
C      Determine the 1-energies if first call and pass to ELAG
       CALL ENENEWr(USER(N1),USER(N8),USER(N9),USER(N10),USER(N2),
     &              USER(N3),USER(N15),USER(N16),USER(N17),EAHF,E)
       DO I=1,NBF
        ELAG(I,I) = E(I)
       ENDDO
      ELSEIF(IFIRSTCALL==1)THEN
C      The 1-energies are taken as eigenvalues of the MO optimization
       DO I=1,NBF
        E(I) = ELAG(I,I)
       ENDDO
       if(ICOEF==3)then
C       Determine the 1-energies if fragment calculation in in progress
        CALL ENENEWr(USER(N1),USER(N8),USER(N9),USER(N10),USER(N2),
     &               USER(N3),USER(N15),USER(N16),USER(N17),EAHF,E)
        DO I=1,NBF
         ELAG(I,I) = E(I)
        ENDDO
       endif
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Initial Output (IFIRSTCALL==0), Intermediate Output (NPRINT=2)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF((IFIRSTCALL==0.or.(IFIRSTCALL==1.and.NPRINT==2)).and.
     &    IPRINTOPT==1)THEN
       CALL PRINTOCr(E,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,              
     &               OVERLAP,USER(N1),USER(N2),USER(N3),USER(N7),
     &               USER(N10),USER(N11),USER(N12),
     &               USER(N13),USER(N14),USER(N15),USER(N16),USER(N17),
     &               USER(N18),USER(N19),USER(N20),USER(N21),USER(N22),
     &               USER(N23),USER(N24),USER(N25),USER(N26),USER(N27),
     &               USER(N28),USER(N29),USER(N30),USER(N31),USER(N32),
     &               USER(N33),USER(N34),USER(N35),USER(N36),USER(N37),
     &               USER(N38),USER(N39),USER(N40),USER(N41),USER(N42),
     &               USER(N43),USER(N44),USER(N45),USER(N46),USER(N47),
     &               USER(N48),USER(N49),USER(N50),USER(N51),IZCORE,
     &               CX0,CY0,CZ0,KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,
     &               KLOC,EX1,CS,CP,CD,CF,CG,CH,CI,IFIRSTCALL,DIPS)
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Write GAMMA, COEF, E, and FMIUG0 on File GCF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL WRITEGCFr(3,USER(N1),SUMS,COEF,E,FMIUG0,NSQ,NBF,NBF5,IT,
     &      EELEC,EN,NO1,NDOC,NSOC,NCWO,NAC,NO0,ZNUC,CX0,CY0,CZ0,NATOMS)
      IF(EELEC<EELEC_MIN.AND.IPRINTOPT==1)THEN
       CALL WRITEGCFr(8,USER(N1),SUMS,COEF,E,FMIUG0,NSQ,NBF,NBF5,IT,
     &      EELEC,EN,NO1,NDOC,NSOC,NCWO,NAC,NO0,ZNUC,CX0,CY0,CZ0,NATOMS)
       EELEC_MIN = EELEC
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Exit if convergence achieved
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(CONVGDELAG.and.ICOEF/=0)THEN
       CONVG=.TRUE.
       CALL FINALOUTPUTr(E,USER(N1),USER(N2),USER(N3),
     &                   USER(N7),USER(N8),USER(N9),USER(N10),
     &                   ELAG,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,
     &                   OVERLAP,USER(N11),USER(N12),USER(N13),
     &                   USER(N14),USER(N15),USER(N16),USER(N17),
     &                   USER(N18),USER(N19),USER(N20),USER(N21),
     &                   USER(N22),USER(N23),USER(N24),USER(N25),
     &                   USER(N26),USER(N27),USER(N28),USER(N29),
     &                   USER(N30),USER(N31),USER(N32),USER(N33),
     &                   USER(N34),USER(N35),USER(N36),USER(N37),
     &                   USER(N38),USER(N39),USER(N40),USER(N41),
     &                   USER(N42),USER(N43),USER(N44),USER(N45),
     &                   USER(N46),USER(N47),USER(N48),USER(N49),
     &                   USER(N50),USER(N51),IZCORE,CX0,CY0,CZ0,
     &                   KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC,
     &                   EX1,CS,CP,CD,CF,CG,CH,CI,ELAGN,COEFN,RON,
     &                   AHCORE,IJKL,XIJKL,IFIRSTCALL,DIPS,IPRINTOPT)
      ENDIF
C-----------------------------------------------------------------------
      DEALLOCATE(GAMMA_OLD,EAHF,E)
      RETURN
      END

!======================================================================!
!                                                                      !
!       Subroutines for transformations from atomic into molecular     !
!             integrals: Hjj, <ij|ij>, <ij|ji>, <ii|jj>                !
!                                                                      !
!                      HCORE, QJ and QK MATRICES                       !
!                                                                      !
!    FORMQHJK: Density for each j (QDj), HCORE, QJ and QK matrices     !
!    OUTQHJK: Print molecular integrals, that is, QJ and QK matrices   !
!    QHMATm: Calculate Dj matrix keeping in QD(J,:,:) and molec. Hcore !
!    DENMATj: Obtain Density matix for each j (called from QHMATm)     !
!    QJMATm: Coulomb Integrals QJ(i,j)                                 !
!    HSTARJ: Determine the skeleton J from atomic integrals (AUX)      !
!    QKMATm: Exchange Integrals QK(i,j)                                !
!    HSTARK: Determine the skeleton K from atomic integrals (AUX)      !
!                                                                      !
!======================================================================!

C FORMQHJK
      SUBROUTINE FORMQHJK(COEF,QD,HCORE,QJ,QK,AHCORE,IJKL,XIJKL)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION COEF(NBF,NBF)
      DIMENSION QD(NBF,NBF,NBF),HCORE(NBF5),QJ(NBFT5),QK(NBFT5)
      DIMENSION AHCORE(NBF,NBF),IJKL(NSTORE),XIJKL(NSTORE)
C-----------------------------------------------------------------------
      QJ=0.0d0
      QK=0.0d0
      CALL QHMATm(COEF,QD,HCORE,AHCORE)
      CALL QJMATm(QD,QJ,IJKL,XIJKL)
      CALL QKMATm(QD,QK,IJKL,XIJKL)
C-----------------------------------------------------------------------
      RETURN
      END

C OUTQJQK
      SUBROUTINE OUTQJQK(QJ,QK)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION QJ(NBFT5),QK(NBFT5)
C-----------------------------------------------------------------------
C     Print molecular integrals (called from OCCOPTr)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
      WRITE(6,1)
      DO J=1,NBF5
       DO I=1,J
        IJ=I+J*(J-1)/2
        WRITE(6,2)I,J,QJ(IJ),QK(IJ)
       ENDDO
      ENDDO
      DO J=1,NBF5
       JJ=J*(J+1)/2
       WRITE(6,3)J,QJ(JJ)/2.0d0
      ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
    1 FORMAT(/,
     *1X,46('-'),/,6X,'I',3X,'J',4X,'QJ(IJ)',2X,'QK(IJ)',/,1X,46('-'),/)
    2 FORMAT(3X,2I4,1X,2F8.3)
    3 FORMAT(3X,I4,1X,F8.3)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C QHMATm
      SUBROUTINE QHMATm(C,QD,HCORE,AHCORE)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION C(NBF,NBF),QD(NBF,NBF,NBF),HCORE(NBF5),AHCORE(NBF,NBF)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AUX
C-----------------------------------------------------------------------
C     Calculate D matrix for each value J and keep in QD(J,:,:)
C     Calculate molecular Hcore matrix (HCORE)
C-----------------------------------------------------------------------
      ALLOCATE(AUX(NBF,NBF))
      DO J=1,NBF
       CALL DENMATj(J,AUX,C,NBF)
       QD(J,1:NBF,1:NBF) = AUX(1:NBF,1:NBF)
      ENDDO
      DO J=1,NBF5
       AUX(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL TRACEm(HCORE(J),AUX,AHCORE,NBF)
      ENDDO
C-----------------------------------------------------------------------
      DEALLOCATE(AUX)
      RETURN
      END

C DENMATj
      SUBROUTINE DENMATj(J,D,C,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION D(NBF,NBF),C(NBF,NBF)
      DO M=1,NBF
       DO N=M,NBF
        D(M,N)=2.0d0*C(M,J)*C(N,J)
        D(N,M)=D(M,N)
       ENDDO
      ENDDO
      RETURN
      END

C QJMATm
      SUBROUTINE QJMATm(QD,QJ,IJKL,XIJKL)
C     Coulomb Integrals QJ(i,j)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION QD(NBF,NBF,NBF),QJ(NBFT5),IJKL(NSTORE),XIJKL(NSTORE)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AUX1,AUX2
      ALLOCATE (AUX1(NBF,NBF),AUX2(NBF,NBF))       ! AUX1:Jj(i,l)
C-----------------------------------------------------------------------
      DO J=1,NBF5
       AUX2(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL HSTARJ(AUX1,AUX2,IJKL,XIJKL)
       DO I=1,J
        IJ=I+J*(J-1)/2
        AUX2(1:NBF,1:NBF) = QD(I,1:NBF,1:NBF)
        CALL TRACEm(QJ(IJ),AUX2,AUX1,NBF)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      DEALLOCATE (AUX1,AUX2)
      RETURN
      END

C HSTARJ
      SUBROUTINE HSTARJ(FM,PM,IERI,ERI)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Wake up the nodes for the task
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=1
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
C----------------------------------------------------------------------
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
C----------------------------------------------------------------------
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

                       F(NIJ)=F(NIJ)+0.5*P(NKL)*XJ
       IF(NIJ/=NKL)    F(NKL)=F(NKL)+0.5*P(NIJ)*XJ
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Get the pieces from slaves
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,
     &                MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE(P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE(P,F)
#endif
C----------------------------------------------------------------------
      RETURN
      END

C QKMATm
      SUBROUTINE QKMATm(QD,QK,IJKL,XIJKL)
C     Exchange Integrals QK(i,j)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION QD(NBF,NBF,NBF),QK(NBFT5),IJKL(NSTORE),XIJKL(NSTORE)
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: AUX1,AUX2
      ALLOCATE (AUX1(NBF,NBF),AUX2(NBF,NBF))       ! AUX1:Kj(i,l)
C-----------------------------------------------------------------------
      DO J=1,NBF5
       AUX2(1:NBF,1:NBF) = QD(J,1:NBF,1:NBF)
       CALL HSTARK(AUX1,AUX2,IJKL,XIJKL)
       DO I=1,J
        IJ=I+J*(J-1)/2
        AUX2(1:NBF,1:NBF) = QD(I,1:NBF,1:NBF)
        CALL TRACEm(QK(IJ),AUX2,AUX1,NBF)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      DEALLOCATE (AUX1,AUX2)
      RETURN
      END

C HSTARK
      SUBROUTINE HSTARK(FM,PM,IERI,ERI)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=2
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
C----------------------------------------------------------------------
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
C----------------------------------------------------------------------
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       XJ = 0.25*XJ
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)+P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)+P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)+P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)+P(NIL)*XJ
       ENDIF
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Get the pieces from slaves
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,
     &                MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE (P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE (P,F)
#endif
C----------------------------------------------------------------------
      RETURN
      END

C LABELIJKL
      SUBROUTINE LABELIJKL(LABEL,I,J,K,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     Determine label (ijkl) (2**16-1=65535)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      I = ISHFT( LABEL, -48 )                                 
      J = IAND( ISHFT( LABEL, -32 ), 65535 )                  
      K = IAND( ISHFT( LABEL, -16 ), 65535 )                  
      L = IAND( LABEL, 65535 )                                
C-----------------------------------------------------------------------
      RETURN
      END
      
************************************************************************
*                                                                      *
*     1-Particle Energies                                              *
*                                                                      *
*     ENENEWr: Evaluate one-particle energies                          *
*                                                                      *
************************************************************************

C ENENEWr
      SUBROUTINE ENENEWr(RO,HCORE,QJ,QK,CJ12,CK12,DIPx,DIPy,DIPz,EAHF,E)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF)::EAHF,E
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX
C-----------------------------------------------------------------------
C     EAHF: New HF energies
C-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF5,NBF5))
      DO j=1,NBF5
       DO i=1,NBF5
        AUX(j,i) = RO(j)*RO(i)
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,na
       FI2j= RO(j)*(1.0-RO(j))
       FIj = SQRT(FI2j)
        jj = j*(j+1)/2
        ja = NBF5-j+1
       jja = j + ja*(ja-1)/2
       EAHF(j) =  RO(j)*HCORE(j) + 0.5d0*FI2j*QJ(jj)
     &         - 0.5d0*FIj*QK(jja) - FI2j*(QJ(jja)-0.5d0*QK(jja))
       do i=1,j
        ij = i + j*(j-1)/2
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))
       enddo
       do i=j+1,NBF5
        ij = j + i*(i-1)/2
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))
       enddo
      ENDDO
c      
      DO j=na+1,nbf5
       FI2j= RO(j)*(1.0-RO(j))
       FIj = SQRT(FI2j)
        jj = j*(j+1)/2
        ja = NBF5-j+1
       jja = ja + j*(j-1)/2
       EAHF(j) =  RO(j)*HCORE(j) + 0.5d0*FI2j*QJ(jj)
     &         - 0.5d0*FIj*QK(jja) - FI2j*(QJ(jja)-0.5d0*QK(jja))
       do i=1,j
        ij = i + j*(j-1)/2
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))
       enddo
       do i=j+1,NBF5
        ij = j + i*(i-1)/2
        EAHF(j) = EAHF(j) + AUX(j,i)*(2.0d0*QJ(ij)-QK(ij))
       enddo
      ENDDO
c      
      IF(NBF5<NBF)THEN
       DO J=NBF5+1,NBF
        EAHF(J) = 0.0d0
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
C     E: Diagonal of the Lagrangian (ELAG)
C-----------------------------------------------------------------------
      if(MSpin==0)then
       DO J=1,NB
        JJ=J*(J+1)/2
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )
     &       + PRODCWQWj(J,CJ12,QJ) - PRODCWQWj(J,CK12,QK)
       ENDDO
       DO J=NB+1,NA
        E(J) = RO(J) * HCORE(J)
     &       + PRODCWQWj(J,CJ12,QJ)-PRODCWQWj(J,CK12,QK)
       ENDDO
       DO J=NA+1,NBF5
        JJ=J*(J+1)/2
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )
     &       + PRODCWQWj(J,CJ12,QJ) - PRODCWQWj(J,CK12,QK)
       ENDDO
      else if(MSpin>0)then       
       DO J=1,NB
        JJ=J*(J+1)/2
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )
     &       + PRODCWQWj1(J,CJ12,QJ) - PRODCWQWj1(J,CK12,QK)
     &       + 2.0d0*PRODROQWj1(J,RO,QJ)-PRODROQWj1(J,RO,QK)
       ENDDO
       DO J=NB+1,NA
        E(J) = 0.5d0*( RO(J)*HCORE(J) + PRODROQWj0(J,RO,QJ)
     &                - PRODROQWj0(J,RO,QK) )
       ENDDO
       DO J=NA+1,NBF5
        JJ=J*(J+1)/2
        E(J) = RO(J) * ( HCORE(J) + QJ(JJ) )
     &       + PRODCWQWj2(J,CJ12,QJ) - PRODCWQWj2(J,CK12,QK)
     &       + 2.0d0*PRODROQWj2(J,RO,QJ)-PRODROQWj2(J,RO,QK)
       ENDDO
      end if 
c      
      IF(NBF5<NBF)THEN
       DO J=NBF5+1,NBF
        E(J) = 0.0d0                  ! /= ELAG(J,J) !!!
       ENDDO
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Including Electric Field
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EFIELDL)THEN
       DO J=1,NBF5
        E(J) = E(J) + (EX*DIPx(J)+EY*DIPy(J)+EZ*DIPz(J))*RO(J)
       ENDDO
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calculation of the Total Energy 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c      ETOTAL = 0.0
c      DO J=1,NB
c       ETOTAL = ETOTAL + E(J) + RO(J)*HCORE(J)
c      ENDDO
c      if(MSpin==0)then
c       DO J=NB+1,NA
c        ETOTAL = ETOTAL + E(J) + RO(J)*HCORE(J)       
c       ENDDO
c      else if(MSpin>0)then       
c       DO J=NB+1,NA
c        ETOTAL = ETOTAL + E(J) + 0.5d0*RO(J)*HCORE(J)       
c       ENDDO
c      end if
c      DO J=NA+1,NBF5
c       ETOTAL = ETOTAL + E(J) + RO(J)*HCORE(J)
c      ENDDO
c      IF(EFIELDL)THEN
c       DO J=1,NBF5
c        ETOTAL = ETOTAL + (EX*DIPx(J)+EY*DIPy(J)+EZ*DIPz(J))*RO(J)
c       ENDDO
c      ENDIF
c      write(6,*)'ETOTAL=',ETOTAL + EN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE (AUX)
      RETURN
      END

************************************************************************
*                                                                      *
*     Minimization of Elec. Energy using NAG CG or LBFGS Algorithms    *
*                                                                      *
*     OCUPACIONr: Calculate Occupation NUmbers and their Derivatives   *
*     CGOCUPNAGr: Prepare for calling the NAG subroutine E04DGF        *
*     ENERFUNr: External Energy subroutine that calls OCUPENERGYrc,ro  *
*     OCUPENERGYrc,ro: Calculate the electronic energy and gradient    *
*     LBFGSOCUPr: Optimize occupations by LBFGS algorithm              *
*                                                                      *
************************************************************************

C OCUPACIONr
      SUBROUTINE OCUPACIONr(GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,NV)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA       ! NV = NCWO*NDOC
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::DRO,BETA,DBETA,HR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::DB,DHR
C-----------------------------------------------------------------------
C                 Occupations and their Derivatives
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (DRO(NBF5),BETA(NBF5),DBETA(NBF5),DB(NBF5,NV))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RO = 0.0d0
      BETA = 0.0d0
      DRO = 0.0d0
      DBETA = 0.0d0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Occupations (1,NO1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NO1>0)THEN
       DO in=1,NO1
        RO(in) = 1.0d0
        BETA(in) = 1.0d0
       ENDDO
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Occupations (NO1+1,NO1+NDOC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,NDOC
       in = NO1+i
       RO(in)   = 0.5d0 + 0.5d0*DCOS(GAMMA(i))*DCOS(GAMMA(i))
       DRO(in)  = - 0.5d0*DSIN(2.0d0*GAMMA(i))
       BETA(in) = DSQRT(RO(in))
       DBETA(in)= 0.5d0*DRO(in)/BETA(in)
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Occupations (NO1+NDOC+1,NA=NO1+NDNS)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NSOC>0)THEN
       if(.not.HighSpin)then
        DO i=NDOC+1,NDNS
         in = NO1+i
         MULT1 = NA - NB
         RO(in)  = 0.5d0*MULT1/NSOC
         DRO(in) = 0.0d0
         BETA(in) = DSQRT(RO(in))
         DBETA(in) = 0.0d0
        ENDDO
       else if(HighSpin)then
        DO i=NDOC+1,NDNS
         in = NO1+i
         RO(in)  = 1.0d0
         DRO(in) = 0.0d0
        ENDDO
       end if      
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Occupations (NA+1,NBF5)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
C
       DR = 0.0d0
       DB = 0.0d0
       DO i=1,NDOC
        in = NO1+i                               ! in=no1+1,nb 
        DR(in,i) = DRO(in)
        DB(in,i) = DBETA(in)
        icf = na+ndoc-i+1      ! icf=na+ncwo*(ndoc-i)+ncwo with ncwo=1
        RO(icf)   = DSIN(GAMMA(i))*DSIN(GAMMA(i))/2.0d0
        DRO(icf)  = DSIN(2.0d0*GAMMA(i))/2.0d0
        DR(icf,i) = DRO(icf)
        BETA(icf) = DSIN(GAMMA(i))/DSQRT(2.0d0)
        DBETA(icf)= DCOS(GAMMA(i))/DSQRT(2.0d0)
        DB(icf,i) = DBETA(icf)
       ENDDO
C
      ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
C
       ALLOCATE (HR(NV-NDOC),DHR(NV-NDOC,NV))
       DR = 0.0d0
       DB = 0.0d0
       HR = 0.0d0
       DHR = 0.0d0
C       
       DO i=1,NDOC                                ! ig=i=1,ndoc
        in = NO1+i                                ! in=no1+1,nb
        DR(in,i) = DRO(in)
        DB(in,i) = DBETA(in)
        ici = (ncwo-1)*(i-1)+1
        icf = (ncwo-1)*i
         HR(ici:icf)  = 1.0d0 - RO(in)
        DHR(ici:icf,i)= - DRO(in)

C- - - -- - - - - - - - - - (i,iw) <-> ic,ig,in  - - - - - - - - - - - -
        do iw=1,ncwo-1
         ic = (ncwo-1)*(i-1)+iw             ! ic=1,ndoc*(ncwo-1)
         ig = ndoc+ic                       ! ig=ndoc+1,ndoc*ncwo
         im = na+ncwo*(ndoc-i)+iw           ! im=na+1,na+ncwo*ndoc-1
       
         ROn   = DSIN(GAMMA(ig))*DSIN(GAMMA(ig))
         BETAn = DSIN(GAMMA(ig))
         DRO(im)  = DSIN(2.0d0*GAMMA(ig))
         DBETA(im)= DCOS(GAMMA(ig))
         RO(im) =       HR(ic)*ROn
         RAIZic = DSQRT(HR(ic))
         BETA(im) = RAIZic*BETAn

         DR(im,i) =        DHR(ic,i)*ROn
         if(RAIZic>0.0d0)then
          DB(im,i) = 0.5d0*DHR(ic,i)*BETAn/RAIZic
         else 
          DB(im,i) = 0.0d0
         endif
         do ic1=ici,ic-1                           ! ici < ic1 < ic-1
          ig1 = ndoc+ic1                           !   i < ig1 < ig
          DR(im,ig1) =        DHR(ic,ig1)*ROn
          if(RAIZic>0.0d0)then
           DB(im,ig1) = 0.5d0*DHR(ic,ig1)*BETAn/RAIZic
          else 
           DB(im,ig1) = 0.0d0
          endif
         enddo
         DR(im,ig) = HR(ic)*DRO(im)
         DB(im,ig) = RAIZic*DBETA(im)

C- - - - HR(ic+1) - - - - - - - - - - - - - - - -
         if(iw<ncwo-1)then
          do ix=1,ncwo-1-iw
           ic1 = ic+ix                          ! ic < ic1 < i*(ncwo-1)
            HR(ic1)  =  HR(ic1) - RO(im)
           DHR(ic1,i)= DHR(ic1,i) - DR(im,i)
           do icn=ici,ic-1
            ign = ndoc+icn
            DHR(ic1,ign)= DHR(ic1,ign) - DR(im,ign)
           enddo
           DHR(ic1,ig)= DHR(ic1,ig) - DR(im,ig)
          enddo
         endif
C- - - - HR(ic+1) - - - - - - - - - - - - - - - -
        enddo
C- - - -- - - - - - - - - - (i,iw) <-> ic,ig,in  - - - - - - - - - - - -

C- - - - ic = icf - last RO  - - - - - - - - - - - - - -
        ig = ndoc+icf               ! ig=ndoc+i*(ncwo-1)
        im = na+ncwo*(ndoc-i)+ncwo
        Hn    = DCOS(GAMMA(ig))*DCOS(GAMMA(ig))
        BETAn = DCOS(GAMMA(ig))
        DRO(im)  = -DSIN(2.0d0*GAMMA(ig)) 
        DBETA(im)= -DSIN(GAMMA(ig))
        RO(im)  =       HR(icf)*Hn
        RAIZicf = DSQRT(HR(icf))
        BETA(im)= RAIZicf*BETAn

        DR(im,i) =        DHR(icf,i)*Hn
        if(RAIZicf>0.0d0)then
         DB(im,i) = 0.5d0*DHR(icf,i)*BETAn/RAIZicf
        else 
         DB(im,i) = 0.0d0
        endif
 
        do ic1=ici,icf-1            ! ici < ic1 < icf-1
         ig1 = ndoc+ic1             !   i < ig1 < ig
         DR(im,ig1) =        DHR(icf,ig1)*Hn
         if(RAIZicf>0.0d0)then
          DB(im,ig1) = 0.5d0*DHR(icf,ig1)*BETAn/RAIZicf
         else 
          DB(im,ig1) = 0.0d0
         endif
        enddo
        DR(im,ig) = HR(icf) *DRO(im)
        DB(im,ig) = RAIZicf*DBETA(im)
C- - - - ic = icf - last RO  - - - - - - - - - - - - - -
       ENDDO
       DEALLOCATE(HR,DHR)       
C
      ENDIF
      DEALLOCATE(DRO,DBETA)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Sum of the Holes below the Fermi Level (SUMS)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SUMS = DFLOAT(NB)
      do j=1,nb
       SUMS = SUMS - RO(j)
      enddo
C-----------------------------------------------------------------------
C                   CJ12, CK12, DCJ12r, DCK12r
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(IPNOF==3)THEN
       if(NSOC==0)CALL CJCKD3(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==4)THEN
       if(NSOC==0)CALL CJCKD4(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==5)THEN
       CALL CJCKD5(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==6)THEN
       if(NSOC==0)CALL CJCKD6(NV,RO,DR,CJ12,CK12,DCJ12r,DCK12r)
      ELSEIF(IPNOF==7)THEN
       CALL CJCKD7(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      ENDIF
C-----------------------------------------------------------------------
      DEALLOCATE(BETA,DB)
      RETURN
      END

C CGOCUPNAGr
      SUBROUTINE CGOCUPNAGr(NV,GAMMA,USER,ENERGY)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
      INTEGER,ALLOCATABLE,DIMENSION(:)::IUSER,IWORK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::GRAD,WORK
      EXTERNAL ENERFUNr
      ALLOCATE (IUSER(1),IWORK(NV+1),GRAD(NV),WORK(13*NV))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Send output of E04DGF to NAG file
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
cnag      CALL X04ABF(1,2)      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Function Precision (machine precision**0.9)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(THRESHEN>=1.0d-10)THEN
cnag      CALL E04DKF ('Function Precision = 1.0D-10')
      ELSEIF(THRESHEN==1.0d-11)THEN
cnag      CALL E04DKF ('Function Precision = 1.0D-11')
      ELSEIF(THRESHEN==1.0d-12)THEN
cnag      CALL E04DKF ('Function Precision = 1.0D-12')
      ELSEIF(THRESHEN==1.0d-13)THEN
cnag      CALL E04DKF ('Function Precision = 1.0D-13')
      ELSEIF(THRESHEN==1.0d-14)THEN
cnag      CALL E04DKF ('Function Precision = 1.0D-14')
      ELSEIF(THRESHEN==1.0d-15)THEN
cnag      CALL E04DKF ('Function Precision = 1.0D-15')
      ELSEIF(THRESHEN<=1.0d-16)THEN
cnag      CALL E04DKF ('Function Precision = 1.0D-16')
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Verify Level (-1 = No checks, 0 = cheap test, 1 = 0 + gradients)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
cnag      CALL E04DKF ('Verify Level = -1')      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Print Level (0 = No output, 1 = The final solution only)
C                 (5 = One line of summary output for each iteration)
C                 (10 = The final solution and one line for each iter.)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
cnag      CALL E04DKF ('Print Level = 0')
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calling to NAG Library for using the CG method
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IFAIL = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      GAMMA(1) = GAMMA(1)
      USER(1) = USER(1)
      ENERGY = ENERGY
cnag      CALL E04DGF(NV,ENERFUNr,ITER_E04DGF,ENERGY,GRAD,GAMMA,
cnag     &            IWORK,WORK,IUSER,USER,IFAIL)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE (IUSER,IWORK,GRAD,WORK)
      RETURN
      END

C ENERFUNr
      SUBROUTINE ENERFUNr(MODE,NV,X,ENERGY,GRAD,NSTATE,IUSER,USER)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(*)::IUSER
      DOUBLE PRECISION,DIMENSION(NV)::X,GRAD
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
C-----------------------------------------------------------------------
      NSTATE=NSTATE
      IUSER(1)=IUSER(1)
C-----------------------------------------------------------------------
      if(MSpin==0)then
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
C      Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
       CALL OCUPENERGYrc(MODE,X,USER(N1),USER(N2),USER(N3),USER(N4),
     &            USER(N5),USER(N6),USER(N7),USER(N8),USER(N9),
     &            USER(N10),USER(N11),USER(N12),USER(N13),USER(N14),
     &            USER(N15),USER(N16),USER(N17),ENERGY,GRAD,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -   
      else if(MSpin>0)then
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
C      High-Spin Multiplet State (S>0,Ms=S)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
       CALL OCUPENERGYro(MODE,X,USER(N1),USER(N2),USER(N3),USER(N4),
     &            USER(N5),USER(N6),USER(N7),USER(N8),USER(N9),
     &            USER(N10),USER(N11),USER(N12),USER(N13),USER(N14),
     &            USER(N15),USER(N16),USER(N17),ENERGY,GRAD,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      end if
C-----------------------------------------------------------------------
      RETURN
      END

C OCUPENERGYrc
      SUBROUTINE OCUPENERGYrc(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,
     &                        QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,
     &                        DIPx,DIPy,DIPz,ENERGY,GRAD,NV)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA,GRAD
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
C----------------------------------------------------------------------- 
C     Occupations
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OCUPACIONr(GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,NV)
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C                                ENERGY
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      IF(MODE==0.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
        enddo
        do i=1,NDOC
         in = NO1+i
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
         in = na+ndoc-i+1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
        enddo
        if(NSOC>0)then
         do i=NDOC+1,NDNS
          in = NO1+i
          ENERGY = ENERGY + 2.0d0*RO(in)*HCORE(in)
     &           + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
         enddo
        endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
        enddo
        do i=1,NDOC
         in = NO1+i
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
         do iw=1,ncwo-1
          in = na+ncwo*(ndoc-i)+iw   
          ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &           + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
         enddo
         in = na+ncwo*(ndoc-i)+ncwo
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
        enddo
        if(NSOC>0)then
         do i=NDOC+1,NDNS
          in = NO1+i
          ENERGY = ENERGY + 2.0d0*RO(in)*HCORE(in)
     &           + PRODCWQWj(in,CJ12,QJ) - PRODCWQWj(in,CK12,QK)
         enddo
        endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
c- - - including Electric Field  - - - - - - - - - - - - - - - - -
       if(EFIELDL)then
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,
     &               QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        ENERGY = ENERGY - EX*DMX - EY*DMY - EZ*DMZ
       endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C                               GRADIENTS
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      IF(MODE==1.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk(nv,in,ig,DCK12r,QK) )
          in = na+ndoc-i+1
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk(nv,in,ig,DCK12r,QK) )
         enddo
        ENDDO
c- - -  including Electric Field  - - - - - - - - - - - - - - - -
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
           in = na+ndoc-i+1
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk(nv,in,ig,DCK12r,QK) )
          do iw=1,NCWO-1
           in = na+ncwo*(ndoc-i)+iw   
           GRAD(ig) = GRAD(ig)
     &              + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &              + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)
     &                        - PRODCWQWjk(nv,in,ig,DCK12r,QK) )
          enddo
          in = na+ncwo*(ndoc-i)+ncwo
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk(nv,in,ig,DCK12r,QK) )
         enddo
        ENDDO
c- - -  including Electric Field  - - - - - - - - - - - - - - - -
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
           do iw=1,NCWO-1
            in = na+ncwo*(ndoc-i)+iw   
            GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &               * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
           enddo
           in = na+ncwo*(ndoc-i)+ncwo           
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END
      
C OCUPENERGYro
      SUBROUTINE OCUPENERGYro(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,
     &                        QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,
     &                        DIPx,DIPy,DIPz,ENERGY,GRAD,NV)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA,GRAD
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
C----------------------------------------------------------------------- 
C     Occupations
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL OCUPACIONr(GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,NV)
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C                                ENERGY
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      IF(MODE==0.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)
     &          + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)
        enddo
        do i=1,NDOC
         in = NO1+i
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)
     &          + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)          
         in = na+ndoc-i+1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj2(in,CJ12,QJ) - PRODCWQWj2(in,CK12,QK)
     &          + 2.0d0*PRODROQWj2(in,RO,QJ)-PRODROQWj2(in,RO,QK)     
        enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        do i=NDOC+1,NDNS
         in = NO1+i
         ENERGY = ENERGY + RO(in)*HCORE(in)
     &          + 0.5d0*(PRODROQWj0(in,RO,QJ)-PRODROQWj0(in,RO,QK))
        enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ENERGY = 0.0d0
        do in=1,NO1
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)
     &          + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)     
        enddo
        do i=1,NDOC
         in = NO1+i
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj1(in,CJ12,QJ) - PRODCWQWj1(in,CK12,QK)
     &          + 2.0d0*PRODROQWj1(in,RO,QJ)-PRODROQWj1(in,RO,QK)     
         do iw=1,ncwo-1
          in = na+ncwo*(ndoc-i)+iw   
          ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &           + PRODCWQWj2(in,CJ12,QJ) - PRODCWQWj2(in,CK12,QK)
     &          + 2.0d0*PRODROQWj2(in,RO,QJ)-PRODROQWj2(in,RO,QK)          
         enddo
         in = na+ncwo*(ndoc-i)+ncwo
         ENERGY = ENERGY + RO(in)*(2.0*HCORE(in)+QJ(in*(in+1)/2))
     &          + PRODCWQWj2(in,CJ12,QJ) - PRODCWQWj2(in,CK12,QK)
     &          + 2.0d0*PRODROQWj2(in,RO,QJ)-PRODROQWj2(in,RO,QK)          
        enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        do i=NDOC+1,NDNS
         in = NO1+i
         ENERGY = ENERGY + RO(in)*HCORE(in)
     &          + 0.5d0*(PRODROQWj0(in,RO,QJ)-PRODROQWj0(in,RO,QK))
        enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
c- - - including Electric Field  - - - - - - - - - - - - - - - - -
       if(EFIELDL)then
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,
     &               QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        ENERGY = ENERGY - EX*DMX - EY*DMY - EZ*DMZ
       endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C                               GRADIENTS
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      IF(MODE==1.or.MODE==2)THEN
       IF(NCWO==1)THEN             ! PNOFi(1): Perfect Pairing (NCWO=1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk1(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk1(nv,in,ig,DCK12r,QK) )
     &             + 2.0d0 *   PRODDRQWjk1(nv,in,ig,DR,QJ)
     &             -           PRODDRQWjk1(nv,in,ig,DR,QK)
          in = na+ndoc-i+1
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk2(nv,in,ig,DCK12r,QK) )
     &             + 2.0d0 *   PRODDRQWjk2(nv,in,ig,DR,QJ)
     &             -           PRODDRQWjk2(nv,in,ig,DR,QK)
         enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        ENDDO
C - - -  including Electric Field  - - - - - - - - - - - - - - - - - - - 
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
           in = na+ndoc-i+1
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ELSE                        ! PNOFi(Nc): Extended PNOF (NCWO>1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        GRAD = 0.0d0
        DO ig=1,NV
         do i=1,NDOC
          in = NO1+i
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk1(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk1(nv,in,ig,DCK12r,QK) )
     &             + 2.0d0 *   PRODDRQWjk1(nv,in,ig,DR,QJ)
     &             -           PRODDRQWjk1(nv,in,ig,DR,QK)
          do iw=1,NCWO-1
           in = na+ncwo*(ndoc-i)+iw   
           GRAD(ig) = GRAD(ig)
     &              + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &              + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,DCJ12r,QJ)
     &                        - PRODCWQWjk2(nv,in,ig,DCK12r,QK) )
     &              + 2.0d0 *   PRODDRQWjk2(nv,in,ig,DR,QJ)
     &              -           PRODDRQWjk2(nv,in,ig,DR,QK)
          enddo
          in = na+ncwo*(ndoc-i)+ncwo
          GRAD(ig) = GRAD(ig)
     &             + DR(in,ig) * ( 2.0d0*HCORE(in) + QJ(in*(in+1)/2) )
     &             + 2.0d0 * ( PRODCWQWjk2(nv,in,ig,DCJ12r,QJ)
     &                       - PRODCWQWjk2(nv,in,ig,DCK12r,QK) )
     &             + 2.0d0 *   PRODDRQWjk2(nv,in,ig,DR,QJ)
     &             -           PRODDRQWjk2(nv,in,ig,DR,QK)
         enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -          
        ENDDO
C - - -  including Electric Field  - - - - - - - - - - - - - - - - - - -
        if(EFIELDL)then   
         DO ig=1,NV
          do i=1,NDOC
           in = NO1+i
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
           do iw=1,NCWO-1
            in = na+ncwo*(ndoc-i)+iw   
            GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &               * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
           enddo
           in = na+ncwo*(ndoc-i)+ncwo           
           GRAD(ig) = GRAD(ig) + 2.0d0 * DR(in,ig)
     &              * ( EX*DIPx(in) + EY*DIPy(in) + EZ*DIPz(in) )
          enddo
         ENDDO
        endif
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END
      
C LBFGSOCUPr
      SUBROUTINE LBFGSOCUPr(NV,GAMMA,USER,ENERGY)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION,DIMENSION(NV)::GAMMA
      DOUBLE PRECISION,DIMENSION(NUSER)::USER
C
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
      INTEGER,PARAMETER::MSAVE=7
      DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE::W
      DOUBLE PRECISION X(NV),G(NV),DIAG(NV)
      DOUBLE PRECISION::F,EPS,XTOL,GTOL,STPMIN,STPMAX
      INTEGER::IFLAG,ICALL,N,M,MP,LP,NWORK
      INTEGER,DIMENSION(2)::IPRINT
      LOGICAL::DIAGCO
C     The driver for LBFGS must always declare LB2 as EXTERNAL
      EXTERNAL LB2
C-----------------------------------------------------------------------
      NWORK=NV*(2*MSAVE +1)+2*MSAVE
      ALLOCATE(W(NWORK))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calling to LBFGS SUBROUTINE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     CHECK COMMON /LB3, MP SETS UNIT WHERE PRINTING OPTIMIZATION INFO, 
C     AND LP WHERE PRINTING INFO ABOUT ERRORS
      N=NV ! NUMBER OF VARIABLES
      M=5     ! 0 <= M <= 7
      IPRINT(1)= -1
C     IPRINT(1) < 0 : no output is generated,
C     IPRINT(1) = 0 : output only at first and last iteration,
C     IPRINT(1) > 0 : output every IPRINT(1) iterations.      
      IPRINT(2)= 0
C     IPRINT(2) = 0 : iteration count, number of function 
C                     evaluations, function value, norm of the
C                     gradient, and steplength,
C     IPRINT(2) = 1 : same as IPRINT(2)=0, plus vector of
C                     variables and  gradient vector at the
C                     initial point,
C     IPRINT(2) = 2 : same as IPRINT(2)=1, plus vector of
C                     variables,
C     IPRINT(2) = 3 : same as IPRINT(2)=2, plus gradient vector.      
C
C     We do not wish to provide the diagonal matrices Hk0, and 
C     therefore set DIAGCO to FALSE.
      DIAGCO= .FALSE.
      EPS= 1.0D-5
      XTOL= 1.0D-16
      ICALL=0
      IFLAG=0
      X = GAMMA ! INITIAL ESTIMATE OF THE SOLUTION VECTOR
      MODE = 2
      DO
       if(NSOC==0)then
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C       Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        CALL OCUPENERGYrc(MODE,X,USER(N1),USER(N2),USER(N3),
     &                    USER(N4),USER(N5),USER(N6),USER(N7),
     &                    USER(N8),USER(N9),USER(N10),USER(N11),
     &                    USER(N12),USER(N13),USER(N14),USER(N15),
     &                    USER(N16),USER(N17),ENERGY,G,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --     
       else
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C       High-Spin Multiplet State (S>0,Ms=S)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        CALL OCUPENERGYro(MODE,X,USER(N1),USER(N2),USER(N3),
     &                    USER(N4),USER(N5),USER(N6),USER(N7),
     &                    USER(N8),USER(N9),USER(N10),USER(N11),
     &                    USER(N12),USER(N13),USER(N14),USER(N15),
     &                    USER(N16),USER(N17),ENERGY,G,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       end if
C      F CONTAINS THE VALUE OF THE FUNCTION AT THE POINT X
C      G CONTAINS THE COMPONENTS OF GRADIENT AT X
       F = ENERGY
       CALL LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
       GAMMA = X
       IF(IFLAG.LE.0) EXIT
       ICALL=ICALL + 1
C      We allow at most 2000 evaluations of F and G
       IF(ICALL.GT.2000) EXIT
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --       
      ENDDO
      DEALLOCATE(W)
C     FINAL CALL TO COMPUTE ENERGY AT EQUILIBRIUM POINT
      MODE = 1
      if(NSOC==0)then
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYrc(MODE,X,USER(N1),USER(N2),USER(N3),
     &                   USER(N4),USER(N5),USER(N6),USER(N7),
     &                   USER(N8),USER(N9),USER(N10),USER(N11),
     &                   USER(N12),USER(N13),USER(N14),USER(N15),
     &                   USER(N16),USER(N17),ENERGY,G,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --     
      else
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      High-Spin Multiplet State (S>0,Ms=S)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYro(MODE,X,USER(N1),USER(N2),USER(N3),
     &                   USER(N4),USER(N5),USER(N6),USER(N7),
     &                   USER(N8),USER(N9),USER(N10),USER(N11),
     &                   USER(N12),USER(N13),USER(N14),USER(N15),
     &                   USER(N16),USER(N17),ENERGY,G,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      end if
C-----------------------------------------------------------------------
      RETURN
      END

!**********************************************************************!
!                                                                      !
!                           Output Routines                            !
!                                                                      !
!  OUTINITIALSr: Output of properties with the input, stop if IEINI=1  !
!  GENOUTPUTr: Print Occupations, 1-Energies, Sum Occ                  !
!  PRINTOCr: Initial and Intermediate Outputs                          !
!  WRITEGCFr: Write ONs, NOs, and diag-elements of F on NFILE unix     !
!  FINALOUTPUTr: Final Output of the occupation optimization results   !
!  DIAGELAG: Diagonalization of Lagrange Multiplier Matrix if DIAGLAG  !
!  PRINTV: Print vectors V(N) without heading on NFILE unix            !
!  PRINTVERO: Print vectors V(N) with heading En-Occ on NFILE unix     !
!                                                                      !
!**********************************************************************!

C OUTINITIALSr
      SUBROUTINE OUTINITIALSr(NV,GAMMA,COEF,RO,CJ12,CK12,
     &                        DR,DCJ12r,DCK12r,QD,HCORE,QJ,QK,
     &                        DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,
     &                        QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,
     &                        AQUADxz,AQUADyz,QUADxx,QUADyy,QUADzz,
     &                        QUADxy,QUADxz,QUADyz,OCTUN,AOCTxxx,
     &                        AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,AOCTxyy,
     &                        AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,
     &                        OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,
     &                        OCTxzz,OCTyzz,OCTxyz,ATMNAME,ZNUC,LIMLOW,
     &                        LIMSUP,OVERLAP,IT,ITTOTAL,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC
      DOUBLE PRECISION,DIMENSION(NBF5)::GAMMA,RO,HCORE,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxx,QUADyy,QUADzz,QUADxy
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxz,QUADyz      
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxx,OCTyyy,OCTzzz,OCTxxy
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxz,OCTxyy,OCTyyz,OCTxzz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTyzz,OCTxyz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxy,AOCTxxz,AOCTxyy
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyyz,AOCTxzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::GRAD,EAHF,E
      INTEGER::IPRINTOPT
C-----------------------------------------------------------------------
C     Evaluate the Electronic Energy
C-----------------------------------------------------------------------
      ALLOCATE(GRAD(NV))
c
      MODE = 0
      if(MSpin==0)then
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      Singlet State (S=0,Ms=0) and Multiplet States (S>0,Ms=0)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYrc(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,
     &                   QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,
     &                   DIPx,DIPy,DIPz,EELEC,GRAD,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --    
      else if(MSpin>0)then
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      High-Spin Multiplet State (S>0,Ms=S)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       CALL OCUPENERGYro(MODE,GAMMA,RO,CJ12,CK12,DR,DCJ12r,DCK12r,
     &                   QD,HCORE,QJ,QK,DIPN,ADIPx,ADIPy,ADIPz,
     &                   DIPx,DIPy,DIPz,EELEC,GRAD,NV)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      end if
c      
      DEALLOCATE(GRAD)
C-----------------------------------------------------------------------
      IF(ICOEF/=2.and.NV>0)THEN
C-----------------------------------------------------------------------
C      Initial Values
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NZEROS<=NZEROSm)WRITE(6,1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      One-particle Energies
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(EAHF(NBF),E(NBF))
       CALL ENENEWr(RO,HCORE,QJ,QK,CJ12,CK12,DIPx,DIPy,DIPz,EAHF,E)
       DEALLOCATE(EAHF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Write Coeficient Matrix (Natural Orbitals)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IWRITEC==1.AND.IPRINTOPT==1)THEN
        WRITE(6,11)
        CALL PRINTVERO(6,COEF,E,RO,NBF,NBF5)                
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Mulliken Population Analysis
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IMULPOP==1.AND.IPRINTOPT==1)THEN
        WRITE(6,12)
        if(MSpin==0)then
         CALL MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,RO,QD)
        else if(MSpin>0)then
c        CALL MULLIKENro        to do!
        end if
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      General Output (Occupations)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IPRINTOPT==1)CALL GENOUTPUTr(RO,E)
       DEALLOCATE(E)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Print Electric Field
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL.AND.IPRINTOPT==1)WRITE(6,13)EX,EY,EZ
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Calculate Electrostatic Moments and print on the main output (6)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IEMOM>=1.AND.IPRINTOPT==1)THEN
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,
     &               QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        WRITE(6,14)DM*DFAC,DM,DMX,DMY,DMZ
       END IF
       IF(IEMOM>=2.AND.IPRINTOPT==1)THEN
        CALL QUADMOMr(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,
     &                AQUADyz,QUADxx,QUADyy,QUADzz,QUADxy,QUADxz,QUADyz,
     &                QD,RO,QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,
     &                QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)
        WRITE(6,15)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,
     &             QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,
     &             QTxx,QTyy,QTzz,QTxy,QTxz,QTyz
       ENDIF
       IF(IEMOM==3.AND.IPRINTOPT==1)THEN
        CALL OCTMOMr(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,
     &               AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,
     &               OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,OCTxzz,
     &               OCTyzz,OCTxyz,QD,RO,OMXXXe,OMYYYe,OMZZZe,OMXXYe,
     &               OMXXZe,OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,
     &               OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,
     &               OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)
        WRITE(6,16)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,OTXXY*OFAC,
     &             OTXXZ*OFAC,OTXYY*OFAC,OTYYZ*OFAC,OTXZZ*OFAC,
     &             OTYZZ*OFAC,OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,
     &             OTXXY,OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Energy Output
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IPRINTOPT==0)STOP
       IF(NZEROS<=NZEROSm)THEN
        WRITE(6,100)
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN
        WRITE(6,103)EELEC-EHF
       ELSE
        WRITE(6,104)
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN
        WRITE(6,103)EELEC-EHF
        WRITE(6,105)IT,ITTOTAL
        WRITE(6,200)
       ENDIF
       STOP
C-----------------------------------------------------------------------
      ENDIF
C----------------------------------------------------------------------
    1 FORMAT(/3X,'INITIAL VALUES'
     *     ,/2X,'=================')
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   11 FORMAT(/,
     * 18X,'------------------------------------------',/,
     * 18X,' NATURAL ORBITALS IN ATOMIC ORBITAL BASIS ',/,
     * 18X,'------------------------------------------')
   12 FORMAT(
     * /,2X,'------------------------------',/,
     *   2X,' Mulliken Population Analysis ',/,
     *   2X,'------------------------------')
   13 FORMAT(/,6X,'ELECTRIC FIELD (',D8.1,',',D8.1,',',D8.1,')')
   14 FORMAT(/,2X,'---------------',
     *        /2X,' Dipole Moment',
     *        /2X,'---------------',
     *      //,3X,F9.4,' Debye',' [',F9.4,
     *         2X,'(',F9.4,',',F9.4,',',F9.4,')',' ]')
   15 FORMAT(/,2X,'-------------------',
     *        /2X,' Quadrupole Moment',
     *        /2X,'-------------------',
     *       //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',
     *       //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')
   16 FORMAT(/,2X,'-----------------',
     *        /2X,' Octupole Moment',
     *        /2X,'-----------------',
     *       //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',
     *         5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',
     *       //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',
     *       //1X,'[',10F9.4,1X,']')
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  100 FORMAT(//2X,'INITIAL ENERGY (AU)',
     *       /1X,'=====================')
  101 FORMAT(/,8X,' HF Total Energy =',F14.6)
  102 FORMAT(  8X,'NOF Total Energy =',F14.6)
  103 FORMAT(  6X,'Correlation Energy =',F14.6,/)
  104 FORMAT(//3X,'ENERGY (AU)',
     *       /2X,'=============')
  105 FORMAT(/2X,'**************************************************',
     *       /2X,'*         No. EXTERNAL ITER =',I6,'              *',
     *       /2X,'*         No. of TOTAL ITER =',I6,'              *',
     *       /2X,'**************************************************')
C----------------------------------------------------------------------
  200 FORMAT(//2X,'**************************************************',
     *        /2X,'*                                                *',
     *        /2x,'*       SINGLE-POINT PNOF CALCULATION            *',
     *        /2X,'*                                                *',
     *        /2X,'*       BE CAREFUL NZEROS > NZEROSm!             *',
     *        /2X,'*                                                *',
     *        /2x,'*  FINAL RESULTS   FINAL RESULTS  FINAL RESULTS  *',
     *        /2X,'*                                                *',
     *        /2X,'**************************************************',
     *        /)
C----------------------------------------------------------------------
      END

C GENOUTPUTr
      SUBROUTINE GENOUTPUTr(RO,E)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,E
C-----------------------------------------------------------------------
C     Print the Occupations
C     SUMRO: Sum of the Occupations
C-----------------------------------------------------------------------
      WRITE(6,1)
      SUMRO = 0.0d0
c      
      DO J=1,NB
       WRITE(6,2)J,2.0*RO(J),E(J)
       SUMRO = SUMRO + 2.0d0*RO(J)       
      ENDDO
c      
      IF(NSOC>0)THEN      
       if(.not.HighSpin)then      
        DO J=NB+1,NA
         WRITE(6,2)J,2.0*RO(J),E(J)
         SUMRO = SUMRO + 2.0d0*RO(J)         
        ENDDO
       else if(HighSpin)then      
        DO J=NB+1,NA
         WRITE(6,2)J,RO(J),E(J)
         SUMRO = SUMRO + RO(J)         
        ENDDO
       end if
      END IF 
c      
      DO J=NA+1,NBF5
       WRITE(6,2)J,2.0*RO(J),E(J)
       SUMRO = SUMRO + 2.0d0*RO(J)       
      ENDDO
c      
      WRITE(6,3)NE,SUMRO
C-----------------------------------------------------------------------
    1 FORMAT(/,3X,'OM',5X,'Occupation',6X,'Elag Diag',/)
    2 FORMAT(2X,I3,2F15.7)
    3 FORMAT(/3X,'RO Sum (',I3,') =',F8.2)
C-----------------------------------------------------------------------     
      RETURN
      END

C PRINTOCr
      SUBROUTINE PRINTOCr(E,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,
     &                    OVERLAP,RO,CJ12,CK12,QD,QK,
     &                    DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,
     &                    QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,
     &                    AQUADxz,AQUADyz,QUADxx,QUADyy,QUADzz,
     &                    QUADxy,QUADxz,QUADyz,OCTUN,
     &                    AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,
     &                    AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,
     &                    OCTxxx,OCTyyy,OCTzzz,OCTxxy,OCTxxz,
     &                    OCTxyy,OCTyyz,OCTxzz,OCTyzz,OCTxyz,
     &                    IZCORE,CX0,CY0,CZ0,KSTART,KNG,
     &                    KKMIN,KKMAX,KATOM,KTYPE,KLOC,
     &                    EX1,CS,CP,CD,CF,CG,CH,CI,IFIRSTCALL,DIPS)                          
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP,IZCORE
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxx,QUADyy,QUADzz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxy,QUADxz,QUADyz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxx,OCTyyy,OCTzzz,OCTxxy
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxz,OCTxyy,OCTyyz,OCTxzz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTyzz,OCTxyz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QK
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12      
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxy,AOCTxxz,AOCTxyy
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyyz,AOCTxzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,DIMENSION(3):: DIPS
C-----------------------------------------------------------------------
      KLOC(1) = KLOC(1)
      IFIRSTCALL = IFIRSTCALL
C-----------------------------------------------------------------------
C     Skip Printing if NPRINT/=2
C-----------------------------------------------------------------------
      IF(ICOEF==0.or.NPRINT==2)THEN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Write Header on output file
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(ICOEF/=2)WRITE(6,1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      General Output (Occupations and N-representability conditions)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL GENOUTPUTr(RO,E)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Electric Field and Electrostatic Moments
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL)WRITE(6,7)EX,EY,EZ
       IF(IEMOM>=1)THEN
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,
     &               QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        DIPS(1) = DMX
        DIPS(2) = DMY
        DIPS(3) = DMZ
        WRITE(6,8)DM*DFAC,DM,DMX,DMY,DMZ
       END IF
       IF(IEMOM>=2)THEN
        CALL QUADMOMr(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,
     &                AQUADyz,QUADxx,QUADyy,QUADzz,QUADxy,QUADxz,QUADyz,
     &                QD,RO,QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,
     &                QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)
        WRITE(6,9)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,
     &            QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,
     &            QTxx,QTyy,QTzz,QTxy,QTxz,QTyz
       ENDIF
       IF(IEMOM==3)THEN
        CALL OCTMOMr(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,
     &               AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,
     &               OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,OCTxzz,
     &               OCTyzz,OCTxyz,QD,RO,OMXXXe,OMYYYe,OMZZZe,OMXXYe,
     &               OMXXZe,OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,
     &               OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,
     &               OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)
        WRITE(6,10)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,OTXXY*OFAC,
     &             OTXXZ*OFAC,OTXYY*OFAC,OTYYZ*OFAC,OTXZZ*OFAC,
     &             OTYZZ*OFAC,OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,
     &             OTXXY,OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
       ENDIF       
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Coeficient matrix and one-particle occupations
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IWRITEC==1)THEN
        IF(ICOEF==0)THEN
         WRITE(6,3)
        ELSE
         WRITE(6,4)
        ENDIF
        CALL PRINTVERO(6,COEF,E,RO,NBF,NBF5)        
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Mulliken Population Analysis
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IMULPOP==1.and.MSpin==0)THEN
        WRITE(6,5)
        CALL MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,RO,QD)
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Energy Output
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       WRITE(6,100)
       IF(INPUTC==0.and.EHF<0.0)THEN
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN
        WRITE(6,103)EELEC-EHF
       ELSE
        WRITE(6,102)EELEC+EN
       ENDIF
C-----------------------------------------------------------------------
      END IF
C
      IF(ICOEF==0)THEN
C-----------------------------------------------------------------------
C      Bader's analysis: Write information into a wavefunction file (wfn) 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IAIMPAC==1.and.MSpin==0)THEN
        CALL AIMMEMrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,
     &                KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
       END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      APSG File for the APSG generating wavefunction of PNOF5(Nc)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(APSG.and.NSOC==0.and.IPNOF==5)THEN
        REWIND(9)
C       Coefficient matrix
        WRITE(9,'(A5)')' $VEC'
        CALL PUNCHVEC(COEF,NBF)
        WRITE(9,'(A5)')' $END'
C       APSG Expansion Coefficients of the Generating PNOF5-wavefunction
        WRITE(9,'(A6)')' $APSG'
        CALL PUNCHAPSG(NO1,NCWO,NA,NBF5,RO,SUMA,THAPSG)
        WRITE(9,'(A5)')' $END'
        WRITE(9,'(1X,A16,F15.10)')'EXP. COEF. SUM =',SUMA
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      PRINT CJ12 and CK12 (MOLECULAR RDMs) IN CJK FILE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTCJK==1.and.MSpin==0)CALL OUTPUTCJKrc(RO,CJ12,CK12)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      PRINT ATOMIC RDMs IN .1dm and .2dm FILES
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTRDM==1.and.MSpin==0)THEN
        CALL OUTPUTRDMrc(OVERLAP,RO,QD,CJ12,CK12)
       ENDIF
C-----------------------------------------------------------------------       
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Non-Dynamic Correction if OIMP2 or MBPT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(OIMP2.OR.MBPT)CALL ECorrNonDyn(RO,QK,ECndl)
C----------------------------------------------------------------------
    1 FORMAT(//2X,'RESULTS OF THE OCCUPATION OPTIMIZATION'
     *      ,/1X,'========================================')
C    2 FORMAT(/,3X,'Chem Pot =',F12.6,4X,F15.6)
    3 FORMAT(/,
     * 18X,'------------------------------------------',/,
     * 18X,' NATURAL ORBITALS IN ATOMIC ORBITAL BASIS ',/,
     * 18X,'------------------------------------------')
    4 FORMAT(/,
     * 2X,'--------------------',/,
     * 2X,' COEFFICIENT MATRIX',/,
     * 2X,'--------------------')
    5 FORMAT(
     * /,2X,'------------------------------',/,
     *   2X,' Mulliken Population Analysis ',/,
     *   2X,'------------------------------')
C    6 FORMAT( 2X,'-------------',
C     *       /2X,' Occupations',
C     *       /2X,'-------------')
    7 FORMAT(/,6X,'Electric Field (',D8.1,',',D8.1,',',D8.1,')')
    8 FORMAT(/,2X,'---------------',
     *        /2X,' Dipole Moment',
     *        /2X,'---------------',
     *      //,3X,F9.4,' Debye',' [',F9.4,
     *         2X,'(',F9.4,',',F9.4,',',F9.4,')',' ]')
    9 FORMAT(/,2X,'-------------------',
     *        /2X,' Quadrupole Moment',
     *        /2X,'-------------------',
     *       //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',
     *       //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')
   10 FORMAT(/,2X,'-----------------',
     *        /2X,' Octupole Moment',
     *        /2X,'-----------------',
     *       //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',
     *         5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',
     *       //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',
     *       //1X,'[',10F9.4,1X,']')
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  100 FORMAT(/,
     * 2X,'----------------------------------------',/,
     * 2X,' Energies after Occupation Optimization ',/,
     * 2X,'----------------------------------------')
  101 FORMAT(/,8X,' HF Total Energy =',F14.6)
  102 FORMAT(  8X,'NOF Total Energy =',F14.6)
  103 FORMAT(  6X,'Correlation Energy =',F14.6,/)
C-----------------------------------------------------------------------
      RETURN
      END

C WRITEGCFr
      SUBROUTINE WRITEGCFr(NFILE,RO,SUMS,C,E,F,NSQ,NBF,NBF5,IT,EELEC,EN,
     &            NO1,NDOC,NSOC,NCWO,NAC,NO0,ZNUC,CX0,CY0,CZ0,NAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION RO(NBF5),C(NSQ),E(NBF),F(NBF)
      DOUBLE PRECISION,DIMENSION(NAT):: ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,PARAMETER::BOHR = 0.52917724924D+00
C-----------------------------------------------------------------------
      REWIND(NFILE)
      DO I=1,NBF5
       WRITE(NFILE,'(I6,F30.16)')I,RO(I)
      ENDDO
      DO I=NBF5+1,NBF
       WRITE(NFILE,'(I6,F30.16)')I,0.0d0
      ENDDO
      WRITE(NFILE,'(F30.16)')SUMS
      DO J = 1,NBF
       DO I = 1,NBF
        WRITE(NFILE,'(I6,F30.16)')I,C(I+(J-1)*NBF)
       ENDDO
      ENDDO
      DO I = 1,NBF
       WRITE(NFILE,'(I6,F30.16)')I,E(I)
      ENDDO
      DO I = 1,NBF
       WRITE(NFILE,'(I6,F30.16)')I,F(I)
      ENDDO
      WRITE(NFILE,'(I6,F30.16)')IT,EELEC+EN
      WRITE(NFILE,'(6I6)')NO1,NDOC,NSOC,NCWO,NAC,NO0
      DO I = 1,NAT
       WRITE(NFILE,'(I6,F30.16,F30.16,F30.16)')
     &                 INT(ZNUC(I)),BOHR*CX0(I),BOHR*CY0(I),BOHR*CZ0(I)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C FINALOUTPUTr
      SUBROUTINE FINALOUTPUTr(E,RO,CJ12,CK12,QD,HCORE,QJ,QK,
     &                        ELAG,COEF,ATMNAME,ZNUC,LIMLOW,LIMSUP,
     &                        OVERLAP,DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,
     &                        DIPz,QUADN,AQUADxx,AQUADyy,AQUADzz,
     &                        AQUADxy,AQUADxz,AQUADyz,QUADxx,QUADyy,
     &                        QUADzz,QUADxy,QUADxz,QUADyz,OCTUN,
     &                        AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,
     &                        AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,
     &                        OCTxxx,OCTyyy,OCTzzz,OCTxxy,OCTxxz,
     &                        OCTxyy,OCTyyz,OCTxzz,OCTyzz,OCTxyz,
     &                        IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,
     &                        KKMAX,KATOM,KTYPE,KLOC,EX1,CS,CP,CD,CF,
     &                        CG,CH,CI,ELAGN,COEFN,RON,AHCORE,
     &                        IJKL,XIJKL,IFIRSTCALL,DIPS,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4,DIMENSION(NATOMS)::ATMNAME
      INTEGER,DIMENSION(NATOMS)::LIMLOW,LIMSUP,IZCORE
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NIJKL)::IJKL
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(6)::QUADN
      DOUBLE PRECISION,DIMENSION(10)::OCTUN
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NBF5)::HCORE,RO,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxx,QUADyy,QUADzz
      DOUBLE PRECISION,DIMENSION(NBF5)::QUADxy,QUADxz,QUADyz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxx,OCTyyy,OCTzzz,OCTxxy
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTxxz,OCTxyy,OCTyyz,OCTxzz
      DOUBLE PRECISION,DIMENSION(NBF5)::OCTyzz,OCTxyz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF)::E,ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxx,AQUADyy,AQUADzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AQUADxy,AQUADxz,AQUADyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxx,AOCTyyy,AOCTzzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTxxy,AOCTxxz,AOCTxyy
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyyz,AOCTxzz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AOCTyzz,AOCTxyz
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEFN,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,DIMENSION(NIJKL)::XIJKL
      DOUBLE PRECISION,DIMENSION(3):: DIPS
      INTEGER::IPRINTOPT
C-----------------------------------------------------------------------
      KLOC(1) = KLOC(1)
      IFIRSTCALL = IFIRSTCALL
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check the orthonormality
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(CHKORTHO)CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
C-----------------------------------------------------------------------
      IF(IPRINTOPT==1)THEN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Write Header on output file
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(ICOEF/=2)WRITE(6,1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      General Output
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL GENOUTPUTr(RO,E)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Electric Field and Electrostatic Moments
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(EFIELDL)WRITE(6,7)EX,EY,EZ
       IF(IEMOM>=1)THEN
        CALL DIPMOMr(DIPN,ADIPx,ADIPy,ADIPz,DIPx,DIPy,DIPz,
     &               QD,RO,DMXe,DMYe,DMZe,DMX,DMY,DMZ,DM)
        DIPS(1) = DMX
        DIPS(2) = DMY
        DIPS(3) = DMZ
        WRITE(6,8)DM*DFAC,DM,DMX,DMY,DMZ
       END IF
       IF(IEMOM>=2)THEN
        CALL QUADMOMr(QUADN,AQUADxx,AQUADyy,AQUADzz,AQUADxy,AQUADxz,
     &                AQUADyz,QUADxx,QUADyy,QUADzz,QUADxy,QUADxz,QUADyz,
     &                QD,RO,QMXXe,QMYYe,QMZZe,QMXYe,QMXZe,QMYZe,
     &                QTxx,QTyy,QTzz,QTxy,QTxz,QTyz)
        WRITE(6,9)QTxx*QFAC,QTyy*QFAC,QTzz*QFAC,
     &            QTxy*QFAC,QTxz*QFAC,QTyz*QFAC,
     &            QTxx,QTyy,QTzz,QTxy,QTxz,QTyz
       END IF     
       IF(IEMOM==3)THEN
        CALL OCTMOMr(OCTUN,AOCTxxx,AOCTyyy,AOCTzzz,AOCTxxy,AOCTxxz,
     &               AOCTxyy,AOCTyyz,AOCTxzz,AOCTyzz,AOCTxyz,OCTxxx,
     &               OCTyyy,OCTzzz,OCTxxy,OCTxxz,OCTxyy,OCTyyz,OCTxzz,
     &               OCTyzz,OCTxyz,QD,RO,OMXXXe,OMYYYe,OMZZZe,OMXXYe,
     &               OMXXZe,OMXYYe,OMYYZe,OMXZZe,OMYZZe,OMXYZe,
     &               OTXXX,OTYYY,OTZZZ,OTXXY,OTXXZ,
     &               OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ)
        WRITE(6,10)OTXXX*OFAC,OTYYY*OFAC,OTZZZ*OFAC,OTXXY*OFAC,
     &             OTXXZ*OFAC,OTXYY*OFAC,OTYYZ*OFAC,OTXZZ*OFAC,
     &             OTYZZ*OFAC,OTXYZ*OFAC,OTXXX,OTYYY,OTZZZ,
     &             OTXXY,OTXXZ,OTXYY,OTYYZ,OTXZZ,OTYZZ,OTXYZ
       END IF
C-----------------------------------------------------------------------
C      Skip Printing if NPRINT=0, otherwise print EKT,ELAG,COEF,MulPop
C-----------------------------------------------------------------------
       IF(NPRINT>0)THEN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Coefficient matrix (NOs) and one-particle occupations
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(IWRITEC==1)THEN
         WRITE(6,4)
         CALL PRINTVERO(6,COEF,E,RO,NBF,NBF5)        
        ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Extended Koopmans Theorem (EKT)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(IEKT==1.and.MSpin==0)THEN       
         CALL EXTKOOPMANSrc(ELAG,COEF,OVERLAP,AHCORE,IJKL,XIJKL,RO)
        END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Print Lagrange Multipliers (ELAG Matrix) on main output (6)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(PRINTLAG)THEN
         WRITE(6,3)
         CALL PRINTV(6,ELAG,NBF)
        ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Diagonalization of Lagrange Multipliers (ELAG)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(DIAGLAG)CALL DIAGELAG(ELAG,COEF,RO,ELAGN,COEFN,RON)       
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Mulliken Population Analysis 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        IF(IMULPOP==1.and.MSpin==0)THEN
         WRITE(6,5)
         CALL MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,OVERLAP,RO,QD)
        ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       Calculate the chemical potential (CHEMP) for PNOF5,7(Nc)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ICHEMPOT=0
        IF(ICHEMPOT==1.and.MSpin==0.and.(IPNOF==5.or.IPNOF==7))
     &   CALL CHEMPOTrc(HCORE,QJ,QK,RO,DIPx,DIPy,DIPz)       
       END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Energy Output
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       WRITE(6,100)
       IF(EHF<0.0)THEN
        WRITE(6,101)EHF+EN
        WRITE(6,102)EELEC+EN,DUMEL,ABS(EELEC_OLD-EELEC)
        WRITE(6,103)EELEC-EHF
       ELSE
        WRITE(6,102)EELEC+EN,DUMEL,ABS(EELEC_OLD-EELEC)
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Bader's analysis:Write information into a wavefunction file (wfn) 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(IAIMPAC==1.and.MSpin==0)THEN
        CALL AIMMEMrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,
     &                KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
       END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      APSG File for the APSG generating wavefunction of PNOF5(Nc)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(APSG.and.NSOC==0.and.IPNOF==5)THEN
        REWIND(9)
C       Coefficient matrix
        WRITE(9,'(A5)')' $VEC'
        CALL PUNCHVEC(COEF,NBF)
        WRITE(9,'(A5)')' $END'
C       APSG Expansion Coefficients of the Generating PNOF5-wavefunction
        WRITE(9,'(A6)')' $APSG'
        CALL PUNCHAPSG(NO1,NCWO,NA,NBF5,RO,SUMA,THAPSG)
        WRITE(9,'(A5)')' $END'
        WRITE(9,'(1X,A16,F15.10)')'EXP. COEF. SUM =',SUMA
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      PRINT CJ12 and CK12 (MOLECULAR RDMs) IN CJK FILE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTCJK==1.and.MSpin==0)THEN
        CALL OUTPUTCJKrc(RO,CJ12,CK12)
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      PRINT ATOMIC RDMs IN .1dm and .2dm FILES
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(NOUTRDM==1.and.MSpin==0)THEN
        CALL OUTPUTRDMrc(OVERLAP,RO,QD,CJ12,CK12)
       ENDIF
C-----------------------------------------------------------------------       
      END IF 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Non-Dynamic Correction if OIMP2 or MBPT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(OIMP2.OR.MBPT)CALL ECorrNonDyn(RO,QK,ECndl)
C-----------------------------------------------------------------------
    1 FORMAT(//2X,'RESULTS OF THE OCCUPATION OPTIMIZATION'
     *      ,/1X,'========================================')
C    2 FORMAT(/,3X,'Chem Pot =',F12.6,4X,F15.6)
    3 FORMAT(/,
     * 18X,'--------------------------------',/,
     * 18X,' MATRIX OF LAGRANGE MULTIPLIERS ',/,
     * 18X,'--------------------------------')
    4 FORMAT(/,
     * 18X,'------------------------------------------',/,
     * 18X,' NATURAL ORBITALS IN ATOMIC ORBITAL BASIS ',/,
     * 18X,'------------------------------------------')
    5 FORMAT(/,
     * /,2X,'------------------------------',/,
     *   2X,' Mulliken Population Analysis ',/,
     *   2X,'------------------------------')
C    6 FORMAT(/2X,' Occupations ',
C     *       /2X,'-------------')
    7 FORMAT(/,6X,'Electric Field (',D8.1,',',D8.1,',',D8.1,')')
    8 FORMAT(/,2X,'---------------',
     *        /2X,' Dipole Moment',
     *        /2X,'---------------',
     *      //,3X,F9.4,' Debye',' [',F9.4,
     *         2X,'(',F9.4,',',F9.4,',',F9.4,')',' ]')
    9 FORMAT(/,2X,'-------------------',
     *        /2X,' Quadrupole Moment',
     *        /2X,'-------------------',
     *       //6X,'QXX',6X,'QYY',6X,'QZZ',6X,'QXY',6X,'QXZ',6X,'QYZ',
     *       //2X,6F9.4,2X,'(Buckingham)',//1X,'[',6F9.4,1X,']')
   10 FORMAT(/,2X,'-----------------',
     *        /2X,' Octupole Moment',
     *        /2X,'-----------------',
     *       //6X,'OXXX',5X,'OYYY',5X,'OZZZ',5X,'OXXY',5X,'OXXZ',
     *         5X,'OXYY',5X,'OYYZ',5X,'OXZZ',5X,'OYZZ',5X,'OXYZ',
     *       //2X,10F9.4,2X,'(X10**34 ESU-CM**3)',
     *       //1X,'[',10F9.4,1X,']')
C-----------------------------------------------------------------------
  100 FORMAT(/,
     * 1X,'----------------',/,
     * 1X,' Final Energies  ',/,
     * 1X,'----------------',/)
  101 FORMAT(8X,' HF Total Energy =',F20.10)
  102 FORMAT(2X,'Final NOF Total Energy =',
     *             F20.10,' (',ES7.0,1X,',',ES7.0,' )')
  103 FORMAT(6X,'Correlation Energy =',F20.10,/)
C-----------------------------------------------------------------------
      RETURN
      END

C DIAGELAG 
      SUBROUTINE DIAGELAG(ELAG,COEF,RO,ELAGN,COEFN,RON)
C=======================================================================
C     DIAGONALIZATION OF LAGRANGE MULTIPLIERS (ELAG)
C=======================================================================
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF)::ELAGN,RON
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,COEFN
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::TEMP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,DENMAT
C-----------------------------------------------------------------------
C     INTERMEDIATE MATRICES
C-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF,NBF),W(NBF,NBF),TEMP(NBF))
C-----------------------------------------------------------------------
C     DIAGONALIZATION OF THE LAGRANGE MULTIPLIERS (ELAG)
C-----------------------------------------------------------------------
C     ELAG -> SQUARE MATRIX (AUX)
C-----------------------------------------------------------------------
      DO I=1,NBF
       DO J=1,I
        AUX(I,J)=ELAG(I,J)
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     DIAGONALIZE SQUARE MATRIX (AUX) FOR REAL SYMMETRIC CASE
C     NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
C     W - EIGENVECTORS, ELAGN - EIGENVALUES 
C-----------------------------------------------------------------------
      CALL DIAG(NBF,AUX,W,ELAGN,TEMP)
C-----------------------------------------------------------------------
C     New Density Matrix (D=Wt*RO*W)
C-----------------------------------------------------------------------
      ALLOCATE(DENMAT(NBF,NBF))
      DO IP=1,NBF
       DO IQ=1,NBF
        DENMAT(IP,IQ)=0.0d0
        do i=1,nbf5
         DENMAT(IP,IQ)=DENMAT(IP,IQ)+W(i,IP)*RO(i)*W(i,IQ)
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     WRITE ONE-PARTICLE ENERGIES and NEW AVERAGE OCCUPATIONS (OUTPUT)
C-----------------------------------------------------------------------
      WRITE(6,1)
      DO I=1,NBF
       RON(I)=2.0d0*DENMAT(I,I)
       IF(RON(I)>1.0d-6)THEN
        WRITE(6,2)I,ELAGN(I),ELAGN(I)*27.21138386,RON(I)
       ENDIF
      ENDDO
      CALL DMATMAX(DENMAT,NBF,MAXI,MAXJ,DUM)
      WRITE(6,3)DUM,MAXI,MAXJ
C-----------------------------------------------------------------------
C     Coefficients of Canonical Orbitals (COEFN=COEF*W)
C-----------------------------------------------------------------------
      COEFN = MATMUL(COEF,W)
      WRITE(6,4)
      CALL PRINTVERO(6,COEFN,ELAGN,RON,NBF,NBF5)
C-----------------------------------------------------------------------
    1 FORMAT(/2X,26('-'),/3X,'Canonical Representation',/2X,26('-'),/,
     &       /20X,'One-Particle Energies',11X,'1RDM Diag',
     &       //19X,'(aU)',14X,'(eV)')
    2 FORMAT(2X,I4,4X,F15.6,4X,F15.6,9X,F8.6)
    3 FORMAT(/,15X,'Maximum 1RDM off-diagonal element:',F12.6,
     &         1X,'(',I3,',',I3,')')    
    4 FORMAT(/,
     & 18X,'---------------------------------',/,
     & 18X,' Eigenvectors of Lagrange Matrix ',/,
     & 18X,'---------------------------------')
C-----------------------------------------------------------------------
      DEALLOCATE (AUX,W,TEMP,DENMAT)
      RETURN
      END

C PRINTV
      SUBROUTINE PRINTV(NFILE,V,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::V
C-----------------------------------------------------------------------
      MAX=0
  10  MIN=MAX+1
      MAX=MAX+5
      IF(MAX>N)MAX=N
      WRITE(NFILE,1)(J,J=MIN,MAX)
      WRITE(NFILE,*)
      DO I=1,N
       WRITE(NFILE,2)I,(V(I,J),J=MIN,MAX)
      ENDDO
      IF(MAX<N) GOTO 10
      WRITE(NFILE,3)
C-----------------------------------------------------------------------
    1 FORMAT(/,7X,5(4X,I4,3X))
    2 FORMAT(I5,2X,5F11.6)
    3 FORMAT(/)
C-----------------------------------------------------------------------
      RETURN
      END

C PRINTVERO
      SUBROUTINE PRINTVERO(NFILE,V,E,RO,N,NL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*2 LABELAT
      CHARACTER*4 BFNAM1
      CHARACTER*6 BFNAM2
      DOUBLE PRECISION,DIMENSION(N)::E,RO
      DOUBLE PRECISION,DIMENSION(N,N)::V
C-----------------------------------------------------------------------
      MAX=0
  10  MIN=MAX+1
      MAX=MAX+5
      IF(MAX>NL) MAX=NL
      WRITE(NFILE,1)(J,J=MIN,MAX)
      WRITE(NFILE,*)      
      WRITE(NFILE,2)(RO(J),J=MIN,MAX)
      WRITE(NFILE,2)(E(J),J=MIN,MAX)      
      REWIND(4)
      READ(4,'(I5)')N0
      DO I=1,N
       IF(I<=35)THEN
        READ(4,3)LABELAT,IAT,BFNAM1
        WRITE(NFILE,4) I,LABELAT,IAT,BFNAM1,(V(I,J),J=MIN,MAX)
       ELSE
        READ(4,5)LABELAT,BFNAM2
        WRITE(NFILE,6) I,LABELAT,BFNAM2,(V(I,J),J=MIN,MAX)
       ENDIF
      ENDDO
      IF(MAX<NL) GOTO 10
      WRITE(NFILE,7)
C-----------------------------------------------------------------------
    1 FORMAT(/,15X,5(4X,I4,3X))
    2 FORMAT(15X,5F11.4)
    3 FORMAT(A2,I2,A4)
    4 FORMAT(I5,2X,A2,I2,A4,5F11.6)
    5 FORMAT(A2,A6)
    6 FORMAT(I5,2X,A2,A6,5F11.6)
    7 FORMAT(/)
C-----------------------------------------------------------------------
      RETURN
      END

! ==================================================================== !
!                                                                      !
!                                                                      !
!             Orthonormalization subroutines used in DoNOF             !
!                                                                      !
!   ORTHONORMAL: Orthogonalize and Orthonormalize MOs (COEF)           !
!   CANORTORB: Form Canonical Orthonormal Orbitals that diagonalize S  !
!   ORTHOGONALIZE: Project COEF into W vectors                         !
!   ORTHONORMALIZE: Orthonormalize COEF                                !
!   CHECKORTHO: Check the Orthonormality of the MOs                    !
!                                                                      !
!======================================================================!

C ORTHONORMAL
      SUBROUTINE ORTHONORMAL(NV,NBF,NBFT,OVERLAP,COEF,ICHECK,IPRINTOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NV)::COEF
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::OVERLAP
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,AUXE,S
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,COEFN
      INTEGER::IPRINTOPT
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Form Canonical Orthonormal Orbitals: Diagonalize the Overlap (AUX)
C     W - eigenvectors, EVA - eigenvalues
C     LIV - number of linearly independent eigenvectors 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(AUX(NBF,NBF),W(NBF,NBF),EVA(NBF),AUXE(NBF))
      AUX = OVERLAP
      CALL CANORTORB(AUX,W,EVA,AUXE,LIV,NBF)       ! LIV <= NBF
      DEALLOCATE(AUX)
C     Square OVERLAP -> Symmetric S
      ALLOCATE(S(NBFT))
      NZ=0
      DO I=1,NBF
       DO J=1,I
        NZ=NZ+1
        S(NZ)=OVERLAP(I,J)
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Orthogonalize orbitals
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Project COEF into W vectors
      CALL ORTHOGONALIZE(W,S,COEF,AUXE,NBF,LIV,NBFT)
C     Orthonormalize COEF
      CALL ORTHONORMALIZE(COEF,NBF,LIV)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     New Coefficients: Back-Transform to first basis (COEFN=COEF*W)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(COEFN(NBF,NV))
      CALL COEFW(NBF,LIV,COEFN,W,COEF)
      COEF=COEFN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check the Orthonormality of the new orbitals at least 3 times
C     and if not, then get the correct orthonormality for COEF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICHECK==1)THEN
       CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
       ITO=0
       DO WHILE(ITO<=1)
        ITO=ITO+1
        IF(IVIOORTHO/=0)THEN
         CALL ORTHOGONALIZE(W,S,COEF,AUXE,NBF,LIV,NBFT)
         CALL ORTHONORMALIZE(COEF,NBF,LIV)
         CALL COEFW(NBF,LIV,COEFN,W,COEF)
         COEF=COEFN
         CALL CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
        ENDIF
       ENDDO
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(COEFN,W,EVA,AUXE,S)
      RETURN
      END

C CANORTORB
      SUBROUTINE CANORTORB(S,Q,EIG,AUX,LIV,N)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION S(N,N),Q(N,N),EIG(N),AUX(N)
C-----------------------------------------------------------------------
      CALL DIAG(N,S,Q,EIG,AUX)
      DUM = EIG(1)
      J = 0
      K = 0
      DO I = 1,N
       IF(EIG(I)<1.0D-16)THEN
        K = K+1
       ELSE
        J = J+1
        EIG(J) = 1.0D0/SQRT(EIG(I))
        Q(1,J)=Q(1,I)
       ENDIF
      ENDDO
      LIV = N-K                                ! LIV <= N

      DO J=1,LIV
       DO i=1,N
        QiJ=Q(i,J)*EIG(J)
        IF(ABS(QiJ)<1.0D-16)QiJ=0.0d0
        Q(i,J)=QiJ
       ENDDO
      ENDDO
C
c      IF(LIV/=N)THEN
c       WRITE(6,'(/,50A,I5,/)')
c     & 'The number of linearly independent eigenvectors is',LIV
c       STOP
c      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C ORTHOGONALIZE
      SUBROUTINE ORTHOGONALIZE(Q,S,V,T,N,LIV,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)      
      DIMENSION Q(N,LIV),S(NT),V(N,N),T(N)
C-----------------------------------------------------------------------
      DO J=1,N
       IK=0
       DO I=1,N
        DUM = 0.0d0
        VDUM = V(I,J)
        IF(I>1) THEN
         DO K=1,I-1
          IK = IK+1
          DUM = DUM+S(IK)*V(K,J)
          T(K) = T(K)+S(IK)*VDUM
         ENDDO
        ENDIF
        IK = IK+1
        T(I) = DUM+S(IK)*VDUM
       ENDDO
       DO I=1,N
        V(I,J) = T(I)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      DO J=1,N
       DO I=1,LIV
        T(I) = DDOT(N,Q(1,I),1,V(1,J),1)
       ENDDO
       DO I=1,LIV
        V(I,J) = T(I)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C ORTHONORMALIZE
      SUBROUTINE ORTHONORMALIZE(V,N,LIV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION V(N,N)
C-----------------------------------------------------------------------
C     Orthonormalize first LIV Orbitals
C-----------------------------------------------------------------------
      IF(LIV>0)THEN
       DO I=1,LIV
        DUMI = 0.0d0
        DO K=1,N
         DUMI = DUMI + V(K,I)*V(K,I)
        ENDDO
        DUMI = 1.0d0/ SQRT(DUMI)
        DO K=1,N
         V(K,I) = V(K,I)*DUMI
        ENDDO
        IF(I<LIV)THEN
         DO J=I+1,LIV
          DUM = -DDOT(N,V(1,J),1,V(1,I),1)
          CALL DAXPY(N,DUM,V(1,I),1,V(1,J),1)
         ENDDO
        ENDIF
       ENDDO
      ENDIF
      IF(LIV==N)RETURN
C-----------------------------------------------------------------------
C     Get Orthogonal Space
C-----------------------------------------------------------------------
      I = LIV
      J = 0
    1 I0 = I
      I = I+1
      IF(I>N)RETURN
    2 J = J+1
      IF(J>N)THEN
       WRITE(6,10)I0,N
       STOP
      ENDIF
      DO K=1,N
       V(K,I) = 0.0d0
      ENDDO
      V(J,I) = 1.0d0
      DO L=1,I0
       DUM = -DDOT(N,V(1,L),1,V(1,I),1)
       CALL DAXPY(N,DUM,V(1,L),1,V(1,I),1)
      ENDDO
      DUMI = 0.0d0
      DO K=1,N
       DUMI = DUMI+V(K,I)*V(K,I)
      ENDDO
      IF(ABS(DUMI)<1.0D-16)GOTO 2
      DUMI = 1.0d0/ SQRT(DUMI)
      DO K=1,N
       V(K,I) = V(K,I)*DUMI
      ENDDO
      GOTO 1
   10 FORMAT(1X,'Orthogonalizing found a redundant set of vectors'/
     &       1X,'only',I5,' independent vectors found but there'/
     &       1X,'should be',I5,' MOs')
C-----------------------------------------------------------------------
      END
      
C CHECKORTHO
      SUBROUTINE CHECKORTHO(COEF,OVERLAP,IVIOORTHO,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION COEF(NBF,NBF),OVERLAP(NBF,NBF)
      INTEGER::IPRINTOPT
C-----------------------------------------------------------------------
      IVIOORTHO=0
      CSCMAX=0.0d0
      DO IQ=1,NBF
       DO JQ=1,IQ
        CSC=0.0d0
        do i=1,nbf
         CSC = CSC + COEF(i,IQ)*FC(i,JQ,OVERLAP,COEF)
        enddo
        IF(IQ==JQ.and.ABS(1.0-CSC)>1.0d-6)THEN
         IVIOORTHO=IVIOORTHO+1
         if(CSCMAX<ABS(1.0-CSC))CSCMAX=ABS(1.0-CSC)
c         write(6,*)IQ,JQ,CSC         
        ELSEIF(IQ/=JQ.and.ABS(CSC)>1.0d-6)THEN
         IVIOORTHO=IVIOORTHO+1
         if(CSCMAX<ABS(CSC))CSCMAX=ABS(CSC)
c         write(6,*)IQ,JQ,CSC         
        ENDIF
       ENDDO
      ENDDO
      IF(IPRINTOPT==0)RETURN
      IF(IVIOORTHO==0)THEN
       WRITE(6,1)
      ELSE
       WRITE(6,2)IVIOORTHO,CSCMAX
      ENDIF
      RETURN
C-----------------------------------------------------------------------
C     Format definitions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(/,' No violations of the orthonormality')
    2 FORMAT(/,' Orthonormality violations:',I8,
     &         ', Maximum Violation:',F10.6)
C-----------------------------------------------------------------------
      END
      
!======================================================================!
!                                                                      !
!          Subroutines related to occupation optimization of           !
!          spin-compensated systems using different PNOFs              !
!                                                                      !
!  CJCKD3: Define the coefficientes in front J,K,L integrals for PNOF3 !
!          ( J. Chem. Phys. 132, 031103, 2010 )                        !
!  CJCKD4: Define the coefficientes in front J,K,L integrals for PNOF4 !
!          ( J. Chem. Phys. 133, 111101, 2010 )                        !
!  CJCKD5: Define the coefficientes in front J,K,L integrals for PNOF5 !
!          ( J. Chem. Phys. 134, 164102, 2011; 139, 234109, 2013 )     !
!  CJCKD6: Define the coefficientes in front J,K,L integrals for PNOF6 !
!          ( J. Chem. Phys. 141, 044107, 2014 )                        !
!  AACOMP: Add parallel spin components in PNOFi (i=4,5,6) if Daa=Dab  !
!  CJCKD7: Define the coefficientes in front J,K,L integrals for PNOF7 !
!          ( PRL 119, 063002, 2017; PRA 100, 032508, 2019 )            !
!                                                                      !
!======================================================================!

C CJCKD3 = PNOF3 + pairing conditions
      SUBROUTINE CJCKD3(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::DSUMS(:)
C-----------------------------------------------------------------------
C                  CJ12, CK12, DCJ12r and DCK12r
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     CJpq = 2NpNq, CKpq = SQRT(NpNq)  (Note: in PNOF3 Daa = 0.0)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = 2.0d0*RO(j)*RO(i)
        CK12(j,i) = BETA(j)*BETA(i)
        do k=1,nv        
         DCJ12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         DCK12r(j,i,k) = DB(j,k)*BETA(i)
        enddo
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Derivatives of SUMS, FSUMS = (1-S)/S, and its derivatives
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SUMS<=1.0d0)THEN
       ALLOCATE(DSUMS(NV))
       do k=1,nv
        DSUMS(k) = 0.0d0
        DO j=1,NB
         DSUMS(k) = DSUMS(k) - DR(j,k)
        ENDDO
       enddo
       if(SUMS>1.0d-20)then
        FSUMS = 1.0d0/SUMS - 1.0d0
        do k=1,nv
        DSUMS(k) = DSUMS(k)/(SUMS*SUMS)           ! DSUMS is changed
       enddo
       else
        FSUMS = 0.0d0
        DSUMS = 0.0d0
       endif
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Including interactions
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SUMS<=1.0d0)THEN
       DO j=1,NB
        Hj = 1.0d0-RO(j)
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         CJ12(j,i) = CJ12(j,i) - Hj*Hi
         do k=1,nv
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DR(j,k)*Hi
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = CJ12(j,i) - FSUMS*Hj*RO(i)
         CK12(j,i) = CK12(j,i) + DSQRT(Hj*RO(i))
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DSUMS(k)*Hj*RO(i)
     &                  + FSUMS*DR(j,k)*RO(i)
          if(Hj>0.0d0)DCK12r(j,i,k) = DCK12r(j,i,k) 
     &                - 0.5d0*DSQRT(Hj*RO(i))*DR(j,k)/Hj
         enddo
        ENDDO
       ENDDO
       DO j=NB+1,NBF5
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         CJ12(j,i) = CJ12(j,i) - FSUMS*RO(j)*Hi
         CK12(j,i) = CK12(j,i) + DSQRT(RO(j)*Hi)
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - FSUMS*DR(j,k)*Hi
          if(RO(j)>0.0d0)DCK12r(j,i,k) = DCK12r(j,i,k) 
     &                   + 0.5d0*DSQRT(RO(j)*Hi)*DR(j,k)/RO(j)
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = CJ12(j,i) - RO(j)*RO(i)
         CK12(j,i) = - CK12(j,i)
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DR(j,k)*RO(i)
          DCK12r(j,i,k) = - DCK12r(j,i,k)
         enddo
        ENDDO
       ENDDO
      ELSE
       WRITE(6,*)'STOP PNOF3: SUMS > 1'
       STOP
      ENDIF
C-----------------------------------------------------------------------
      IF(SUMS<=1.0d0)DEALLOCATE(DSUMS)
      RETURN
      END

C CJCKD4 = PNOF4 + pairing conditions + SUMS>1 implementation as PNOF6
      SUBROUTINE CJCKD4(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::DSUMS(:),G(:),FI(:),DG(:,:),DF(:,:),DSUMF(:),DSUMG(:)
C-----------------------------------------------------------------------
C          Alpha-Beta Components of CJ12, CK12, DCJ12 and DCK12
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C                         CJpq = NpNq, CKpq = 0
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      CK12 = 0.0d0
      DCK12r = 0.0d0
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = RO(j)*RO(i)
        do k=1,nv        
         DCJ12r(j,i,k) = DR(j,k)*RO(i)
        enddo
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Derivatives of SUMS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DSUMS(NV))
      do k=1,nv
       DSUMS(k) = 0.0d0
       DO j=1,NB
        DSUMS(k) = DSUMS(k) - DR(j,k)
       ENDDO
      enddo
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
C                 Including interactions in CJ and CK
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      IF(SUMS<=1.0d0)THEN                                  ! SUMS <= 1
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      FSUMS = (1-S)/S, and its derivatives
C- - - - - - - - - - - - - - - - - - - - - - 
       if(SUMS>1.0d-20)then
        FSUMS = 1.0d0/SUMS - 1.0d0
        do k=1,nv
C        DSUMS is changed
         DSUMS(k) = DSUMS(k)/(SUMS*SUMS)
        enddo
       else
        FSUMS = 0.0d0
        DSUMS = 0.0d0
       endif
C- - - - - - - - - - - - - - - - - - - - - - 
       DO j=1,NB
        Hj = 1.0d0-RO(j)
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         CJ12(j,i) = CJ12(j,i) - Hj*Hi
         CK12(j,i) = DSQRT(Hj*Hi)
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DR(j,k)*Hi
          if(DABS(Hj)>0.0d0)DCK12r(j,i,k)=-0.5d0*CK12(j,i)*DR(j,k)/Hj
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = CJ12(j,i) - FSUMS*Hj*RO(i)
         CK12ji = Hj*RO(i)/SUMS
         CK12(j,i) = DSQRT( CK12ji*(RO(j)-RO(i)) + CK12ji*CK12ji )
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) + DSUMS(k)*Hj*RO(i)
     &                  + FSUMS*DR(j,k)*RO(i)
          DCK12jik = - DR(j,k)*RO(i)/SUMS - DSUMS(k)*Hj*RO(i)
          if(DABS(CK12(j,i))>0.0d0)
     &     DCK12r(j,i,k) = ( DCK12jik*(RO(j)-RO(i)) + CK12ji*DR(j,k)
     &                   + 2.0d0*CK12ji*DCK12jik ) / (2.0d0*CK12(j,i))
         enddo
        ENDDO
       ENDDO
       DEALLOCATE(DSUMS)
       DO j=NB+1,NBF5
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         CJ12(j,i) = CJ12(j,i) - FSUMS*RO(j)*Hi
         CK12ji = RO(j)*Hi/SUMS
         CK12(j,i) = DSQRT( CK12ji*(RO(i)-RO(j)) + CK12ji*CK12ji )
         do k=1,nv        
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - FSUMS*DR(j,k)*Hi
          DCK12jik = DR(j,k)*Hi/SUMS
          if(DABS(CK12(j,i))>0.0d0)
     &     DCK12r(j,i,k) = ( DCK12jik*(RO(i)-RO(j)) - CK12ji*DR(j,k)
     &                   + 2.0d0*CK12ji*DCK12jik ) / (2.0d0*CK12(j,i))
         enddo
        ENDDO
        DO i=NB+1,NBF5
         CJ12(j,i) = 0.0d0
         CK12(j,i) = - BETA(j)*BETA(i)
         do k=1,nv        
          DCJ12r(j,i,k) = 0.0d0
          DCK12r(j,i,k) = - DB(j,k)*BETA(i)
         enddo
        ENDDO
       ENDDO
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ELSE                                                 ! SUMS > 1
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      Gq, FIq = Nq*Hq + Gq*Gq - Gq*S, SUMF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(G(NBF5),DG(NBF5,NV))
       RHc = 0.5d0
       SUMS1 = 1.0d0-SUMS                  ! SUMS1 is negative
       DO j=1,NB
        Hj = 1.0d0 - RO(j)
        G(j) = HEAV(SUMS1)*Hj + (1.0d0-HEAV(SUMS1))*Hj*DEXP(-Hj/RHc)
        do k=1,nv
         DG(j,k) = -HEAV(SUMS1)*DR(j,k) - (1.0d0-HEAV(SUMS1))
     &           * (1.0d0-Hj/RHc)*DR(j,k)*DEXP(-Hj/RHc)
     &           + (DEXP(-Hj/RHc)-1.0d0)*Hj*DHEAV(SUMS1)*DSUMS(k)
        enddo
       ENDDO
       DO j=NB+1,NBF5
        G(j) = HEAV(SUMS1)*RO(j) 
     &       + (1.0d0-HEAV(SUMS1))*RO(j)*DEXP(-RO(j)/RHc)
        do k=1,nv
         DG(j,k) = HEAV(SUMS1)*DR(j,k) + (1.0d0-HEAV(SUMS1))
     &           * (1.0d0-RO(j)/RHc)*DR(j,k)*DEXP(-RO(j)/RHc)
     &           +(DEXP(-RO(j)/RHc)-1.0d0)*RO(j)*DHEAV(SUMS1)*DSUMS(k)
        enddo
       ENDDO
       DEALLOCATE(DSUMS)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       SUMG = 0.0d0
       DO j=NB+1,NBF5
        SUMG = SUMG + G(j) 
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(DSUMG(NV))
       do k=1,nv
        DSUMG(k) = 0.0d0
        DO j=NB+1,NBF5
         DSUMG(k) = DSUMG(k) + DG(j,k)
        ENDDO
       enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(FI(NBF5),DF(NBF5,NV))
       DO j=1,NBF5
        FI(j) = RO(j)*(1.0d0-RO(j)) + G(j)*(G(j)-SUMG)
        do k=1,nv        
         DF(j,k) = (1.0d0-2.0d0*RO(j))*DR(j,k) + DG(j,k)*(G(j)-SUMG)
     &           + G(j)*(DG(j,k)-DSUMG(k))
        enddo
       ENDDO
       DEALLOCATE(DSUMG)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       SUMF = 0.0d0
       DO j=NB+1,NBF5
        SUMF = SUMF + FI(j) 
       ENDDO
       IF(SUMF==0.0d0)SUMF=1.0d-6      ! to avoid dividing by zero
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(DSUMF(NV))
       do k=1,nv
        DSUMF(k) = 0.0d0
        DO j=NB+1,NBF5
         DSUMF(k) = DSUMF(k) + DF(j,k)
        ENDDO
        DSUMF(k) = DSUMF(k) / (SUMF*SUMF)
       enddo
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
       DO j=1,NB
        Hj = 1.0d0-RO(j)
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         Deltaji = G(j)*G(i)
         CJ12(j,i) = CJ12(j,i) - Deltaji
         F1ji = RO(j)*Hi + Deltaji
         F2ji = Hj*RO(i) + Deltaji
         CK12(j,i) = DSQRT( F1ji*F2ji )
         do k=1,nv
          DDeltajik = DG(j,k)*G(i)
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik
          DF1jik =  DR(j,k)*Hi    + DDeltajik
          DF2jik = -DR(j,k)*RO(i) + DDeltajik
          if(DABS(F1ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji
          if(DABS(F2ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
         enddo
        ENDDO
        DO i=NB+1,NBF5                    
         Hi = 1.0d0-RO(i)
         Deltaji = FI(j)*FI(i)/SUMF
         CJ12(j,i) = CJ12(j,i) - Deltaji
         F1ji = RO(j)*Hi + Deltaji
         F2ji = Hj*RO(i) + Deltaji
         CK12(j,i) = DSQRT( F1ji*F2ji )
         do k=1,nv
          DDeltajik = DF(j,k)*FI(i)/SUMF
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik
          DF1jik =  DR(j,k)*Hi    + DDeltajik
          DF2jik = -DR(j,k)*RO(i) + DDeltajik
          if(DABS(F1ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji
          if(DABS(F2ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
         enddo
        ENDDO
       ENDDO
       DO j=NB+1,NBF5
        Hj = 1.0d0-RO(j)
        DO i=1,NB
         Hi = 1.0d0-RO(i)
         Deltaji = FI(j)*FI(i)/SUMF
         CJ12(j,i) = CJ12(j,i) - Deltaji
         F1ji = RO(j)*Hi + Deltaji
         F2ji = Hj*RO(i) + Deltaji
         CK12(j,i) = DSQRT( F1ji*F2ji )
         do k=1,nv
          DDeltajik = DF(j,k)*FI(i)/SUMF - FI(j)*FI(i)*DSUMF(k)
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik
          DF1jik= DR(j,k)*Hi    + DDeltajik
          DF2jik=-DR(j,k)*RO(i) + DDeltajik
          if(DABS(F1ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji
          if(DABS(F2ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
         enddo
        ENDDO
        DO i=NB+1,NBF5
         Hi = 1.0d0-RO(i)
         Deltaji = G(j)*G(i)
         CJ12(j,i) = CJ12(j,i) - Deltaji
         F1ji = RO(j)*Hi + Deltaji
         F2ji = Hj*RO(i) + Deltaji
         CK12(j,i) = - DSQRT( F1ji*F2ji )
         do k=1,nv
          DDeltajik = DG(j,k)*G(i)
          DCJ12r(j,i,k) = DCJ12r(j,i,k) - DDeltajik
          DF1jik =  DR(j,k)*Hi    + DDeltajik
          DF2jik = -DR(j,k)*RO(i) + DDeltajik
          if(DABS(F1ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji
          if(DABS(F2ji)>0.0d0)
     &     DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
         enddo
        ENDDO
       ENDDO
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
       DEALLOCATE(G,DG,FI,DF,DSUMF)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ENDIF
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C                Alpha-Alpha Components (N > 2), Daa = Dab
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(NTWOPAR/=1)CALL AACOMP(NV,CJ12,CK12,DCJ12r,DCK12r)
C-----------------------------------------------------------------------
      RETURN
      END

C CJCKD6 = PNOF6(Nc)
      SUBROUTINE CJCKD6(NV,RO,DR,CJ12,CK12,DCJ12r,DCK12r)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::DSUMS(:),G(:),FI(:),DG(:,:),DF(:,:),DSUMF(:),DSUMG(:)
C-----------------------------------------------------------------------
C          Alpha-Beta Components of CJ12, CK12, DCJ12r and DCK12r
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C                         CJpq = NpNq, CKpq = 0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CK12 = 0.0d0
      DCK12r = 0.0d0
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = RO(j)*RO(i)
        do k=1,nv        
         DCJ12r(j,i,k) = DR(j,k)*RO(i)
        enddo
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Derivatives of SUMS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DSUMS(NV))
      do k=1,nv
       DSUMS(k) = 0.0d0
       DO j=1,NB
        DSUMS(k) = DSUMS(k) - DR(j,k)
       ENDDO
      enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Gq, DGqk
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(G(NBF5),DG(NBF5,NV))
      DO j=1,NB
       Hj = 1.0d0 - RO(j)
       G(j) = Hj*DEXP(-SUMS)
       do k=1,nv
        DG(j,k) = - ( DR(j,k) + Hj*DSUMS(k) ) * DEXP(-SUMS)
       enddo
      ENDDO
      DO j=NB+1,NBF5
       G(j) = RO(j)*DEXP(-SUMS)
       do k=1,nv        
        DG(j,k) = ( DR(j,k) - RO(j)*DSUMS(k) ) * DEXP(-SUMS)
       enddo
      ENDDO
      DEALLOCATE(DSUMS)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     SUMG, DSUMG
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SUMG = 0.0d0
      DO j=NB+1,NBF5
       SUMG = SUMG + G(j) 
      ENDDO
C- - - - - - - - - - - - - - - - - - - - 
      ALLOCATE(DSUMG(NV))
      do k=1,nv
       DSUMG(k) = 0.0d0
       DO j=NB+1,NBF5
        DSUMG(k) = DSUMG(k) + DG(j,k)
       ENDDO
      enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     FIq = Nq*Hq + Gq*Gq - Gq*S
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(FI(NBF5),DF(NBF5,NV))
      DO j=1,NBF5
       FI(j) = RO(j)*(1.0d0-RO(j)) + G(j)*(G(j)-SUMG)
       do k=1,nv        
        DF(j,k) = (1.0d0-2.0d0*RO(j))*DR(j,k) + DG(j,k)*(G(j)-SUMG)
     &          + G(j)*(DG(j,k)-DSUMG(k))
       enddo
      ENDDO
      DEALLOCATE(DSUMG)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     SUMF, DSUMF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      SUMF = 0.0d0
      DO j=NB+1,NBF5
       SUMF = SUMF + FI(j) 
      ENDDO
      IF(SUMF==0.0d0)SUMF=1.0d-6      ! to avoid dividing by zero
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(DSUMF(NV))
      do k=1,nv
       DSUMF(k) = 0.0d0
       DO j=NB+1,NBF5
        DSUMF(k) = DSUMF(k) + DF(j,k)
       ENDDO
       DSUMF(k) = DSUMF(k) / (SUMF*SUMF)
      enddo
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
C                 Including interactions in CJ and CK
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      DO j=1,NB
       Hj = 1.0d0-RO(j)
       DO i=1,NB
        Hi = 1.0d0-RO(i)
        CJ12(j,i) = CJ12(j,i) - G(j)*G(i)
        CK12(j,i) = DSQRT(G(j)*G(i))
        do k=1,nv        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DG(j,k)*G(i)
         if(G(j)>0.0d0)DCK12r(j,i,k) = 0.5d0*CK12(j,i)*DG(j,k)/G(j)
        enddo
       ENDDO
       DO i=NB+1,NBF5                    
        Hi = 1.0d0-RO(i)
        Deltaji = FI(j)*FI(i)/SUMF
        CJ12(j,i) = CJ12(j,i) - Deltaji
        F1ji = RO(j)*Hi + Deltaji
        F2ji = Hj*RO(i) + Deltaji
        CK12(j,i) = DSQRT( F1ji*F2ji )
        do k=1,nv        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DF(j,k)*FI(i)/SUMF
         DF1jik =  DR(j,k)*Hi    + DF(j,k)*FI(i)/SUMF
         DF2jik = -DR(j,k)*RO(i) + DF(j,k)*FI(i)/SUMF
         if(DABS(F1ji)>0.0d0)
     &    DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji
         if(DABS(F2ji)>0.0d0)
     &    DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
        enddo
       ENDDO
      ENDDO
      DO j=NB+1,NBF5
       Hj = 1.0d0-RO(j)
       DO i=1,NB
        Hi = 1.0d0-RO(i)
        Deltaji = FI(j)*FI(i)/SUMF
        CJ12(j,i) = CJ12(j,i) - Deltaji
        F1ji = RO(j)*Hi + Deltaji
        F2ji = Hj*RO(i) + Deltaji
        CK12(j,i) = DSQRT( F1ji*F2ji )
        do k=1,nv        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DF(j,k)*FI(i)/SUMF
     &                 + FI(j)*FI(i)*DSUMF(k)
         DF1jik= DR(j,k)*Hi   +DF(j,k)*FI(i)/SUMF-FI(j)*FI(i)*DSUMF(k)
         DF2jik=-DR(j,k)*RO(i)+DF(j,k)*FI(i)/SUMF-FI(j)*FI(i)*DSUMF(k)
         if(DABS(F1ji)>0.0d0)
     &    DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF1jik/F1ji
         if(DABS(F2ji)>0.0d0)
     &    DCK12r(j,i,k) = DCK12r(j,i,k) + 0.5d0*CK12(j,i)*DF2jik/F2ji
        enddo
       ENDDO
       DO i=NB+1,NBF5
        Hi = 1.0d0-RO(i)
        CJ12(j,i) = CJ12(j,i) - G(j)*G(i)
        CK12(j,i) = - DSQRT(G(j)*G(i))
        do k=1,nv        
         DCJ12r(j,i,k) = DCJ12r(j,i,k) - DG(j,k)*G(i)
         if(G(j)>0.0d0)DCK12r(j,i,k) = 0.5d0*CK12(j,i)*DG(j,k)/G(j)
        enddo
       ENDDO
      ENDDO
C-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
      DEALLOCATE(G,DG,FI,DF,DSUMF)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C             Alpha-Alpha Components (N > 2), Daa = Dab
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(NTWOPAR/=1)CALL AACOMP(NV,CJ12,CK12,DCJ12r,DCK12r)
C-----------------------------------------------------------------------
      RETURN
      END

C AACOMP
      SUBROUTINE AACOMP(NV,CJ12,CK12,DCJ12r,DCK12r)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
C-----------------------------------------------------------------------
      DO j=1,NBF5
       DO i=1,NBF5
        CK12(j,i) = CK12(j,i) +  CJ12(j,i)
        CJ12(j,i) = 2.0d0*CJ12(j,i)
        do k=1,nv
         DCK12r(j,i,k) = DCK12r(j,i,k) + DCJ12r(j,i,k)
         DCJ12r(j,i,k) = 2.0d0*DCJ12r(j,i,k) 
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C CJCKD5 = PNOF5(Nc)
      SUBROUTINE CJCKD5(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Extended (Nc>1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
C-----------------------------------------------------------------------
C                Inter-pair interactions for PNOF5(Nc)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     CJpq = 2NpNq, CKpq = NpNq [ DCJpqk = 2DNpk*Nq, DCKpq = DNpk*Nq ]
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C           NO1 |     NDNS     |              NVIR         = NBF               
C           NO1 | NDOC + NSOC  |     NCWO*NDOC     + NO0   = NBF               
C                      | NSOC  | NBF5 - NDNS - NO1 | NO0   = NBF
C                      NB      NA                NBF5
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = 2.0d0*RO(j)*RO(i)
        CK12(j,i) = RO(j)*RO(i)
        do k=1,nv
         DCJ12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         DCK12r(j,i,k) = DR(j,k)*RO(i)
        enddo
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - -              
      if(MSpin==0.and.NSOC>1)then                     
       DO j=NB+1,NA
        DO i=NB+1,NA
         CK12(j,i) = 2.0d0*RO(j)*RO(i)
         do k=1,nv
          DCK12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         enddo
        ENDDO      
       ENDDO
      end if
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C                Intra-pair interactions for PNOF5(Nc)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      DO l=1,NDOC
       ln = NO1+l
       DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        in = NO1+i
        CJ12(ln,in) = 0.0d0
        CJ12(in,ln) = 0.0d0
        CK12(ln,in) = BETA(ln)*BETA(in)
        CK12(in,ln) = BETA(in)*BETA(ln)
        do k=1,nv
         DCJ12r(ln,in,k) = 0.0d0
         DCJ12r(in,ln,k) = 0.0d0
         DCK12r(ln,in,k) = DB(ln,k)*BETA(in)
         DCK12r(in,ln,k) = DB(in,k)*BETA(ln)
        enddo
        DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         jn = NO1+j
         CJ12(jn,in) = 0.0d0
         CK12(jn,in) = - BETA(jn)*BETA(in)
         do k=1,nv
          DCJ12r(jn,in,k) = 0.0d0
          DCK12r(jn,in,k) = - DB(jn,k)*BETA(in)
         enddo
        ENDDO
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C CJCKD7 = PNOF7n(Nc)(Ista=0) and PNOF7s(Nc)(Ista=1)
      SUBROUTINE CJCKD7(NV,RO,DR,BETA,DB,CJ12,CK12,DCJ12r,DCK12r)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,BETA
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR,DB
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::DCJ12r,DCK12r
      ALLOCATABLE::FIs(:),DFIs(:,:)
C-----------------------------------------------------------------------
C     FIs
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(FIs(NBF5),DFIs(NBF5,NV))
      FIs = 0.0d0      
      DFIs = 0.0d0
      if(Ista==0)then
C- - - - - - - - - - - - - - - - - - - - - - - - - - -  
C      FIs = (Np*Hp)^1/2
C- - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        FIs(j) = DSQRT( RO(j)*(1.0d0-RO(j)) )
        if(FIs(j)>1.0d-20)then
         do k=1,nv        
          DFIs(j,k) = (0.5d0-RO(j))*DR(j,k)/FIs(j)
         enddo
        endif
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - -              
      else if(Ista==1)then
C- - - - - - - - - - - - - - - - - - - - - - - - - - -  
c      FIs = (4*Np*Hp)^0.5*(Np*Hp)^0.5 = 2*Np*Hp
C- - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        FIs(j) = 2.0d0*RO(j)*(1.0d0-RO(j))
        do k=1,nv        
         DFIs(j,k) = 2.0d0*(1.0d0-2.0d0*RO(j))*DR(j,k)
        enddo
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - -       
      end if
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                  - Interpair Electron Correlation -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C           NO1 |     NDNS     |              NVIR         = NBF               
C           NO1 | NDOC + NSOC  |     NCWO*NDOC     + NO0   = NBF               
C                      | NSOC  | NBF5 - NDNS - NO1 | NO0   = NBF
C                      NB      NA                NBF5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NBF5
       DO i=1,NBF5
        CJ12(j,i) = 2.0d0*RO(j)*RO(i)
        CK12(j,i) = RO(j)*RO(i) + FIs(j)*FIs(i)        
        do k=1,nv
         DCJ12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         DCK12r(j,i,k) = DR(j,k)*RO(i) + DFIs(j,k)*FIs(i)   
        enddo
       ENDDO
      ENDDO
      DEALLOCATE(FIs,DFIs)      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(MSpin==0.and.NSOC>1)then
       DO j=NB+1,NA
        DO i=NB+1,NA
         CK12(j,i) = 2.0d0*RO(j)*RO(i)
         do k=1,nv
          DCK12r(j,i,k) = 2.0d0*DR(j,k)*RO(i)
         enddo
        ENDDO      
       ENDDO
      end if
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                  - Intrapair Electron Correlation -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO l=1,NDOC
       ln = NO1+l
       DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        in = NO1+i
        CJ12(ln,in) = 0.0d0
        CJ12(in,ln) = 0.0d0
        CK12(ln,in) = BETA(ln)*BETA(in)
        CK12(in,ln) = BETA(in)*BETA(ln)
        do k=1,nv
         DCJ12r(ln,in,k) = 0.0d0
         DCJ12r(in,ln,k) = 0.0d0
         DCK12r(ln,in,k) = DB(ln,k)*BETA(in)
         DCK12r(in,ln,k) = DB(in,k)*BETA(ln)
        enddo
        DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         jn = NO1+j
         CJ12(jn,in) = 0.0d0
         CK12(jn,in) = - BETA(jn)*BETA(in)
         do k=1,nv
          DCJ12r(jn,in,k) = 0.0d0
          DCK12r(jn,in,k) = - DB(jn,k)*BETA(in)
         enddo
        ENDDO
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C----------------------------------------------------------------------C

C ECorrNonDyn (ECndl in NOF-MP2)
      SUBROUTINE ECorrNonDyn(RO,QK,ENonDEnergy)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::BETA,FIs
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::CK12nd
C-----------------------------------------------------------------------
      ALLOCATE(FIs(NBF5),CK12nd(NBF5,NBF5))
      CK12nd = 0.0d0      
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --      
C                       FIs(j)  = 2*RO(j)*HOLE(j)      
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      FIs = 0.0d0
      DO j=NO1+1,NBF5
       FIs(j) = 2.0d0*RO(j)*(1.0d0-RO(j))
      ENDDO
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C          Inter-pair Non-Dynamic (Static) Electron Correlation
C                  CK12ji = +- FIs(j)*FIs(i) (-+PIs)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      DO j=NO1+1,NBF5
       DO i=NO1+1,NBF5
        CK12nd(j,i) = FIs(j)*FIs(i)        
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(FIs)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C           Intra-pair Non-Dynamic (Static) Electron Correlation
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     BETA(j) = DSQRT(2*HOLE(j)) * DSQRT(RO(j))
C     BETA(j) = DSQRT(2*RO(j))   * DSQRT(RO(j))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(BETA(NBF5))
      DO j=1,NBF5
       Cj = 1.0d0 - DABS(1.0d0-2.0d0*RO(j))
       BETA(j) = DSQRT( Cj*RO(j) )
      ENDDO
C      
      DO l=1,NDOC
       ln = NO1+l
       DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        in = NO1+i
        CK12nd(ln,in) = BETA(ln)*BETA(in)
        CK12nd(in,ln) = BETA(in)*BETA(ln)
        DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         jn = NO1+j
         CK12nd(jn,in) = - BETA(jn)*BETA(in)         
        ENDDO
       ENDDO
      ENDDO
      DEALLOCATE(BETA)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     Non-Dynamic Correlation Energy
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(MSpin==0)then
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       ENonDEnergy = 0.0d0
       ECndHF = 0.0d0       
       do i=1,ndoc
        in = no1+i
        ENonDEnergy = ENonDEnergy - PRODCWQWj(in,CK12nd,QK)
        do iw=1,ncwo
         in = na+ncwo*(ndoc-i)+iw
         ENonDEnergy = ENonDEnergy -PRODCWQWj(in,CK12nd,QK)
        enddo
       enddo
       if(NSOC>0)then
        do i=ndoc+1,ndns
         in = no1+i
         ENonDEnergy = ENonDEnergy - PRODCWQWj(in,CK12nd,QK) 
         ECndHF = ECndHF - CK12nd(in,in)*QK(in*(in+1)/2)             
        end do
       end if
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      else if(MSpin>0)then
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       ENonDEnergy = 0.0d0
       do i=1,ndoc
        in = no1+i
        ENonDEnergy = ENonDEnergy - PRODCWQWj1(in,CK12nd,QK)
        do iw=1,ncwo
         in = na+ncwo*(ndoc-i)+iw
         ENonDEnergy = ENonDEnergy -PRODCWQWj2(in,CK12nd,QK)
        enddo
       enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      end if
C-----------------------------------------------------------------------
      DEALLOCATE(CK12nd)
      RETURN
      END

!======================================================================!
!                                                                      !
!             O R B I T A L       O P T I M I Z A T I O N              !
!                                                                      !
!                  ( J. Comp. Chem. 30, 2078, 2009 )                   !
!                                                                      !
!             Spin-compensated Systems (Restricted Shells)             !
!                                                                      !
!    'Restricted Closed' (rc) Case: MSpin=0 [Singlet and Multiplet]    !
!       Singlet States (S=0,Ms=0) and Multiplet States (S>0,Ms=0)      !
!                                                                      !
!        'Restricted Open' (ro) Case: MSpin>0 [High-Spin State]        !
!                                                                      !
!            Variables: MOs {Cvq}  (NVAR = NSQ = NBF*NBF)              !
!                                                                      !
!   ORBOPTr: Minimize the energy with respect to the MOs {Cvq} = COEF  !
!   ENERGY1r: Calculate the Electronic Energy (EELEC) and Lagrangian   !
!   PCONVE: Check for the symmetry of Lagrangian [ ELAG(ij)-ELAG(ji) ] !
!   FFJMN1rc,ro: Calculate the generalized Fock matrix Fj(m,n)         !
!   ELG: Calculate the Lagrange Multipliers                            !
!   EELECTRr: Trace( Ct*RO*H*C + Ct*G )                                !
!   EELECTRr_EFIELD: Trace [ Ct*RO*(Ei*ADIPi)*C ] - Ei*DIPN(i)         !
!   FFMIUG_SCALING: Decrease gen-Fock matrix using a scaling factor    !
!   F01: Fij = Fij*0.1                                                 !
!   FFMIUG_DIIS: Direct Inversion in the Iterative Subspace Technique  !
!   TRACEFF: Calculate the trace by i,j of F(m,i,j)*F(idiis,j,i)       !
!                                                                      !
!======================================================================!

C ORBOPTr
      SUBROUTINE ORBOPTr(ITCALL,ITLIM,AHCORE,IJKL,XIJKL,QD,COEF,RO,
     &                   CJ12,CK12,ELAG,FMIUG0,DIPN,ADIPx,ADIPy,ADIPz,
     &                   ILOOP,IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      COMMON/RUNTYPE/IRUNTYP      
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,TEMP,CFM
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::FMIUG,W,COEFNEW,BFM,G
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:)::FK
      INTEGER::IPRINTOPT
C-----------------------------------------------------------------------
      CONVGDELAG=.FALSE.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     First Call to ORBOPTr
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ITCALL==1)THEN
       IF(IRUNTYP==3)NZEROS=NZEROSr
       IF(IPRINTOPT==1)WRITE(6,1)
       EELEC_OLD=EELEC
       SUMDIF_OLD=0.0d0
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calculate Initial Electronic Energy (EELEC) and Lagrangian
C     Note: This Energy is equal to EELEC from MOLOCUPrc
C     PCONV = ABS(DIF_EELEC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (G(NBF,NBF5))      
      CALL ENERGY1r(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,ELAG,
     &              DIPN,ADIPx,ADIPy,ADIPz,G)
      CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
      DIF_EELEC=EELEC-EELEC_OLD
      PCONV=ABS(DIF_EELEC)
      EELEC_OLD=EELEC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Output of the first evaluated energy
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ILOOP==0.and.IPRINTOPT==1)
     & WRITE(6,2)0,EELEC,EELEC+EN,DIF_EELEC,DUMEL
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check ITCALL and SUMDIF for changing the scaling factor
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SCALING.and.ITCALL>2.and.ITCALL>ITLIM.and.
     &   SUMDIF>SUMDIF_OLD)THEN
       NZEROS=NZEROS+1
       ITLIM=ITCALL+ITZITER
C      NZEROS>NZEROSm -> Restart from here with NZEROSr
       IF(NZEROS>NZEROSm)THEN
        NZEROS=NZEROSr
       ENDIF
      ENDIF
      SUMDIF_OLD=SUMDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check for the Symmetry of Lagrangian (ELAG(IQJQ)-ELAG(JQIQ))
C     for ITCALL>1 (do not stop in the first call)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF( ITCALL>1 .and. DUMEL<THRESHL .and. PCONV < THRESHE )THEN
       CONVGDELAG=.TRUE.
       IF(IPRINTOPT==1)WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL
       RETURN
      ENDIF
C-----------------------------------------------------------------------
C                       START SCF-ITERATION CYCLE
C-----------------------------------------------------------------------
      ALLOCATE(FMIUG(NOPTORB,NOPTORB),W(NOPTORB,NOPTORB),EVA(NOPTORB))
      ALLOCATE(TEMP(NOPTORB),FK(MAXLOOP,NOPTORB,NOPTORB))
      ALLOCATE(COEFNEW(NBF,NBF),BFM(MAXLOOP+1,MAXLOOP+1),CFM(MAXLOOP+1))
      IF(ITCALL==1.and.INPUTFMIUG==0)THEN
       MAXLP=1
      ELSE
       MAXLP=MAXLOOP
      ENDIF
C-----------------------------------------------------------------------
      ILOOP=0
      IDIIS=0
      DO LOOP=1,MAXLP
       ILOOP=ILOOP+1
       EELEC_OLD2=EELEC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Generalized Fock Matrix (FMIUG)
C
C      Convergent technique:
C
C      1) SCALING:   Decrease FMIUG using a scaling factor.
C                    The scaling factor varies until the number of
C                    ZEROS (.000##) is equal for all elements Fij
C      3) DIIS       Direct Inversion in the Iterative Subspace 
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(SCALING)CALL FFMIUG_SCALING(FMIUG,ELAG,FMIUG0,ITCALL)
       IF(DIIS.and.DUMEL<THDIIS)THEN
        CALL FFMIUG_DIIS(NOPTORB,FMIUG,CFM,BFM,FK,IDIIS)
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      DIAGONALIZE SQUARE MATRIX (FMIUG) FOR REAL SYMMETRIC CASE
C      W - EIGENVECTORS, EVA - EIGENVALUES IN ALGEBRAIC DESCENDING ORDER
C      HOUSEHOLDER METHOD
C      NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL DIAG(NOPTORB,FMIUG,W,EVA,TEMP)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Move EVA -> FMIUG0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO I=1,NOPTORB
        FMIUG0(I) = EVA(I)
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      New Coefficients (COEFNEW=COEF*W), Move COEFNEW -> COEF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       COEFNEW = COEF                     ! initial values for coefnew 
       CALL COEFW1(NBF,NOPTORB,COEFNEW,COEF,W)
       COEF = COEFNEW
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Calculate Dj(miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,nbf)
C      Keep Matrices Jj, Kj in WJj, WKj
C      Form F Matrix and keep it in WF
C      Compute G, Lagrangian Multipliers (ELAG) and one-energies (E)
C      Calculate Electronic Energy (EELEC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL ENERGY1r(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,ELAG,
     &               DIPN,ADIPx,ADIPy,ADIPz,G)
       DIF_EELEC2=EELEC-EELEC_OLD2
C      Intermediate Output (Nprint=2)
       IF(NPRINT==2.AND.IPRINTOPT==1)
     &  WRITE(6,3)LOOP,EELEC,EELEC+EN,DIF_EELEC2
       CALL PCONVE(ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Check for energy convergent solution
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF( DABS(DIF_EELEC2) < THRESHEC )THEN
        DEALLOCATE (COEFNEW,FMIUG,W,EVA,TEMP)
        DIF_EELEC=EELEC-EELEC_OLD
        EELEC_OLD=EELEC
        IF(IPRINTOPT==1)WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL
        RETURN
       ENDIF
C------------------------------------------------------------------------
C                       LOOP-END OF SCF-ITERATION
C-----------------------------------------------------------------------
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Itermediate Output of the external iteration
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DIF_EELEC=EELEC-EELEC_OLD
      EELEC_OLD=EELEC
      DEALLOCATE (COEFNEW,FMIUG,W,EVA,TEMP,CFM,BFM,FK,G)
      IF(IPRINTOPT==1)WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL
      RETURN
C-----------------------------------------------------------------------
C     FORMAT STATEMENTS
C-----------------------------------------------------------------------
    1 FORMAT(//2X,'RESULTS OF OCCUPATION-COEFFICIENT S.C.F. PROCEDURE'
     *      ,/1X,'====================================================',
     *  //2X,'Iter',5X,'Electronic Energy',6X,'Total Energy',
     *    3X,'Energy Convergency',4X,'Max Mul-Lag Diff',/)
    2 FORMAT(I5,'.',1X,F20.10,1X,F19.10,2X,F15.10,8X,F11.6)
    3 FORMAT(2X,I3,'.',3X,F17.8,4X,F15.8,6X,F11.6)
C-----------------------------------------------------------------------
      END

C ENERGY1r
      SUBROUTINE ENERGY1r(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,
     &                    ELAG,DIPN,ADIPx,ADIPy,ADIPz,G)
C-----------------------------------------------------------------------
C     Calculate the Electronic Energy and Lagrange Multipliers
C-----------------------------------------------------------------------
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF5)::G      
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::WJj,WKj,WF,AUX1
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::AUX2
C-----------------------------------------------------------------------
C     Calculate Dj: QD(j,miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,NBF5) 
C-----------------------------------------------------------------------
      ALLOCATE (WJj(NSQ,NBF5),WKj(NSQ,NBF5),AUX1(NBF,NBF),AUX2(NSQ))
      DO j=1,NBF5
       CALL DENMATj(j,AUX1,COEF,NBF)
       QD(j,1:NBF,1:NBF) = AUX1(1:NBF,1:NBF) 
       CALL HSTARJ(AUX2,AUX1,IJKL,XIJKL)
       WJj(1:NSQ,j) = AUX2(1:NSQ)
       CALL HSTARK(AUX2,AUX1,IJKL,XIJKL)
       WKj(1:NSQ,j) = AUX2(1:NSQ)
      ENDDO
      DEALLOCATE (AUX1,AUX2)
C-----------------------------------------------------------------------
C     Form F Matrix and keep it in WF
C-----------------------------------------------------------------------
      ALLOCATE (WF(NSQ,NBF5))
      if(MSpin==0)then
       CALL FFJMN1rc(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)
      else if(MSpin>0)then
       CALL FFJMN1ro(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)      
      end if      
      DEALLOCATE (WJj,WKj)
C-----------------------------------------------------------------------
C     Calculate G Matrix
C-----------------------------------------------------------------------
      DO IQ=1,NBF5
       do i=1,nbf
        G(i,IQ) = FC(i,IQ,WF(1,IQ),COEF)
       enddo
      ENDDO
      DEALLOCATE (WF)
C-----------------------------------------------------------------------
C     Lagrangian Multipliers (ELAG)
C-----------------------------------------------------------------------
      CALL ELG(ELAG,COEF,G)
C-----------------------------------------------------------------------
C     Calculate ELECTRONIC ENERGY
C-----------------------------------------------------------------------
C     Calculate Trace(Ct*RO*H*C+Ct*G)
      CALL EELECTRr(EELEC,AHCORE,ELAG,COEF,RO)
C     Include Nuclear Dipoles if electric field =/ 0
      IF(EFIELDL)THEN
       CALL EELECTRr_EFIELD(EELEC_EF,COEF,RO,DIPN,ADIPX,ADIPY,ADIPZ)
       EELEC=EELEC+EELEC_EF
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C PCONVE
      SUBROUTINE PCONVE(ELAG,DUM,MAXI,MAXJ,SUMDIFF)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG
C-----------------------------------------------------------------------
C     Check for the symmetry of Lagrangian [ ELAG(ij)-ELAG(ji) ], i.e.,
C     the convergence of the difference of Lagrange multipliers
C-----------------------------------------------------------------------
      DUM=0.0d0
      SUMDIFF=0.0d0
      DO IQ=1,NBF
       DO JQ=1,NBF
        GCF=ABS(ELAG(IQ,JQ)-ELAG(JQ,IQ))
        SUMDIFF=SUMDIFF+GCF
        IF(GCF>DUM)THEN
         DUM=GCF
         MAXI=IQ
         MAXJ=JQ
        ENDIF
       ENDDO
      ENDDO
c      WRITE(6,'(2I4,2F10.5)')MAXI,MAXJ,ELAG(MAXI,MAXJ),ELAG(MAXJ,MAXI)
C-----------------------------------------------------------------------
      RETURN
      END

C FFJMN1rc
      SUBROUTINE FFJMN1rc(RO,CJ12,CK12,H,DJ,DK,F,ADIPx,ADIPy,ADIPz)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::DJ,DK,F
C-----------------------------------------------------------------------
C     Calculate Fj(m,n)
C-----------------------------------------------------------------------
      IF(NO1>1)THEN
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         F(ik,1) = H(i,k) + PRODWCWij(ik,DJ,CJ12)-PRODWCWij(ik,DK,CK12)
         DO J=NO1+1,NB
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
         ENDDO
         if(NSOC>0)then
          DO J=NB+1,NA
           F(ik,J) = RO(J) * H(i,k) 
     &             + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
          ENDDO
         end if
         DO J=NA+1,NBF5
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
         ENDDO
        enddo
       enddo
       DO J=2,NO1
        F(1:NSQ,J) = F(1:NSQ,1)
       ENDDO
      ELSE
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         DO J=1,NB
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
         ENDDO
         if(NSOC>0)then         
          DO J=NB+1,NA
           F(ik,J) = RO(J) * H(i,k) 
     &             + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
          ENDDO
         end if
         DO J=NA+1,NBF5
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq(ik,J,DJ,CJ12) - PRODWCWijq(ik,J,DK,CK12)
         ENDDO
        enddo
       enddo
      ENDIF
C-----------------------------------------------------------------------
C     Including Electric Field ( Note: FEikj is constant )
C-----------------------------------------------------------------------
      IF(EFIELDL)THEN
       DO J=1,NBF5
        do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         FEikj = RO(J)*(EX*ADIPx(i,k)+EY*ADIPy(i,k)+EZ*ADIPz(i,k))
         F(ik,J) = F(ik,J) + FEikj
        enddo
        enddo
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END
      
C FFJMN1ro
      SUBROUTINE FFJMN1ro(RO,CJ12,CK12,H,DJ,DK,F,ADIPx,ADIPy,ADIPz)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::DJ,DK,F
C-----------------------------------------------------------------------
C     Calculate Fj(m,n)
C-----------------------------------------------------------------------
      IF(NO1>1)THEN
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         F(ik,1) = H(i,k)+PRODWCWij1(ik,DJ,CJ12)-PRODWCWij1(ik,DK,CK12)
     &           + SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK)
         DO J=NO1+1,NB
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq1(ik,J,DJ,CJ12)-PRODWCWijq1(ik,J,DK,CK12)
     &            + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )         
         ENDDO
         DO J=NB+1,NA
          F(ik,J) = 0.50d0 * ( H(i,k)+SUMWijq(ik,J,DJ)-SUMWijq(ik,J,DK)
     &                + 2.0d0*PRODWROij(ik,DJ,RO)-PRODWROij(ik,DK,RO) )
         ENDDO     
         DO J=NA+1,NBF5
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq2(ik,J,DJ,CJ12)-PRODWCWijq2(ik,J,DK,CK12)
     &            + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )         
         ENDDO
        enddo
       enddo
       DO J=2,NO1
        F(1:NSQ,J) = F(1:NSQ,1)
       ENDDO
      ELSE
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         DO J=1,NB
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq1(ik,J,DJ,CJ12)-PRODWCWijq1(ik,J,DK,CK12)
     &            + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )         
         ENDDO
         DO J=NB+1,NA
          F(ik,J) = 0.50d0 * ( H(i,k)+SUMWijq(ik,J,DJ)-SUMWijq(ik,J,DK)
     &                + 2.0d0*PRODWROij(ik,DJ,RO)-PRODWROij(ik,DK,RO) )
         ENDDO     
         DO J=NA+1,NBF5
          F(ik,J) = RO(J) * ( H(i,k) + DJ(ik,J) )
     &            + PRODWCWijq2(ik,J,DJ,CJ12)-PRODWCWijq2(ik,J,DK,CK12)
     &            + RO(J) * ( SUMWij(ik,DJ) - 0.50d0*SUMWij(ik,DK) )         

         ENDDO
        enddo
       enddo
      ENDIF
C-----------------------------------------------------------------------
C     Including Electric Field ( Note: FEikj is constant )
C-----------------------------------------------------------------------
      IF(EFIELDL)THEN
       DO J=1,NBF5
        do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         FEikj = RO(J)*(EX*ADIPx(i,k)+EY*ADIPy(i,k)+EZ*ADIPz(i,k))
         F(ik,J) = F(ik,J) + FEikj
        enddo
        enddo
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C ELG
      SUBROUTINE ELG(ELAG,C,G)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,C
      DOUBLE PRECISION,DIMENSION(NBF,NBF5)::G
C-----------------------------------------------------------------------
C     Calculate the Lagrange Multipliers
C-----------------------------------------------------------------------
      DO IQ=1,NOPTORB
       DO JQ=1,NBF5
        ELAG(IQ,JQ) = 0.0d0
        do i=1,nbf
         ELAG(IQ,JQ) = ELAG(IQ,JQ) + C(i,IQ)*G(i,JQ)
        enddo
       ENDDO
       DO JQ=NBF5+1,NBF
        ELAG(IQ,JQ) = 0.0d0
       ENDDO
      ENDDO
      IF(NOPTORB<NBF)THEN
       DO IQ=NOPTORB+1,NBF
        DO JQ=1,NBF
         ELAG(IQ,JQ) = 0.0d0
        ENDDO
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C EELECTRr
      SUBROUTINE EELECTRr(ENERGIA,H,ELAG,C,RO)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ELAG,C
C-----------------------------------------------------------------------
C     Calculate the electronic energy [ Trace( Ct*RO*H*C + Ct*G ) ]
C-----------------------------------------------------------------------
      ENERGIA = 0.0d0
      DO IQ=1,NB
       ENERGIA = ENERGIA + ELAG(IQ,IQ)
       do i=1,nbf
        ENERGIA = ENERGIA + RO(IQ)*C(i,IQ)*FC(i,IQ,H,C)
       enddo
      ENDDO
c
      if(NSOC>0)then
       if(.not.HighSpin)then
        DO IQ=NB+1,NA
         ENERGIA = ENERGIA + ELAG(IQ,IQ)
         do i=1,nbf
          ENERGIA = ENERGIA + RO(IQ)*C(i,IQ)*FC(i,IQ,H,C)
         enddo
        ENDDO
       else if(HighSpin)then
        DO IQ=NB+1,NA
         ENERGIA = ENERGIA + ELAG(IQ,IQ)
         do i=1,nbf
          ENERGIA = ENERGIA +  0.50d0*C(i,IQ)*FC(i,IQ,H,C)
         enddo
        ENDDO
       end if
      end if       
c      
      DO IQ=NA+1,NBF5
       ENERGIA = ENERGIA + ELAG(IQ,IQ)
       do i=1,nbf
        ENERGIA = ENERGIA + RO(IQ)*C(i,IQ)*FC(i,IQ,H,C)
       enddo
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C EELECTRr_EFIELD
      SUBROUTINE EELECTRr_EFIELD(EELEC_EF,C,RO,DIPN,ADIPx,ADIPy,ADIPz)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::C,ADIPx,ADIPy,ADIPz
C-----------------------------------------------------------------------
C     Calculate the electronic energy associated to the electric field
C     EELEC_EF = Trace [ Ct*RO*(Ei*ADIPi)*C ] - Ei*DIPN(i)
C-----------------------------------------------------------------------
      EELEC_EF=0.0d0
      DO IQ=1,NBF5
       do i=1,nbf
        EELEC_EF = EELEC_EF + RO(IQ)*C(i,IQ)*( EX*FC(i,IQ,ADIPx,C) +
     &                      EY*FC(i,IQ,ADIPy,C) + EZ*FC(i,IQ,ADIPz,C) )
       enddo
      ENDDO
      EELEC_EF = EELEC_EF - EX*DIPN(1) - EY*DIPN(2) - EZ*DIPN(3)
C-----------------------------------------------------------------------
      RETURN
      END

C FFMIUG_SCALING
      SUBROUTINE FFMIUG_SCALING(FMIUG,ELAG,FMIUG0,ITCALL)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NOPTORB,NOPTORB)::FMIUG
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG
C-----------------------------------------------------------------------
C     Generalized Fock Matrix (FMIUG)
C-----------------------------------------------------------------------
      IF(itcall==1.AND.INPUTFMIUG==0)THEN          ! only for itcall==1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO IQ=1,NOPTORB
        DO JQ=1,IQ-1
         FMIUG(IQ,JQ)=(ELAG(IQ,JQ)+ELAG(JQ,IQ))/2.0        ! Nondiagonal 
         FMIUG(JQ,IQ)=FMIUG(IQ,JQ)
        ENDDO
        FMIUG(IQ,IQ)=ELAG(IQ,IQ)                            ! Diagonal
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO IQ=1,NOPTORB
        DO JQ=1,IQ-1
         FMIUG(IQ,JQ)=ELAG(IQ,JQ)-ELAG(JQ,IQ)              ! Nondiagonal 
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
C        Decrease FMIUG using a scaling factor
C        The scaling factor varies until the number of
C        ZEROS (.000##) is equal for all elements Fij
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         CALL F01(NZEROS+9,FMIUG(IQ,JQ))
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         FMIUG(JQ,IQ)=FMIUG(IQ,JQ)                         ! Fji=Fij
        ENDDO
        FMIUG(IQ,IQ)=FMIUG0(IQ)                            ! Diagonal
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C F01
      SUBROUTINE F01(imax,Fij)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      do i=0,imax
       VAL=ABS(Fij)
       if(VAL>10.0d0**(9-i).and.VAL<10.0d0**(10-i))then
        Fij = Fij * 0.1d0
       endif
      enddo
      RETURN
      END

C FFMIUG_DIIS
      SUBROUTINE FFMIUG_DIIS(NUM,FMIUG,CFM,BFM,FK,IDIIS)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(MAXLOOP+1)::CFM
      DOUBLE PRECISION,DIMENSION(MAXLOOP+1,MAXLOOP+1)::BFM
      DOUBLE PRECISION,DIMENSION(NUM,NUM)::FMIUG
      DOUBLE PRECISION,DIMENSION(MAXLOOP,NUM,NUM)::FK
C
      INTEGER,ALLOCATABLE,DIMENSION(:)::IPIV
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::A
C-----------------------------------------------------------------------
      IDIIS = IDIIS+1
      FK(IDIIS,1:NUM,1:NUM) = FMIUG(1:NUM,1:NUM)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Form BFM(1:idiis,idiis)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NN = idiis+1
      do m=1,idiis
       BFM(m,idiis) = TRACEFF(MAXLOOP,NUM,m,idiis,FK)
       BFM(idiis,m) = BFM(m,idiis)
       BFM(m,NN)    = -1.0d0
       BFM(NN,m)    = -1.0d0
      enddo
      BFM(NN,NN) = 0.0d0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      if(idiis>NDIIS)then
C- - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE (A(NN,NN),IPIV(NN))
       IPIV = 0
       A = BFM(1:NN,1:NN)
       CFM(1:idiis) = 0.0d0
       CFM(NN) =  -1.0d0
C- - - - - - - - - - - - - - - - - - - - - - -
       CALL DGESV(NN,1,A,NN,IPIV,CFM,NN,INFO)
       DEALLOCATE (A,IPIV)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      New Generalized Fock Matrix: F'=SUM_k [CFM(k)*F(k)]
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       do i=1,NUM
        do j=1,i-1
         FMIUG(i,j) = 0.0d0
         do k=1,idiis
          FMIUG(i,j) = FMIUG(i,j) + CFM(k) * FK(k,i,j)
         enddo
         FMIUG(j,i) = FMIUG(i,j)
        enddo
       enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      IDIIS is nullified for a periodic DIIS
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(PERDIIS)IDIIS = 0
C- - - - - - - - - - - - - - - - - - - - - - -
      endif
C-----------------------------------------------------------------------
      RETURN
      END

C TRACEFF
      FUNCTION TRACEFF(maxloop,N,m,idiis,F)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(maxloop,N,N)::F
C-----------------------------------------------------------------------
      TRACEFF = 0.0d0
      do i=1,N
       do j=1,i-1
        TRACEFF = TRACEFF + F(m,i,j)*F(idiis,j,i)
       enddo
      enddo
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!              P R O P E R T Y       S U B R O U T I N E S             !
!                                                                      !
!======================================================================!

!======================================================================!
!                                                                      !
!                       Internuclear distances                         !
!                                                                      !
!======================================================================!

C NUCDIST
      SUBROUTINE NUCDIST(NV,CXYZ)
      USE PARCOM
      IMPLICIT NONE
      INTEGER,INTENT(IN):: NV
      DOUBLE PRECISION,DIMENSION(NV),INTENT(IN)::CXYZ
      DOUBLE PRECISION,DIMENSION(NATOMS)::DIST
      DOUBLE PRECISION::RR
      INTEGER::I,J,MAXX,MINN
      DOUBLE PRECISION,PARAMETER::BOHR = 0.52917724924D+00               
C-----------------------------------------------------------------------
      WRITE(11,'(1X)')
      WRITE(11,*)'Internuclear distances (Angs)'
      MAXX=0
      DO
      MINN = MAXX+1
      MAXX = MAXX+5
      IF(MAXX>NATOMS) MAXX=NATOMS
      WRITE(11,'(1X)')
      WRITE(11,'(10X,7(I4,8X))') (J,J=MINN,MAXX)
      WRITE(11,'(1X)')
C      
      DO I = 1,NATOMS
       DO J = MINN,MAXX
        RR =       (CXYZ(1+(I-1)*3)-CXYZ(1+(J-1)*3))**2 + 
     &             (CXYZ(2+(I-1)*3)-CXYZ(2+(J-1)*3))**2 + 
     &             (CXYZ(3+(I-1)*3)-CXYZ(3+(J-1)*3))**2
        RR = DSQRT(RR)
        DIST(J) = RR*BOHR
       ENDDO
       WRITE(11,'(I4,7(F12.4))')
     &        I,(DIST(J),J=MINN,MAXX)
      ENDDO
      IF(.NOT.(MAXX<NATOMS)) EXIT
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                    Mulliken Population Analysis                      !
!                                                                      !
!     MULLIKENrc: Calculate Mulliken populations on Atoms and every MO !
!     WRITEMULLAPMOrc: Print Mulliken atomic populations in each MO    !
!     ATDENMATrc: Compute atomic density matrix                        !
!                                                                      !
!======================================================================!

C MULLIKENrc
      SUBROUTINE MULLIKENrc(ATMNAME,ZNUC,LIMLOW,LIMSUP,S,RO,QD)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4 ATMNAME(NATOMS)
      DIMENSION ZNUC(NATOMS),LIMLOW(NATOMS),LIMSUP(NATOMS)
      DIMENSION S(NBF,NBF),RO(NBF5),QD(NBF,NBF,NBF)
      ALLOCATABLE:: CMUL(:,:),QMOAT(:,:)
      ALLOCATABLE:: AOVLPOP(:,:),OVLPOP(:,:),POPAT(:)
C
C     Mulliken Population:
C     CMUL:    Atomic Orbital populations in each Molecular Orbital
C     QMOAT:   Atomic populations in each Molecular Orbital
C     AOVLPOP: Atomic Overlap Populations
C     OVLPOP:  Overlap Populations
C     POPAT:   Populations on Atoms
C
C-----------------------------------------------------------------------
C     Compute Mulliken population of each AO in every MO
C-----------------------------------------------------------------------
      ALLOCATE(CMUL(NBF,NBF5))
      DO IQ=1,NBF5
       DO J=1,NBF
        SCSC=0.0d0
        DO K=1,NBF
         SCSC=SCSC+QD(IQ,K,J)*S(J,K)
        ENDDO
        CMUL(J,IQ)=SCSC*RO(IQ)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     Condense to atoms
C-----------------------------------------------------------------------
      ALLOCATE (QMOAT(NATOMS,NBF5))
      DO IQ=1,NBF5
       DO IAT=1,NATOMS
        SCMUL = 0.0d0
        IMIN=LIMLOW(IAT)
        IMAX=LIMSUP(IAT)
        DO J=IMIN,IMAX
         SCMUL = SCMUL + CMUL(J,IQ)
        ENDDO
        QMOAT(IAT,IQ) = SCMUL
       ENDDO
      ENDDO      
C-----------------------------------------------------------------------
C     Print Atomic populations in each Molecular Orbital
C-----------------------------------------------------------------------
      WRITE(6,1)
      CALL WRITEMULLAPMOrc(QMOAT,RO,NBF5,NATOMS)
C-----------------------------------------------------------------------
C     Calculate Overlap Atomic Populations
C-----------------------------------------------------------------------
      ALLOCATE(AOVLPOP(NBF,NBF))
      AOVLPOP=0.0d0
      DO K=1,NBF
       DO L=1,NBF
        AOVLPOP(K,L) = AOVLPOP(K,L) 
     &               + ATDENMATrc(K,L,RO,QD,NBF,NBF5)*S(K,L)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     Compress Overlap Atomic Populations to Atoms
C-----------------------------------------------------------------------
      ALLOCATE(OVLPOP(NATOMS,NATOMS))
      DO I=1,NATOMS
       IMIN=LIMLOW(I)
       IMAX=LIMSUP(I)
       DO J=1,NATOMS
        JMIN=LIMLOW(J)
        JMAX=LIMSUP(J)
        OVLPOP(I,J)=0.0d0
        IF(IMIN<=IMAX)THEN
         DO K=IMIN,IMAX
          IF(JMIN<=JMAX)THEN
           DO L=JMIN,JMAX
            OVLPOP(I,J) = OVLPOP(I,J) + AOVLPOP(K,L)
           ENDDO
          ENDIF
         ENDDO
        ENDIF
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     Calculate total populations on Atoms
C-----------------------------------------------------------------------
      WRITE(6,2)
      WRITE(6,3)
      ALLOCATE(POPAT(NATOMS))
      DO I=1,NATOMS
       POPAT(I)=0.0d0
       DO J=1,NATOMS
        POPAT(I)=POPAT(I)+OVLPOP(I,J)
       ENDDO
C-----------------------------------------------------------------------
C      Print total Populations
C-----------------------------------------------------------------------
       WRITE(6,4)I,ATMNAME(I),POPAT(I),ZNUC(I)-POPAT(I)
      ENDDO
C-----------------------------------------------------------------------
    1 FORMAT(
     */2X,' Atomic populations in each Molecular Orbital ',/,
     * 2X,'- - - - - - - - - - - - - - - - - - - - - - - -')
    2 FORMAT(/,
     */2X,' Total Populations on Atoms ',/,
     * 2X,'- - - - - - - - - - - - - - -',/)
    3 FORMAT(9X,'Atom',8X,'Pop.',7X,'Charge',/)
    4 FORMAT(1X,I4,1X,A8,2F12.4)
C-----------------------------------------------------------------------
      DEALLOCATE(CMUL,QMOAT,AOVLPOP,OVLPOP)
      RETURN
      END

C WRITEMULLAPMOrc
      SUBROUTINE WRITEMULLAPMOrc(QMOAT,RO,NBF5,NATOMS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION QMOAT(NATOMS,NBF5),RO(NBF5)
C-----------------------------------------------------------------------
C     Print Atomic populations in each Molecular Orbital
C-----------------------------------------------------------------------
      IMAX=0
  10  IMIN=IMAX+1
      IMAX=IMAX+10
      IF(IMAX>NBF5)IMAX=NBF5
      WRITE(6,1)
      WRITE(6,2)(I,I=IMIN,IMAX)
      WRITE(6,1)
      WRITE(6,3)(2*RO(I),I=IMIN,IMAX)
      WRITE(6,1)
      DO J=1,NATOMS
       WRITE(6,4)J,(QMOAT(J,I),I=IMIN,IMAX)
      ENDDO
      IF(IMAX<NBF5)GOTO 10
C-----------------------------------------------------------------------
    1 FORMAT(1X)
    2 FORMAT(9X,10(3X,I4,2X))
    3 FORMAT(9X,10F9.4)
    4 FORMAT(I5,4X,10F9.4)
C-----------------------------------------------------------------------
      RETURN
      END

C ATDENMATrc
      FUNCTION ATDENMATrc(K,L,RO,QD,NBF,NBF5)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION RO(NBF5),QD(NBF,NBF,NBF)
C-----------------------------------------------------------------------
      ATDENMATrc = 0.0d0
      DO J =1,NBF5
       ATDENMATrc = ATDENMATrc + RO(J)*QD(J,K,L)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                   Extended Koopmans' Theorem (EKT)                   !
!                                                                      !
!                 ( J. Chem. Phys. 136, 174116, 2012 )                 !
!                                                                      !
!     EXTKOOPMANSrc: Ionization Potentials by Ext. Koopmans' theorem   !
!     DYSONORB: Dyson molecular orbitals (related to EKT)              !
!     DYSVECOUTrc: Print Dyson eigenvectors (related to EKT)           !
!                                                                      !
!======================================================================!

C EXTKOOPMANSrc
      SUBROUTINE EXTKOOPMANSrc(ELAG,COEF,OVERLAP,AHCORE,IJKL,XIJKL,RO)
C-----------------------------------------------------------------------
C                Extended Koopmans' Theorem (EKT)
C                This subroutine is called when IEKT=1
C-----------------------------------------------------------------------
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NIJKL)::IJKL
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,COEF,OVERLAP,AHCORE
      DOUBLE PRECISION,DIMENSION(NIJKL)::XIJKL
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,TEMP,OCCD
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::AUX,W,DYSON
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::DM,GFOCK,COEFT
C-----------------------------------------------------------------------
C     Intermediate matrices
C-----------------------------------------------------------------------
      ALLOCATE (AUX(NBF,NBF),W(NBF,NBF),EVA(NBF),TEMP(NBF))
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
C     Ionization Potentials:
C     Diagonalization of -ELAG/RAIZ[RO*RO], ELAG: Lagrangian
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
C     ELAG/RAIZ[RO*RO] -> square symmetric matrix (AUX)
C-----------------------------------------------------------------------
      DO I=1,NBF5
       BETAi=DSQRT(RO(i))
       DO J=1,I
        BETAj=DSQRT(RO(j))
        IF( (DABS(BETAi)>1.0d-6).and.(DABS(BETAj)>1.0d-6) )THEN
         AUX(I,J)=ELAG(I,J)/(BETAi*BETAj)
        ELSE
         AUX(I,J)=0.0d0
        ENDIF
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
      DO I=NBF5+1,NBF
       DO J=1,I
        AUX(I,J)=0.0d0
        AUX(J,I)=AUX(I,J)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     Diagonalize square matrix (AUX)
C     W - Eigenvectors, EVA - EIGENVALUES
C-----------------------------------------------------------------------
      CALL DIAG(NBF,AUX,W,EVA,TEMP)
C-----------------------------------------------------------------------
C     Write Ionization Energies (Output File)
C     Coefficients of Dyson Orbitals (DYSON=COEF*BETA*W)
C-----------------------------------------------------------------------
      ALLOCATE (DYSON(NBF,NBF5),OCCD(NBF5))
      CALL DYSONORB(OCCD,DYSON,COEF,RO,W,OVERLAP)
      WRITE(6,1)
      DO I=1,NBF5
       IF(EVA(I)<0.0d0.and.OCCD(I)>0.45d0)THEN
        WRITE(6,2)I,-EVA(I),-EVA(I)*27.21138386
       ENDIF
      ENDDO
C      
      IWRITEDYSON=0
      IF(IWRITEDYSON==1)THEN
       WRITE(6,4)
       CALL DYSVECOUTrc(DYSON,OCCD,NBF,NBF5,NBF5)
      ENDIF
      DEALLOCATE (DYSON)
C-----------------------------------------------------------------------
C     Write Cation Energy if ICATION=1 (Output File)
C     Ecation = Eelec + EN + MinVal IonPotential obtained with EKT
C-----------------------------------------------------------------------
      ICATION=0                                          ! ICATION=0
      IF(NSOC==0.and.ICATION==1)THEN
       TEMP = 1.0d06
       DO I=1,NBF5
        IF(-EVA(I)>0.0d0.and.OCCD(I)>0.45d0)TEMP(I)=-EVA(I)
       ENDDO
       PIMIN = MINVAL(TEMP,NBF5)
       WRITE(6,3)EELEC+EN+PIMIN
      ENDIF
      DEALLOCATE (OCCD)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -
C     Electron Affinities:
C     Diagonalization of (ELAG-GFOCK)/RAIZ[(1-RO)*(1-RO)]
C     GFOCK: Generalized Fock Matrix, ELAG: Lagrangian
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEA=0                                                 ! IEA=0
      IF(IEA==1)THEN
C-----------------------------------------------------------------------
C      Form the Generalized Fock Matrix
C-----------------------------------------------------------------------
       ALLOCATE (DM(NBF,NBF),GFOCK(NBF,NBF))
       CALL DENMATrc(DM,COEF,RO)
       CALL FORM2JK(AUX,DM,IJKL,XIJKL)
       DEALLOCATE(DM)
       GFOCK = AHCORE + AUX
       AUX  = MATMUL(GFOCK,COEF)
       ALLOCATE (COEFT(NBF,NBF))
       COEFT = TRANSPOSE(COEF)     
       GFOCK = MATMUL(COEFT,AUX)
       DEALLOCATE (COEFT)
C-----------------------------------------------------------------------
C      (ELAG-GFOCK)/RAIZ[(1-RO)*(1-RO)] -> square symmetric matrix (AUX)
C-----------------------------------------------------------------------
       DO I=1,NB
        AUX(I,I) = -DABS(ELAG(I,I)-GFOCK(I,I)) / (1.0d0-RO(i))
       ENDDO

       DO I=NB+1,NBF5
        AUX(I,I) = (ELAG(I,I)-GFOCK(I,I)) / (1.0d0-RO(i))
       ENDDO

       DO I=1,NBF5
        BETAi=DSQRT(1.0d0-RO(i))
        DO J=1,I-1
         BETAj=DSQRT(1.0d0-RO(j))
         IF( (DABS(BETAi)>1.0d-3).and.(DABS(BETAj)>1.0d-3) )THEN
          AUX(I,J) = (ELAG(I,J)-GFOCK(I,J)) / (BETAi*BETAj)
         ELSE
          AUX(I,J)=0.0d0
         ENDIF
         AUX(J,I)=AUX(I,J)
        ENDDO
       ENDDO

       DO I=NBF5+1,NBF
        DO J=1,I
         AUX(I,J) = -GFOCK(I,J)
         AUX(J,I) = AUX(I,J)
        ENDDO
       ENDDO

       DEALLOCATE (GFOCK)
C-----------------------------------------------------------------------      
C      Diagonalize square matrix (AUX)
C      W - Eigenvectors, EVA - Eigenvalues
C-----------------------------------------------------------------------
       CALL DIAG(NBF,AUX,W,EVA,TEMP)
C-----------------------------------------------------------------------
C      Write electron affinities (Output File)
C-----------------------------------------------------------------------
       WRITE(6,5)
       DO I=1,NBF
        WRITE(6,2)I,EVA(I),EVA(I)*27.2107
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
    1 FORMAT(/2X,'--------------------------------------------------',
     *       /2X,' Extended Koopmans'' Theorem (Ionization Energies) ',
     *       /2X,'--------------------------------------------------',
     *      //4X,'OM',14X,'(aU)',14X,'(eV)',/)
    2 FORMAT(2X,I4,4X,F15.3,4X,F15.3,10X,F7.3)
    3 FORMAT(/,3X,'NOF Total Cation Energy (aU) =',F16.6)
    4 FORMAT(/,
     * 18X,'----------------------------------------',/,
     * 18X,' DYSON ORBITALS IN ATOMIC ORBITAL BASIS ',/,
     * 18X,'----------------------------------------')
    5 FORMAT(/2X,'-------------------------------------------------',
     *       /2X,' EXTENDED KOOPMANS THEOREM (ELECTRON AFFINITIES) ',
     *       /2X,'-------------------------------------------------',
     *      //20X,'(aU)',14X,'(eV)',/)
C-----------------------------------------------------------------------
      DEALLOCATE (AUX,W,EVA,TEMP)
      RETURN
      END

C DYSONORB
      SUBROUTINE DYSONORB(OCCD,DYSON,COEF,RO,W,OVERLAP)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO,OCCD
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,W,OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF5)::DYSON
C-----------------------------------------------------------------------
C     DYSON=COEF*BETA*WC (unnormalized)
C-----------------------------------------------------------------------
      DO NIU=1,NBF
       DO IQ=1,NBF5
        DYSON(NIU,IQ)=0.0d0
        do i=1,nbf5
         BETAi = DSQRT(RO(i))
         DYSON(NIU,IQ)=DYSON(NIU,IQ)+COEF(NIU,i)*BETAi*W(i,IQ)
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     Occupation Number of Dyson Orbital (Normalization Factor)
C-----------------------------------------------------------------------
      DO IQ=1,NBF5
       OCCD(IQ)=0.0d0
       do niu=1,nbf
        OCCD(IQ) = OCCD(IQ) + DYSON(niu,IQ)*FC(niu,IQ,OVERLAP,DYSON)
       enddo
      ENDDO
C-----------------------------------------------------------------------
C     Normalized Dyson Orbitals
C-----------------------------------------------------------------------
      DO IQ=1,NBF5
       DO niu=1,nbf
        DYSON(niu,IQ)=DYSON(niu,IQ)/DSQRT(OCCD(IQ))
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C DYSVECOUTrc
      SUBROUTINE DYSVECOUTrc(V,RO,NBF,NBF5,NL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     Print Eigenvectors
C-----------------------------------------------------------------------
      CHARACTER*2 LABELAT
      CHARACTER*4 BFNAM1
      CHARACTER*6 BFNAM2
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::V
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::DOSRO
      ALLOCATE(DOSRO(NBF))
C-----------------------------------------------------------------------
      DO J=1,NBF5
       DOSRO(J)=2.0*RO(J)
      ENDDO
      DO J=NBF5+1,NBF
       DOSRO(J)=0.0
      ENDDO
      MAX=0
  10  MIN=MAX+1
      MAX=MAX+5
      IF(MAX>NL) MAX=NL
      WRITE(6,1)(J,J=MIN,MAX)
      WRITE(6,2)(DOSRO(J),J=MIN,MAX)
      WRITE(6,*)
      REWIND(4)
      READ(4,'(I5)')NBF0
      DO I=1,NBF
       IF(I<=35)THEN
        READ(4,3)LABELAT,IAT,BFNAM1
        WRITE(6,4) I,LABELAT,IAT,BFNAM1,(V(I,J),J=MIN,MAX)
       ELSE
        READ(4,5)LABELAT,BFNAM2
        WRITE(6,6) I,LABELAT,BFNAM2,(V(I,J),J=MIN,MAX)
       ENDIF
      ENDDO
      IF(MAX<NL) GOTO 10
      WRITE(6,7)
C-----------------------------------------------------------------------
    1 FORMAT(/,15X,5(4X,I4,3X))
    2 FORMAT(/,15X,5F11.4)
    3 FORMAT(A2,I2,A4)
    4 FORMAT(I5,2X,A2,I2,A4,5F11.6)
    5 FORMAT(A2,A6)
    6 FORMAT(I5,2X,A2,A6,5F11.6)
    7 FORMAT(/)
C-----------------------------------------------------------------------
      DEALLOCATE(DOSRO)
      RETURN
      END

C DENMATrc
      SUBROUTINE DENMATrc(DM,C,RO)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::DM,C
C----------------------------------------------------------------------
      DO M=1,NBF
       DO N=M,NBF
       DM(M,N)=0.0d0
       DO J=1,NBF5
        DM(M,N)=DM(M,N)+ RO(J)*C(M,J)*C(N,J)
       ENDDO
       DM(N,M)=DM(M,N)
       ENDDO
      ENDDO
      DM=2.0d0*DM
C----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                       Wavefunction file (.wfn)                       !
!                                                                      !
!    AIMMEMrc: Create an input file for Bader's AIMPAC Program         !
!    AIMPACrc: Write information into a WFN file (7)                   !
!                                                                      !
!======================================================================!

C AIMMEMrc
      SUBROUTINE AIMMEMrc(COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,KNG,KKMIN,
     &                  KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
C-----------------------------------------------------------------------
C     Create an input File for Bader's AIMPAC Program
C-----------------------------------------------------------------------
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NATOMS)::IZCORE
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,CS,CP,CD,CF,CG,CH,CI
C-----------------------------------------------------------------------
      NPRIMS = 0
      DO I = 1,NSHELL
       NPRIMS = NPRIMS + KNG(I) * (KKMAX(I)-KKMIN(I)+1)
      ENDDO
C-----------------------------------------------------------------------
      CALL AIMPACrc(NBF5,NPRIMS,COEF,ZNUC,IZCORE,CX0,CY0,CZ0,KSTART,
     &     KNG,KKMIN,KKMAX,KATOM,KTYPE,RO,E,EX1,CS,CP,CD,CF,CG,CH,CI)
C-----------------------------------------------------------------------
      RETURN
      END

C AIMPACrc
      SUBROUTINE AIMPACrc(NMO,NPRIMS,VEC,ZNUC,IZCORE,CX0,CY0,CZ0,
     &                    KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE,RO,E,
     &                    EX1,CS,CP,CD,CF,CG,CH,CI)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*4,DIMENSION(106)::ATMLAB
      INTEGER,DIMENSION(NATOMS)::IZCORE
      INTEGER,DIMENSION(NSHELL)::KSTART,KNG,KKMIN,KKMAX,KATOM,KTYPE
      INTEGER,DIMENSION(NPRIMS)::ICENT,ITYPE
      DOUBLE PRECISION,DIMENSION(NBF)::E
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::VEC
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NATOMS)::ZNUC,CX0,CY0,CZ0
      DOUBLE PRECISION,DIMENSION(NPRIMI)::EX1,CS,CP,CD,CF,CG,CH,CI
      DOUBLE PRECISION,DIMENSION(NPRIMS)::EXPON,AIC,ACO
C-----------------------------------------------------------------------
      DATA ATMLAB/'  H ','  HE','  LI','  BE','  B ','  C ',
     *            '  N ','  O ','  F ','  NE','  NA','  MG',
     *            '  AL','  SI','  P ','  S ','  CL','  AR',
     *            '  K ','  CA','  SC','  TI','  V ','  CR',
     *            '  MN','  FE','  CO','  NI','  CU','  ZN',
     *            '  GA','  GE','  AS','  SE','  BR','  KR',
     *            '  RB','  SR','  Y ','  ZR','  NB','  MO',
     *            '  TC','  RU','  RH','  PD','  AG','  CD',
     *            '  IN','  SN','  SB','  TE','  I ','  XE',
     *            '  CS','  BA','  LA','  CE','  PR','  ND',
     *            '  PM','  SM','  EU','  GD','  TB','  DY',
     *            '  HO','  ER','  TM','  YB','  LU','  HF',
     *            '  TA','  W ','  RE','  OS','  IR','  PT',
     *            '  AU','  HG','  TL','  PB','  BI','  PO',
     *            '  AT','  RN','  FR','  RA','  AC','  TH',
     *            '  PA','  U ','  NP','  PU','  AM','  CM',
     *            '  BK','  CF','  ES','  FM','  MD','  NO',
     *            '  LR','    ','    ','    '/
C-----------------------------------------------------------------------
      REWIND(7)
      WRITE(7,1)TITLE
      WRITE(7,2)NMO,NPRIMS,NATOMS
C-----------------------------------------------------------------------
C     CX0,CY0,CZ0: Cartesian nuclear coordinate arrays
C     ZNUC: Nuclear charge array (1,NATOMS)
C     IZCORE: Number of electrons removed from each atom (ECP)
C-----------------------------------------------------------------------
      DO I=1,NATOMS
       IZNUC = INT(ZNUC(I))+IZCORE(I)
       WRITE(7,3)ATMLAB(IZNUC),I,I,CX0(I),CY0(I),CZ0(I),
     &           ZNUC(I)+IZCORE(I)
      ENDDO
C-----------------------------------------------------------------------
C     Fill AIC (CONTRACTION COEFFS)
C-----------------------------------------------------------------------
      L = 0
      DO I = 1,NSHELL
       JST = KSTART(I)
       JEN = JST + KNG(I) - 1
       MINK = KKMIN(I)
       MAXK = KKMAX(I)
       DO K = MINK,MAXK
        DO J = JST,JEN
         L = L + 1
         ICENT(L) = KATOM(I)
         ITYPE(L) = K
         EXPON(L) = EX1(J)
         IF( K==1          )AIC(L) = CS(J)
         IF( 2<=K.and.K<= 4)AIC(L) = CP(J)
         IF( 5<=K.and.K<=10)AIC(L) = CD(J)
         IF(11<=K.and.K<=20)AIC(L) = CF(J)
         IF(21<=K.and.K<=35)AIC(L) = CG(J)
         IF(36<=K.and.K<=56)AIC(L) = CH(J)
         IF(57<=K.and.K<=84)AIC(L) = CI(J)
        ENDDO
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
C     Write primitive information: ICENT, ITYPE, EXPON
C-----------------------------------------------------------------------
      WRITE(7,4) (ICENT(I),I=1,NPRIMS)
      WRITE(7,5) (ITYPE(I),I=1,NPRIMS)
      WRITE(7,6) (EXPON(I),I=1,NPRIMS)
C-----------------------------------------------------------------------
C     Expand the Natural Orbitals in the Atomic Orbital Basis
C     into the primitive representation. Write NOs and their OCC and E.
C-----------------------------------------------------------------------
      SQRT3 = SQRT(3.0D0)
      SQRT5 = SQRT(5.0D0)
      SQRT7 = SQRT(7.0D0)
      DO II=1,NMO
       L = 0
       M = 0
       DO I=1,NSHELL
        KST = KSTART(I)
        KEN = KST + KNG(I) - 1
        JMIN= KKMIN(I)
        JMAX= KKMAX(I)
        ITYP= KTYPE(I)
        DO J=JMIN,JMAX
         M = M+1
         DO K=KST,KEN
          L = L+1
          ACO(L) = VEC(M,II)*AIC(L)
          IF(ITYP==3)THEN
           IF(J>=8)ACO(L) = ACO(L)*SQRT3
          END IF
          IF(ITYP==4)THEN
           IF(J>=14)ACO(L)=ACO(L)*SQRT5
           IF(J==17)THEN
            DUMMY    = ACO(L-1)
            ACO(L-1) = ACO(L)
            ACO(L)   = DUMMY
           ENDIF
           IF(J==20)ACO(L) = ACO(L)*SQRT3
          ENDIF
          IF(ITYP==5)THEN
           IF(J>=24)ACO(L) = ACO(L)*SQRT7
           IF(J>=30)ACO(L) = ACO(L)*SQRT5/SQRT3
           IF(J>=33)ACO(L) = ACO(L)*SQRT3
          ENDIF
         ENDDO
        ENDDO
       ENDDO
       WRITE(7,7) II,2.0*RO(II),E(II)
       WRITE(7,8) (ACO(L),L=1,NPRIMS)
      ENDDO
C-----------------------------------------------------------------------
C     Terminate data, add SCF Energy and Virial
C-----------------------------------------------------------------------
      VIR = 0.0d0
      WRITE(7,9)
      WRITE(7,10)'THE RHF ',EELEC+EN,VIR
C-----------------------------------------------------------------------
    1 FORMAT(A80)
    2 FORMAT ('GAUSSIAN',10X,I5,' MOL ORBITALS',1X,I6,' PRIMITIVES',
     &        4X,I5,' NUCLEI')
    3 FORMAT(A4,I4,4X,'(CENTRE',I3,')',1X,3F12.8,'  CHARGE =',F5.1)
    4 FORMAT('CENTRE ASSIGNMENTS',2X,20I3)
    5 FORMAT('TYPE ASSIGNMENTS',4X,20I3)
    6 FORMAT('EXPONENTS',1X,1P,5E14.7)
    7 Format('MO',I5,5X,'MO 0.0',8X,'OCC NO = ',F12.7,
     &       '  ORB. ENERGY =', F12.6)
    8 FORMAT(1P,5E16.8)
    9 FORMAT('END DATA')
   10 FORMAT(A8,' ENERGY =',F20.12,' THE VIRIAL(-V/T)=',F13.8)
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!   APSG File (.apsg) containing the generating wavefunction of PNOF5  !
!                                                                      !
!                 ( J. Chem. Phys. 139, 234109, 2013 )                 !
!                                                                      !
!======================================================================!

C PUNCHVEC
      SUBROUTINE PUNCHVEC(V,NBF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::V
C-----------------------------------------------------------------------
      DO J = 1,NBF
       K = 0
       MAX = 0
    1  MIN = MAX + 1
       MAX = MAX + 5
       K = K + 1
       IF(MAX>NBF)MAX = NBF
       MODJ = MOD(J,100)
       WRITE(9,10) MODJ,K,(V(I,J),I = MIN,MAX)
       IF (MAX<NBF)GOTO 1
      ENDDO
C-----------------------------------------------------------------------
   10 FORMAT(I2,I3,1P,5E15.8)
      RETURN
      END

C PUNCHAPSG
      SUBROUTINE PUNCHAPSG(NO1,NCWO,NCO,NBF5,RO,SUMA,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      ALLOCATABLE::IOCU(:),BB(:,:)
C-----------------------------------------------------------------------
C     NCO:  Number of HF occupied MOs (OCC=1)
C     NVIR: Number of HF virtual  MOs (OCC=0)
C
C     NO1:  Number of inactive doubly occupied orbitals (OCC=1)
C     NDOC: Number of strongly occupied MOs
C     NCWO: Number of coupled weakly occupied MOs per strongly occupied
C     NCWO*NDOC: Active orbitals in the virtual subspace
C     NO0: Empty orbitals  (OCC=0)
C     NAC:  Dimension of the active natural orbital subspace
C
C           NCO     |       NVIR          = NBF
C       NO1 + NDOC  |  NCWO*NDOC + NO0    = NBF
C           |      NAC           |
C-----------------------------------------------------------------------
      NO1NAC=NCO+NCWO*(NCO-NO1)                             ! NO1+NAC
      ALLOCATE(IOCU(NO1NAC),BB(NCO,NO1NAC))
      IOCU = 0
      SUMA = 0.0d0

C     HF Fermi Vacuum
      D0 = 1.0d0
      do i=1,NCO
       IOCU(i) = i
       D0 = D0*DSQRT(RO(i))
      enddo
      WRITE(9,1)D0,(IOCU(i),-IOCU(i),i=1,NCO)
      SUMA = SUMA + D0*D0

      do i=NO1+1,NCO
       do j=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        BB(i,j) = DSQRT(RO(j)/RO(i))
       enddo
      enddo

      CALL OneNCO(NO1,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,D0,THAPSG)
      IF(NCO>1)THEN
       do ig=2,NCO
        if(mod(ig, 2)==0)then
         CALL EvenNCO(NO1,NCO-ig+2,NCWO,NCO,NO1NAC,
     &                IOCU,BB,SUMA,D0,THAPSG)
        else
         CALL  OddNCO(NO1,NCO-ig+3,NCWO,NCO,NO1NAC,
     &                IOCU,BB,SUMA,D0,THAPSG)
        endif
       enddo
      ENDIF
C-----------------------------------------------------------------------
    1 FORMAT(F20.16,2X,99I4)
      DEALLOCATE(IOCU,BB)
      RETURN
      END

C OneNCO
      SUBROUTINE OneNCO(I1,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,DD,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      INTEGER,DIMENSION(NO1NAC)::IOCU
      DOUBLE PRECISION,DIMENSION(NCO,NO1NAC)::BB
C-----------------------------------------------------------------------
      do i=I1+1,NCO
       do ip=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        IOCU(i)=ip
        Di = -DD*BB(i,ip)
        IF(DABS(Di)>THAPSG)THEN
         WRITE(9,1)Di,(IOCU(ii),-IOCU(ii),ii=1,NCO)
         SUMA = SUMA + Di*Di
        ENDIF
        IOCU(i) = i
       enddo
      enddo
C-----------------------------------------------------------------------
    1 FORMAT(F20.16,2X,99I4)
      RETURN
      END

C OddNCO
      SUBROUTINE OddNCO(I1,I2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,DD,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NO1NAC)::IOCU
      DOUBLE PRECISION,DIMENSION(NCO,NO1NAC)::BB
C-----------------------------------------------------------------------
      do i=I1+1,I2-2
       do ip=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        IOCU(i) = ip
        Di = -DD*BB(i,ip)
        CALL EvenNCO(i,I2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,Di,THAPSG)
        IOCU(i) = i
       enddo
      enddo
C-----------------------------------------------------------------------
      RETURN
      END

C EvenNCO
      SUBROUTINE EvenNCO(I1,I2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,DD,THAPSG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NO1NAC)::IOCU
      DOUBLE PRECISION,DIMENSION(NCO,NO1NAC)::BB
C-----------------------------------------------------------------------
      do i=I1+1,I2-1
       do ip=NCO+NCWO*(NCO-i)+1,NCO+NCWO*(NCO-i+1)
        IOCU(i) = ip
        Di = -DD*BB(i,ip)
        if(I2==NCO)then
         CALL OneNCO(i,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,Di,THAPSG)
        else
         CALL OddNCO(i,I2+2,NCWO,NCO,NO1NAC,IOCU,BB,SUMA,Di,THAPSG)
        endif
        IOCU(i) = i
       enddo
      enddo
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                         Chemical Potential                           !
!                                                                      !
!               ( Int. J. Quantum Chem. 116, 805, 2016 )               !
!                                                                      !
!======================================================================!

C CHEMPOTrc
      SUBROUTINE CHEMPOTrc(HCORE,QJ,QK,RO,DIPx,DIPy,DIPz)
C-----------------------------------------------------------------------
C     This subroutine is called when ICHEMPOT = 1 for PNOF5 and PNOF7
C-----------------------------------------------------------------------
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::HCORE,RO,DIPx,DIPy,DIPz
      DOUBLE PRECISION,DIMENSION(NBFT5)::QJ,QK
      ALLOCATABLE::CMIU(:),DCJ12DRO(:,:),DCK12DRO(:,:)
      ALLOCATE (CMIU(NBF5))
      ALLOCATE (DCJ12DRO(NBF5,NBF5),DCK12DRO(NBF5,NBF5))
C-----------------------------------------------------------------------
      DCJ12DRO = 0.0d0
      DCK12DRO = 0.0d0
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C                      Inter-pair interactions
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(IPNOF==5)THEN                 ! PNOF5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=1,NBF5
        DO i=1,NBF5
         DCJ12DRO(j,i) = 2.0d0*RO(i)
         DCK12DRO(j,i) = RO(i)
        ENDDO
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
      ELSE IF(IPNOF==7)THEN            ! PNOF7
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       if(Ista==0)then
        DO j=1,NBF5
         DO i=1,NBF5
          DCJ12DRO(j,i) = 2.0d0*RO(i)
          FIj = DSQRT(RO(j)*(1.0d0-RO(j)))
          IF(FIj/=0.0d0)THEN          
           DCK12DRO(j,i) = RO(i)
     &                   + (0.5d0-RO(j))*DSQRT(RO(i)*(1.0d0-RO(i)))/FIj
          ENDIF
         ENDDO
        ENDDO
       else if(Ista==1)then       
        DO j=1,NBF5
         DO i=1,NBF5
          DCJ12DRO(j,i) = 2.0d0*RO(i)
          DCK12DRO(j,i) = RO(i) 
     &                  + 4.0d0*(1.0d0-2.0d0*RO(j))*RO(i)*(1.0d0-RO(i))
         ENDDO
        ENDDO
       end if
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
      END IF       
C      
      if(MSpin==0.and.NSOC>1)then                     
       DO j=NB+1,NA
        DO i=NB+1,NA
         DCK12DRO(j,i) = 2.0d0*RO(i)        
        ENDDO      
       ENDDO
      endif
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C                      Intra-pair interactions
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     below-above Fermi level interaction
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,NDOC
       jn = NO1+j
       DO i=NDNS+NCWO*(NDOC-j)+1,NDNS+NCWO*(NDOC-j+1)
        in = NO1+i
        DCJ12DRO(jn,in) = 0.0d0
        DCJ12DRO(in,jn) = 0.0d0
        IF(RO(jn)/=0.0d0)THEN
         DCK12DRO(jn,in) = DSQRT(RO(in))/(2.0*DSQRT(RO(jn)))
        ELSE
         DCK12DRO(jn,in) = 0.0d0
        ENDIF
        IF(RO(in)/=0.0d0)THEN
         DCK12DRO(in,jn) = DSQRT(RO(jn))/(2.0*DSQRT(RO(in)))
        ELSE
         DCK12DRO(in,jn) = 0.0d0
        ENDIF
       ENDDO
      ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     above-above Fermi level interaction for each geminal 'l'
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO l=1,NDOC
       DO j=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
        jn = NO1+j
        DO i=NDNS+NCWO*(NDOC-l)+1,NDNS+NCWO*(NDOC-l+1)
         in = NO1+i
         DCJ12DRO(jn,in) = 0.0d0
         IF(RO(jn)/=0.0d0)THEN
          DCK12DRO(jn,in) = - DSQRT(RO(in))/(2.0*DSQRT(RO(jn)))
         ELSE
          DCK12DRO(jn,in) = 0.0d0
         ENDIF
        ENDDO
       ENDDO
      ENDDO
C-----------------------------------------------------------------------      
C     Chemical Potential for each subspace      
C-----------------------------------------------------------------------
      DO j=1,NDOC
       jn = NO1+j      
       jj = jn*(jn+1)/2
       CMIU(jn) = HCORE(jn) + QJ(jj)/2.0 + PRODCWQWj(jn,DCJ12DRO,QJ)
     &                                   - PRODCWQWj(jn,DCK12DRO,QK)
      ENDDO
      IF(MSpin==0.and.NSOC>1)THEN
       DO j=NDOC+1,NDNS
        jn = NO1+j      
        jj = jn*(jn+1)/2
        CMIU(jn) = HCORE(jn) + PRODCWQWj(jn,DCJ12DRO,QJ)
     &                       - PRODCWQWj(jn,DCK12DRO,QK)
       ENDDO
      ENDIF       
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Including Electric Field
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(EFIELDL)THEN
       DO j=1,NDNS
        jn = NO1+j      
        CMIU(jn) = CMIU(jn) - (EX*DIPX(jn)+EY*DIPY(jn)+EZ*DIPZ(jn))
       ENDDO
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c      write(6,'(/,11X,A19,/)')'Chemical Potentials'
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c      DO j=1,NDNS
c       jn = NO1+j      
c       write(6,'(I6,2F19.6)')jn,CMIU(jn),CMIU(jn)*27.21138386
c      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CHEPOT = -1.0d10
      DO j=1,NDNS
       jn = NO1+j
       if(CMIU(jn)>CHEPOT)CHEPOT=CMIU(jn)
      ENDDO
      write(6,1)CHEPOT,CHEPOT*27.21138386             
C-----------------------------------------------------------------------
    1 FORMAT(/,3X,'Chemical Potential =',F10.4,2X,'(',F10.4,1X,'eV )')
      DEALLOCATE (CMIU,DCJ12DRO,DCK12DRO)
      RETURN
      END

!======================================================================!
!                                                                      !
!                     CJ12 and CK12 (MOLECULAR RDMs)                   !
!                                                                      !
!    NOUTCJK=1: Print CJ12 and CK12 to 'CJK' File (.cjk)               !
!    NTHRESHCJK determines THRESHOLD for CJKs = 10.0**(-NTHRESHCJK)    !
!                                                                      !
!======================================================================!
      
      SUBROUTINE OUTPUTCJKrc(RO,CJ12,CK12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::BETA,FIs
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::CK12nd
C----------------------------------------------------------------------- 
C     Print CJ12 and -CK12
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,NBF5
       if(RO(i)>THRESHCJK)WRITE(12)i,i,i,i,RO(i)    ! CLii = CJii
       DO j=1,i-1
        if(DABS(CJ12(i,j))>THRESHCJK)then
         WRITE(12)i,j,i,j,CJ12(i,j)
         WRITE(12)j,i,j,i,CJ12(i,j)
        end if
        if(DABS(CK12(i,j))>THRESHCJK)then            ! Print -CK12
         WRITE(12)i,j,j,i,-CK12(i,j)
         WRITE(12)j,i,i,j,-CK12(i,j)
        end if
       ENDDO
      ENDDO
      WRITE(12)0,0,0,0,0.0d0
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C                   CK12nd: Non-Dynamic (Static) CK12
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      IF(NOUTTijab==1)THEN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
       ALLOCATE(FIs(NBF5),BETA(NBF5),CK12nd(NBF5,NBF5))
       FIs = 0.0d0
       BETA = 0.0d0
       CK12nd = 0.0d0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      FIs(j)  = 2*RO(j)*HOLE(j)
C      BETA(j) = DSQRT(2*HOLE(j)) * DSQRT(RO(j))
C      BETA(j) = DSQRT(2*RO(j))   * DSQRT(RO(j))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        FIs(j) = 2.0d0*RO(j)*(1.0d0-RO(j))
        Cj = 1.0d0 - DABS(1.0d0-2.0d0*RO(j))
        BETA(j) = DSQRT( Cj*RO(j) )
       ENDDO
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      Inter-pair Non-Dynamic (Static) Electron Correlation
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=NO1+1,NBF5
        DO i=NO1+1,NBF5
         CK12nd(j,i) = FIs(j)*FIs(i)
        ENDDO
       ENDDO
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      Intra-pair Non-Dynamic (Static) Electron Correlation
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      below-above Fermi level interaction
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO j=1,NDOC
        jn = NO1+j
        DO i=NDOC+NCWO*(NDOC-j)+1,NDOC+NCWO*(NDOC-j+1)
         in = NO1+i
         CK12nd(jn,in) = BETA(jn)*BETA(in)
         CK12nd(in,jn) = BETA(in)*BETA(jn)
        ENDDO
       ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      above-above Fermi level interaction for each geminal 'l'
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO l=1,NDOC
        DO j=NDOC+NCWO*(NDOC-l)+1,NDOC+NCWO*(NDOC-l+1)
         jn = NO1+j
         DO i=NDOC+NCWO*(NDOC-l)+1,NDOC+NCWO*(NDOC-l+1)
          in = NO1+i
          CK12nd(jn,in) = - BETA(jn)*BETA(in)
         ENDDO
        ENDDO
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Print -CK12nd
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO i=1,NBF5
        DO j=1,i-1
         if(DABS(CK12nd(i,j))>THRESHCJK)then        
          WRITE(13)i,j,j,i,-CK12nd(i,j)
          WRITE(13)j,i,i,j,-CK12nd(i,j)
         end if
        ENDDO
       ENDDO
       WRITE(13)0,0,0,0,0.0d0       
       DEALLOCATE(FIs,BETA,CK12nd)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END IF
C-----------------------------------------------------------------------
      RETURN
      END
      
!======================================================================!
!                                                                      !
!                         Tijab (MOLECULAR RDMs)                       !
!                                                                      !
!    NOUTTijab=1: Print MP2 amplitudes to 'CND' File (.cnd)            !
!    NTHRESHTijab determines Tijab THRESHOLD = 10.0**(-NTHRESHTijab)   !
!                                                                      !
!======================================================================!
      
      SUBROUTINE OUTPUTTijab_rc(NOC,NVI,NN,Tijab)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NN)::Tijab
C-----------------------------------------------------------------------  
      DO i=1,NOC
       DO j=1,NOC
         DO k=1,NVI
          ki = (k-1)*noc + i
          DO l=1,NVI
           ijkl =  i + (j-1)*noc + (k-1)*noc*noc + (l-1)*noc*noc*nvi
           ijlk =  i + (j-1)*noc + (l-1)*noc*noc + (k-1)*noc*noc*nvi
           TTijab = 2.0*Tijab(ijkl)-Tijab(ijlk)
           IF(DABS(TTijab)>THRESHTijab)THEN
            in = NO1+i
            jn = NO1+j
            kn = NO1+noc+k
            ln = NO1+noc+l
            WRITE(13)in,jn,kn,ln,TTijab
           ENDIF
          ENDDO
         ENDDO
       ENDDO
      ENDDO
      WRITE(13)0,0,0,0,0.0d0
C-----------------------------------------------------------------------
      RETURN
      END
      
! ==================================================================== !
!                                                                      !
!             Subroutines related to atomic density matrices           !
!                                                                      !
! ==================================================================== !
!                                                                      !
!    NOUTRDM=1: Print Atomic RDMs IN 1DM and 2DM Files                 !
!    NSQT=0: 2DM (14), 1DM (15) [formatted files]                      !
!    NSQT=1: 2DM (14), 1DM (15), N2DM (16) [unformatted files]         !
!                                                                      !
!    OUTPUTRDMrc: Calculate, check norms and print atomic DMs          !
!    SUMDDL: Perform the trasformation from NOs to atomic MOs for 2DM  !
!    SUMDL: Perform the trasformation from NOs to atomic MOs for 1DM   !
!    RDM1NORM: Calculate and print the 1DM norm                        !
!    RDM2NORM: Calculate and print the 2DM norm                        !
!    DENSI: Calculate density for each 2DM(ijkl)                       !
!                                                                      !
!======================================================================!

C OUTPUTRDMrc
      SUBROUTINE OUTPUTRDMrc(OVERLAP,RO,QD,CJ12,CK12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::OVERLAP
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      ALLOCATABLE::IDXD(:),BUFD(:)
C-----------------------------------------------------------------------
C     2DM
C-----------------------------------------------------------------------
      LBUFDM = 10000       ! Length of buffer for Density Matrix values
      IF(NSQT==1)THEN
C      ifort -i8 in PNOF, MAX=2**64-1, MAX_NBF=2**16-1=65535 !!!
       NSHI1=2**16
C      NSH2=2**32
       NSHI2=NSHI1*NSHI1
C      NSH3=2**48
       NSHI3=NSHI2*NSHI1
       ALLOCATE (IDXD(LBUFDM),BUFD(LBUFDM))
       NBINT=0
       NREC=0
       DO IETA=1,NBF
        DO IMIU=1,NBF
         DO INIU=1,NBF
          DO ILAM=1,NBF
           RDM2 = SUMDDL(IETA,IMIU,INIU,ILAM,RO,QD,CJ12,CK12)
           IF(DABS(RDM2)>THRESHDM)THEN
            NBINT=NBINT+1
C           CHANGE INDEXES ( IMIU <-> INIU ) for Ugalde's Program
            IDXD(NBINT)=NSHI3*IETA+NSHI2*INIU+NSHI1*IMIU+ILAM
            BUFD(NBINT)=RDM2
C           Write: IDXD(IETA,INIU,IMIU,ILAM) ; BUFD(RDM2)
            IF(NBINT==LBUFDM)THEN
             WRITE(14)NBINT,(IDXD(M),M=1,NBINT),(BUFD(M),M=1,NBINT)
             NBINT=0
             NREC=NREC+1
            ENDIF
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
C      Write the last record on file 14
       IF(NBINT/=0)THEN
        WRITE(14)NBINT,(IDXD(M),M=1,NBINT),(BUFD(M),M=1,NBINT)
        NREC=NREC+1
       ENDIF
C      Total number of written integrals
       NBINT=NBINT+(NREC-1)*LBUFDM
C      Write the number of records and 2DMS
       WRITE(16,3)NREC,NBINT
       DEALLOCATE (IDXD,BUFD)
      ELSEIF(NSQT==0)THEN
       DO IETA=1,NBF
        DO IMIU=1,NBF
         DO INIU=1,NBF
          DO ILAM=1,NBF
           RDM2 = SUMDDL(IETA,IMIU,INIU,ILAM,RO,QD,CJ12,CK12)
           IF(DABS(RDM2)>THRESHDM)THEN
C           Change indexes ( IMIU <-> INIU ) for Ugalde's Program
C           WRITE(14,1)IETA,INIU,IMIU,ILAM,RDM2
            WRITE(14,1)IETA,IMIU,INIU,ILAM,RDM2
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
C     1DM
C-----------------------------------------------------------------------
      DO IETA=1,NBF
       DO IMIU=1,NBF
        RDM1 = SUMDL(IETA,IMIU,RO,QD)
        IF(DABS(RDM1)>THRESHDM)THEN
         WRITE(15,2)IETA,IMIU,RDM1
        ENDIF
       ENDDO
      ENDDO
C     Check the normalization of the 2RDM
      CALL RDM1NORM(OVERLAP,RO,QD)
      CALL RDM2NORM(OVERLAP,RO,QD,CJ12,CK12)
C-----------------------------------------------------------------------
1     FORMAT(4I4,D20.10)
2     FORMAT(2I4,D20.10)
3     FORMAT(I4,I20)
      RETURN
      END
  
C SUMDDL (2RDM)
      FUNCTION SUMDDL(IETA,IMIU,INIU,ILAM,RO,QD,CJ12,CK12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      ALLOCATABLE::Dj(:,:),Di(:,:)
      ALLOCATE (Dj(NBF,NBF),Di(NBF,NBF))
C-----------------------------------------------------------------------
      SUMDDL=0.0d0
      DO j=1,NBF5
       Dj = QD(j,1:NBF,1:NBF)
       DO i=1,NBF5
        Di = QD(i,1:NBF,1:NBF)
        IF(i==j)THEN
         SUMDDL = SUMDDL + RO(j)*Dj(IETA,INIU)*Di(IMIU,ILAM)
        ELSE
         SUMDDL = SUMDDL + CJ12(j,i)*Dj(IETA,INIU)*Di(IMIU,ILAM)
     &                   - CK12(j,i)*Dj(IETA,ILAM)*Di(IMIU,INIU)
CL     &                   - CK12(j,i)*Dj(IETA,IMIU)*Di(INIU,ILAM)
        ENDIF
       ENDDO
      ENDDO
      DO j=NB+1,NA
       Dj = QD(j,1:NBF,1:NBF)
       SUMDDL = SUMDDL - RO(j)*Dj(IETA,INIU)*Dj(IMIU,ILAM)
      ENDDO
      
      SUMDDL = SUMDDL/4.0d0
      IF(DABS(SUMDDL)<=THRESHDM)SUMDDL = 0.0d0
      DEALLOCATE (Dj,Di)
C-----------------------------------------------------------------------
      RETURN
      END

C SUMDL (1RDM)
      FUNCTION SUMDL(IETA,IMIU,RO,QD)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
C-----------------------------------------------------------------------
      SUMDL=0.0d0
      DO J=1,NB
       SUMDL = SUMDL + RO(J) * QD(J,IETA,IMIU)
      ENDDO
      IF(NSOC>0)THEN
       DO J=NB+1,NA
       if(HighSpin)THEN
        SUMDL = SUMDL + 0.5d0 * RO(J) * QD(J,IETA,IMIU)
       else
        SUMDL = SUMDL + RO(J) * QD(J,IETA,IMIU)
       endif
       ENDDO
      ENDIF
      DO J=NA+1,NBF5
       SUMDL = SUMDL + RO(J) * QD(J,IETA,IMIU)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C RDM1NORM
      SUBROUTINE RDM1NORM(S,RO,QD)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::S
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
C-----------------------------------------------------------------------
      SUMNORM=0.0d0
      DO IETA=1,NBF
       DO IMIU=1,IETA
        SUMNORM=SUMNORM+2.0*S(IETA,IMIU)*SUMDL(IETA,IMIU,RO,QD)
       ENDDO
       SUMNORM=SUMNORM-S(IETA,IETA)*SUMDL(IETA,IETA,RO,QD)
      ENDDO
      WRITE(6,1)SUMNORM
C-----------------------------------------------------------------------     
1     FORMAT(/' RDM Norms ',/,
     *        ' ---------  ',//,1X,'1RDM Norm =',F7.3)
      RETURN
      END

C RDM2NORM
      SUBROUTINE RDM2NORM(S,RO,QD,CJ12,CK12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::S
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
C-----------------------------------------------------------------------
      TWONORMA=0.D0
      DO I=1,NBF
       DO K=1,I
        DO J=1,NBF
         DO L=1,J
          DENSITY = DENSI(I,J,K,L,RO,QD,CJ12,CK12)
          TWONORMA=TWONORMA+DENSITY*S(I,K)*S(J,L)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
      WRITE(6,1)TWONORMA
1     FORMAT(1X,'2RDM Norm =',F7.3)
C-----------------------------------------------------------------------
      RETURN
      END

C DENSI
      DOUBLE PRECISION FUNCTION DENSI(II,JJ,KK,LL,RO,QD,CJ12,CK12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
C-----------------------------------------------------------------------
      IF((II==KK).AND.(JJ==LL))THEN
       DENSI=SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)
       RETURN
      ELSE IF((II==KK).AND.(JJ/=LL))THEN
       DENSI = SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)
     &       + SUMDDL(ii,ll,kk,jj,RO,QD,CJ12,CK12)
       RETURN
      ELSE IF((II/=KK).AND.(JJ==LL))THEN
       DENSI = SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)
     &       + SUMDDL(kk,jj,ii,ll,RO,QD,CJ12,CK12)
       RETURN
      ELSE IF((II/=KK).AND.(JJ/=LL))THEN
       DENSI = SUMDDL(ii,jj,kk,ll,RO,QD,CJ12,CK12)
     &       + SUMDDL(ii,ll,kk,jj,RO,QD,CJ12,CK12)
     &       + SUMDDL(kk,jj,ii,ll,RO,QD,CJ12,CK12)
     &       + SUMDDL(kk,ll,ii,jj,RO,QD,CJ12,CK12)
       RETURN
      ELSE
       WRITE(6,*)' *** ERROR IN DENSI SUBROUTINE ***'
       STOP
      END IF
C----------------------------------------------------------------------- 
      END

!======================================================================!
!                                                                      !
!                    M C P T   S U B R O U T I N E S                   !
!                                                                      !
!                 ( J. Chem. Phys. 139, 064111, 2013 )                 !
!                                                                      !
!======================================================================!

C SC2MCPThf
      SUBROUTINE SC2MCPThf(RO,COEF,AHCORE,IERI,ERI,QK)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NIJKL)::IERI
      DOUBLE PRECISION,DIMENSION(NIJKL)::ERI
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QK
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::COEF,AHCORE
C
      INTEGER,ALLOCATABLE,DIMENSION(:):: IPOS,IEX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::  OCC,OCCn,QKv,EIG
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: VEC,DMhf,BBn
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:):: AUX,FOCK,TVEC,FOCKm
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:,:):: ERImol
C-----------------------------------------------------------------------
C     NA:  Number of HF occupied MOs (OCC=1)
C     NVI: Number of HF virtual  MOs (OCC=0)
C
C     NO1:  Number of inactive doubly occupied orbitals (OCC=1)
C     NDOC: Number of strongly occupied MOs
C     NCWO: Number of coupled weakly occupied MOs per strongly occupied
C     NCWO*NDOC: Active orbitals in the virtual subspace
C     NO0: Empty orbitals  (OCC=0)
C     NAC:  Dimension of the active natural orbital subspace
C
C           NA      |       NVI           = NBF
C       NO1 + NDOC  |  NCWO*NDOC + NO0    = NBF
C           |      NAC           |
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C                  EHFL: HF Energy with localized orbitals
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C     DMhf: HF Density Matrix     ( DMhf -> FOCK = H + 2J-K )
C     FOCK: Fock Matrix in the atomic basis set
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (DMhf(NBF,NBF),FOCK(NBF,NBF))
      CALL DENMATHFr(DMhf,COEF)
      CALL FORM2JK(FOCK,DMhf,IERI,ERI)
      FOCK = AHCORE + FOCK
      EHFL = TRACE(DMhf,AHCORE,NBF) + TRACE(DMhf,FOCK,NBF)
      DEALLOCATE(DMhf)
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     Substracting core orbitals (NO1)
C     If using ECPotentials (IECP/=0): NO1=0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NOC = NA - NO1                              ! NOC = NDOC
      NVI = NQMT - NA
      NORB = NQMT - NO1
      WRITE(6,1)NO1,NOC,NVI,NQMT
      NOCNC = NOC + NCWO*NOC
      NOCNCT = NOCNC*(NOCNC+1)/2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check the value of NCWO if NOCNC = NOC + NCWO*NOC > NORB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOCNC>NORB)THEN
       NCWO1 = NORB/NOC - 1 
       IF(NCWO>NCWO1)THEN
        WRITE(6,2)NCWO1
        STOP
       ENDIF
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     OCC,VEC: Occupations and Molecular Orbitals without Core
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(OCC(NOCNC),VEC(NBF,NORB),QKv(NOCNCT))
      DO J=1,NOCNC
       OCC(J) = RO(J+NO1)
       DO I=1,J
        IJ = I + J*(J-1)/2
        IJold = I+NO1 + (J+NO1)*(J+NO1-1)/2
        QKv(IJ) = QK(IJold)
       ENDDO
      ENDDO
      DO J=1,NORB
       DO I=1,NBF
        VEC(I,J) = COEF(I,J+NO1)
       ENDDO
      ENDDO
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     FOCKm: Fock Matrix in the molecular basis set
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      ALLOCATE (FOCKm(NORB,NORB),AUX(NBF,NORB),TVEC(NORB,NBF))
      AUX   = MATMUL(FOCK,VEC)
      TVEC  = TRANSPOSE(VEC)     
      FOCKm = MATMUL(TVEC,AUX)
      DEALLOCATE(FOCK,AUX,TVEC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     EIG = One-particle energies [E(i)=Ct(i)*FOCK*C(i)=FOCKm(i,i)]
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (EIG(NORB))
      DO i=1,NORB
       EIG(i) = FOCKm(i,i)
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Print one-particle energies (EIG) if IPRINTEIG = 1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IPRINTEIG=0
      IF(IPRINTEIG==1)THEN
       write(6,'(/,A22,/)')'One-particle energies:'
       do i=1,NORB
        write(6,'(4x,I5,F20.10)')NO1+i,EIG(i)
       enddo
      ENDIF
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     Integral transformation ( Form <ab|rs> )
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     Allocate <ab|rs>
      ALLOCATE(ERImol(NBF,NBF,NBF,NBF))
C     Form <al|mn> from <kl|mn>
      CALL ERIC1c(ERImol,IERI,ERI,VEC,NORB)
C     Form <ab|ms>  [ ERImol(ia,l,m,k) -> ERImol(ia,ib,is,k) ]
      CALL ERIC23c(ERImol,VEC,NORB)
C     Form <ab|rs>  [ ERImol(ia,ib,is,k) -> ERImol(ia,ib,is,ir) ]
      CALL ERIC4c(ERImol,VEC,NORB)
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C                  PNOF5(Nc)-SC2-MCPT and PNOF5(Nc)-PT2
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      IF(IPNOF==5)THEN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      BBn(i,iw) = BETA(i,iw)/SQRT(OCCi) = SQRT(OCCk)/SQRT(OCCi)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ALLOCATE(BBn(NOC,NCWO))
       do i=1,NOC
        do iw=1,NCWO
         k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
         BBn(i,iw) = DSQRT(OCC(k)/OCC(i))
        enddo
       enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      E0 = < 0'| H |0 > = EHFL + Ecorr   ( E1 = 0 )
C      Ecorr: Correlation Energy with respect to EHFL
C      E2x: Ec(2) correlation energy
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       Ecorr = 0.0d0
       E2x = 0.0d0
       DO i=1,NOC
        do iw=1,NCWO
         k = NOC+NCWO*(NOC-i)+iw
         ik = i + k*(k-1)/2
         BBQK = BBn(i,iw)*QKv(ik)
         Eki = 2.0d0*(EIG(k)-EIG(i))
         Ecorr = Ecorr - BBQK
         E2x = E2x - BBQK/Eki
        enddo
       ENDDO
       E0 = EHFL + Ecorr
       WRITE(6,4)EHFL+EN,Ecorr,E0+EN
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      SC2-MCPT: E2 = Sum_k=1 [  < 0'| H |k >< k'| H |0 > / (E0-Ek) ]
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       E2 = Ecorr*E2x
     &    + E2HFs(NOC,NORB,EIG,FOCKm)
     &    + E2HFd(NOC,NORB,NBF,EIG,ERImol)
     &    + E2F(NOC,NCWO,NORB,EIG,FOCKm,BBn)
     &    + E2FERI(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)
     &    + E2ERIERI(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
     &    + E2dHF(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
       IF(NOC/=1)THEN
        E2 = E2 - Ecorr*E2x/2.0d0
     &          + E2Ql(NOC,NCWO,NORB,NOCNCT,EIG,QKv,BBn)
     &          + E2Qd(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
       ENDIF
       IF(NEX==0)WRITE(6,5)E2,E0+E2+EN
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      PNOF5(Nc)-PT2: exclude excitations from the same spatial orbital
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       E2ex = E2HFs(NOC,NORB,EIG,FOCKm)
     &      + E2HFdex(NOC,NORB,NBF,EIG,ERImol)
     &      + E2F(NOC,NCWO,NORB,EIG,FOCKm,BBn) 
     &      + E2FERIex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)
     &      + E2ERIERIex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)     
     &      + E2dHFex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
       IF(NOC/=1)THEN
        E2ex = E2ex + E2Qd(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn) 
       ENDIF
       IF(NEX==0)WRITE(6,6)E2ex,E0+E2ex+EN
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C      PNOF5(Nc)-PT2-NEX: Remove subspaces associated to NEX->E2ex-E2exi
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
       IF(NEX>0)THEN
        IF(NEX>NOC)THEN
         WRITE(6,'(/1X,A32,I5)')'STOP: NEX must be lesser than ',NOC+1
         STOP
        ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       IEX: Position of the 'NEX' minimum strongly occupation numbers
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ALLOCATE(IEX(NEX),IPOS(1),OCCn(NOC))
        IEX = -1
        WRITE(6,3)NEX
        OCCn = OCC(1:NOC)
        do i=1,nex
         IPOS = MINLOC(OCCn)
         IEX(i) = IPOS(1)
         OCCn(IEX(i)) = 1.0d0
        enddo
        E2exi = E2HFs_nex(NOC,NCWO,NORB,EIG,FOCKm,IEX,NEX)
     &        + E2HFdex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,IEX,NEX)
     &        + E2F_nex(NOC,NCWO,NORB,EIG,FOCKm,BBn,IEX,NEX)
     &        + E2FERIex_nex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn,
     &          IEX,NEX) + E2ERIERIex_nex
     &          (NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)
     &        + E2dHFex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)
        IF(NOC/=1)THEN
         E2exi = E2exi
     &         + E2Qd_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX) 
        ENDIF
        WRITE(6,7)E2ex+E2exi,E0+E2ex+E2exi+EN
        DEALLOCATE(IEX,IPOS,OCCn)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DEALLOCATE(BBn)
      ENDIF
C-----------------------------------------------------------------------
      DEALLOCATE(OCC,VEC,QKv,EIG,FOCKm,ERImol)
      RETURN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    1 FORMAT(//2X,'PNOF5-MCPT',/1X,12('='),//,
     *         1X,'NUMBER OF CORE ORBITALS    (NO1) =',I5,/,
     *         1X,'NUMBER OF OCCUPIED ORBS.   (NOC) =',I5,/,
     *         1X,'NUMBER OF VIRTUAL ORBS.    (NVI) =',I5,/,
     *         1X,'NUMBER OF LIN. IND. ORBS. (NQMT) =',I5)
    2 FORMAT(/1X,'NCWO is too large, reduce the value at least to',I5)
    3 FORMAT(/1X,'NUMBER OF EXCLUDED COUPLES (NEX) =',I5,/)
    4 FORMAT(/11X,'Ehf(l) =',F20.10,/,
     *        11X,' Ecorr =',F20.10,/,
     *        11X,'  E(0) =',F20.10)
    5 FORMAT(/6X,'       E(2) =',F20.10,/,
     *        6X,'E(SC2-MCPT) =',F20.10)
    6 FORMAT(/5X,'        E(2) =',F20.10,/,
     *        5X,'E(PNOF5-PT2) =',F20.10)
    7 FORMAT(1X,'            E(2) =',F20.10,/,
     *       1X,'E(PNOF5-PT2-NEX) =',F20.10)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                Integral transformation ( Form <ab|rs> )              !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C ERIC1c
      SUBROUTINE ERIC1c(ERImol,IERI,ERI,VEC,NORB)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
C-----------------------------------------------------------------------
      ERImol = 0.0d0
      DO M=1,NINTCR
       XINT1 = ERI(M)
       XINT2 = XINT1
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(I==J)XINT1 = XINT1 + XINT1
       IF(K==L)XINT2 = XINT2 + XINT2
       do ia=1,norb
        ERImol(ia,I,J,K) = ERImol(ia,I,J,K) + XINT1*VEC(L,ia)
        ERImol(ia,J,I,K) = ERImol(ia,I,J,K)
        ERImol(ia,I,J,L) = ERImol(ia,I,J,L) + XINT1*VEC(K,ia)
        ERImol(ia,J,I,L) = ERImol(ia,I,J,L)
        ERImol(ia,K,L,I) = ERImol(ia,K,L,I) + XINT2*VEC(J,ia)
        ERImol(ia,L,K,I) = ERImol(ia,K,L,I)
        ERImol(ia,K,L,J) = ERImol(ia,K,L,J) + XINT2*VEC(I,ia)
        ERImol(ia,L,K,J) = ERImol(ia,K,L,J)
       enddo
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C ERIC23c
      SUBROUTINE ERIC23c(ERImol,VEC,NORB)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NBF),AUX2(NBF,NORB))
C-----------------------------------------------------------------------
      do k=1,nbf
       do ia=1,norb
C - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       ERImol(ia,i,j,k) -> AUX1(i,j) for each (ia,k)
C - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do i=1,nbf
         do j=1,nbf
          AUX1(i,j) = ERImol(ia,i,j,k)
         enddo
        enddo
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       AUX2=AUX1*C
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        DO I=1,NBF
         do is=1,norb
          AUX2(I,is) = 0.0d0
          DO L=1,NBF
           AUX2(I,is) = AUX2(I,is) + AUX1(I,L)*VEC(L,is)
          ENDDO
         enddo
        ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       AUX1=VECt*AUX2
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL CeqAtB(AUX1,VEC,NBF,NORB,AUX2,NORB)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       AUX1 -> ERImol(ia,ib,is,k)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do ib=1,norb
         do is=1,norb
          ERImol(ia,ib,is,k) = AUX1(ib,is)
         enddo
        enddo
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       enddo
      enddo
C-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

C ERIC4c
      SUBROUTINE ERIC4c(ERImol,VEC,NORB)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NORB),AUX2(NBF,NORB))
C-----------------------------------------------------------------------
      do ib=1,norb
       do is=1,norb
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       ERImol(ia,ib,is,k) -> AUX1(k,ia) for each (ib,is)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do ia=1,norb
         do k=1,nbf
          AUX1(k,ia) = ERImol(ia,ib,is,k)
         enddo
        enddo
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       AUX2 = VEC*AUX1
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        CALL CeqAtB(AUX2,VEC,NBF,NORB,AUX1,NORB)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C       AUX2 -> ERImol(ia,ib,is,ir)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        do ir=1,norb
         do ia=1,norb
          ERImol(ia,ib,is,ir) = AUX2(ir,ia)
         enddo
        enddo
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       enddo
      enddo
C-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                     PNOF5(Nc)-SC2-MCPT -> E2                         !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C E2HFs
      FUNCTION E2HFs(NOC,NORB,EIG,FOCKm)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFs = 0.0d0
      DO i=1,noc
       DO l=noc+1,norb
        Eil = EIG(l) - EIG(i)
        E2HFs = E2HFs - FOCKm(i,l)*FOCKm(l,i)/Eil
       ENDDO
      ENDDO
      E2HFs = 2.0d0*E2HFs
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2HFd
      FUNCTION E2HFd(NOC,NORB,NBF,EIG,ERImol)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFd = 0.0d0
      DO i=1,noc
       DO j=1,noc
        DO k=noc+1,norb
         DO l=noc+1,norb
          Xijkl = ERImol(i,j,l,k)
          Xijlk = ERImol(i,j,k,l)
          Eklij = EIG(k) + EIG(l) - EIG(i) - EIG(j)
          E2HFd = E2HFd - Xijkl*(2.0*Xijkl-Xijlk)/Eklij
         ENDDO
        ENDDO
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2F
      FUNCTION E2F(NOC,NCWO,NORB,EIG,FOCKm,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2F = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
        Eki = EIG(k) - EIG(i)
        E2F = E2F + BBn(i,iw)*FOCKm(i,k)*FOCKm(k,i)/Eki 
       enddo
      ENDDO
      E2F = 2.0d0*E2F
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2FERI
      FUNCTION E2FERI(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2FERI = 0.0d0
c
      DO i=1,noc
       DO l=noc+1,norb
        Eli = EIG(l) - EIG(i)
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
         Eklii = EIG(k) - EIG(i) + Eli
         Xiikl = ERImol(i,i,l,k)
         Xilkk = ERImol(i,l,k,k)
         E2FERI = E2FERI + BBn(i,iw)*
     &          ( FOCKm(i,l)*Xilkk/Eli + FOCKm(k,l)*Xiikl/Eklii )
        enddo
       ENDDO
      ENDDO
c
      DO j=1,noc
       DO i=1,noc
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
         Ekj = EIG(k) - EIG(j)
         Ekkij = 2.0d0*EIG(k) - EIG(i) - EIG(j)
         Xiijk = ERImol(i,i,k,j)
         Xijkk = ERImol(i,j,k,k)
         E2FERI = E2FERI - BBn(i,iw)*
     &          ( FOCKm(j,k)*Xiijk/Ekj + FOCKm(i,j)*Xijkk/Ekkij )
        enddo
       ENDDO
      ENDDO
c
      E2FERI = 2.0d0*E2FERI
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2ERIERI
      FUNCTION E2ERIERI(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2ERIERI = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                  ! k = (i,iw)
        DO m=1,noc
         DO j=1,noc
          Ekkmj = 2.0d0*EIG(k) - EIG(m) - EIG(j)
          Xiimj = ERImol(i,i,j,m)
          Xmjkk = ERImol(m,j,k,k)
          E2ERIERI = E2ERIERI + BBn(i,iw)*Xiimj*Xmjkk/Ekkmj
         ENDDO
        ENDDO
        DO l=noc+1,norb
         DO n=noc+1,norb
          Enlii = EIG(n) + EIG(l) - 2.0d0*EIG(i)
          Xiiln = ERImol(i,i,l,n)
          Xlnkk = ERImol(l,n,k,k)
          E2ERIERI = E2ERIERI + BBn(i,iw)*Xiiln*Xlnkk/Enlii
         ENDDO
        ENDDO
       enddo
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2dHF
      FUNCTION E2dHF(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2dHF = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
        DO j=1,noc
         DO l=noc+1,norb
          Elkij = EIG(l) + EIG(k) - EIG(i) - EIG(j)
          Xijlk = ERImol(i,j,k,l)
          Xiljk = ERImol(i,l,k,j)
          Xijkl = ERImol(i,j,l,k)
          Xilkj = ERImol(i,l,j,k)
          XXijlk = Xijlk - Xijkl
          XXiljk = Xiljk - Xilkj
          E2dHF = E2dHF - (BBn(i,iw)/Elkij) *
     &                    ( XXijlk*Xilkj + Xijlk*Xiljk + Xijkl*XXiljk )
         ENDDO
        ENDDO
       enddo
      ENDDO
      E2dHF = 2.0d0*E2dHF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2Ql
      FUNCTION E2Ql(NOC,NCWO,NORB,NOCNCT,EIG,QKv,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOCNCT)::QKv
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2Ql = 0.0d0
      DO i=1,noc
       DO j=1,noc
        if(j/=i)then
         do iw=1,ncwo
          k = noc+ncwo*(noc-i)+iw                    ! k = (i,iw)
          jk = j + k*(k-1)/2
          do jw=1,ncwo
           l = noc+ncwo*(noc-j)+jw                   ! l = (j,jw)
           il = i + l*(l-1)/2
           Eli = EIG(l)-EIG(i)
           BB2 = BBn(i,iw)*BBn(j,jw)
           E2Ql = E2Ql - BB2*QKv(il)*QKv(jk)/Eli
          enddo
         enddo
        endif
       ENDDO
      ENDDO
      E2Ql = E2Ql/4.0d0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2Qd
      FUNCTION E2Qd(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2Qd = 0.0d0
      DO i=1,noc
       DO j=1,noc
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
         do jw=1,ncwo
          l = noc+ncwo*(noc-j)+jw                    ! l = (j,jw)
          BB2 = BBn(i,iw)*BBn(j,jw)
          if(j/=i)then
           Eklii = EIG(k) + EIG(l) - 2.0d0*EIG(i)
           Xiikl = ERImol(i,i,l,k)
           Xjjkl = ERImol(j,j,l,k)
           E2Qd = E2Qd + BB2*Xiikl*Xjjkl/Eklii
          endif
          if(l/=k)then
           Ekkij = 2.0d0*EIG(k) - EIG(i) - EIG(j)
           Xijkk = ERImol(i,j,k,k)
           Xijll = ERImol(i,j,l,l)
           E2Qd = E2Qd + BB2*Xijkk*Xijll/Ekkij
          endif
          Eklij = EIG(k) - EIG(i) + EIG(l) - EIG(j)
          Xijkl = ERImol(i,j,l,k)
          Xijlk = ERImol(i,j,k,l)
          XX = Xijkl*Xijkl - Xijkl*Xijlk + Xijlk*Xijlk
          E2Qd = E2Qd - BB2*XX/Eklij
         enddo
        enddo
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                      PNOF5(Nc)-PT2 -> E2ex                           !
!         exclude excitations from the same spatial orbital            !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C E2HFdex
      FUNCTION E2HFdex(NOC,NORB,NBF,EIG,ERImol)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     i,j (i/=j) -> k,l
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFdex = 0.0d0
      DO i=1,noc
       DO j=1,noc
        if(i/=j)then
         DO k=noc+1,norb
          DO l=noc+1,norb
           Xijkl = ERImol(i,j,l,k)
           Xijlk = ERImol(i,j,k,l)
           Eklij = EIG(k) + EIG(l) - EIG(i) - EIG(j)
           E2HFdex = E2HFdex - Xijkl*(2.0*Xijkl-Xijlk)/Eklij
          ENDDO
         ENDDO
        endif
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2FERIex
      FUNCTION E2FERIex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C-----------------------------------------------------------------------
      E2FERIex = 0.0d0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c     i -> l    ( BBn(i,iw)*FOCKm(k,l)*Xiikl/Eklii is excluded )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO i=1,noc
       DO l=noc+1,norb
        Eli = EIG(l) - EIG(i)
        do iw=1,ncwo
         k = noc+ncwo*(noc-i)+iw               ! k = (i,iw)
         Xilkk = ERImol(i,l,k,k)
         E2FERIex = E2FERIex + BBn(i,iw)*FOCKm(i,l)*Xilkk/Eli
        enddo
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c     j -> k and i/=j -> k,k
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,noc
       DO i=1,noc
        if(i/=j)then       
         do iw=1,ncwo
          k = noc+ncwo*(noc-i)+iw              ! k = (i,iw)
          Ekj = EIG(k) - EIG(j)
          Ekkij = 2.0d0*EIG(k) - EIG(i) - EIG(j)
          Xiijk = ERImol(i,i,k,j)
          Xijkk = ERImol(i,j,k,k)
          E2FERIex = E2FERIex - BBn(i,iw)*
     &              ( FOCKm(j,k)*Xiijk/Ekj + FOCKm(i,j)*Xijkk/Ekkij )
         enddo
        endif
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2FERIex = 2.0d0*E2FERIex
C-----------------------------------------------------------------------
      RETURN
      END

C E2ERIERIex
      FUNCTION E2ERIERIex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     j/=m -> k,k         ( BBn(i,iw)*Xiiln*Xlnkk/Enlii is excluded )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2ERIERIex = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                  ! k = (i,iw)
        DO m=1,noc
         DO j=1,noc
          if(j/=m)then         
           Ekkmj = 2.0d0*EIG(k) - EIG(m) - EIG(j)
           Xiimj = ERImol(i,i,j,m)
           Xmjkk = ERImol(m,j,k,k)
           E2ERIERIex = E2ERIERIex + BBn(i,iw)*Xiimj*Xmjkk/Ekkmj
          endif
         ENDDO
        ENDDO
       enddo
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
      
C E2dHFex
      FUNCTION E2dHFex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c     i/=j -> k,l
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2dHFex = 0.0d0
      DO i=1,noc
       do iw=1,ncwo
        k = noc+ncwo*(noc-i)+iw                     ! k = (i,iw)
        DO j=1,noc
         if(j/=i)then
          DO l=noc+1,norb
           Elkij = EIG(l) + EIG(k) - EIG(i) - EIG(j)
           Xijlk = ERImol(i,j,k,l)
           Xiljk = ERImol(i,l,k,j)
           Xijkl = ERImol(i,j,l,k)
           Xilkj = ERImol(i,l,j,k)
           XXijlk = Xijlk - Xijkl
           XXiljk = Xiljk - Xilkj
           E2dHFex = E2dHFex - (BBn(i,iw)/Elkij) *
     &                     ( XXijlk*Xilkj + Xijlk*Xiljk + Xijkl*XXiljk )
          ENDDO
         endif
        ENDDO
       enddo
      ENDDO
      E2dHFex = 2.0d0*E2dHFex
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                     PNOF5(Nc)-PT2-NEX - > E2exi                      !
!      exclude excitations associated only to the omitted subspaces    !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C E2HFs_nex
      FUNCTION E2HFs_nex(NOC,NCWO,NORB,EIG,FOCKm,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
C-----------------------------------------------------------------------
c     excluding ix -> lx < norb
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFs_nex = 0.0d0
      DO i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        do jxw=1,ncwo  
         lx = noc+ncwo*(noc-jx)+jxw            ! lx = (jx,jxw)
         E2HFs_nex = E2HFs_nex 
     &             + FOCKm(ix,lx)*FOCKm(lx,ix)/(EIG(lx)-EIG(ix))
        enddo
       enddo
      ENDDO
      E2HFs_nex = 2.0d0*E2HFs_nex
C-----------------------------------------------------------------------
      RETURN
      END

C E2HFdex_nex
      FUNCTION E2HFdex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c     excluding mx,nx (mx/=nx) -> kx,lx
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2HFdex_nex = 0.0d0
      do m=1,nex
       mx = iex(m)
       do n=1,nex
        nx = iex(n)
        if(mx/=nx)then
         do i=1,nex
          ix = iex(i)
          do ixw=1,ncwo  
           kx = noc+ncwo*(noc-ix)+ixw            ! kx = (ix,ixw)
           do j=1,nex
            jx = iex(j)
            do jxw=1,ncwo  
             lx = noc+ncwo*(noc-jx)+jxw           ! lx = (jx,jxw)
             Xmnkl = ERImol(mx,nx,lx,kx)
             Xmnlk = ERImol(mx,nx,kx,lx)
             Eklmn = EIG(kx) + EIG(lx) - EIG(mx) - EIG(nx)
             E2HFdex_nex = E2HFdex_nex + Xmnkl*(2.0*Xmnkl-Xmnlk)/Eklmn
            enddo
           enddo
          enddo
         enddo
        endif
       enddo
      enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2F_nex
      FUNCTION E2F_nex(NOC,NCWO,NORB,EIG,FOCKm,BBn,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
C-----------------------------------------------------------------------
c     excluding ix -> kx                     
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2F_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do ixw=1,ncwo
        kx = noc+ncwo*(noc-ix)+ixw               ! kx = (ix,ixw)
        Eki = EIG(kx) - EIG(ix)
        E2F_nex = E2F_nex - BBn(ix,ixw)*FOCKm(ix,kx)*FOCKm(kx,ix)/Eki 
       enddo
      enddo
      E2F_nex = 2.0d0*E2F_nex
C-----------------------------------------------------------------------
      RETURN
      END

C E2FERIex_nex
      FUNCTION E2FERIex_nex(NOC,NCWO,NORB,NBF,EIG,FOCKm,ERImol,BBn,
     &                      IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NORB,NORB)::FOCKm
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C-----------------------------------------------------------------------
      E2FERIex_nex = 0.0d0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c     excluding ix -> lx
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      do i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        do jxw=1,ncwo
         lx = noc+ncwo*(noc-jx)+jxw            ! lx = (jx,jxw)
         Eli = EIG(lx) - EIG(ix)
         do ixw=1,ncwo
          kx = noc+ncwo*(noc-ix)+ixw           ! kx = (ix,ixw)
          Xilkk = ERImol(ix,lx,kx,kx)
          E2FERIex_nex = E2FERIex_nex
     &                 - BBn(ix,ixw)*FOCKm(ix,lx)*Xilkk/Eli
         enddo
        enddo
       enddo
      enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
c     excluding ix,jx (ix/=jx) -> kx,kx
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DO j=1,nex
       jx = iex(j)
       DO i=1,nex
        ix = iex(i)
        if(ix/=jx)then       
         do ixw=1,ncwo
          kx = noc+ncwo*(noc-ix)+ixw              ! kx = (ix,ixw)
          Ekj = EIG(kx) - EIG(jx)          
          Ekkij = 2.0d0*EIG(kx) - EIG(ix) - EIG(jx) 
          Xiijk = ERImol(ix,ix,kx,jx)          
          Xijkk = ERImol(ix,jx,kx,kx)
          E2FERIex_nex = E2FERIex_nex + BBn(ix,ixw)*
     &            ( FOCKm(jx,kx)*Xiijk/Ekj + FOCKm(ix,jx)*Xijkk/Ekkij )
         enddo     
        endif
       ENDDO
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2FERIex_nex = 2.0d0*E2FERIex_nex
C-----------------------------------------------------------------------
      RETURN
      END

C E2ERIERIex_nex
      FUNCTION E2ERIERIex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,
     &                        IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C-----------------------------------------------------------------------
c     excluding ix,jx -> lx,lx                        
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2ERIERIex_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        if(jx/=ix)then
         do m=1,nex
          mx=iex(m)
          do mxw=1,ncwo  
           lx = noc+ncwo*(noc-mx)+mxw            ! lx = (mx,mxw)
           Xmmij = ERImol(mx,mx,jx,ix)
           Xijll = ERImol(ix,jx,lx,lx)
           Ellij = 2.0d0*EIG(lx) - EIG(ix) - EIG(jx)
           E2ERIERIex_nex = E2ERIERIex_nex
     &                    - BBn(mx,mxw)*Xmmij*Xijll/Ellij
          enddo
         ENDDO
        endif
       enddo
      enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C E2dHFex_nex
      FUNCTION E2dHFex_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C-----------------------------------------------------------------------
c     excluding ix,jx -> kx,lx
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2dHFex_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do ixw=1,ncwo
        kx = noc+ncwo*(noc-ix)+ixw            ! kx = (ix,ixw)
        do j=1,nex
         jx = iex(j)
         if(jx/=ix)then
          do m=1,nex
           mx = iex(m)
           do mxw=1,ncwo  
            lx = noc+ncwo*(noc-mx)+mxw        ! lx = (mx,mxw)
            Elkij = EIG(lx) + EIG(kx) - EIG(ix) - EIG(jx)
            Xijlk = ERImol(ix,jx,kx,lx)
            Xiljk = ERImol(ix,lx,kx,jx)
            Xijkl = ERImol(ix,jx,lx,kx)
            Xilkj = ERImol(ix,lx,jx,kx)
            XXijlk = Xijlk - Xijkl
            XXiljk = Xiljk - Xilkj
            E2dHFex_nex = E2dHFex_nex + (BBn(ix,ixw)/Elkij) *
     &                    (XXijlk*Xilkj+Xijlk*Xiljk+Xijkl*XXiljk)
           enddo
          enddo
         endif
        enddo
       enddo
      enddo
      E2dHFex_nex = 2.0d0*E2dHFex_nex
C-----------------------------------------------------------------------
      RETURN
      END

C E2Qd_nex
      FUNCTION E2Qd_nex(NOC,NCWO,NORB,NBF,EIG,ERImol,BBn,IEX,NEX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NEX)::IEX
      DOUBLE PRECISION,DIMENSION(NORB)::EIG
      DOUBLE PRECISION,DIMENSION(NOC,NCWO)::BBn
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF,NBF)::ERImol
C-----------------------------------------------------------------------
c     excluding ix,jx -> kx,lx
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E2Qd_nex = 0.0d0
      do i=1,nex
       ix = iex(i)
       do j=1,nex
        jx = iex(j)
        if(jx/=ix)then
         do ixw=1,ncwo
          kx = noc+ncwo*(noc-ix)+ixw         ! kx = (ix,ixw)
          do jxw=1,ncwo
           lx = noc+ncwo*(noc-jx)+jxw        ! lx = (jx,jxw)
           BB2 = BBn(ix,ixw)*BBn(jx,jxw)
           Xijkl = ERImol(ix,jx,lx,kx)
           Xijlk = ERImol(ix,jx,kx,lx)
           XX = (2.0d0*Xijkl-Xijlk)*(2.0d0*Xijkl-Xijlk)
           Eklij = EIG(kx) + EIG(lx) - EIG(ix) - EIG(jx)
           E2Qd_nex = E2Qd_nex + BB2 * XX / Eklij
          enddo
         enddo
        endif
       enddo
      enddo
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                 N O F - M P 2   S U B R O U T I N E S                !
!                                                                      !
!            ( PRL 119, 063002, 2017; PRA 98, 022504, 2018 )           !
!                                                                      !
!======================================================================!

C ORBINVMP2 (oiMP2)
      SUBROUTINE ORBINVMP2(ELAG,COEF,RO,CJ12,CK12,AHCORE,IERI,ERI,
     &                     ADIPx,ADIPy,ADIPz)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NIJKL) :: IERI
      DOUBLE PRECISION,DIMENSION(NIJKL) :: ERI
      DOUBLE PRECISION,DIMENSION(NBF5) :: RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5) :: CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: AHCORE,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: ELAG,COEF
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: OCC,EIG,FI1,FI2,Tijab
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: VEC,FOCKm
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:) :: ERImol
C-----------------------------------------------------------------------
C     NO1:  Number of inactive doubly occupied orbitals (OCC=1)         
C     NDOC: Number of strongly doubly occupied MOs                      
C     NSOC: Number of strongly singly occupied MOs                      
C     NDNS: Number of strongly occupied MOs (NDNS=NDOC+NSOC)                        
C     NCWO: Number of coupled weakly occ. MOs per strongly doubly occ.
C     NCWO*NDOC: Active orbitals in the virtual subspace                
C     NO0:  Empty orbitals  (OCC=0)                                      
C     NVIR: Number of weakly occupied MOs + empty MOs                   
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C           NO1 | NDOC  + NSOC  |   NCWO*NDOC + NO0  = NBF               
C           NO1 |      NDNS     |          NVIR      = NBF 
C               | -NAC- |       |  -   NAC  - |
C                      NB      NA            NBF5
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                               !  CLOSED (NB=NA=NCO,NSOC=0)
C     NDOC = NB - NO1           !  NDOC = NCO - NO1, NO1 <= NCO
C     NDNS = NDOC + NSOC        !  NDNS = NDOC      
C     NA   = NO1 + NDNS         !  NA = NB = NCO
C     NVIR = NBF - NA           !  NBF - NCO
C-----------------------------------------------------------------------
C     Calculation of the Matrix of Lagrange Multipliers if ICOEF=0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICOEF==0)CALL ELAGCOEF0(ELAG,COEF,RO,CJ12,CK12,AHCORE,
     &                           ADIPx,ADIPy,ADIPz,IERI,ERI)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Substracting core orbitals (NO1PT2)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NOCB = NB - NO1PT2
      NOC = NA - NO1PT2
      NVI = NQMT - NA 
      NORB = NQMT - NO1PT2
      WRITE(6,1)NO1PT2,NOC,NVI,NORB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NOCNC = NOC + NCWO*NOCB <= NORB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NOCNC = NOC + NCWO*NOCB
      NOCNCT = NOCNC*(NOCNC+1)/2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     If NOCNC > NORB: Check the value of NCWO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(NOCNC>NORB)THEN
       NCWO1 = (NORB-NSOC)/NOCB - 1 
       IF(NCWO>NCWO1)THEN
        WRITE(6,4)
     &  'NCWO is too large, reduce the value at least to',NCWO1        
        STOP
       ENDIF
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     If NO1PT2<NO1: Check the value of NCWO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NCWO1 = (NQMT-NO1-NSOC)/NOC - 1 
      IF(NO1PT2<NO1.and.NCWO>NCWO1)THEN
       WRITE(6,4)
     & 'NCWO is too large, reduce the value at least to',NCWO1        
       STOP
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     OCC,VEC: Occupations and Molecular Orbitals without Core
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(OCC(NOCNC),VEC(NBF,NORB))
      DO i=1,NOC
       OCC(i) = RO(i+NO1PT2)
      ENDDO
      DO i=NOC+1,NOCNC
       if(NOCNC+NO1PT2<=NBF5)then      
        OCC(i) = RO(i+NO1PT2)
       else
        OCC(i) = 0.0d0       
       end if
      ENDDO
      DO J=1,NORB
       do i=1,NBF
        VEC(i,J) = COEF(i,J+NO1PT2)
       enddo
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     EIG: Energy Eigenvalues without Core
C     FOCKm: Fock Matrix in the Molecular Basis
C     EHFL = E(0) + E(1) : HF Energy with Non-HF Orbitals (COEF/=CHF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(EIG(NORB),FOCKm(NORB,NORB))
      CALL FOCKMOL(NORB,COEF,VEC,ELAG,EIG,FOCKm,AHCORE,IERI,ERI,EHFL)      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Integral transformation ( Form <ab|rs> )
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(ERImol(NOC,NBFT,NBF))
C     FORM (pq/rj)
      CALL ERIC1(ERImol,IERI,ERI,VEC,NOC,NORB)
C     FORM (ai/rj) for all a,i
      CALL ERIC23(ERImol,VEC,NVI,NOC,NORB)
C     FORM (ai/bj) for all b
      CALL ERIC4(ERImol,VEC(1,NOC+1),NOC,NVI,NORB)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C           Calculate second-order Dynamic Correlation E(2)
C         Calculate excitation amplitudes to determine Psi(1)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NN1 = NOC*NOC*NVI*NVI
      NN2 = NOC*NVI
      ALLOCATE (Tijab(NN1),FI1(NORB),FI2(NORB))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                              FI1 and FI2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     like in PRL (NOF-MP2) (best result with PNOF7s)
C     Note: Ci=DSQRT[4*(1-OCCi)*OCCi],FI2i=1-Ci*Ci -> (1-2*OCCi)**2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      FI1 = 1.0d0
      DO i=1,NOCNC             ! best for H2
       Ci = 1.0d0 - DABS(1.0d0-2.0d0*OCC(i))
       FI1(i) = 1.0d0 - Ci*Ci
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - -      
      FI2 = 1.0d0    
      DO i=NOC+1,NOCNC
       Ci = DABS(1.0d0-2.0d0*OCC(i))
       FI2(i) = Ci*Ci
      ENDDO
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
C     Calculate Tijab amplitude solving Sparse Sym. Linear System
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      CALL CALTijabIsym(NOCB,NOC,NVI,NORB,NN1,EIG,FOCKm,ERImol,Tijab,
     &                  FI1,FI2)
      if(NOUTTijab==1)CALL OUTPUTTijab_rc(NOC,NVI,NN1,Tijab)
      CALL ORBINVE2Totalsym(NOCB,NOC,NVI,NN1,NBF,NBFT,ERImol,
     &                      Tijab,ECd)
      WRITE(6,2)EHFL+EN+ECndHF
      WRITE(6,3)ECd,ECndl,ECd+ECndl,EHFL+ECd+ECndl+EN+ECndHF
C-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      DEALLOCATE(OCC,VEC,FI1,FI2,EIG,FOCKm,ERImol,Tijab)
      RETURN
C-----------------------------------------------------------------------
    1 FORMAT(//,2X,'NOF-MP2',/1X,9('='),//,
     *         1X,'NUMBER OF CORE ORBITALS  (NO1PT2) =',I5,/,
     *         1X,'NUMBER OF Doubly OCC. ORBS. (NOC) =',I5,/,
     *         1X,'NUMBER OF VIRTUAL ORBS.     (NVI) =',I5,/,
     *         1X,'NUMBER OF LIN. IND. ORBS.  (NORB) =',I5)
    2 FORMAT(/3X,'          Ehfc =',F20.10)
    3 FORMAT(/3X,'           ECd =',F20.10,/,
     *        3X,'          ECnd =',F20.10,/,
     *        3X,'         ECorr =',F20.10,/,
     *        3X,'     E(NOFMP2) =',F20.10)
    4 FORMAT(/1X,A47,I5)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END

C CALTijabIsym
      SUBROUTINE CALTijabIsym(NOCB,NOC,NVI,NORB,NN,EIG,FOCKm,
     &                        ERImol,Tijab,FI1,FI2)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NN) :: Tijab
      DOUBLE PRECISION,DIMENSION(NORB) :: EIG,FI1,FI2
      DOUBLE PRECISION,DIMENSION(NORB,NORB) :: FOCKm
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF) :: ERImol
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IROW,ICOL,NPAIR
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: A,B
C-----------------------------------------------------------------------
C     NPAIR: number of the pair to which the virtual orbital belongs
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(npair(nvi))
      do i=1,nocb
       do iw=1,ncwo
        k = ncwo*(nocb-i) + iw
        npair(k) = i
       end do
      end do
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NN:  the order of the original sparse matrix
C     NNZ: the number of non-zero elements in the lower triangular of A
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NNZM = 2*NOC*NOC*NVI*NVI*NORB
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     A: array (NNZ) that contains the non-zero elements of the lower 
C        triangular part of the original matrix, ordered by increasing
C        row index and by increasing column index within each row
C     IROW: the row indices of non-zero elements given in A
C     ICOL: the column indices of non-zero elements given in A
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(A(NNZM),IROW(NNZM),ICOL(NNZM))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Elements A(ijab,i'j'a'b')
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      nnz = 0
      nnz_end = 0
c
      do ib=1,nvi
       do ia=1,nvi
        do j=1,noc
         do i=1,noc
c
          jab =     (j-1)*noc + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi
          iab = i             + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi
          ijb = i + (j-1)*noc                  + (ib-1)*noc*noc*nvi
          ija = i + (j-1)*noc + (ia-1)*noc*noc
          ijab= i + (j-1)*noc + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi
c
          nnz = nnz + 1
          nnz_ini = nnz_end + 1
          A(nnz) = FOCKm(ia+noc,ia+noc) + FOCKm(ib+noc,ib+noc)
     &           - FOCKm(i,i) - FOCKm(j,j)    ! diagonal elem.
c
          IROW(nnz) = ijab
          ICOL(nnz) = i + jab
c
          do k=1,i-1
           IF(DABS(FOCKm(i,k))>1.0d-10)THEN
            nnz = nnz + 1
            Cki = FI2(k)*FI2(i)
            A(nnz) = - Cki*FOCKm(i,k)
            IROW(nnz) = ijab
            ICOL(nnz) = k + jab
           ENDIF
          end do
c
          do k=1,j-1
           IF(DABS(FOCKm(j,k))>1.0d-10)THEN
            nnz = nnz + 1
            Ckj = FI2(k)*FI2(j)
            A(nnz) = - Ckj*FOCKm(j,k)
            IROW(nnz) = ijab
            ICOL(nnz) = (k-1)*noc + iab
           ENDIF
          end do
c
          do k=1,ia-1
           IF(DABS(FOCKm(ia+noc,k+noc))>1.0d-10)THEN
            nnz = nnz + 1
            if(npair(k)==npair(ia))then
             Ckia = FI1(k+noc)*FI1(ia+noc)
            else
             Ckia = FI2(k+noc)*FI2(ia+noc)
            endif
            A(nnz) = Ckia*FOCKm(ia+noc,k+noc)
            IROW(nnz) = ijab
            ICOL(nnz) = (k-1)*noc*noc + ijb
           ENDIF
          end do
c
          do k=1,ib-1
           IF(DABS(FOCKm(ib+noc,k+noc))>1.0d-10)THEN
            nnz = nnz + 1
            if(npair(k)==npair(ib))then
             Ckib = FI1(k+noc)*FI1(ib+noc)
            else
             Ckib = FI2(k+noc)*FI2(ib+noc)
            endif
            A(nnz) = Ckib*FOCKm(ib+noc,k+noc)
            IROW(nnz) = ijab
            ICOL(nnz) = (k-1)*noc*noc*nvi + ija
           ENDIF
          end do
c
          nnz_end = nnz
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C         Sort Column Index for a given IROW = ijab
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          do k=nnz_ini,nnz_end-1
           do l=k+1,nnz_end
            if(ICOL(k)>ICOL(l))then
             ITEMPCOL = ICOL(l)
             TEMPVECT = A(l)
              ICOL(l) = ICOL(k)
                 A(l) = A(k)
              ICOL(k) = ITEMPCOL
                 A(k) = TEMPVECT
            endif
           end do
          end do
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         end do
        end do      
       end do
      end do
      DEALLOCATE(NPAIR)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Tijab: Initial approximation for the vector Tijab
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      iai = 0
      do ia=1,nvi
       do i=1,noc
        iai = iai+1
        do ib=1,nvi
         do j=1,noc
          ijab = i + (j-1)*noc + (ia-1)*noc*noc + (ib-1)*noc*noc*nvi
          Eijab = EIG(ib+noc) + EIG(ia+noc) - EIG(j) - EIG(i)
          Tijab(ijab) = - ERImol(j,iai,ib)/Eijab
         end do
        end do      
       end do
      end do
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     B: the right-hand side vector
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(B(NN))
      do i=1,noc
       lmin_i = noc+ncwo*(noc-i)+1
       lmax_i = noc+ncwo*(noc-i)+ncwo
       do j=1,noc
        if(j==i)then
c--------------------------------------------------------------------
c        excitations inside the subspace 'i'
c--------------------------------------------------------------------
         do k=1,nvi
          ik = i + (k-1)*noc
          kn = k + noc
          do l=1,nvi
           ln = l + noc
           if(      (lmin_i<=kn.and.kn<=lmax_i)
     &        .and. (lmin_i<=ln.and.ln<=lmax_i) )then
            Ciikl = FI1(kn)*FI1(ln)*FI1(i)*FI1(i)
           else
            Ciikl = FI2(kn)*FI2(ln)*FI2(i)*FI2(i)
           endif
           iikl =  i + (i-1)*noc + (k-1)*noc*noc + (l-1)*noc*noc*nvi
           B(iikl) = - Ciikl*ERImol(i,ik,l)
          enddo
         enddo
c--------------------------------------------------------------------
        else
c--------------------------------------------------------------------
         do k=1,nvi
          ik = i + (k-1)*noc
          kn = k + noc
          do l=1,nvi
           ln = l + noc
           ijkl =  i + (j-1)*noc + (k-1)*noc*noc + (l-1)*noc*noc*nvi
           Cijkl = FI2(kn)*FI2(ln)*FI2(i)*FI2(j)
           B(ijkl) = - Cijkl*ERImol(j,ik,l)
          enddo
         enddo
c--------------------------------------------------------------------
        endif
       enddo
      enddo
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Solving the Sparse Linear System AT=B using the CG method
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ICGMETHOD==1)THEN
       CALL SparseSymLinearSystem_CG(NN,NNZ,A,IROW,ICOL,B,Tijab)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Prepare for calling the subroutine F11JEF of the NAG Library
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE IF(ICGMETHOD==2)THEN
       CALL SparseSymLinearSystem_NAG(NN,NNZ,A,IROW,ICOL,B,Tijab)
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(A,IROW,ICOL,B)
      RETURN
C-----------------------------------------------------------------------
      END

C SparseSymLinearSystem_NAG
      SUBROUTINE SparseSymLinearSystem_NAG(NN,NNZ,A,IROW,ICOL,B,Tijab)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER PRECON
      CHARACTER*6 METHOD
      INTEGER,DIMENSION(NNZ) :: IROW,ICOL
      DOUBLE PRECISION,DIMENSION(NNZ) :: A
      DOUBLE PRECISION,DIMENSION(NN) :: B,Tijab
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IWORK
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: WORK
C-----------------------------------------------------------------------
C     The iterative method to be used:
C     'CG'      ==> Conjugate gradient method
C     'SYMMLQ'  ==> Lanczos method (SYMMLQ).
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      METHOD = 'CG'
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     The type of preconditioning used:
C     'N'       ==> no preconditioning
C     'J'       ==> Jacobi preconditioning.
C     'S'       ==> symmetric SOR preconditioning.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      PRECON = 'N'
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     OMEGA ( 0.0 < OMEGA < 2.0 )
C     if PRECON = 'S' then OMEGA is the relaxation parameter to be used
C     Otherwise OMEGA need not be initialised.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      OMEGA = 1.0d0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     TOL: the tolerance required ( TOL < 1.0 )
C          The iteration is judged to have converged at step k if:
C
C               || r || <= TOL*(|| b || + || A ||*|| x ||).
C                   k                                 k
C     If TOL = 0.0 the default value of SQRT(machine precision) is used.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TOL = 1.0d-10
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     MAXITN: the maximum number of iterations allowed.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      MAXITN = 3000
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     LWORK: the dimension of the array WORK
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(METHOD=='CG')THEN
       IF(PRECON=='J'.or.PRECON=='S')THEN
        LWORK = 7*NN + 120
       ELSE
        LWORK = 6*NN + 120
       END IF
      ELSEIF(METHOD=='SYMMLQ')THEN
       IF(PRECON=='J'.or.PRECON=='S')THEN
        LWORK = 8*NN + 120
       ELSE
        LWORK = 7*NN + 120
       END IF
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C                                 AX = B
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     NN:  the order of the original sparse matrix
C     NNZ: the number of non-zero elements in the lower triangular of A
C     A: array (NNZ) that contains the non-zero elements of the lower 
C        triangular part of the original matrix, ordered by increasing
C        row index and by increasing column index within each row
C     IROW: the row indices of non-zero elements given in A
C     ICOL: the column indices of non-zero elements given in A
C     B: array (NN), the right-hand side vector
C     RNORM: the final residual norm
C     ITN: the actual number of iterations taken
C     WORK: working REAL array of dimension LWORK
C     IWORK: working INTEGER array of dimension NN+1
C
C     IFAIL (On entry must be -1, 0, or 1)
C      On exit, the following values may occur:
C       IFAIL = 0 => no error detected.
C       IFAIL = 1 => METHOD invalid, or PRECON invalid, or
C                    NN < 1, or NNZ < 1, or NNZ > N*(N+1)/2, or
C                    OMEGA not in (0,2), or TOL >= 1.0, or
C                    MAXITN < 1, or LWORK too small.
C       IFAIL = 2 => the arrays IROW and ICOL fail to satisfy:
C                    1 <= IROW(i) <= N,
C                    1 <= ICOL(i) <= IROW(i), i = 1,2,...,NNZ.
C                    IROW(i-1) < IROW(i), or
C                    IROW(i-1) = IROW(i) and ICOL(i-1) < ICOL(i)
C                    for i = 2,3,...,NNZ.
C       IFAIL = 3 => A has a zero diagonal element.
C       IFAIL = 4 => A reasonable accuracy has been obtained and
C                    further iterations could not improve the result.
C       IFAIL = 5 => Required accuracy not obtained in MAXITN
C       IFAIL = 6 => The preconditioner is not positive definite.
C       IFAIL = 7 => The matrix A is not positive definite (CG only).
C       IFAIL = 8 => A serious error has occurred in an internal call.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(WORK(LWORK),IWORK(NN+1))
      IFAIL = 1
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -      
!     Avoiding warnings
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      A(1) = A(1)
      IROW(1) = IROW(1)
      ICOL(1) = ICOL(1)
      B(1) = B(1)
      Tijab(1) = Tijab(1)
cnag      CALL F11JEF(METHOD,PRECON,NN,NNZ,A,IROW,ICOL,OMEGA,B,TOL,
cnag     &            MAXITN,Tijab,RNORM,ITN,WORK,LWORK,IWORK,IFAIL)
      write(6,'(/,A8,E11.4,A7,I5)')' RNORM =',RNORM,', ITN =',ITN
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DEALLOCATE(WORK,IWORK)
      RETURN
C-----------------------------------------------------------------------
      END

C SparseSymLinearSystem_CG      
      SUBROUTINE SparseSymLinearSystem_CG(NN,NNZ,A,IROW,ICOL,B,Tijab)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NNZ) :: IROW,ICOL
      DOUBLE PRECISION,DIMENSION(NNZ) :: A
      DOUBLE PRECISION,DIMENSION(NN) :: B,Tijab
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IIROW,IICOL
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: AA,AP,R,P
C-----------------------------------------------------------------------
C     Symmetric A -> Square AA
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      NNZ2 = NNZ*2
      ALLOCATE(IIROW(NNZ2),IICOL(NNZ2),AA(NNZ2))
      IIROW(1:NNZ) = IROW(1:NNZ) 
      IICOL(1:NNZ) = ICOL(1:NNZ)
      AA(1:NNZ) = A(1:NNZ)
      NZ = NNZ
      DO i=1,NNZ
       if(IIROW(i)>IICOL(i))then
        NZ = NZ + 1
        IIROW(NZ) = IICOL(i)
        IICOL(NZ) = IIROW(i)       
        AA(NZ)    = AA(i)
       end if 
      END DO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Initial Values for AP, R, P
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE(AP(NN),R(NN),P(NN))
      CALL BeqProdAT(NN,NZ,IIROW,IICOL,AA,Tijab,AP)
      R(1:NN) = B(1:NN) - AP(1:NN)
      P(1:NN) = B(1:NN) - AP(1:NN)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Do Nsteps of CG method
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      Nsteps = NN
      DO i = 1,Nsteps
       CALL BeqProdAT(NN,NZ,IIROW,IICOL,AA,P,AP)
       PR  = DOT_PRODUCT(P,R)                   
       PAP = DOT_PRODUCT(P,AP)                  
       IF(PAP==0.0d0)RETURN
       Tijab(1:NN) = Tijab(1:NN) + (PR/PAP)*P(1:NN)
       R(1:NN) = R(1:NN) - (PR/PAP)*AP(1:NN)       
       RAP = DOT_PRODUCT(R,AP)                
       P(1:NN) = R(1:NN) - (RAP/PAP)*P(1:NN)  
      END DO
C-----------------------------------------------------------------------
      DEALLOCATE(IIROW,IICOL,AA,AP,R,P)
      RETURN
      END

C BeqProdAT      
      SUBROUTINE BeqProdAT(N,NZ,IROW,ICOL,A,T,B )
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NZ) :: ICOL,IROW
      DOUBLE PRECISION,DIMENSION(NZ) :: A
      DOUBLE PRECISION,DIMENSION(N) :: T,B
C-----------------------------------------------------------------------      
      B = 0.0d0
      do k = 1,NZ
       i = IROW(k)
       j = ICOL(k)
       B(i) = B(i) + A(k)*T(j)
      end do
C-----------------------------------------------------------------------
      RETURN
      END

C ORBINVE2Totalsym
      SUBROUTINE ORBINVE2Totalsym(NOCB,NOC,NVI,NN,NBF,NBFT,ERImol,
     &                            Tijab,E2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NN) :: Tijab
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF) :: ERImol
C-----------------------------------------------------------------------
      E2 = 0.0d0
      DO k=1,nvi
       DO l=1,nvi
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       
        DO i=1,nocb
         ki = (k-1)*noc + i
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                  
         DO j=1,nocb
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          E2 = E2 + Xijkl*(2.0d0*Tijab(ijkl)-Tijab(ijlk))
         ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -         
         DO j=nocb+1,noc
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          E2 = E2 + Xijkl*(Tijab(ijkl)-0.5d0*Tijab(ijlk))
         ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                  
        ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        DO i=nocb+1,noc
         ki = (k-1)*noc + i
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                  
         DO j=1,nocb        
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          E2 = E2 + Xijkl*(Tijab(ijkl)-0.5d0*Tijab(ijlk))
         ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -         
         DO j=nocb+1,noc
          Xijkl = ERImol(j,ki,l)
          ijkl = i+(j-1)*noc+(k-1)*noc*noc+(l-1)*noc*noc*nvi
          ijlk = i+(j-1)*noc+(l-1)*noc*noc+(k-1)*noc*noc*nvi
          if(j/=i)E2 = E2 + Xijkl*(Tijab(ijkl)-0.5d0*Tijab(ijlk))/2.0
         ENDDO
        ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!     ERIC1: FORM (PQ/RJ)                                              !
!    ERIC23: FORM (AI/RJ) for all A,I                                  !
!     ERIC4: FORM (AI/BJ) for all B                                    !
!   FOCKMOL: Form the Fock Matrix in the Molecular Basis               !
!   DENMATHFr: Calculate the density matrix (DM) using HF MOs (CHF)    !
!   FORM2JK: Calculate 2J-K in the MO basis to form the Fock matrix    ! 
!    FORMJK: Calculate J-K in the MO basis to form the Fock matrix     !
!   DENMATHF05ro: Calculate the open shell part of density matrix (DM) !
!   ELAGCOEF0: Calculate Matrix of Lagrange Multipliers if ICOEF=0     !
!                                                                      !
!======================================================================!

C ERIC1
      SUBROUTINE ERIC1(XIJKN,IERI,ERI,VEC,NOC,NORB)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF)::XIJKN
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
C-----------------------------------------------------------------------
      XIJKN=0.0d0
      DO M=1,NINTCR
       XINT1 = ERI(M)
       XINT2 = XINT1
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IJ = I*(I-1)/2 + J
       KL = K*(K-1)/2 + L
       IF(I==J)XINT1 = XINT1 + XINT1
       IF(K==L)XINT2 = XINT2 + XINT2
       DO N=1,NOC
        XIJKN(N,IJ,K) = XIJKN(N,IJ,K) + XINT1*VEC(L,N)
        XIJKN(N,IJ,L) = XIJKN(N,IJ,L) + XINT1*VEC(K,N)
        XIJKN(N,KL,I) = XIJKN(N,KL,I) + XINT2*VEC(J,N)
        XIJKN(N,KL,J) = XIJKN(N,KL,J) + XINT2*VEC(I,N)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C ERIC23
      SUBROUTINE ERIC23(ERImol,VEC,NVI,NOC,NORB)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NBF),AUX2(NBF,NBF))
C-----------------------------------------------------------------------
      DO MR=1,NBF
       DO MJ=1,NOC
C       ERImol -> AUX1
        MPQ = 0
        DO MP=1,NBF
         DO MQ=1,MP
          MPQ = MPQ + 1
          AUX1(MP,MQ) = ERImol(MJ,MPQ,MR)
          AUX1(MQ,MP) = AUX1(MP,MQ)
         ENDDO
        ENDDO
C       AUX2=AUX1*C
        DO IQ=1,NBF
         DO JQ=1,NOC
          AUX2(IQ,JQ)=0.0d0
          do i=1,NBF
           AUX2(IQ,JQ)=AUX2(IQ,JQ)+AUX1(IQ,i)*VEC(i,JQ)
          enddo
         ENDDO
        ENDDO
C       AUX1=VECt*AUX2
        CALL CeqAtB(AUX1,VEC(1,NOC+1),NBF,NVI,AUX2,NOC)
C       AUX1 -> ERImol
        MAI=0
        DO MA=1,NVI
         DO MI=1,NOC
          MAI=MAI+1
          ERImol(MJ,MAI,MR) = AUX1(MA,MI)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

C ERIC4
      SUBROUTINE ERIC4(ERImol,VEC,NOC,NVI,NORB)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NOC,NBFT,NBF)::ERImol
      DOUBLE PRECISION,DIMENSION(NBF,NORB)::VEC
      ALLOCATABLE::AUX1(:,:),AUX2(:,:)
      ALLOCATE(AUX1(NBF,NBF),AUX2(NBF,NBF))
C-----------------------------------------------------------------------
      MAI = 0
      DO MA=1,NVI
       DO MI=1,NOC
C       ERImol -> AUX1
        MAI = MAI+1
        DO MJ=1,NOC
         DO MR=1,NBF
          AUX1(MR,MJ) = ERImol(MJ,MAI,MR)
         ENDDO
        ENDDO
C       AUX2=VEC*AUX1
        CALL CeqAtB(AUX2,VEC,NBF,NVI,AUX1,NOC)
C       AUX2 -> ERImol  
        DO MB=1,NVI
         DO MJ=1,NOC
          ERImol(MJ,MAI,MB) = AUX2(MB,MJ)
         ENDDO
        ENDDO
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      DEALLOCATE(AUX1,AUX2)
      RETURN
      END

C FOCKMOL
      SUBROUTINE FOCKMOL(NORB,COEF,VEC,ELAG,EIG,FOCKm,AHCORE,IERI,ERI,
     &                   EHFL)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NIJKL) :: IERI
      DOUBLE PRECISION,DIMENSION(NIJKL) :: ERI
      DOUBLE PRECISION,DIMENSION(NORB) :: EIG
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: COEF,ELAG,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NORB) :: VEC
      DOUBLE PRECISION,DIMENSION(NORB,NORB) :: FOCKm
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: DMhf,FOCK,DMa
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: FOCKa,AUX,TVEC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     DMhf: HF Density Matrix
C     FOCK: Fock Matrix in the atomic basis set ( FOCK = H + 2J-K )
C     EHFL = E(0) + E(1) : HF Energy with Non-HF Orbitals (COEF/=CHF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (DMhf(NBF,NBF),FOCK(NBF,NBF))
      if(MSpin==0)then               ! Singlet and Multiplet States 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL DENMATHFr(DMhf,COEF)     ! 2*COEF(M,J)*COEF(N,J)
C- - - - - - - - - - - - - - - - - - - -      
       if(NSOC>0)then
        ALLOCATE (DMa(NBF,NBF))
        CALL DENMATHF05ro(DMa,COEF)                 ! NB+1,NA       
        DMhf = DMhf + DMa
       endif         
C- - - - - - - - - - - - - - - - - - - -
       CALL FORM2JK(FOCK,DMhf,IERI,ERI)
       FOCK = AHCORE + FOCK       
       EHFL = TRACE(DMhf,AHCORE,NBF) + TRACE(DMhf,FOCK,NBF) 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -             
      else if(MSpin>0)then                    ! High-Spin State
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -            
       ALLOCATE (DMa(NBF,NBF))
       CALL DENMATHFr(DMhf,COEF)              ! 1,NB
       CALL DENMATHF05ro(DMa,COEF)            ! NB+1,NA       
C- - - - - - - - - - - - - - - - - - - - -       
       CALL FORM2JK(FOCK,DMhf,IERI,ERI)    
       EHFL=2.0*TRACE(DMhf+DMa,AHCORE,NBF)+TRACE(DMhf+2.0*DMa,FOCK,NBF)
       FOCK = AHCORE + FOCK       
       IF(NSOC>1)THEN
        ALLOCATE (FOCKa(NBF,NBF))       
        CALL FORMJK(FOCKa,DMa,IERI,ERI)
        EHFL = EHFL + 2.0*TRACE(DMa,FOCKa,NBF)
        FOCK = FOCK + FOCKa
        DEALLOCATE(FOCKa)                     
       ENDIF
       DEALLOCATE(DMa)             
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -             
      end if
      DEALLOCATE(DMhf)      
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     FOCKm: Fock Matrix in the molecular basis set
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (AUX(NBF,NORB),TVEC(NORB,NBF))
      AUX   = MATMUL(FOCK,VEC)
      TVEC  = TRANSPOSE(VEC)     
      FOCKm = MATMUL(TVEC,AUX)
      DEALLOCATE(FOCK,AUX,TVEC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     EIG: Energy Eigenvalues without Core
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IEIGeqELAG = 0
      IF(IEIGeqELAG==1)THEN
C- - - - - - - - - - - - - - - - - - - - 
       DO i=1,NORB
        EIG(i) = ELAG(i+NO1PT2,i+NO1PT2)
       ENDDO
C- - - - - - - - - - - - - - - - - - - - 
      ELSE
C- - - - - - - - - - - - - - - - - - - - 
C      EIG(i) -> FOCKm(i,i)
C- - - - - - - - - - - - - - - - - - - - 
       DO i=1,NORB
        EIG(i) = FOCKm(i,i)
       ENDDO
C- - - - - - - - - - - - - - - - - - - - 
      END IF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Print one-particle energies (EIG) if IPRINTEIG = 1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IPRINTEIG = 0
      IF(IPRINTEIG==1)THEN
       write(6,'(/,A22,/)')'One-particle energies:'
       do i=1,NORB
        write(6,'(4x,I5,F20.10)')NO1PT2+i,EIG(i)
       enddo
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END

C DENMATHFr
      SUBROUTINE DENMATHFr(DM,CHF)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::DM,CHF
C----------------------------------------------------------------------
      DO M=1,NBF
       DO N=M,NBF
        DM(M,N)=0.0d0
        DO J=1,NB                                   ! NB
         DM(M,N)=DM(M,N)+ CHF(M,J)*CHF(N,J)
        ENDDO
        DM(N,M)=DM(M,N)
       ENDDO
      ENDDO
      DM=2.0d0*DM
C----------------------------------------------------------------------
      RETURN
      END
      
C FORM2JK
      SUBROUTINE FORM2JK(FM,PM,IERI,ERI)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Wake up the nodes for the task
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=3
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
C-----------------------------------------------------------------------
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
C-----------------------------------------------------------------------
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
C-----------------------------------------------------------------------
C      2*J
C-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

                      F(NIJ)=F(NIJ)+P(NKL)*XJ
       IF(NIJ/=NKL)   F(NKL)=F(NKL)+P(NIJ)*XJ
C-----------------------------------------------------------------------
C      -K
C-----------------------------------------------------------------------
       XJ = 0.25*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Get the pieces from slaves
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,
     &                MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE(P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE(P,F)
#endif
C----------------------------------------------------------------------
      RETURN
      END
     
C FORMJK
      SUBROUTINE FORMJK(FM,PM,IERI,ERI)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER,DIMENSION(NSTORE)::IERI
      DOUBLE PRECISION,DIMENSION(NSTORE)::ERI
      DOUBLE PRECISION,DIMENSION(NBF,NBF):: FM,PM
      ALLOCATABLE::P(:),F(:)
#ifdef MPI
      ALLOCATABLE::FF(:)
#endif
      ALLOCATE (P(NBFT),F(NBFT))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Wake up the nodes for the task
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      ALLOCATE (FF(NBFT))
      DO I=1,NPROCS-1
       NOPT=4
       CALL MPI_SEND(NOPT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
       CALL MPI_SEND(NBFT,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
#endif
C----------------------------------------------------------------------
      CALL SQUARETRIAN(PM,P,NBF,NBFT)
C----------------------------------------------------------------------
      F = 0.0d0
#ifdef MPI
      FF = 0.0d0
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,NBFT,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
#endif
      DO M=1,NINTCR
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
C-----------------------------------------------------------------------
C      J
C-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

                      F(NIJ)=F(NIJ)+0.5*P(NKL)*XJ
       IF(NIJ/=NKL)   F(NKL)=F(NKL)+0.5*P(NIJ)*XJ
C-----------------------------------------------------------------------
C      -K
C-----------------------------------------------------------------------
       XJ = 0.25*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Get the pieces from slaves
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#ifdef MPI
      CALL MPI_REDUCE(F,FF,NBFT,MPI_REAL8,MPI_SUM,MASTER,
     &                MPI_COMM_WORLD,IERR)
      CALL TRIANSQUARE(FM,FF,NBF,NBFT)
      DEALLOCATE(P,F,FF)
#else
      CALL TRIANSQUARE(FM,F,NBF,NBFT)
      DEALLOCATE(P,F)
#endif
C----------------------------------------------------------------------
      RETURN
      END

C DENMATHF05ro
      SUBROUTINE DENMATHF05ro(DMa,CHF)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::DMa,CHF
C----------------------------------------------------------------------
      DO M=1,NBF
       DO N=M,NBF
       DMa(M,N)=0.0d0
       DO J=NB+1,NA
        DMa(M,N)=DMa(M,N)+ CHF(M,J)*CHF(N,J)
       ENDDO
       DMa(N,M)=DMa(M,N)
       ENDDO
      ENDDO
C----------------------------------------------------------------------
      RETURN
      END
                  
C ELAGCOEF0
      SUBROUTINE ELAGCOEF0(ELAG,COEF,RO,CJ12,CK12,AHCORE,
     &                     ADIPx,ADIPy,ADIPz,IERI,ERI)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NIJKL) :: IERI
      DOUBLE PRECISION,DIMENSION(NIJKL) :: ERI
      DOUBLE PRECISION,DIMENSION(NBF5) :: RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: ELAG,COEF,AHCORE
      DOUBLE PRECISION,DIMENSION(NBF,NBF) :: ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5):: CJ12,CK12
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:) :: WJj,WKj,WF,G,AUX1
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:):: AUX2
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calculate AUX1: QD(j,miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,NBF5) 
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (WJj(NSQ,NBF5),WKj(NSQ,NBF5),AUX1(NBF,NBF),AUX2(NSQ))
      DO j=1,NBF5
       CALL DENMATj(j,AUX1,COEF,NBF)
       CALL HSTARJ(AUX2,AUX1,IERI,ERI)
       WJj(1:NSQ,j) = AUX2(1:NSQ)
       CALL HSTARK(AUX2,AUX1,IERI,ERI)
       WKj(1:NSQ,j) = AUX2(1:NSQ)
      ENDDO
      DEALLOCATE (AUX1,AUX2)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Form F Matrix and keep it in WF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (WF(NSQ,NBF5))
      if(MSpin==0)then               ! Singlet and Multiplet States
       CALL FFJMN1rc(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)
      else if(MSpin>0)then           ! High-Spin States
       CALL FFJMN1ro(RO,CJ12,CK12,AHCORE,WJj,WKj,WF,ADIPx,ADIPy,ADIPz)      
      end if      
      DEALLOCATE (WJj,WKj)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calculate G Matrix
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (G(NBF,NBF5))
      DO IQ=1,NBF5
       do i=1,nbf
        G(i,IQ) = FC(i,IQ,WF(1,IQ),COEF)
       enddo
      ENDDO
      DEALLOCATE (WF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Lagrangian Multipliers (ELAG)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL ELG(ELAG,COEF,G)
      DEALLOCATE (G)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END      

!======================================================================!
!                                                                      !
!                  U T I L       S U B R O U T I N E S                 !
!                                                                      !
!   XtoX0: It keeps the linear arrangement X(N) in X0(N)               !
!   TRACE: Calculate the trace of a symmetric matrix A(N,N)            !
!   TRACEm: Calculate the trace (E) of a symmetric matrix A(N,N)       !
!   SQUARETRIAN: Put square matrix FM(N,N) in triangular form F(NT)    !
!   TRIANSQUARE: Put triangular F(NT) in square matrix form FM(N,N)    !
!   CeqAtB: C = At*B where C(NA,NB), A(NA,MA) and B((NA,NB))           !
!   COEFW: COEFN = COEF*W  where COEFN(N,L), COEF(N,N) and W(N,L)      !
!   COEFW1: COEFN = COEF*W where COEFN(L,N), COEF(L,N) and W(N,N)      !
!   FC: FC(i,IQ) = Sum_j[F(i,j)*C(j,IQ)], Sym. F(nbf,nbf), C(nbf,nbf)  !
!   DMATMAX: Determine the maximum off-diagonal element of symmetric A !
!   HEAV and DHEAV: Heaviside function and its derivative              !
!                                                                      !
!======================================================================!

C XtoX0
      SUBROUTINE XtoX0(X,X0,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N)::X,X0
C-----------------------------------------------------------------------
      DO I=1,N
       X0(I) = X(I)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C IXtoIX0
      SUBROUTINE IXtoIX0(IX,IX0,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(N)::IX,IX0
C-----------------------------------------------------------------------
      DO I=1,N
       IX0(I) = IX(I)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END
      
C TRACE
      FUNCTION TRACE(D,A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::D,A
C-----------------------------------------------------------------------
C     Calculate the trace of a symmetric matrix A(N,N)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      TRACE = 0.0
      DO K=1,N
       DO L=1,K
        TRACE = TRACE + A(K,L)*D(K,L)
       ENDDO
       TRACE = TRACE - A(K,K)*D(K,K)*0.5
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C TRACEm
      SUBROUTINE TRACEm(E,D,AA,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DIMENSION D(N,N),AA(N,N)
C-----------------------------------------------------------------------
C     Calculate the trace (E) of a symmetric matrix A(N,N)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      E = 0.0d0
      DO K=1,N
       DO L=1,K
        E = E + AA(K,L)*D(K,L)
       ENDDO
       E = E - AA(K,K)*D(K,K)*0.5d0
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C SQUARETRIAN
      SUBROUTINE SQUARETRIAN(FM,F,N,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::FM
      DOUBLE PRECISION,DIMENSION(NT)::F
C-----------------------------------------------------------------------
C     PUT SQUARE FM IN TRIANGULAR FORM F
C-----------------------------------------------------------------------
      NZ=0
      DO I=1,N
       DO J=1,I
        NZ=NZ+1
        F(NZ)=FM(I,J)+FM(I,J)
       ENDDO
       F(NZ)=F(NZ)-FM(I,I)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C TRIANSQUARE
      SUBROUTINE TRIANSQUARE(FM,F,N,NT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::FM
      DOUBLE PRECISION,DIMENSION(NT)::F
C-----------------------------------------------------------------------
C     PUT TRIANGULAR F IN SQUARE FORM FM
C-----------------------------------------------------------------------
      NZ=0
      DO I=1,N
       DO J=1,I
        NZ=NZ+1
        FM(I,J)=F(NZ)
        FM(J,I)=F(NZ)
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C CeqAtB
      SUBROUTINE CeqAtB(C,A,NA,MA,B,NB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NA,MA)::A
      DOUBLE PRECISION,DIMENSION(NA,NB)::B
      DOUBLE PRECISION,DIMENSION(NA,NB)::C
C-----------------------------------------------------------------------
C     C = At * B
C-----------------------------------------------------------------------
      DO i=1,MA
       DO j=1,NB
        C(i,j) = 0.0d0
        do k=1,NA
         C(i,j) = C(i,j) + A(k,i)*B(k,j)
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C COEFW
      SUBROUTINE COEFW(N,L,COEFN,COEF,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,L)::COEFN,W
      DOUBLE PRECISION,DIMENSION(N,N)::COEF
C-----------------------------------------------------------------------
C     COEFN = COEF*W
C-----------------------------------------------------------------------
      DO i=1,N
       DO j=1,L
        COEFN(i,j)=0.0d0
        do k=1,N
         COEFN(i,j)=COEFN(i,j)+COEF(i,k)*W(k,j)
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C COEFW1
      SUBROUTINE COEFW1(L,N,COEFN,COEF,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(L,N)::COEFN,COEF
      DOUBLE PRECISION,DIMENSION(N,N)::W
C-----------------------------------------------------------------------
C     COEFN = COEF*W
C-----------------------------------------------------------------------
      DO i=1,L
       DO j=1,N
        COEFN(i,j)=0.0d0
        do k=1,N
         COEFN(i,j) = COEFN(i,j) + COEF(i,k)*W(k,j)
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C FC
      FUNCTION FC(i,IQ,F,C)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::F,C
C-----------------------------------------------------------------------
C     FC(i,IQ) = Sum_j[F(i,j)*C(j,IQ)], F:Sym, C(nbf,nbf)
C-----------------------------------------------------------------------
      FC = 0.0d0
      do j=1,NBF
       FC = FC + F(i,j) * C(j,IQ)
      enddo
C-----------------------------------------------------------------------
      RETURN
      END

C DMATMAX
      SUBROUTINE DMATMAX(A,N,MAXI,MAXJ,DUM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(N,N)::A
C-----------------------------------------------------------------------
C     Determine the maximum off-diagonal element of symmetric matrix A 
C-----------------------------------------------------------------------
      DUM=0.0d0
      DO IQ=1,N
       DO JQ=1,IQ-1
        DMij=ABS(A(IQ,JQ))
        IF(DMij>DUM)THEN
         DUM=DMij
         MAXI=IQ
         MAXJ=JQ
        ENDIF
       ENDDO
      ENDDO
C      WRITE(6,1)MAXI,MAXJ,DUM
C-----------------------------------------------------------------------
C    1 FORMAT(4X,'(',I3,',',I3,')',4X,F15.6)
      RETURN
      END

C Heaviside
      FUNCTION HEAV(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      IF(X>=0.0d0)THEN
       HEAV = 1.0d0
      ELSE
       HEAV = 0.0d0
      ENDIF
      RETURN
      END

C Derivative of Heaviside
      FUNCTION DHEAV(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)               
      IF(X>=0.0d0)THEN
       DHEAV = 0.0d0
      ELSE
       DHEAV = 0.0d0
      ENDIF
      RETURN
      END

!**********************************************************************!
!                                                                      !
!             Multipurpose-Product Functions used in DoNOF             !
!                                                                      !
!     PRODCWQWj: PRODCWQW(j) = CW12j*QWj excluding i=j                 !
!     PRODCWQWjk: PRODCWQWjk = CW12jk*QWj excluding i=j                !
!     PRODROQWj: PRODROQWj = RO*QWj                                    !
!     PRODWCWij: PRODWCWij = W(ij)*CW12                                !
!     PRODWCWijq: PRODWCWijq = W(ij)*CW12(q) excluding q'=q            !
!                                                                      !
!**********************************************************************!

C PRODCWQWj
      FUNCTION PRODCWQWj(J,CW12,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODCWQWj = CW12j*QWj. Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODCWQWj = 0.0d0
      DO I=1,J-1
       PRODCWQWj = PRODCWQWj + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWj = PRODCWQWj + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODCWQWj1
      FUNCTION PRODCWQWj1(J,CW12,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODCWQWj1 = CW12j*QWj, j<NB (NSOC is excluded from the Sum)
C     Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODCWQWj1 = 0.0d0
      DO I=1,J-1
       PRODCWQWj1 = PRODCWQWj1 + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NB
       PRODCWQWj1 = PRODCWQWj1 + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
      DO I=NA+1,NBF5
       PRODCWQWj1 = PRODCWQWj1 + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END      

C PRODCWQWj2
      FUNCTION PRODCWQWj2(J,CW12,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODCWQWj2 = CW12j*QWj, j>NA (NSOC is excluded from the Sum)
C     Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODCWQWj2 = 0.0d0
      DO I=1,NB
       PRODCWQWj2 = PRODCWQWj2 + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=NA+1,J-1
       PRODCWQWj2 = PRODCWQWj2 + CW12(J,I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWj2 = PRODCWQWj2 + CW12(J,I)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END
      
C PRODCWQWjk
      FUNCTION PRODCWQWjk(NV,J,K,CW12,QW)
*     Called from occopt.f for obtaining the gradients
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODCWQWjk = CW12jk*QWj. Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODCWQWjk=0.0d0
      DO I=1,J-1
       PRODCWQWjk = PRODCWQWjk + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWjk = PRODCWQWjk + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODCWQWjk1
      FUNCTION PRODCWQWjk1(NV,J,K,CW12,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODCWQWjk = CW12jk*QWj, j<NB (NSOC is excluded from the Sum)
C     Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODCWQWjk1 = 0.0d0
      DO I=1,J-1
       PRODCWQWjk1 = PRODCWQWjk1 + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NB
       PRODCWQWjk1 = PRODCWQWjk1 + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
      DO I=NA+1,NBF5
       PRODCWQWjk1 = PRODCWQWjk1 + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODCWQWjk2
      FUNCTION PRODCWQWjk2(NV,J,K,CW12,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5,NV)::CW12
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODCWQWjk = CW12jk*QWj, j>NA (NSOC is excluded from the Sum)
C     Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODCWQWjk2 = 0.0d0
      DO I=1,NB
       PRODCWQWjk2 = PRODCWQWjk2 + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=NA+1,J-1
       PRODCWQWjk2 = PRODCWQWjk2 + CW12(J,I,K)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODCWQWjk2 = PRODCWQWjk2 + CW12(J,I,K)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END
      
C PRODROQWj
      FUNCTION PRODROQWj(J,RO,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODROQWj = RO*QWj    Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODROQWj=0.0d0
      DO I=1,J-1
       PRODROQWj = PRODROQWj + RO(I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NBF5
       PRODROQWj = PRODROQWj + RO(I)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODROQWj0
      FUNCTION PRODROQWj0(J,RO,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODROQWj0 = RO*QWj  (Sum only for NSOC)
C     Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODROQWj0 = 0.0d0
      DO I=NB+1,J-1
       PRODROQWj0 = PRODROQWj0 + RO(I)*QW(I+J*(J-1)/2)
      ENDDO
      DO I=J+1,NA
       PRODROQWj0 = PRODROQWj0 + RO(I)*QW(J+I*(I-1)/2)
      ENDDO
C--------------------------------------------------------------------      
      RETURN
      END
      
C PRODROQWj1
      FUNCTION PRODROQWj1(J,RO,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODROQWj = RO*QWj, j<NB<i (Sum only for NSOC)
C-----------------------------------------------------------------------
      PRODROQWj1 = 0.0d0
      DO I=NB+1,NA
       PRODROQWj1 = PRODROQWj1 + RO(J)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------      
      RETURN
      END

C PRODROQWj2
      FUNCTION PRODROQWj2(J,RO,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODROQWj = RO*QWj, j>NA>i (Sum only for NSOC)
C-----------------------------------------------------------------------
      PRODROQWj2 = 0.0d0
      DO I=NB+1,NA
       PRODROQWj2 = PRODROQWj2 + RO(J)*QW(I+J*(J-1)/2)
      ENDDO
C-----------------------------------------------------------------------      
      RETURN
      END

C PRODDRQWjk1
      FUNCTION PRODDRQWjk1(NV,J,K,DR,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODDRQWjk1 = DRjk*QWj, j<NB (NSOC is excluded from the Sum)
C     Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODDRQWjk1=0.0d0
      DO I=NB+1,NA
       PRODDRQWjk1 = PRODDRQWjk1 + DR(J,K)*QW(J+I*(I-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODDRQWjk2
      FUNCTION PRODDRQWjk2(NV,J,K,DR,QW)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NV)::DR
      DOUBLE PRECISION,DIMENSION(NBFT5)::QW
C-----------------------------------------------------------------------
C     PRODDRQWjk2 = DRjk*QWj, j>NA (NSOC is excluded from the Sum)
C     Note: Term with I=J is not included
C-----------------------------------------------------------------------
      PRODDRQWjk2=0.0d0
      DO I=NB+1,NA
       PRODDRQWjk2 = PRODDRQWjk2 + DR(J,K)*QW(I+J*(J-1)/2)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODWCWij
      FUNCTION PRODWCWij(ij,W,CW12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*CW12(1,*) by IQP
C-----------------------------------------------------------------------
      PRODWCWij = 0.0d0
      DO IQP=1,NBF5
       PRODWCWij = PRODWCWij + W(ij,IQP)*CW12(1,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODWCWij1
      FUNCTION PRODWCWij1(ij,W,CW12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*CW12(1,*) by IQP. NSOC terms are excluded from the Sum.
C-----------------------------------------------------------------------
      PRODWCWij1 = 0.0d0
      DO IQP=1,NB
       PRODWCWij1 = PRODWCWij1 + W(ij,IQP)*CW12(1,IQP)
      ENDDO
      DO IQP=NA+1,NBF5
       PRODWCWij1 = PRODWCWij1 + W(ij,IQP)*CW12(1,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END
      
C PRODWCWijq
      FUNCTION PRODWCWijq(ij,IQ,W,CW12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*CW12(IQ,*) by IQP, IQ is not considered
C-----------------------------------------------------------------------
      PRODWCWijq = 0.0d0
      DO IQP=1,IQ-1
       PRODWCWijq = PRODWCWijq + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=IQ+1,NBF5
       PRODWCWijq = PRODWCWijq + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODWCWijq1
      FUNCTION PRODWCWijq1(ij,IQ,W,CW12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*CW12(IQ,*) by IQP, IQ is not considered (IQ<NB)
C     NSOC terms are excluded from the Sum.
C-----------------------------------------------------------------------
      PRODWCWijq1 = 0.0d0
      DO IQP=1,IQ-1
       PRODWCWijq1 = PRODWCWijq1 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=IQ+1,NB
       PRODWCWijq1 = PRODWCWijq1 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=NA+1,NBF5
       PRODWCWijq1 = PRODWCWijq1 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END
      
C PRODWCWijq2
      FUNCTION PRODWCWijq2(ij,IQ,W,CW12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*CW12(IQ,*) by IQP, IQ is not considered (IQ>NA)
C     NSOC terms are excluded from the Sum.
C-----------------------------------------------------------------------
      PRODWCWijq2 = 0.0d0
      DO IQP=1,NB
       PRODWCWijq2 = PRODWCWijq2 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=NA+1,IQ-1
       PRODWCWijq2 = PRODWCWijq2 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
      DO IQP=IQ+1,NBF5
       PRODWCWijq2 = PRODWCWijq2 + W(ij,IQP)*CW12(IQ,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C SUMWij
      FUNCTION SUMWij(ij,W)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W      
C-----------------------------------------------------------------------
C     Sum Wij for NSOC terms
C-----------------------------------------------------------------------
      SUMWij = 0.0d0
      DO IQP=NB+1,NA
       SUMWij = SUMWij + W(ij,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C SUMWijq
      FUNCTION SUMWijq(ij,IQ,W)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum Wij for NSOC terms, IQ is not considered
C-----------------------------------------------------------------------
      SUMWijq = 0.0d0
      DO IQP=NB+1,IQ-1
        SUMWijq = SUMWijq + W(ij,IQP)
      ENDDO
      DO IQP=IQ+1,NA
        SUMWijq = SUMWijq + W(ij,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODWROij
      FUNCTION PRODWROij(ij,W,RO)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*RO. NSOC terms are excluded from the Sum.
C-----------------------------------------------------------------------
      PRODWROij = 0.0d0
      DO IQP=1,NB
       PRODWROij = PRODWROij + W(ij,IQP)*RO(IQP)
      ENDDO
      DO IQP=NA+1,NBF5
       PRODWROij = PRODWROij + W(ij,IQP)*RO(IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END
      
!======================================================================!
!                                                                      !
!           M A T H     L I B R A R Y   S U B R O U T I N E S          !
!                                                                      !
!======================================================================!

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!    DIAG: Diagonalization of real symmetric matrix using Houselholder !
!          method. NAN is the maximum possible size = 5000.            !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C DIAG
      SUBROUTINE DIAG(NN,A,VEC,EIG,W)                                  
************************************************************************
*     MATRIX DIAGNOLIZATION ROUTINE FOR REAL SYMMETRIC CASE            *
*     HOUSEHOLDER METHOD                                               *
*     RHOSQ = UPPER LIMIT FOR OFF-DIAGONAL ELEMENT                     *
*     NN= SIZE OF MATRIX                                               *
*     A = MATRIX (ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED)     *
*     EIG = RETURNED EIGENVALUES IN ALGEBRAIC DESCENDING ORDER         *
*     VEC = RETURNED EIGENVECTORS IN COLUMNS                           *
************************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      PARAMETER (NAN = 5000)
      INTEGER,DIMENSION(NAN)::IPOSV,IORD,IVPOS
      DOUBLE PRECISION,DIMENSION(NAN)::GAMMA,BETA,P,Q,BETASQ
      DOUBLE PRECISION,DIMENSION(NN)::EIG,W
      DOUBLE PRECISION,DIMENSION(NN,NN)::A,VEC
      EQUIVALENCE (P,Q,IVPOS,BETA),(IPOSV,GAMMA),(IORD,BETASQ)
      DATA ZERO/0.0d0/,PT5/0.5d0/,ONE/1.0d0/,TWO/2.0d0/,RHOSQ/1.0D-30/
C-----------------------------------------------------------------------
      N=NN
      IF(N)10,550,10
   10 N1=N-1
      N2=N-2
      GAMMA(1)=A(1,1)
      IF(N2) 180,170,20
   20 DO 160 NR=1,N2
      B=A(NR+1,NR)
      S=ZERO
      DO 30 I=NR,N2
   30 S=S+A(I+2,NR)**2
C     PREPARE FOR POSSIBLE BYPASS OF TRANSFORMATION
      A(NR+1,NR)=ZERO
      IF (S) 150,150,40
   40 S=S+B*B
      SGN=+ONE
      IF (B) 50,60,60
   50 SGN=-ONE
   60 SQRTS= SQRT(S)
      D=SGN/(SQRTS+SQRTS)
      TEMP= SQRT(PT5+B*D)
      W(NR)=TEMP
      A(NR+1,NR)=TEMP
      D=D/TEMP
      B=-SGN*SQRTS
C     D IS FACTOR OF PROPORTIONALITY. NOW COMPUTE AND SAVE W VECTOR.
C     EXTRA SINGLY SUBSCRIPTED W VECTOR USED FOR SPEED.
      DO 70 I=NR,N2
      TEMP=D*A(I+2,NR)
      W(I+1)=TEMP
   70 A(I+2,NR)=TEMP
C     PREMULTIPLY VECTOR W BY MATRIX A TO OBTAIN P VECTOR.
C     SIMULTANEOUSLY ACCUMULATE DOT PRODUCT WP,(THE SCALAR K)
      WTAW=ZERO
      DO 120 I=NR,N1
      SUM=ZERO
      DO 80 J=NR,I
   80 SUM=SUM+A(I+1,J+1)*W(J)
      I1=I+1
      IF(N1-I1) 110,90,90
   90 DO 100 J=I1,N1
  100 SUM=SUM+A(J+1,I+1)*W(J)
  110 P(I)=SUM
  120 WTAW=WTAW+SUM*W(I)
C     P VECTOR AND SCALAR K  NOW STORED. NEXT COMPUTE Q VECTOR
      DO 130 I=NR,N1
  130 Q(I)=P(I)-WTAW*W(I)
C     NOW FORM PAP MATRIX, REQUIRED PART
      DO 140 J=NR,N1
      QJ=Q(J)
      WJ=W(J)
      DO 140 I=J,N1
  140 A(I+1,J+1)=A(I+1,J+1)-TWO*(W(I)*QJ+WJ*Q(I))
  150 BETA(NR)=B
      BETASQ(NR)=B*B
  160 GAMMA(NR+1)=A(NR+1,NR+1)
  170 B=A(N,N-1)
      BETA(N-1)=B
      BETASQ(N-1)=B*B
      GAMMA(N)=A(N,N)
  180 BETASQ(N)=ZERO
C     ADJOIN AN IDENTIFY MATRIX TO BE POSTMULTIPLIED BY ROTATIONS.
      DO 200 I=1,N
      DO 190 J=1,N
  190 VEC(I,J)=ZERO
  200 VEC(I,I)=ONE
      M=N
      SUM=ZERO
      NPAS=1
      GO TO 330
  210 SUM=SUM+SHIFT
      COSA=ONE
      G=GAMMA(1)-SHIFT
      PP=G
      PPBS=PP*PP+BETASQ(1)
      PPBR= SQRT(PPBS)
      DO 300 J=1,M
      COSAP=COSA
      IF(PPBS)230,220,230
  220 SINA=ZERO
      SINA2=ZERO
      COSA=ONE
      GO TO 270
  230 SINA=BETA(J)/PPBR
      SINA2=BETASQ(J)/PPBS
      COSA=PP/PPBR
C     POSTMULTIPLY IDENTITY BY P-TRANSPOSE MATRIX
      NT=J+NPAS
      IF(NT-N)250,240,240
  240 NT=N
  250 DO 260 I=1,NT
      TEMP=COSA*VEC(I,J)+SINA*VEC(I,J+1)
      VEC(I,J+1)=-SINA*VEC(I,J)+COSA*VEC(I,J+1)
  260 VEC(I,J)=TEMP
  270 DIA=GAMMA(J+1)-SHIFT
      U=SINA2*(G+DIA)
      GAMMA(J)=G+U
      G=DIA-U
      PP=DIA*COSA-SINA*COSAP*BETA(J)
      IF(J-M)290,280,290
  280 BETA(J)=SINA*PP
      BETASQ(J)=SINA2*PP*PP
      GO TO 310
  290 PPBS=PP*PP+BETASQ(J+1)
      PPBR= SQRT(PPBS)
      BETA(J)=SINA*PPBR
  300 BETASQ(J)=SINA2*PPBS
  310 GAMMA(M+1)=G
C     TEST FOR CONVERGENCE OF LAST DIAGONAL ELEMENT
      NPAS=NPAS+1
      IF(BETASQ(M)-RHOSQ)320,320,350
  320 EIG(M+1)=GAMMA(M+1)+SUM
  330 BETA(M)=ZERO
      BETASQ(M)=ZERO
      M=M-1
      IF(M)340,380,340
  340 IF(BETASQ(M)-RHOSQ)320,320,350
C     TAKE ROOT OF CORNER 2 BY 2 NEAREST TO LOWER DIAGONAL IN VALUE
C     AS ESTIMATE OF EIGENVALUE TO USE FOR SHIFT
  350 A2=GAMMA(M+1)
      R2=PT5*A2
      R1=PT5*GAMMA(M)
      R12=R1+R2
      DIF=R1-R2
      TEMP= SQRT(DIF*DIF+BETASQ(M))
      R1=R12+TEMP
      R2=R12-TEMP
      DIF= ABS(A2-R1)- ABS(A2-R2)
      IF(DIF)370,360,360
  360 SHIFT=R2
      GO TO 210
  370 SHIFT=R1
      GO TO 210
  380 EIG(1)=GAMMA(1)+SUM
C     INITIALIZE AUXILIARY TABLES REQUIRED FOR REARRANGING THE VECTORS
      DO 390 J=1,N
      IPOSV(J)=J
      IVPOS(J)=J
  390 IORD(J)=J
C     USE A TRANSPOSITION SORT TO ORDER THE EIGENVALUES
      M=N
      GO TO 430
  400 DO 420 J=1,M
      IF(EIG(J)-EIG(J+1))420,420,410
  410 TEMP=EIG(J)
      EIG(J)=EIG(J+1)
      EIG(J+1)=TEMP
      ITEMP=IORD(J)
      IORD(J)=IORD(J+1)
      IORD(J+1)=ITEMP
  420 CONTINUE
  430 M=M-1
      IF(M)400,440,400
  440 IF(N1)450,490,450
  450 DO 480 L=1,N1
      NV=IORD(L)
      NP=IPOSV(NV)
      IF(NP-L)460,480,460
  460 LV=IVPOS(L)
      IVPOS(NP)=LV
      IPOSV(LV)=NP
      DO 470 I=1,N
      TEMP=VEC(I,L)
      VEC(I,L)=VEC(I,NP)
  470 VEC(I,NP)=TEMP
  480 CONTINUE
C     BACK TRANSFORM THE VECTORS OF THE TRIPLE DIAGONAL MATRIX
  490 DO 540 NRR=1,N
      K=N1
  500 K=K-1
      IF(K)540,540,510
  510 SUM=ZERO
      DO 520 I=K,N1
  520 SUM=SUM+VEC(I+1,NRR)*A(I+1,K)
      SUM=SUM+SUM
      DO 530 I=K,N1
  530 VEC(I+1,NRR)=VEC(I+1,NRR)-SUM*A(I+1,K)
      GO TO 500
  540 CONTINUE
  550 RETURN
C**  THIS PROGRAM VALID ON FTN4 AND FTN5 **
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                           LAPACK SUBROUTINES                         !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C DLAMCH
      DOUBLE PRECISION FUNCTION dlamch( CMACH )
*
*  -- LAPACK auxiliary routine (version 3.7.0) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     April 2012
*
*     .. Scalar Arguments ..
      CHARACTER          cmach
*     ..
*     .. Parameters ..
      DOUBLE PRECISION   one, zero
      parameter( one = 1.0d+0, zero = 0.0d+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            first, lrnd
      INTEGER            beta, imax, imin, it
      DOUBLE PRECISION   base, emax, emin, eps, prec, rmach, rmax, rmin,
     $                   rnd, sfmin, small, t
*     ..
*     .. External Functions ..
      LOGICAL            lsame
      EXTERNAL           lsame
*     ..
*     .. External Subroutines ..
      EXTERNAL           dlamc2
*     ..
*     .. Save statement ..
      SAVE               first, eps, sfmin, base, t, rnd, emin, rmin,
     $                   emax, rmax, prec
*     ..
*     .. Data statements ..
      DATA               first / .true. /
*     ..
*     .. Executable Statements ..
*
      IF( first ) THEN
         CALL dlamc2( beta, it, lrnd, eps, imin, rmin, imax, rmax )
         base = beta
         t = it
         IF( lrnd ) THEN
            rnd = one
            eps = ( base**( 1-it ) ) / 2
         ELSE
            rnd = zero
            eps = base**( 1-it )
         END IF
         prec = eps*base
         emin = imin
         emax = imax
         sfmin = rmin
         small = one / rmax
         IF( small.GE.sfmin ) THEN
*
*           Use SMALL plus a bit, to avoid the possibility of rounding
*           causing overflow when computing  1/sfmin.
*
            sfmin = small*( one+eps )
         END IF
      END IF
*
      IF( lsame( cmach, 'E' ) ) THEN
         rmach = eps
      ELSE IF( lsame( cmach, 'S' ) ) THEN
         rmach = sfmin
      ELSE IF( lsame( cmach, 'B' ) ) THEN
         rmach = base
      ELSE IF( lsame( cmach, 'P' ) ) THEN
         rmach = prec
      ELSE IF( lsame( cmach, 'N' ) ) THEN
         rmach = t
      ELSE IF( lsame( cmach, 'R' ) ) THEN
         rmach = rnd
      ELSE IF( lsame( cmach, 'M' ) ) THEN
         rmach = emin
      ELSE IF( lsame( cmach, 'U' ) ) THEN
         rmach = rmin
      ELSE IF( lsame( cmach, 'L' ) ) THEN
         rmach = emax
      ELSE IF( lsame( cmach, 'O' ) ) THEN
         rmach = rmax
      END IF
*
      dlamch = rmach
      first  = .false.
      RETURN
*
*     End of DLAMCH
*
      END

C DLAMC1
      SUBROUTINE DLAMC1( BETA, T, RND, IEEE1 )
*
*  -- LAPACK auxiliary routine (version 3.7.0) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2010
*
*     .. Scalar Arguments ..
      LOGICAL            IEEE1, RND
      INTEGER            BETA, T
*     ..
* =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            FIRST, LIEEE1, LRND
      INTEGER            LBETA, LT
      DOUBLE PRECISION   A, B, C, F, ONE, QTR, SAVEC, T1, T2
*     ..
*     .. External Functions ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           dlamc3
*     ..
*     .. Save statement ..
      SAVE               first, lieee1, lbeta, lrnd, lt
*     ..
*     .. Data statements ..
      DATA               first / .true. /
*     ..
*     .. Executable Statements ..
*
      IF( first ) THEN
         one = 1
*
*        LBETA,  LIEEE1,  LT and  LRND  are the  local values  of  BETA,
*        IEEE1, T and RND.
*
*        Throughout this routine  we use the function  DLAMC3  to ensure
*        that relevant values are  stored and not held in registers,  or
*        are not affected by optimizers.
*
*        Compute  a = 2.0**m  with the  smallest positive integer m such
*        that
*
*           fl( a + 1.0 ) = a.
*
         a = 1
         c = 1
*
*+       WHILE( C.EQ.ONE )LOOP
   10    CONTINUE
         IF( c.EQ.one ) THEN
            a = 2*a
            c = dlamc3( a, one )
            c = dlamc3( c, -a )
            GO TO 10
         END IF
*+       END WHILE
*
*        Now compute  b = 2.0**m  with the smallest positive integer m
*        such that
*
*           fl( a + b ) .gt. a.
*
         b = 1
         c = dlamc3( a, b )
*
*+       WHILE( C.EQ.A )LOOP
   20    CONTINUE
         IF( c.EQ.a ) THEN
            b = 2*b
            c = dlamc3( a, b )
            GO TO 20
         END IF
*+       END WHILE
*
*        Now compute the base.  a and c  are neighbouring floating point
*        numbers  in the  interval  ( beta**t, beta**( t + 1 ) )  and so
*        their difference is beta. Adding 0.25 to c is to ensure that it
*        is truncated to beta and not ( beta - 1 ).
*
         qtr = one / 4
         savec = c
         c = dlamc3( c, -a )
         lbeta = c + qtr
*
*        Now determine whether rounding or chopping occurs,  by adding a
*        bit  less  than  beta/2  and a  bit  more  than  beta/2  to  a.
*
         b = lbeta
         f = dlamc3( b / 2, -b / 100 )
         c = dlamc3( f, a )
         IF( c.EQ.a ) THEN
            lrnd = .true.
         ELSE
            lrnd = .false.
         END IF
         f = dlamc3( b / 2, b / 100 )
         c = dlamc3( f, a )
         IF( ( lrnd ) .AND. ( c.EQ.a ) )
     $      lrnd = .false.
*
*        Try and decide whether rounding is done in the  IEEE  'round to
*        nearest' style. B/2 is half a unit in the last place of the two
*        numbers A and SAVEC. Furthermore, A is even, i.e. has last  bit
*        zero, and SAVEC is odd. Thus adding B/2 to A should not  change
*        A, but adding B/2 to SAVEC should change SAVEC.
*
         t1 = dlamc3( b / 2, a )
         t2 = dlamc3( b / 2, savec )
         lieee1 = ( t1.EQ.a ) .AND. ( t2.GT.savec ) .AND. lrnd
*
*        Now find  the  mantissa, t.  It should  be the  integer part of
*        log to the base beta of a,  however it is safer to determine  t
*        by powering.  So we find t as the smallest positive integer for
*        which
*
*           fl( beta**t + 1.0 ) = 1.0.
*
         lt = 0
         a = 1
         c = 1
*
*+       WHILE( C.EQ.ONE )LOOP
   30    CONTINUE
         IF( c.EQ.one ) THEN
            lt = lt + 1
            a = a*lbeta
            c = dlamc3( a, one )
            c = dlamc3( c, -a )
            GO TO 30
         END IF
*+       END WHILE
*
      END IF
*
      beta = lbeta
      t = lt
      rnd = lrnd
      ieee1 = lieee1
      first = .false.
      RETURN
*
*     End of DLAMC1
*
      END

C DLAMC2      
      SUBROUTINE DLAMC2( BETA, T, RND, EPS, EMIN, RMIN, EMAX, RMAX )
*
*  -- LAPACK auxiliary routine (version 3.7.0) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2010
*
*     .. Scalar Arguments ..
      LOGICAL            RND
      INTEGER            BETA, EMAX, EMIN, T
      DOUBLE PRECISION   EPS, RMAX, RMIN
*     ..
* =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            FIRST, IEEE, IWARN, LIEEE1, LRND
      INTEGER            GNMIN, GPMIN, I, LBETA, LEMAX, LEMIN, LT,
     $                   NGNMIN, NGPMIN
      DOUBLE PRECISION   A, B, C, HALF, LEPS, LRMAX, LRMIN, ONE, RBASE,
     $                   SIXTH, SMALL, THIRD, TWO, ZERO
*     ..
*     .. External Functions ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           dlamc3
*     ..
*     .. External Subroutines ..
      EXTERNAL           dlamc1, dlamc4, dlamc5
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          abs, max, min
*     ..
*     .. Save statement ..
      SAVE               first, iwarn, lbeta, lemax, lemin, leps, lrmax,
     $                   lrmin, lt
*     ..
*     .. Data statements ..
      DATA               first / .true. / , iwarn / .false. /
*     ..
*     .. Executable Statements ..
*
      IF( first ) THEN
         zero = 0
         one = 1
         two = 2
*
*        LBETA, LT, LRND, LEPS, LEMIN and LRMIN  are the local values of
*        BETA, T, RND, EPS, EMIN and RMIN.
*
*        Throughout this routine  we use the function  DLAMC3  to ensure
*        that relevant values are stored  and not held in registers,  or
*        are not affected by optimizers.
*
*        DLAMC1 returns the parameters  LBETA, LT, LRND and LIEEE1.
*
         CALL dlamc1( lbeta, lt, lrnd, lieee1 )
*
*        Start to find EPS.
*
         b = lbeta
         a = b**( -lt )
         leps = a
*
*        Try some tricks to see whether or not this is the correct  EPS.
*
         b = two / 3
         half = one / 2
         sixth = dlamc3( b, -half )
         third = dlamc3( sixth, sixth )
         b = dlamc3( third, -half )
         b = dlamc3( b, sixth )
         b = abs( b )
         IF( b.LT.leps )
     $      b = leps
*
         leps = 1
*
*+       WHILE( ( LEPS.GT.B ).AND.( B.GT.ZERO ) )LOOP
   10    CONTINUE
         IF( ( leps.GT.b ) .AND. ( b.GT.zero ) ) THEN
            leps = b
            c = dlamc3( half*leps, ( two**5 )*( leps**2 ) )
            c = dlamc3( half, -c )
            b = dlamc3( half, c )
            c = dlamc3( half, -b )
            b = dlamc3( half, c )
            GO TO 10
         END IF
*+       END WHILE
*
         IF( a.LT.leps )
     $      leps = a
*
*        Computation of EPS complete.
*
*        Now find  EMIN.  Let A = + or - 1, and + or - (1 + BASE**(-3)).
*        Keep dividing  A by BETA until (gradual) underflow occurs. This
*        is detected when we cannot recover the previous A.
*
         rbase = one / lbeta
         small = one
         DO 20 i = 1, 3
            small = dlamc3( small*rbase, zero )
   20    CONTINUE
         a = dlamc3( one, small )
         CALL dlamc4( ngpmin, one, lbeta )
         CALL dlamc4( ngnmin, -one, lbeta )
         CALL dlamc4( gpmin, a, lbeta )
         CALL dlamc4( gnmin, -a, lbeta )
         ieee = .false.
*
         IF( ( ngpmin.EQ.ngnmin ) .AND. ( gpmin.EQ.gnmin ) ) THEN
            IF( ngpmin.EQ.gpmin ) THEN
               lemin = ngpmin
*            ( Non twos-complement machines, no gradual underflow;
*              e.g.,  VAX )
            ELSE IF( ( gpmin-ngpmin ).EQ.3 ) THEN
               lemin = ngpmin - 1 + lt
               ieee = .true.
*            ( Non twos-complement machines, with gradual underflow;
*              e.g., IEEE standard followers )
            ELSE
               lemin = min( ngpmin, gpmin )
*            ( A guess; no known machine )
               iwarn = .true.
            END IF
*
         ELSE IF( ( ngpmin.EQ.gpmin ) .AND. ( ngnmin.EQ.gnmin ) ) THEN
            IF( abs( ngpmin-ngnmin ).EQ.1 ) THEN
               lemin = max( ngpmin, ngnmin )
*            ( Twos-complement machines, no gradual underflow;
*              e.g., CYBER 205 )
            ELSE
               lemin = min( ngpmin, ngnmin )
*            ( A guess; no known machine )
               iwarn = .true.
            END IF
*
         ELSE IF( ( abs( ngpmin-ngnmin ).EQ.1 ) .AND.
     $            ( gpmin.EQ.gnmin ) ) THEN
            IF( ( gpmin-min( ngpmin, ngnmin ) ).EQ.3 ) THEN
               lemin = max( ngpmin, ngnmin ) - 1 + lt
*            ( Twos-complement machines with gradual underflow;
*              no known machine )
            ELSE
               lemin = min( ngpmin, ngnmin )
*            ( A guess; no known machine )
               iwarn = .true.
            END IF
*
         ELSE
            lemin = min( ngpmin, ngnmin, gpmin, gnmin )
*         ( A guess; no known machine )
            iwarn = .true.
         END IF
         first = .false.
***
* Comment out this if block if EMIN is ok
         IF( iwarn ) THEN
            first = .true.
            WRITE( 6, fmt = 9999 )lemin
         END IF
***
*
*        Assume IEEE arithmetic if we found denormalised  numbers above,
*        or if arithmetic seems to round in the  IEEE style,  determined
*        in routine DLAMC1. A true IEEE machine should have both  things
*        true; however, faulty machines may have one or the other.
*
         ieee = ieee .OR. lieee1
*
*        Compute  RMIN by successive division by  BETA. We could compute
*        RMIN as BASE**( EMIN - 1 ),  but some machines underflow during
*        this computation.
*
         lrmin = 1
         DO 30 i = 1, 1 - lemin
            lrmin = dlamc3( lrmin*rbase, zero )
   30    CONTINUE
*
*        Finally, call DLAMC5 to compute EMAX and RMAX.
*
         CALL dlamc5( lbeta, lt, lemin, ieee, lemax, lrmax )
      END IF
*
      beta = lbeta
      t = lt
      rnd = lrnd
      eps = leps
      emin = lemin
      rmin = lrmin
      emax = lemax
      rmax = lrmax
*
      RETURN
*
 9999 FORMAT( / / ' WARNING. The value EMIN may be incorrect:-',
     $      '  EMIN = ', i8, /
     $      ' If, after inspection, the value EMIN looks',
     $      ' acceptable please comment out ',
     $      / ' the IF block as marked within the code of routine',
     $      ' DLAMC2,', / ' otherwise supply EMIN explicitly.', / )
*
*     End of DLAMC2
*
      END

C DLAMC3
      DOUBLE PRECISION FUNCTION dlamc3( A, B )
*
*  -- LAPACK auxiliary routine (version 3.7.0) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2010
*
*     .. Scalar Arguments ..
      DOUBLE PRECISION   a, b
*     ..
* =====================================================================
*
*     .. Executable Statements ..
*
      dlamc3 = a + b
*
      RETURN
*
*     End of DLAMC3
*
      END

C DLAMC4
      SUBROUTINE DLAMC4( EMIN, START, BASE )
*
*  -- LAPACK auxiliary routine (version 3.7.0) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2010
*
*     .. Scalar Arguments ..
      INTEGER            BASE, EMIN
      DOUBLE PRECISION   START
*     ..
* =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I
      DOUBLE PRECISION   A, B1, B2, C1, C2, D1, D2, ONE, RBASE, ZERO
*     ..
*     .. External Functions ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           dlamc3
*     ..
*     .. Executable Statements ..
*
      a = start
      one = 1
      rbase = one / base
      zero = 0
      emin = 1
      b1 = dlamc3( a*rbase, zero )
      c1 = a
      c2 = a
      d1 = a
      d2 = a
*+    WHILE( ( C1.EQ.A ).AND.( C2.EQ.A ).AND.
*    $       ( D1.EQ.A ).AND.( D2.EQ.A )      )LOOP
   10 CONTINUE
      IF( ( c1.EQ.a ) .AND. ( c2.EQ.a ) .AND. ( d1.EQ.a ) .AND.
     $    ( d2.EQ.a ) ) THEN
         emin = emin - 1
         a = b1
         b1 = dlamc3( a / base, zero )
         c1 = dlamc3( b1*base, zero )
         d1 = zero
         DO 20 i = 1, base
            d1 = d1 + b1
   20    CONTINUE
         b2 = dlamc3( a*rbase, zero )
         c2 = dlamc3( b2 / rbase, zero )
         d2 = zero
         DO 30 i = 1, base
            d2 = d2 + b2
   30    CONTINUE
         GO TO 10
      END IF
*+    END WHILE
*
      RETURN
*
*     End of DLAMC4
*
      END

C DLAMC5
      SUBROUTINE DLAMC5( BETA, P, EMIN, IEEE, EMAX, RMAX )
*
*  -- LAPACK auxiliary routine (version 3.7.0) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2010
*
*     .. Scalar Arguments ..
      LOGICAL            IEEE
      INTEGER            BETA, EMAX, EMIN, P
      DOUBLE PRECISION   RMAX
*     ..
* =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO, ONE
      parameter( zero = 0.0d0, one = 1.0d0 )
*     ..
*     .. Local Scalars ..
      INTEGER            EXBITS, EXPSUM, I, LEXP, NBITS, TRY, UEXP
      DOUBLE PRECISION   OLDY, RECBAS, Y, Z
*     ..
*     .. External Functions ..
      DOUBLE PRECISION   DLAMC3
      EXTERNAL           dlamc3
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          mod
*     ..
*     .. Executable Statements ..
*
*     First compute LEXP and UEXP, two powers of 2 that bound
*     abs(EMIN). We then assume that EMAX + abs(EMIN) will sum
*     approximately to the bound that is closest to abs(EMIN).
*     (EMAX is the exponent of the required number RMAX).
*
      lexp = 1
      exbits = 1
   10 CONTINUE
      try = lexp*2
      IF( try.LE.( -emin ) ) THEN
         lexp = try
         exbits = exbits + 1
         GO TO 10
      END IF
      IF( lexp.EQ.-emin ) THEN
         uexp = lexp
      ELSE
         uexp = try
         exbits = exbits + 1
      END IF
*
*     Now -LEXP is less than or equal to EMIN, and -UEXP is greater
*     than or equal to EMIN. EXBITS is the number of bits needed to
*     store the exponent.
*
      IF( ( uexp+emin ).GT.( -lexp-emin ) ) THEN
         expsum = 2*lexp
      ELSE
         expsum = 2*uexp
      END IF
*
*     EXPSUM is the exponent range, approximately equal to
*     EMAX - EMIN + 1 .
*
      emax = expsum + emin - 1
      nbits = 1 + exbits + p
*
*     NBITS is the total number of bits needed to store a
*     floating-point number.
*
      IF( ( mod( nbits, 2 ).EQ.1 ) .AND. ( beta.EQ.2 ) ) THEN
*
*        Either there are an odd number of bits used to store a
*        floating-point number, which is unlikely, or some bits are
*        not used in the representation of numbers, which is possible,
*        (e.g. Cray machines) or the mantissa has an implicit bit,
*        (e.g. IEEE machines, Dec Vax machines), which is perhaps the
*        most likely. We have to assume the last alternative.
*        If this is true, then we need to reduce EMAX by one because
*        there must be some way of representing zero in an implicit-bit
*        system. On machines like Cray, we are reducing EMAX by one
*        unnecessarily.
*
         emax = emax - 1
      END IF
*
      IF( ieee ) THEN
*
*        Assume we are on an IEEE machine which reserves one exponent
*        for infinity and NaN.
*
         emax = emax - 1
      END IF
*
*     Now create RMAX, the largest machine number, which should
*     be equal to (1.0 - BETA**(-P)) * BETA**EMAX .
*
*     First compute 1.0 - BETA**(-P), being careful that the
*     result is less than 1.0 .
*
      recbas = one / beta
      z = beta - one
      y = zero
      DO 20 i = 1, p
         z = z*recbas
         IF( y.LT.one )oldy = y
         y = dlamc3( y, z )
   20 CONTINUE
      IF( y.GE.one )y = oldy
*
*     Now multiply by BETA**EMAX to get RMAX.
*
      DO 30 i = 1, emax
         y = dlamc3( y*beta, zero )
   30 CONTINUE
*
      rmax = y
      RETURN
*
*     End of DLAMC5
*
      END

C DLAPY2
      DOUBLE PRECISION FUNCTION DLAPY2( X, Y )
C
C  -- LAPACK AUXILIARY ROUTINE (VERSION 1.1) --
C     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
C     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
C     OCTOBER 31, 1992
C
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION   X, Y
C     ..
C
C  PURPOSE
C  =======
C
C  DLAPY2 RETURNS SQRT(X**2+Y**2), TAKING CARE NOT TO CAUSE UNNECESSARY
C  OVERFLOW.
C
C  ARGUMENTS
C  =========
C
C  X       (INPUT) DOUBLE PRECISION
C  Y       (INPUT) DOUBLE PRECISION
C          X AND Y SPECIFY THE VALUES X AND Y.
C
C  =====================================================================
C
C     .. PARAMETERS ..
      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D+0 )
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
C     ..
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION   W, XABS, YABS, Z
C     ..
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          ABS, MAX, MIN, SQRT
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
      XABS = ABS( X )
      YABS = ABS( Y )
      W = MAX( XABS, YABS )
      Z = MIN( XABS, YABS )
      IF( Z==ZERO ) THEN
         DLAPY2 = W
      ELSE
         DLAPY2 = W*SQRT( ONE+( Z / W )**2 )
      END IF
      RETURN
C
C     END OF DLAPY2
C
      END

C DLAPY3
      DOUBLE PRECISION FUNCTION DLAPY3( X, Y, Z )
C
C  -- LAPACK AUXILIARY ROUTINE (VERSION 1.1) --
C     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
C     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
C     OCTOBER 31, 1992
C
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION   X, Y, Z
C     ..
C
C  PURPOSE
C  =======
C
C  DLAPY3 RETURNS SQRT(X**2+Y**2+Z**2), TAKING CARE NOT TO CAUSE
C  UNNECESSARY OVERFLOW.
C
C  ARGUMENTS
C  =========
C
C  X       (INPUT) DOUBLE PRECISION
C  Y       (INPUT) DOUBLE PRECISION
C  Z       (INPUT) DOUBLE PRECISION
C          X, Y AND Z SPECIFY THE VALUES X, Y AND Z.
C
C  =====================================================================
C
C     .. PARAMETERS ..
      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D+0 )
C     ..
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION   W, XABS, YABS, ZABS
C     ..
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          ABS, MAX, SQRT
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
      XABS = ABS( X )
      YABS = ABS( Y )
      ZABS = ABS( Z )
      W = MAX( XABS, YABS, ZABS )
      IF( W==ZERO ) THEN
         DLAPY3 = ZERO
      ELSE
         DLAPY3 = W*SQRT( ( XABS / W )**2+( YABS / W )**2+
     $            ( ZABS / W )**2 )
      END IF
      RETURN
C
C     END OF DLAPY3
C
      END

C DLADIV
      SUBROUTINE DLADIV( A, B, C, D, P, Q )
C
C  -- LAPACK AUXILIARY ROUTINE (VERSION 1.1) --
C     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
C     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
C     OCTOBER 31, 1992
C
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION   A, B, C, D, P, Q
C     ..
C
C  PURPOSE
C  =======
C
C  DLADIV PERFORMS COMPLEX DIVISION IN  REAL ARITHMETIC
C
C                        A + I*B
C             P + I*Q = ---------
C                        C + I*D
C
C  THE ALGORITHM IS DUE TO ROBERT L. SMITH AND CAN BE FOUND
C  IN D. KNUTH, THE ART OF COMPUTER PROGRAMMING, VOL.2, P.195
C
C  ARGUMENTS
C  =========
C
C  A       (INPUT) DOUBLE PRECISION
C  B       (INPUT) DOUBLE PRECISION
C  C       (INPUT) DOUBLE PRECISION
C  D       (INPUT) DOUBLE PRECISION
C          THE SCALARS A, B, C, AND D IN THE ABOVE EXPRESSION.
C
C  P       (OUTPUT) DOUBLE PRECISION
C  Q       (OUTPUT) DOUBLE PRECISION
C          THE SCALARS P AND Q IN THE ABOVE EXPRESSION.
C
C  =====================================================================
C
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION   E, F
C     ..
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          ABS
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
      IF( ABS( D )<ABS( C ) ) THEN
         E = D / C
         F = C + D*E
         P = ( A+B*E ) / F
         Q = ( B-A*E ) / F
      ELSE
         E = C / D
         F = D + C*E
         P = ( B+A*E ) / F
         Q = ( -A+B*E ) / F
      END IF
C
      RETURN
C
C     END OF DLADIV
C
      END

C DLARTG
      SUBROUTINE DLARTG( F, G, CS, SN, R )
C
C  -- LAPACK AUXILIARY ROUTINE (VERSION 1.1) --
C     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
C     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
C     OCTOBER 31, 1992
C
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION   CS, F, G, R, SN
C     ..
C
C  PURPOSE
C  =======
C
C  DLARTG GENERATE A PLANE ROTATION SO THAT
C
C     [  CS  SN  ]  .  [ F ]  =  [ R ]   WHERE CS**2 + SN**2 = 1.
C     [ -SN  CS  ]     [ G ]     [ 0 ]
C
C  THIS IS A FASTER VERSION OF THE BLAS ROUTINE DROTG, EXCEPT FOR
C  THE FOLLOWING DIFFERENCES:
C     F AND G ARE UNCHANGED ON RETURN.
C     IF G=0, THEN CS=1 AND SN=0.
C     IF F=0 AND (G /= 0), THEN CS=0 AND SN=1 WITHOUT DOING ANY
C        FLOATING POINT OPERATIONS (SAVES WORK IN DBDSQR WHEN
C        THERE ARE ZEROS ON THE DIAGONAL).
C
C  ARGUMENTS
C  =========
C
C  F       (INPUT) DOUBLE PRECISION
C          THE FIRST COMPONENT OF VECTOR TO BE ROTATED.
C
C  G       (INPUT) DOUBLE PRECISION
C          THE SECOND COMPONENT OF VECTOR TO BE ROTATED.
C
C  CS      (OUTPUT) DOUBLE PRECISION
C          THE COSINE OF THE ROTATION.
C
C  SN      (OUTPUT) DOUBLE PRECISION
C          THE SINE OF THE ROTATION.
C
C  R       (OUTPUT) DOUBLE PRECISION
C          THE NONZERO COMPONENT OF THE ROTATED VECTOR.
C
C  =====================================================================
C
C     .. PARAMETERS ..
      DOUBLE PRECISION   ZERO
      PARAMETER          ( ZERO = 0.0D+0 )
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
C     ..
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION   T, TT
C     ..
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          ABS, SQRT
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
      IF( G==ZERO ) THEN
         CS = ONE
         SN = ZERO
         R = F
      ELSE IF( F==ZERO ) THEN
         CS = ZERO
         SN = ONE
         R = G
      ELSE
         IF( ABS( F )>ABS( G ) ) THEN
            T = G / F
            TT = SQRT( ONE+T*T )
            CS = ONE / TT
            SN = T*CS
            R = F*TT
         ELSE
            T = F / G
            TT = SQRT( ONE+T*T )
            SN = ONE / TT
            CS = T*SN
            R = G*TT
         END IF
      END IF
      RETURN
C
C     END OF DLARTG
C
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!     DGESV computes the solution to system of linear equations A*X=B  !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C DGESV
      SUBROUTINE DGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )
*      
* DGESV computes the solution to system of linear equations A * X = B
*
*  Definition:
*  ===========
*
*       SUBROUTINE DGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )
* 
*       .. Scalar Arguments ..
*       INTEGER            INFO, LDA, LDB, N, NRHS
*       ..
*       .. Array Arguments ..
*       INTEGER            IPIV( * )
*       DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*       ..
*  
*
* Purpose:
* =============
*
* DGESV computes the solution to a real system of linear equations
*    A * X = B,
* where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
*
* The LU decomposition with partial pivoting and row interchanges is
* used to factor A as
*    A = P * L * U,
* where P is a permutation matrix, L is unit lower triangular, and U is
* upper triangular.  The factored form of A is then used to solve the
* system of equations A * X = B.
*
* Arguments:
* ==========
*
* \param[in] N
*          N is INTEGER
*          The number of linear equations, i.e., the order of the
*          matrix A.  N >= 0.
*
* \param[in] NRHS
*          NRHS is INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
* \param[in,out] A
*          A is DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the N-by-N coefficient matrix A.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
* \param[in] LDA
*          LDA is INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
* \param[out] IPIV
*          IPIV is INTEGER array, dimension (N)
*          The pivot indices that define the permutation matrix P;
*          row i of the matrix was interchanged with row IPIV(i).
*
* \param[in,out] B
*          B is DOUBLE PRECISION array, dimension (LDB,NRHS)
*          On entry, the N-by-NRHS matrix of right hand side matrix B.
*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
*
* \param[in] LDB
*          LDB is INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
* \param[out] INFO
*          INFO is INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
*                has been completed, but the factor U is exactly
*                singular, so the solution could not be computed.
*
* Authors:
* ========
*
* \author Univ. of Tennessee 
* \author Univ. of California Berkeley 
* \author Univ. of Colorado Denver 
* \author NAG Ltd. 
*
* \date November 2011
*
* \ingroup doubleGEsolve
*
*  =====================================================================
*
*  -- LAPACK driver routine (version 3.4.0) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
*     November 2011
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  =====================================================================
*
*     .. External Subroutines ..
      EXTERNAL           DGETRF, DGETRS, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( N.LT.0 ) THEN
         INFO = -1
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGESV ', -INFO )
         RETURN
      END IF
*
*     Compute the LU factorization of A.
*
      CALL DGETRF( N, N, A, LDA, IPIV, INFO )
      IF( INFO.EQ.0 ) THEN
*
*        Solve the system A*X = B, overwriting B with X.
*
         CALL DGETRS( 'No transpose', N, NRHS, A, LDA, IPIV, B, LDB,
     $                INFO )
      END IF
      RETURN
*
*     End of DGESV
*
      END

C DGETRF
      SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
*
*  Definition:
*  ===========
*
*       SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
* 
*       .. Scalar Arguments ..
*       INTEGER            INFO, LDA, M, N
*       ..
*       .. Array Arguments ..
*       INTEGER            IPIV( * )
*       DOUBLE PRECISION   A( LDA, * )
*       ..
*  
*  Purpose:
* ==========
*
* DGETRF computes an LU factorization of a general M-by-N matrix A
* using partial pivoting with row interchanges.
*
* The factorization has the form
*    A = P * L * U
* where P is a permutation matrix, L is lower triangular with unit
* diagonal elements (lower trapezoidal if m > n), and U is upper
* triangular (upper trapezoidal if m < n).
*
* This is the right-looking Level 3 BLAS version of the algorithm.
*
* Arguments:
* ==========
*
* \param[in] M
* 
*          M is INTEGER
*          The number of rows of the matrix A.  M >= 0.
* 
*
* \param[in] N
* 
*          N is INTEGER
*          The number of columns of the matrix A.  N >= 0.
* 
*
* \param[in,out] A
* 
*          A is DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the M-by-N matrix to be factored.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
* 
*
* \param[in] LDA
* 
*          LDA is INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
* 
*
* \param[out] IPIV
* 
*          IPIV is INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
* 
*
* \param[out] INFO
* 
*          INFO is INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
*                has been completed, but the factor U is exactly
*                singular, and division by zero will occur if it is used
*                to solve a system of equations.
* 
*
* -- LAPACK computational routine (version 3.4.0) --
* -- LAPACK is a software package provided by Univ. of Tennessee,    --
* -- Univ. of California Berkeley, Univ. of Colorado Denver
*    November 2011
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, IINFO, J, JB, NB
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMM, DGETF2, DLASWP, DTRSM, XERBLA
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETRF', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Determine the block size for this environment.
*
      NB = ILAENV( 1, 'DGETRF', ' ', M, N, -1, -1 )
      IF( NB.LE.1 .OR. NB.GE.MIN( M, N ) ) THEN
*
*        Use unblocked code.
*
         CALL DGETF2( M, N, A, LDA, IPIV, INFO )
      ELSE
*
*        Use blocked code.
*
         DO 20 J = 1, MIN( M, N ), NB
            JB = MIN( MIN( M, N )-J+1, NB )
*
*           Factor diagonal and subdiagonal blocks and test for exact
*           singularity.
*
            CALL DGETF2( M-J+1, JB, A( J, J ), LDA, IPIV( J ), IINFO )
*
*           Adjust INFO and the pivot indices.
*
            IF( INFO.EQ.0 .AND. IINFO.GT.0 )
     $         INFO = IINFO + J - 1
            DO 10 I = J, MIN( M, J+JB-1 )
               IPIV( I ) = J - 1 + IPIV( I )
   10       CONTINUE
*
*           Apply interchanges to columns 1:J-1.
*
            CALL DLASWP( J-1, A, LDA, J, J+JB-1, IPIV, 1 )
*
            IF( J+JB.LE.N ) THEN
*
*              Apply interchanges to columns J+JB:N.
*
               CALL DLASWP( N-J-JB+1, A( 1, J+JB ), LDA, J, J+JB-1,
     $                      IPIV, 1 )
*
*              Compute block row of U.
*
               CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit', JB,
     $                     N-J-JB+1, ONE, A( J, J ), LDA, A( J, J+JB ),
     $                     LDA )
               IF( J+JB.LE.M ) THEN
*
*                 Update trailing submatrix.
*
                  CALL DGEMM( 'No transpose', 'No transpose', M-J-JB+1,
     $                        N-J-JB+1, JB, -ONE, A( J+JB, J ), LDA,
     $                        A( J, J+JB ), LDA, ONE, A( J+JB, J+JB ),
     $                        LDA )
               END IF
            END IF
   20    CONTINUE
      END IF
      RETURN
*
*     End of DGETRF
*
      END

C DGETRS
      SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
*      
*  Definition:
*  ===========
*
*       SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
* 
*       .. Scalar Arguments ..
*       CHARACTER          TRANS
*       INTEGER            INFO, LDA, LDB, N, NRHS
*       ..
*       .. Array Arguments ..
*       INTEGER            IPIV( * )
*       DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*       ..
*  
*
*  Purpose:
*  ========
*
* DGETRS solves a system of linear equations
*    A * X = B  or  A**T * X = B
* with a general N-by-N matrix A using the LU factorization computed
* by DGETRF.
*
* Arguments:
* ==========
*
* \param[in] TRANS
* 
*          TRANS is CHARACTER*1
*          Specifies the form of the system of equations:
*          = 'N':  A * X = B  (No transpose)
*          = 'T':  A**T* X = B  (Transpose)
*          = 'C':  A**T* X = B  (Conjugate transpose = Transpose)
*
* \param[in] N
* 
*          N is INTEGER
*          The order of the matrix A.  N >= 0.
*
* \param[in] NRHS
* 
*          NRHS is INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
* \param[in] A
* 
*          A is DOUBLE PRECISION array, dimension (LDA,N)
*          The factors L and U from the factorization A = P*L*U
*          as computed by DGETRF.
*
* \param[in] LDA
* 
*          LDA is INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
* 
* \param[in] IPIV
* 
*          IPIV is INTEGER array, dimension (N)
*          The pivot indices from DGETRF; for 1<=i<=N, row i of the
*          matrix was interchanged with row IPIV(i).
*
* \param[in,out] B
* 
*          B is DOUBLE PRECISION array, dimension (LDB,NRHS)
*          On entry, the right hand side matrix B.
*          On exit, the solution matrix X.
*
* \param[in] LDB
* 
*          LDB is INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
* 
* \param[out] INFO
* 
*          INFO is INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*  -- LAPACK computational routine (version 3.4.0) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd
*     November 2011
*
*     .. Scalar Arguments ..
      CHARACTER          TRANS
      INTEGER            INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            NOTRAN
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLASWP, DTRSM, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      NOTRAN = LSAME( TRANS, 'N' )
      IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) .AND. .NOT.
     $    LSAME( TRANS, 'C' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -8
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETRS', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 .OR. NRHS.EQ.0 )
     $   RETURN
*
      IF( NOTRAN ) THEN
*
*        Solve A * X = B.
*
*        Apply row interchanges to the right hand sides.
*
         CALL DLASWP( NRHS, B, LDB, 1, N, IPIV, 1 )
*
*        Solve L*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
*
*        Solve U*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N,
     $               NRHS, ONE, A, LDA, B, LDB )
      ELSE
*
*        Solve A**T * X = B.
*
*        Solve U**T *X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
*
*        Solve L**T *X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Lower', 'Transpose', 'Unit', N, NRHS, ONE,
     $               A, LDA, B, LDB )
*
*        Apply row interchanges to the solution vectors.
*
         CALL DLASWP( NRHS, B, LDB, 1, N, IPIV, -1 )
      END IF
*
      RETURN
*
*     End of DGETRS
*
      END

C DGETF2
      SUBROUTINE DGETF2( M, N, A, LDA, IPIV, INFO )
*
*  Definition:
*  ===========
*
*       SUBROUTINE DGETF2( M, N, A, LDA, IPIV, INFO )
* 
*       .. Scalar Arguments ..
*       INTEGER            INFO, LDA, M, N
*       ..
*       .. Array Arguments ..
*       INTEGER            IPIV( * )
*       DOUBLE PRECISION   A( LDA, * )
*       ..
*
* Purpose:
* ========
*
* DGETF2 computes an LU factorization of a general m-by-n matrix A
* using partial pivoting with row interchanges.
*
* The factorization has the form
*    A = P * L * U
* where P is a permutation matrix, L is lower triangular with unit
* diagonal elements (lower trapezoidal if m > n), and U is upper
* triangular (upper trapezoidal if m < n).
*
* This is the right-looking Level 2 BLAS version of the algorithm.
*
* Arguments:
* ==========
*
* \param[in] M
* 
*          M is INTEGER
*          The number of rows of the matrix A.  M >= 0.
* 
*
* \param[in] N
* 
*          N is INTEGER
*          The number of columns of the matrix A.  N >= 0.
* 
*
* \param[in,out] A
* 
*          A is DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the m by n matrix to be factored.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
* 
*
* \param[in] LDA
* 
*          LDA is INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
* 
*
* \param[out] IPIV
* 
*          IPIV is INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
* 
*
* \param[out] INFO
* 
*          INFO is INTEGER
*          = 0: successful exit
*          < 0: if INFO = -k, the k-th argument had an illegal value
*          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
*               has been completed, but the factor U is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  =====================================================================
*
*  -- LAPACK computational routine (version 3.4.2) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     September 2012
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      DOUBLE PRECISION   SFMIN 
      INTEGER            I, J, JP
*     ..
*     .. External Functions ..
      DOUBLE PRECISION   DLAMCH      
      INTEGER            IDAMAX
      EXTERNAL           DLAMCH, IDAMAX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGER, DSCAL, DSWAP, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETF2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Compute machine safe minimum 
* 
      SFMIN = DLAMCH('S')  
*
      DO 10 J = 1, MIN( M, N )
*
*        Find pivot and test for singularity.
*
         JP = J - 1 + IDAMAX( M-J+1, A( J, J ), 1 )
         IPIV( J ) = JP
         IF( A( JP, J ).NE.ZERO ) THEN
*
*           Apply the interchange to columns 1:N.
*
            IF( JP.NE.J )
     $         CALL DSWAP( N, A( J, 1 ), LDA, A( JP, 1 ), LDA )
*
*           Compute elements J+1:M of J-th column.
*
            IF( J.LT.M ) THEN 
               IF( ABS(A( J, J )) .GE. SFMIN ) THEN 
                  CALL DSCAL( M-J, ONE / A( J, J ), A( J+1, J ), 1 ) 
               ELSE 
                 DO 20 I = 1, M-J 
                    A( J+I, J ) = A( J+I, J ) / A( J, J ) 
   20            CONTINUE 
               END IF 
            END IF 
*
         ELSE IF( INFO.EQ.0 ) THEN
*
            INFO = J
         END IF
*
         IF( J.LT.MIN( M, N ) ) THEN
*
*           Update trailing submatrix.
*
            CALL DGER( M-J, N-J, -ONE, A( J+1, J ), 1, A( J, J+1 ), LDA,
     $                 A( J+1, J+1 ), LDA )
         END IF
   10 CONTINUE
      RETURN
*
*     End of DGETF2
*
      END

C DLASWP
      SUBROUTINE DLASWP( N, A, LDA, K1, K2, IPIV, INCX )
*
*  Definition:
*  ===========
*
*       SUBROUTINE DLASWP( N, A, LDA, K1, K2, IPIV, INCX )
* 
*       .. Scalar Arguments ..
*       INTEGER            INCX, K1, K2, LDA, N
*       ..
*       .. Array Arguments ..
*       INTEGER            IPIV( * )
*       DOUBLE PRECISION   A( LDA, * )
*       ..
*
* \par Purpose:
* =============
*
* DLASWP performs a series of row interchanges on the matrix A.
* One row interchange is initiated for each of rows K1 through K2 of A.
* 
*
* Arguments:
* ==========
*
* \param[in] N
* 
*          N is INTEGER
*          The number of columns of the matrix A.
* 
*
* \param[in,out] A
* 
*          A is DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the matrix of column dimension N to which the row
*          interchanges will be applied.
*          On exit, the permuted matrix.
* 
*
* \param[in] LDA
* 
*          LDA is INTEGER
*          The leading dimension of the array A.
* 
*
* \param[in] K1
* 
*          K1 is INTEGER
*          The first element of IPIV for which a row interchange will
*          be done.
* 
*
* \param[in] K2
* 
*          K2 is INTEGER
*          The last element of IPIV for which a row interchange will
*          be done.
* 
*
* \param[in] IPIV
* 
*          IPIV is INTEGER array, dimension (K2*abs(INCX))
*          The vector of pivot indices.  Only the elements in positions
*          K1 through K2 of IPIV are accessed.
*          IPIV(K) = L implies rows K and L are to be interchanged.
* 
*
* \param[in] INCX
* 
*          INCX is INTEGER
*          The increment between successive values of IPIV.  If IPIV
*          is negative, the pivots are applied in reverse order.
* 
*
* Authors:
* ========
*
* \author Univ. of Tennessee 
* \author Univ. of California Berkeley 
* \author Univ. of Colorado Denver 
* \author NAG Ltd. 
*
* \date September 2012
*
* \ingroup doubleOTHERauxiliary
*
* \par Further Details:
* =====================
*
* 
*
*  Modified by
*   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
* 
*
*  =====================================================================
*
*  -- LAPACK auxiliary routine (version 3.4.2) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     September 2012
*
*     .. Scalar Arguments ..
      INTEGER            INCX, K1, K2, LDA, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
* =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I, I1, I2, INC, IP, IX, IX0, J, K, N32
      DOUBLE PRECISION   TEMP
*     ..
*     .. Executable Statements ..
*
*     Interchange row I with row IPIV(I) for each of rows K1 through K2.
*
      IF( INCX.GT.0 ) THEN
         IX0 = K1
         I1 = K1
         I2 = K2
         INC = 1
      ELSE IF( INCX.LT.0 ) THEN
         IX0 = 1 + ( 1-K2 )*INCX
         I1 = K2
         I2 = K1
         INC = -1
      ELSE
         RETURN
      END IF
*
      N32 = ( N / 32 )*32
      IF( N32.NE.0 ) THEN
         DO 30 J = 1, N32, 32
            IX = IX0
            DO 20 I = I1, I2, INC
               IP = IPIV( IX )
               IF( IP.NE.I ) THEN
                  DO 10 K = J, J + 31
                     TEMP = A( I, K )
                     A( I, K ) = A( IP, K )
                     A( IP, K ) = TEMP
   10             CONTINUE
               END IF
               IX = IX + INCX
   20       CONTINUE
   30    CONTINUE
      END IF
      IF( N32.NE.N ) THEN
         N32 = N32 + 1
         IX = IX0
         DO 50 I = I1, I2, INC
            IP = IPIV( IX )
            IF( IP.NE.I ) THEN
               DO 40 K = N32, N
                  TEMP = A( I, K )
                  A( I, K ) = A( IP, K )
                  A( IP, K ) = TEMP
   40          CONTINUE
            END IF
            IX = IX + INCX
   50    CONTINUE
      END IF
*
      RETURN
*
*     End of DLASWP
*
      END

C DTRSM
      SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
*
*  Definition:
*  ===========
*
*       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)
* 
*       .. Scalar Arguments ..
*       DOUBLE PRECISION ALPHA
*       INTEGER LDA,LDB,M,N
*       CHARACTER DIAG,SIDE,TRANSA,UPLO
*       ..
*       .. Array Arguments ..
*       DOUBLE PRECISION A(LDA,*),B(LDB,*)
*       ..
*
* Purpose:
* ========
*
* DTRSM  solves one of the matrix equations
*
*    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
*
* where alpha is a scalar, X and B are m by n matrices, A is a unit, or
* non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
*
*    op( A ) = A   or   op( A ) = A**T.
*
* The matrix X is overwritten on B.
*
* Arguments:
* ==========
*
* \param[in] SIDE
* 
*          SIDE is CHARACTER*1
*           On entry, SIDE specifies whether op( A ) appears on the left
*           or right of X as follows:
*
*              SIDE = 'L' or 'l'   op( A )*X = alpha*B.
*
*              SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
* 
*
* \param[in] UPLO
* 
*          UPLO is CHARACTER*1
*           On entry, UPLO specifies whether the matrix A is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
* 
*
* \param[in] TRANSA
* 
*          TRANSA is CHARACTER*1
*           On entry, TRANSA specifies the form of op( A ) to be used in
*           the matrix multiplication as follows:
*
*              TRANSA = 'N' or 'n'   op( A ) = A.
*
*              TRANSA = 'T' or 't'   op( A ) = A**T.
*
*              TRANSA = 'C' or 'c'   op( A ) = A**T.
* 
*
* \param[in] DIAG
* 
*          DIAG is CHARACTER*1
*           On entry, DIAG specifies whether or not A is unit triangular
*           as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
* \param[in] M
* 
*          M is INTEGER
*           On entry, M specifies the number of rows of B. M must be at
*           least zero.
* 
*
* \param[in] N
* 
*          N is INTEGER
*           On entry, N specifies the number of columns of B.  N must be
*           at least zero.
* 
*
* \param[in] ALPHA
* 
*          ALPHA is DOUBLE PRECISION.
*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
*           zero then  A is not referenced and  B need not be set before
*           entry.
* 
*
* \param[in] A
* 
*          A is DOUBLE PRECISION array of DIMENSION ( LDA, k ),
*           where k is m when SIDE = 'L' or 'l'  
*             and k is n when SIDE = 'R' or 'r'.
*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*           upper triangular part of the array  A must contain the upper
*           triangular matrix  and the strictly lower triangular part of
*           A is not referenced.
*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
*           lower triangular part of the array  A must contain the lower
*           triangular matrix  and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
*           A  are not referenced either,  but are assumed to be  unity.
* 
*
* \param[in] LDA
* 
*          LDA is INTEGER
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*           then LDA must be at least max( 1, n ).
* 
*
* \param[in,out] B
* 
*          B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
*           Before entry,  the leading  m by n part of the array  B must
*           contain  the  right-hand  side  matrix  B,  and  on exit  is
*           overwritten by the solution matrix  X.
* 
*
* \param[in] LDB
* 
*          LDB is INTEGER
*           On entry, LDB specifies the first dimension of B as declared
*           in  the  calling  (sub)  program.   LDB  must  be  at  least
*           max( 1, m ).
*
*  Level 3 Blas routine.
*
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Iain Duff, Jeremy Du Croz, Sven Hammarling
*
*  =====================================================================
*
*  -- Reference BLAS level3 routine (version 3.4.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2011
*
*     .. Scalar Arguments ..
      DOUBLE PRECISION ALPHA
      INTEGER LDA,LDB,M,N
      CHARACTER DIAG,SIDE,TRANSA,UPLO
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION A(LDA,*),B(LDB,*)
*     ..
*
*  =====================================================================
*
*     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC MAX
*     ..
*     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,INFO,J,K,NROWA
      LOGICAL LSIDE,NOUNIT,UPPER
*     ..
*     .. Parameters ..
      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
*     ..
*
*     Test the input parameters.
*
      LSIDE = LSAME(SIDE,'L')
      IF (LSIDE) THEN
          NROWA = M
      ELSE
          NROWA = N
      END IF
      NOUNIT = LSAME(DIAG,'N')
      UPPER = LSAME(UPLO,'U')
*
      INFO = 0
      IF ((.NOT.LSIDE) .AND. (.NOT.LSAME(SIDE,'R'))) THEN
          INFO = 1
      ELSE IF ((.NOT.UPPER) .AND. (.NOT.LSAME(UPLO,'L'))) THEN
          INFO = 2
      ELSE IF ((.NOT.LSAME(TRANSA,'N')) .AND.
     +         (.NOT.LSAME(TRANSA,'T')) .AND.
     +         (.NOT.LSAME(TRANSA,'C'))) THEN
          INFO = 3
      ELSE IF ((.NOT.LSAME(DIAG,'U')) .AND. (.NOT.LSAME(DIAG,'N'))) THEN
          INFO = 4
      ELSE IF (M.LT.0) THEN
          INFO = 5
      ELSE IF (N.LT.0) THEN
          INFO = 6
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN
          INFO = 9
      ELSE IF (LDB.LT.MAX(1,M)) THEN
          INFO = 11
      END IF
      IF (INFO.NE.0) THEN
          CALL XERBLA('DTRSM ',INFO)
          RETURN
      END IF
*
*     Quick return if possible.
*
      IF (M.EQ.0 .OR. N.EQ.0) RETURN
*
*     And when  alpha.eq.zero.
*
      IF (ALPHA.EQ.ZERO) THEN
          DO 20 J = 1,N
              DO 10 I = 1,M
                  B(I,J) = ZERO
   10         CONTINUE
   20     CONTINUE
          RETURN
      END IF
*
*     Start the operations.
*
      IF (LSIDE) THEN
          IF (LSAME(TRANSA,'N')) THEN
*
*           Form  B := alpha*inv( A )*B.
*
              IF (UPPER) THEN
                  DO 60 J = 1,N
                      IF (ALPHA.NE.ONE) THEN
                          DO 30 I = 1,M
                              B(I,J) = ALPHA*B(I,J)
   30                     CONTINUE
                      END IF
                      DO 50 K = M,1,-1
                          IF (B(K,J).NE.ZERO) THEN
                              IF (NOUNIT) B(K,J) = B(K,J)/A(K,K)
                              DO 40 I = 1,K - 1
                                  B(I,J) = B(I,J) - B(K,J)*A(I,K)
   40                         CONTINUE
                          END IF
   50                 CONTINUE
   60             CONTINUE
              ELSE
                  DO 100 J = 1,N
                      IF (ALPHA.NE.ONE) THEN
                          DO 70 I = 1,M
                              B(I,J) = ALPHA*B(I,J)
   70                     CONTINUE
                      END IF
                      DO 90 K = 1,M
                          IF (B(K,J).NE.ZERO) THEN
                              IF (NOUNIT) B(K,J) = B(K,J)/A(K,K)
                              DO 80 I = K + 1,M
                                  B(I,J) = B(I,J) - B(K,J)*A(I,K)
   80                         CONTINUE
                          END IF
   90                 CONTINUE
  100             CONTINUE
              END IF
          ELSE
*
*           Form  B := alpha*inv( A**T )*B.
*
              IF (UPPER) THEN
                  DO 130 J = 1,N
                      DO 120 I = 1,M
                          TEMP = ALPHA*B(I,J)
                          DO 110 K = 1,I - 1
                              TEMP = TEMP - A(K,I)*B(K,J)
  110                     CONTINUE
                          IF (NOUNIT) TEMP = TEMP/A(I,I)
                          B(I,J) = TEMP
  120                 CONTINUE
  130             CONTINUE
              ELSE
                  DO 160 J = 1,N
                      DO 150 I = M,1,-1
                          TEMP = ALPHA*B(I,J)
                          DO 140 K = I + 1,M
                              TEMP = TEMP - A(K,I)*B(K,J)
  140                     CONTINUE
                          IF (NOUNIT) TEMP = TEMP/A(I,I)
                          B(I,J) = TEMP
  150                 CONTINUE
  160             CONTINUE
              END IF
          END IF
      ELSE
          IF (LSAME(TRANSA,'N')) THEN
*
*           Form  B := alpha*B*inv( A ).
*
              IF (UPPER) THEN
                  DO 210 J = 1,N
                      IF (ALPHA.NE.ONE) THEN
                          DO 170 I = 1,M
                              B(I,J) = ALPHA*B(I,J)
  170                     CONTINUE
                      END IF
                      DO 190 K = 1,J - 1
                          IF (A(K,J).NE.ZERO) THEN
                              DO 180 I = 1,M
                                  B(I,J) = B(I,J) - A(K,J)*B(I,K)
  180                         CONTINUE
                          END IF
  190                 CONTINUE
                      IF (NOUNIT) THEN
                          TEMP = ONE/A(J,J)
                          DO 200 I = 1,M
                              B(I,J) = TEMP*B(I,J)
  200                     CONTINUE
                      END IF
  210             CONTINUE
              ELSE
                  DO 260 J = N,1,-1
                      IF (ALPHA.NE.ONE) THEN
                          DO 220 I = 1,M
                              B(I,J) = ALPHA*B(I,J)
  220                     CONTINUE
                      END IF
                      DO 240 K = J + 1,N
                          IF (A(K,J).NE.ZERO) THEN
                              DO 230 I = 1,M
                                  B(I,J) = B(I,J) - A(K,J)*B(I,K)
  230                         CONTINUE
                          END IF
  240                 CONTINUE
                      IF (NOUNIT) THEN
                          TEMP = ONE/A(J,J)
                          DO 250 I = 1,M
                              B(I,J) = TEMP*B(I,J)
  250                     CONTINUE
                      END IF
  260             CONTINUE
              END IF
          ELSE
*
*           Form  B := alpha*B*inv( A**T ).
*
              IF (UPPER) THEN
                  DO 310 K = N,1,-1
                      IF (NOUNIT) THEN
                          TEMP = ONE/A(K,K)
                          DO 270 I = 1,M
                              B(I,K) = TEMP*B(I,K)
  270                     CONTINUE
                      END IF
                      DO 290 J = 1,K - 1
                          IF (A(J,K).NE.ZERO) THEN
                              TEMP = A(J,K)
                              DO 280 I = 1,M
                                  B(I,J) = B(I,J) - TEMP*B(I,K)
  280                         CONTINUE
                          END IF
  290                 CONTINUE
                      IF (ALPHA.NE.ONE) THEN
                          DO 300 I = 1,M
                              B(I,K) = ALPHA*B(I,K)
  300                     CONTINUE
                      END IF
  310             CONTINUE
              ELSE
                  DO 360 K = 1,N
                      IF (NOUNIT) THEN
                          TEMP = ONE/A(K,K)
                          DO 320 I = 1,M
                              B(I,K) = TEMP*B(I,K)
  320                     CONTINUE
                      END IF
                      DO 340 J = K + 1,N
                          IF (A(J,K).NE.ZERO) THEN
                              TEMP = A(J,K)
                              DO 330 I = 1,M
                                  B(I,J) = B(I,J) - TEMP*B(I,K)
  330                         CONTINUE
                          END IF
  340                 CONTINUE
                      IF (ALPHA.NE.ONE) THEN
                          DO 350 I = 1,M
                              B(I,K) = ALPHA*B(I,K)
  350                     CONTINUE
                      END IF
  360             CONTINUE
              END IF
          END IF
      END IF
*
      RETURN
*
*     End of DTRSM .
*
      END

C LSAME
      LOGICAL FUNCTION LSAME( CA, CB )
C
C  -- LAPACK AUXILIARY ROUTINE (VERSION 1.1) --
C     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
C     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
C     FEBRUARY 29, 1992 
C
C     .. SCALAR ARGUMENTS ..
      CHARACTER          CA, CB
C     ..
C
C  PURPOSE
C  =======
C
C  LSAME RETURNS .TRUE. IF CA IS THE SAME LETTER AS CB REGARDLESS OF
C  CASE.
C
C  ARGUMENTS
C  =========
C
C  CA      (INPUT) CHARACTER*1
C  CB      (INPUT) CHARACTER*1
C          CA AND CB SPECIFY THE SINGLE CHARACTERS TO BE COMPARED.
C
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          ICHAR
C     ..
C     .. LOCAL SCALARS ..
      INTEGER            INTA, INTB, ZCODE
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
C     TEST IF THE CHARACTERS ARE EQUAL
C
      LSAME = CA==CB
      IF( LSAME )
     $   RETURN
C
C     NOW TEST FOR EQUIVALENCE IF BOTH CHARACTERS ARE ALPHABETIC.
C
      ZCODE = ICHAR( 'Z' )
C
C     USE 'Z' RATHER THAN 'A' SO THAT ASCII CAN BE DETECTED ON PRIME
C     MACHINES, ON WHICH ICHAR RETURNS A VALUE WITH BIT 8 SET.
C     ICHAR('A') ON PRIME MACHINES RETURNS 193 WHICH IS THE SAME AS
C     ICHAR('A') ON AN EBCDIC MACHINE.
C
      INTA = ICHAR( CA )
      INTB = ICHAR( CB )
C
      IF( ZCODE==90 .OR. ZCODE==122 ) THEN
C
C        ASCII IS ASSUMED - ZCODE IS THE ASCII CODE OF EITHER LOWER OR
C        UPPER CASE 'Z'.
C
         IF( INTA.GE.97 .AND. INTA<=122 ) INTA = INTA - 32
         IF( INTB.GE.97 .AND. INTB<=122 ) INTB = INTB - 32
C
      ELSE IF( ZCODE==233 .OR. ZCODE==169 ) THEN
C
C        EBCDIC IS ASSUMED - ZCODE IS THE EBCDIC CODE OF EITHER LOWER OR
C        UPPER CASE 'Z'.
C
         IF( INTA.GE.129 .AND. INTA<=137 .OR.
     $       INTA.GE.145 .AND. INTA<=153 .OR.
     $       INTA.GE.162 .AND. INTA<=169 ) INTA = INTA + 64
         IF( INTB.GE.129 .AND. INTB<=137 .OR.
     $       INTB.GE.145 .AND. INTB<=153 .OR.
     $       INTB.GE.162 .AND. INTB<=169 ) INTB = INTB + 64
C
      ELSE IF( ZCODE==218 .OR. ZCODE==250 ) THEN
C
C        ASCII IS ASSUMED, ON PRIME MACHINES - ZCODE IS THE ASCII CODE
C        PLUS 128 OF EITHER LOWER OR UPPER CASE 'Z'.
C
         IF( INTA.GE.225 .AND. INTA<=250 ) INTA = INTA - 32
         IF( INTB.GE.225 .AND. INTB<=250 ) INTB = INTB - 32
      END IF
      LSAME = INTA==INTB
C
C     RETURN
C
C     END OF LSAME
C
      END

C XERBLA
      SUBROUTINE XERBLA( SRNAME, INFO )
C
C  -- LAPACK AUXILIARY ROUTINE (VERSION 1.1) --
C     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
C     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
C     FEBRUARY 29, 1992
C
C     .. SCALAR ARGUMENTS ..
      CHARACTER*6        SRNAME
      INTEGER            INFO
C     ..
C
C  PURPOSE
C  =======
C
C  XERBLA  IS AN ERROR HANDLER FOR THE LAPACK ROUTINES.
C  IT IS CALLED BY AN LAPACK ROUTINE IF AN INPUT PARAMETER HAS AN
C  INVALID VALUE.  A MESSAGE IS PRINTED AND EXECUTION STOPS.
C
C  INSTALLERS MAY CONSIDER MODIFYING THE STOP STATEMENT IN ORDER TO
C  CALL SYSTEM-SPECIFIC EXCEPTION-HANDLING FACILITIES.
C
C  ARGUMENTS
C  =========
C
C  SRNAME  (INPUT) CHARACTER*6
C          THE NAME OF THE ROUTINE WHICH CALLED XERBLA.
C
C  INFO    (INPUT) INTEGER
C          THE POSITION OF THE INVALID PARAMETER IN THE PARAMETER LIST
C          OF THE CALLING ROUTINE.
C
C     .. EXECUTABLE STATEMENTS ..
C
      WRITE( *, FMT = 9999) SRNAME,INFO
      CALL ABRT
      STOP
C
 9999 FORMAT( ' ** ON ENTRY TO ', A6, ' PARAMETER NUMBER ', I2, ' HAD ',
     $      'AN ILLEGAL VALUE' )
C
C     END OF XERBLA
C
      END

C ILAENV
      INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )
C
C  -- LAPACK AUXILIARY ROUTINE (PRELIMINARY VERSION) --
C     UNIV. OF TENNESSEE, UNIV. OF CALIFORNIA BERKELEY, NAG LTD.,
C     COURANT INSTITUTE, ARGONNE NATIONAL LAB, AND RICE UNIVERSITY
C     FEBRUARY 20, 1992
C
C     .. SCALAR ARGUMENTS ..
      CHARACTER*( * )    NAME, OPTS
      INTEGER            ISPEC, N1, N2, N3, N4
C     ..
C
C  PURPOSE
C  =======
C
C  ILAENV IS CALLED FROM THE LAPACK ROUTINES TO CHOOSE PROBLEM-DEPENDENT
C  PARAMETERS FOR THE LOCAL ENVIRONMENT.  SEE ISPEC FOR A DESCRIPTION OF
C  THE PARAMETERS.
C
C  THIS VERSION PROVIDES A SET OF PARAMETERS WHICH SHOULD GIVE GOOD,
C  BUT NOT OPTIMAL, PERFORMANCE ON MANY OF THE CURRENTLY AVAILABLE
C  COMPUTERS.  USERS ARE ENCOURAGED TO MODIFY THIS SUBROUTINE TO SET
C  THE TUNING PARAMETERS FOR THEIR PARTICULAR MACHINE USING THE OPTION
C  AND PROBLEM SIZE INFORMATION IN THE ARGUMENTS.
C
C  THIS ROUTINE WILL NOT FUNCTION CORRECTLY IF IT IS CONVERTED TO ALL
C  LOWER CASE.  CONVERTING IT TO ALL UPPER CASE IS ALLOWED.
C
C  ARGUMENTS
C  =========
C
C  ISPEC   (INPUT) INTEGER
C          SPECIFIES THE PARAMETER TO BE RETURNED AS THE VALUE OF
C          ILAENV.
C          = 1: THE OPTIMAL BLOCKSIZE; IF THIS VALUE IS 1, AN UNBLOCKED
C               ALGORITHM WILL GIVE THE BEST PERFORMANCE.
C          = 2: THE MINIMUM BLOCK SIZE FOR WHICH THE BLOCK ROUTINE
C               SHOULD BE USED; IF THE USABLE BLOCK SIZE IS LESS THAN
C               THIS VALUE, AN UNBLOCKED ROUTINE SHOULD BE USED.
C          = 3: THE CROSSOVER POINT (IN A BLOCK ROUTINE, FOR N LESS
C               THAN THIS VALUE, AN UNBLOCKED ROUTINE SHOULD BE USED)
C          = 4: THE NUMBER OF SHIFTS, USED IN THE NONSYMMETRIC
C               EIGENVALUE ROUTINES
C          = 5: THE MINIMUM COLUMN DIMENSION FOR BLOCKING TO BE USED;
C               RECTANGULAR BLOCKS MUST HAVE DIMENSION AT LEAST K BY M,
C               WHERE K IS GIVEN BY ILAENV(2,...) AND M BY ILAENV(5,...)
C          = 6: THE CROSSOVER POINT FOR THE SVD (WHEN REDUCING AN M BY N
C               MATRIX TO BIDIAGONAL FORM, IF MAX(M,N)/MIN(M,N) EXCEEDS
C               THIS VALUE, A QR FACTORIZATION IS USED FIRST TO REDUCE
C               THE MATRIX TO A TRIANGULAR FORM.)
C          = 7: THE NUMBER OF PROCESSORS
C          = 8: THE CROSSOVER POINT FOR THE MULTISHIFT QR AND QZ METHODS
C               FOR NONSYMMETRIC EIGENVALUE PROBLEMS.
C
C  NAME    (INPUT) CHARACTER*(*)
C          THE NAME OF THE CALLING SUBROUTINE, IN EITHER UPPER CASE OR
C          LOWER CASE.
C
C  OPTS    (INPUT) CHARACTER*(*)
C          THE CHARACTER OPTIONS TO THE SUBROUTINE NAME, CONCATENATED
C          INTO A SINGLE CHARACTER STRING.  FOR EXAMPLE, UPLO = 'U',
C          TRANS = 'T', AND DIAG = 'N' FOR A TRIANGULAR ROUTINE WOULD
C          BE SPECIFIED AS OPTS = 'UTN'.
C
C  N1      (INPUT) INTEGER
C  N2      (INPUT) INTEGER
C  N3      (INPUT) INTEGER
C  N4      (INPUT) INTEGER
C          PROBLEM DIMENSIONS FOR THE SUBROUTINE NAME; THESE MAY NOT ALL
C          BE REQUIRED.
C
C (ILAENV) (OUTPUT) INTEGER
C          >= 0: THE VALUE OF THE PARAMETER SPECIFIED BY ISPEC
C          < 0:  IF ILAENV = -K, THE K-TH ARGUMENT HAD AN ILLEGAL VALUE.
C
C  FURTHER DETAILS
C  ===============
C
C  THE FOLLOWING CONVENTIONS HAVE BEEN USED WHEN CALLING ILAENV FROM THE
C  LAPACK ROUTINES:
C  1)  OPTS IS A CONCATENATION OF ALL OF THE CHARACTER OPTIONS TO
C      SUBROUTINE NAME, IN THE SAME ORDER THAT THEY APPEAR IN THE
C      ARGUMENT LIST FOR NAME, EVEN IF THEY ARE NOT USED IN DETERMINING
C      THE VALUE OF THE PARAMETER SPECIFIED BY ISPEC.
C  2)  THE PROBLEM DIMENSIONS N1, N2, N3, N4 ARE SPECIFIED IN THE ORDER
C      THAT THEY APPEAR IN THE ARGUMENT LIST FOR NAME.  N1 IS USED
C      FIRST, N2 SECOND, AND SO ON, AND UNUSED PROBLEM DIMENSIONS ARE
C      PASSED A VALUE OF -1.
C  3)  THE PARAMETER VALUE RETURNED BY ILAENV IS CHECKED FOR VALIDITY IN
C      THE CALLING SUBROUTINE.  FOR EXAMPLE, ILAENV IS USED TO RETRIEVE
C      THE OPTIMAL BLOCKSIZE FOR STRTRI AS FOLLOWS:
C
C      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
C      IF( NB<=1 ) NB = MAX( 1, N )
C
C  =====================================================================
C
C     .. LOCAL SCALARS ..
      LOGICAL            CNAME, SNAME
      CHARACTER*1        C1
      CHARACTER*2        C2, C4
      CHARACTER*3        C3
      CHARACTER*6        SUBNAM
      INTEGER            I, IC, IZ, NB, NBMIN, NX
C     ..
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
C         NEXT BIT ADDED BY MWS TO SUPPRESS FTNCHEK WARNINGS
      IF(ISPEC>8) THEN
         WRITE(6,*) 'DUMMY MESSAGE TO USE ARGS OPTS AND N3',N3,OPTS
      END IF
C
      GO TO ( 100, 100, 100, 400, 500, 600, 700, 800 ) ISPEC
C
C     INVALID VALUE FOR ISPEC
C
      ILAENV = -1
      RETURN
C
  100 CONTINUE
C
C     CONVERT NAME TO UPPER CASE IF THE FIRST CHARACTER IS LOWER CASE.
C
      ILAENV = 1
      SUBNAM = NAME
      IC = ICHAR( SUBNAM( 1:1 ) )
      IZ = ICHAR( 'Z' )
      IF( IZ==90 .OR. IZ==122 ) THEN
C
C        ASCII CHARACTER SET
C
         IF( IC.GE.97 .AND. IC<=122 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 10 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.97 .AND. IC<=122 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   10       CONTINUE
         END IF
C
      ELSE IF( IZ==233 .OR. IZ==169 ) THEN
C
C        EBCDIC CHARACTER SET
C
         IF( ( IC.GE.129 .AND. IC<=137 ) .OR.
     $       ( IC.GE.145 .AND. IC<=153 ) .OR.
     $       ( IC.GE.162 .AND. IC<=169 ) ) THEN
            SUBNAM( 1:1 ) = CHAR( IC+64 )
            DO 20 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( ( IC.GE.129 .AND. IC<=137 ) .OR.
     $             ( IC.GE.145 .AND. IC<=153 ) .OR.
     $             ( IC.GE.162 .AND. IC<=169 ) )
     $            SUBNAM( I:I ) = CHAR( IC+64 )
   20       CONTINUE
         END IF
C
      ELSE IF( IZ==218 .OR. IZ==250 ) THEN
C
C        PRIME MACHINES:  ASCII+128
C
         IF( IC.GE.225 .AND. IC<=250 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 30 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.225 .AND. IC<=250 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   30       CONTINUE
         END IF
      END IF
C
      C1 = SUBNAM( 1:1 )
      SNAME = C1=='S' .OR. C1=='D'
      CNAME = C1=='C' .OR. C1=='Z'
      IF( .NOT.( CNAME .OR. SNAME ) )
     $   RETURN
      C2 = SUBNAM( 2:3 )
      C3 = SUBNAM( 4:6 )
      C4 = C3( 2:3 )
C
      GO TO ( 110, 200, 300 ) ISPEC
C
  110 CONTINUE
C
C     ISPEC = 1:  BLOCK SIZE
C
C     IN THESE EXAMPLES, SEPARATE CODE IS PROVIDED FOR SETTING NB FOR
C     REAL AND COMPLEX.  WE ASSUME THAT NB WILL TAKE THE SAME VALUE IN
C     SINGLE OR DOUBLE PRECISION.
C
      NB = 1
C
      IF( C2=='GE' ) THEN
         IF( C3=='TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         ELSE IF( C3=='QRF' .OR. C3=='RQF' .OR. C3=='LQF' .OR.
     $            C3=='QLF' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3=='HRD' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3=='BRD' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3=='TRI' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2=='PO' ) THEN
         IF( C3=='TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2=='SY' ) THEN
         IF( C3=='TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         ELSE IF( SNAME .AND. C3=='TRD' ) THEN
            NB = 1
         ELSE IF( SNAME .AND. C3=='GST' ) THEN
            NB = 64
         END IF
      ELSE IF( CNAME .AND. C2=='HE' ) THEN
         IF( C3=='TRF' ) THEN
            NB = 64
         ELSE IF( C3=='TRD' ) THEN
            NB = 1
         ELSE IF( C3=='GST' ) THEN
            NB = 64
         END IF
      ELSE IF( SNAME .AND. C2=='OR' ) THEN
         IF( C3( 1:1 )=='G' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NB = 32
            END IF
         ELSE IF( C3( 1:1 )=='M' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NB = 32
            END IF
         END IF
      ELSE IF( CNAME .AND. C2=='UN' ) THEN
         IF( C3( 1:1 )=='G' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NB = 32
            END IF
         ELSE IF( C3( 1:1 )=='M' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NB = 32
            END IF
         END IF
      ELSE IF( C2=='GB' ) THEN
         IF( C3=='TRF' ) THEN
            IF( SNAME ) THEN
               IF( N4<=64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            ELSE
               IF( N4<=64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            END IF
         END IF
      ELSE IF( C2=='PB' ) THEN
         IF( C3=='TRF' ) THEN
            IF( SNAME ) THEN
               IF( N2<=64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            ELSE
               IF( N2<=64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            END IF
         END IF
      ELSE IF( C2=='TR' ) THEN
         IF( C3=='TRI' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2=='LA' ) THEN
         IF( C3=='UUM' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( SNAME .AND. C2=='ST' ) THEN
         IF( C3=='EBZ' ) THEN
            NB = 1
         END IF
      END IF
      ILAENV = NB
      RETURN
C
  200 CONTINUE
C
C     ISPEC = 2:  MINIMUM BLOCK SIZE
C
      NBMIN = 2
      IF( C2=='GE' ) THEN
         IF( C3=='QRF' .OR. C3=='RQF' .OR. C3=='LQF' .OR.
     $       C3=='QLF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3=='HRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3=='BRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3=='TRI' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         END IF
      ELSE IF( C2=='SY' ) THEN
         IF( C3=='TRF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( SNAME .AND. C3=='TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( CNAME .AND. C2=='HE' ) THEN
         IF( C3=='TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( SNAME .AND. C2=='OR' ) THEN
         IF( C3( 1:1 )=='G' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 )=='M' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      ELSE IF( CNAME .AND. C2=='UN' ) THEN
         IF( C3( 1:1 )=='G' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 )=='M' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      END IF
      ILAENV = NBMIN
      RETURN
C
  300 CONTINUE
C
C     ISPEC = 3:  CROSSOVER POINT
C
      NX = 0
      IF( C2=='GE' ) THEN
         IF( C3=='QRF' .OR. C3=='RQF' .OR. C3=='LQF' .OR.
     $       C3=='QLF' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3=='HRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3=='BRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         END IF
      ELSE IF( C2=='SY' ) THEN
         IF( SNAME .AND. C3=='TRD' ) THEN
            NX = 1
         END IF
      ELSE IF( CNAME .AND. C2=='HE' ) THEN
         IF( C3=='TRD' ) THEN
            NX = 1
         END IF
      ELSE IF( SNAME .AND. C2=='OR' ) THEN
         IF( C3( 1:1 )=='G' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NX = 128
            END IF
         END IF
      ELSE IF( CNAME .AND. C2=='UN' ) THEN
         IF( C3( 1:1 )=='G' ) THEN
            IF( C4=='QR' .OR. C4=='RQ' .OR. C4=='LQ' .OR.
     $          C4=='QL' .OR. C4=='HR' .OR. C4=='TR' .OR.
     $          C4=='BR' ) THEN
               NX = 128
            END IF
         END IF
      END IF
      ILAENV = NX
      RETURN
C
  400 CONTINUE
C
C     ISPEC = 4:  NUMBER OF SHIFTS (USED BY XHSEQR)
C
      ILAENV = 6
      RETURN
C
  500 CONTINUE
C
C     ISPEC = 5:  MINIMUM COLUMN DIMENSION (NOT USED)
C
      ILAENV = 2
      RETURN
C
  600 CONTINUE 
C
C     ISPEC = 6:  CROSSOVER POINT FOR SVD (USED BY XGELSS AND XGESVD)
C
      ILAENV = INT( MIN(N1,N2)*1.6D+00 )
      RETURN
C
  700 CONTINUE
C
C     ISPEC = 7:  NUMBER OF PROCESSORS (NOT USED)
C
      ILAENV = 1
      RETURN
C
  800 CONTINUE
C
C     ISPEC = 8:  CROSSOVER POINT FOR MULTISHIFT (USED BY XHSEQR)
C
      ILAENV = 50
      RETURN
C
C     END OF ILAENV
C
      END

!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!                                                                      !
!                            BLAS SUBROUTINES                          !
!                                                                      !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !

C DASUM
      DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
      INTEGER incx,n
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION dx(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
      DOUBLE PRECISION dtemp
      INTEGER i,m,mp1,nincx
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC dabs,mod
*     ..
      dasum = 0.0d0
      dtemp = 0.0d0
      IF (n.LE.0 .OR. incx.LE.0) RETURN
      IF (incx.EQ.1) THEN
*        code for increment equal to 1
*
*
*        clean-up loop
*
         m = mod(n,6)
         IF (m.NE.0) THEN
            DO i = 1,m
               dtemp = dtemp + dabs(dx(i))
            END DO
            IF (n.LT.6) THEN
               dasum = dtemp
               RETURN
            END IF
         END IF
         mp1 = m + 1
         DO i = mp1,n,6
            dtemp = dtemp + dabs(dx(i)) + dabs(dx(i+1)) +
     $              dabs(dx(i+2)) + dabs(dx(i+3)) +
     $              dabs(dx(i+4)) + dabs(dx(i+5))
         END DO
      ELSE
*
*        code for increment not equal to 1
*
         nincx = n*incx
         DO i = 1,nincx,incx
            dtemp = dtemp + dabs(dx(i))
         END DO
      END IF
      dasum = dtemp
      RETURN
      END

C DROT
      SUBROUTINE DROT(N,DX,INCX,DY,INCY,C,S)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
      DOUBLE PRECISION C,S
      INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION DX(*),DY(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
      DOUBLE PRECISION DTEMP
      INTEGER I,IX,IY
*     ..
      IF (n.LE.0) RETURN
      IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*       code for both increments equal to 1
*
         DO i = 1,n
            dtemp = c*dx(i) + s*dy(i)
            dy(i) = c*dy(i) - s*dx(i)
            dx(i) = dtemp
         END DO
      ELSE
*
*       code for unequal increments or equal increments not equal
*         to 1
*
         ix = 1
         iy = 1
         IF (incx.LT.0) ix = (-n+1)*incx + 1
         IF (incy.LT.0) iy = (-n+1)*incy + 1
         DO i = 1,n
            dtemp = c*dx(ix) + s*dy(iy)
            dy(iy) = c*dy(iy) - s*dx(ix)
            dx(ix) = dtemp
            ix = ix + incx
            iy = iy + incy
         END DO
      END IF
      RETURN
      END

C DROTG
      SUBROUTINE DROTG(DA,DB,C,S)
C
C     CONSTRUCT GIVENS PLANE ROTATION.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DA,DB,C,S,ROE,SCALE,R,Z
      DOUBLE PRECISION ZERO, ONE
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C-----------------------------------------------------------------------
C
C
      ROE = DB
      IF( ABS(DA) > ABS(DB) ) ROE = DA
      SCALE = ABS(DA) + ABS(DB)
      IF( SCALE /= ZERO ) GO TO 10
         C = ONE
         S = ZERO
         R = ZERO
         GO TO 20
C
   10 R = SCALE*SQRT((DA/SCALE)**2 + (DB/SCALE)**2)
      R = SIGN(ONE,ROE)*R
      C = DA/R
      S = DB/R
   20 Z = ONE
      IF( ABS(DA) > ABS(DB) ) Z = S
      IF( ABS(DB) .GE. ABS(DA) .AND. C /= ZERO ) Z = ONE/C
      DA = R
      DB = Z
      RETURN
      END

C DTRMM
      SUBROUTINE DTRMM ( SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA,
     $                   B, LDB )
C     .. SCALAR ARGUMENTS ..
      CHARACTER*1      SIDE, UPLO, TRANSA, DIAG
      INTEGER            M, N, LDA, LDB
      DOUBLE PRECISION   ALPHA
C     .. ARRAY ARGUMENTS ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
C     ..
C
C  PURPOSE
C  =======
C
C  DTRMM  PERFORMS ONE OF THE MATRIX-MATRIX OPERATIONS
C
C     B := ALPHA*OP( A )*B,   OR   B := ALPHA*B*OP( A ),
C
C  WHERE  ALPHA  IS A SCALAR,  B  IS AN M BY N MATRIX,  A  IS A UNIT, OR
C  NON-UNIT,  UPPER OR LOWER TRIANGULAR MATRIX  AND  OP( A )  IS ONE  OF
C
C     OP( A ) = A   OR   OP( A ) = A'.
C
C  PARAMETERS
C  ==========
C
C  SIDE   - CHARACTER*1.
C           ON ENTRY,  SIDE SPECIFIES WHETHER  OP( A ) MULTIPLIES B FROM
C           THE LEFT OR RIGHT AS FOLLOWS:
C
C              SIDE = 'L' OR 'L'   B := ALPHA*OP( A )*B.
C
C              SIDE = 'R' OR 'R'   B := ALPHA*B*OP( A ).
C
C           UNCHANGED ON EXIT.
C
C  UPLO   - CHARACTER*1.
C           ON ENTRY, UPLO SPECIFIES WHETHER THE MATRIX A IS AN UPPER OR
C           LOWER TRIANGULAR MATRIX AS FOLLOWS:
C
C              UPLO = 'U' OR 'U'   A IS AN UPPER TRIANGULAR MATRIX.
C
C              UPLO = 'L' OR 'L'   A IS A LOWER TRIANGULAR MATRIX.
C
C           UNCHANGED ON EXIT.
C
C  TRANSA - CHARACTER*1.
C           ON ENTRY, TRANSA SPECIFIES THE FORM OF OP( A ) TO BE USED IN
C           THE MATRIX MULTIPLICATION AS FOLLOWS:
C
C              TRANSA = 'N' OR 'N'   OP( A ) = A.
C
C              TRANSA = 'T' OR 'T'   OP( A ) = A'.
C
C              TRANSA = 'C' OR 'C'   OP( A ) = A'.
C
C           UNCHANGED ON EXIT.
C
C  DIAG   - CHARACTER*1.
C           ON ENTRY, DIAG SPECIFIES WHETHER OR NOT A IS UNIT TRIANGULAR
C           AS FOLLOWS:
C
C              DIAG = 'U' OR 'U'   A IS ASSUMED TO BE UNIT TRIANGULAR.
C
C              DIAG = 'N' OR 'N'   A IS NOT ASSUMED TO BE UNIT
C                                  TRIANGULAR.
C
C           UNCHANGED ON EXIT.
C
C  M      - INTEGER.
C           ON ENTRY, M SPECIFIES THE NUMBER OF ROWS OF B. M MUST BE AT
C           LEAST ZERO.
C           UNCHANGED ON EXIT.
C
C  N      - INTEGER.
C           ON ENTRY, N SPECIFIES THE NUMBER OF COLUMNS OF B.  N MUST BE
C           AT LEAST ZERO.
C           UNCHANGED ON EXIT.
C
C  ALPHA  - DOUBLE PRECISION.
C           ON ENTRY,  ALPHA SPECIFIES THE SCALAR  ALPHA. WHEN  ALPHA IS
C           ZERO THEN  A IS NOT REFERENCED AND  B NEED NOT BE SET BEFORE
C           ENTRY.
C           UNCHANGED ON EXIT.
C
C  A      - DOUBLE PRECISION ARRAY OF DIMENSION ( LDA, K ), WHERE K IS M
C           WHEN  SIDE = 'L' OR 'L'  AND IS  N  WHEN  SIDE = 'R' OR 'R'.
C           BEFORE ENTRY  WITH  UPLO = 'U' OR 'U',  THE  LEADING  K BY K
C           UPPER TRIANGULAR PART OF THE ARRAY  A MUST CONTAIN THE UPPER
C           TRIANGULAR MATRIX  AND THE STRICTLY LOWER TRIANGULAR PART OF
C           A IS NOT REFERENCED.
C           BEFORE ENTRY  WITH  UPLO = 'L' OR 'L',  THE  LEADING  K BY K
C           LOWER TRIANGULAR PART OF THE ARRAY  A MUST CONTAIN THE LOWER
C           TRIANGULAR MATRIX  AND THE STRICTLY UPPER TRIANGULAR PART OF
C           A IS NOT REFERENCED.
C           NOTE THAT WHEN  DIAG = 'U' OR 'U',  THE DIAGONAL ELEMENTS OF
C           A  ARE NOT REFERENCED EITHER,  BUT ARE ASSUMED TO BE  UNITY.
C           UNCHANGED ON EXIT.
C
C  LDA    - INTEGER.
C           ON ENTRY, LDA SPECIFIES THE FIRST DIMENSION OF A AS DECLARED
C           IN THE CALLING (SUB) PROGRAM.  WHEN  SIDE = 'L' OR 'L'  THEN
C           LDA  MUST BE AT LEAST  MAX( 1, M ),  WHEN  SIDE = 'R' OR 'R'
C           THEN LDA MUST BE AT LEAST MAX( 1, N ).
C           UNCHANGED ON EXIT.
C
C  B      - DOUBLE PRECISION ARRAY OF DIMENSION ( LDB, N ).
C           BEFORE ENTRY,  THE LEADING  M BY N PART OF THE ARRAY  B MUST
C           CONTAIN THE MATRIX  B,  AND  ON EXIT  IS OVERWRITTEN  BY THE
C           TRANSFORMED MATRIX.
C
C  LDB    - INTEGER.
C           ON ENTRY, LDB SPECIFIES THE FIRST DIMENSION OF B AS DECLARED
C           IN  THE  CALLING  (SUB)  PROGRAM.   LDB  MUST  BE  AT  LEAST
C           MAX( 1, M ).
C           UNCHANGED ON EXIT.
C
C
C  LEVEL 3 BLAS ROUTINE.
C
C  -- WRITTEN ON 8-FEBRUARY-1989.
C     JACK DONGARRA, ARGONNE NATIONAL LABORATORY.
C     IAIN DUFF, AERE HARWELL.
C     JEREMY DU CROZ, NUMERICAL ALGORITHMS GROUP LTD.
C     SVEN HAMMARLING, NUMERICAL ALGORITHMS GROUP LTD.
C
C
C     .. EXTERNAL FUNCTIONS ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
C     .. EXTERNAL ROUTINES ..
      EXTERNAL           XERBLA
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          MAX
C     .. LOCAL SCALARS ..
      LOGICAL            LSIDE, NOUNIT, UPPER
      INTEGER            I, INFO, J, K, NROWA
      DOUBLE PRECISION   TEMP
C     .. PARAMETERS ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
C     TEST THE INPUT PARAMETERS.
C
      LSIDE  = LSAME( SIDE  , 'L' )
      IF( LSIDE )THEN
         NROWA = M
      ELSE
         NROWA = N
      END IF
      NOUNIT = LSAME( DIAG  , 'N' )
      UPPER  = LSAME( UPLO  , 'U' )
C
      INFO   = 0
      IF(      ( .NOT.LSIDE                ).AND.
     $         ( .NOT.LSAME( SIDE  , 'R' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.UPPER                ).AND.
     $         ( .NOT.LSAME( UPLO  , 'L' ) )      )THEN
         INFO = 2
      ELSE IF( ( .NOT.LSAME( TRANSA, 'N' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'C' ) )      )THEN
         INFO = 3
      ELSE IF( ( .NOT.LSAME( DIAG  , 'U' ) ).AND.
     $         ( .NOT.LSAME( DIAG  , 'N' ) )      )THEN
         INFO = 4
      ELSE IF( M  <0               )THEN
         INFO = 5
      ELSE IF( N  <0               )THEN
         INFO = 6
      ELSE IF( LDA<MAX( 1, NROWA ) )THEN
         INFO = 9
      ELSE IF( LDB<MAX( 1, M     ) )THEN
         INFO = 11
      END IF
      IF( INFO/=0 )THEN
         CALL XERBLA( 'DTRMM ', INFO )
         RETURN
      END IF
C
C     QUICK RETURN IF POSSIBLE.
C
      IF( N==0 )
     $   RETURN
C
C     AND WHEN  ALPHA==ZERO.
C
      IF( ALPHA==ZERO )THEN
         DO 20, J = 1, N
            DO 10, I = 1, M
               B( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
         RETURN
      END IF
C
C     START THE OPERATIONS.
C
      IF( LSIDE )THEN
         IF( LSAME( TRANSA, 'N' ) )THEN
C
C           FORM  B := ALPHA*A*B.
C
            IF( UPPER )THEN
               DO 50, J = 1, N
                  DO 40, K = 1, M
                     IF( B( K, J )/=ZERO )THEN
                        TEMP = ALPHA*B( K, J )
                        DO 30, I = 1, K - 1
                           B( I, J ) = B( I, J ) + TEMP*A( I, K )
   30                   CONTINUE
                        IF( NOUNIT )
     $                     TEMP = TEMP*A( K, K )
                        B( K, J ) = TEMP
                     END IF
   40             CONTINUE
   50          CONTINUE
            ELSE
               DO 80, J = 1, N
                  DO 70 K = M, 1, -1
                     IF( B( K, J )/=ZERO )THEN
                        TEMP      = ALPHA*B( K, J )
                        B( K, J ) = TEMP
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )*A( K, K )
                        DO 60, I = K + 1, M
                           B( I, J ) = B( I, J ) + TEMP*A( I, K )
   60                   CONTINUE
                     END IF
   70             CONTINUE
   80          CONTINUE
            END IF
         ELSE
C
C           FORM  B := ALPHA*B*A'.
C
            IF( UPPER )THEN
               DO 110, J = 1, N
                  DO 100, I = M, 1, -1
                     TEMP = B( I, J )
                     IF( NOUNIT )
     $                  TEMP = TEMP*A( I, I )
                     DO 90, K = 1, I - 1
                        TEMP = TEMP + A( K, I )*B( K, J )
   90                CONTINUE
                     B( I, J ) = ALPHA*TEMP
  100             CONTINUE
  110          CONTINUE
            ELSE
               DO 140, J = 1, N
                  DO 130, I = 1, M
                     TEMP = B( I, J )
                     IF( NOUNIT )
     $                  TEMP = TEMP*A( I, I )
                     DO 120, K = I + 1, M
                        TEMP = TEMP + A( K, I )*B( K, J )
  120                CONTINUE
                     B( I, J ) = ALPHA*TEMP
  130             CONTINUE
  140          CONTINUE
            END IF
         END IF
      ELSE
         IF( LSAME( TRANSA, 'N' ) )THEN
C
C           FORM  B := ALPHA*B*A.
C
            IF( UPPER )THEN
               DO 180, J = N, 1, -1
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 150, I = 1, M
                     B( I, J ) = TEMP*B( I, J )
  150             CONTINUE
                  DO 170, K = 1, J - 1
                     IF( A( K, J )/=ZERO )THEN
                        TEMP = ALPHA*A( K, J )
                        DO 160, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  160                   CONTINUE
                     END IF
  170             CONTINUE
  180          CONTINUE
            ELSE
               DO 220, J = 1, N
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 190, I = 1, M
                     B( I, J ) = TEMP*B( I, J )
  190             CONTINUE
                  DO 210, K = J + 1, N
                     IF( A( K, J )/=ZERO )THEN
                        TEMP = ALPHA*A( K, J )
                        DO 200, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  200                   CONTINUE
                     END IF
  210             CONTINUE
  220          CONTINUE
            END IF
         ELSE
C
C           FORM  B := ALPHA*B*A'.
C
            IF( UPPER )THEN
               DO 260, K = 1, N
                  DO 240, J = 1, K - 1
                     IF( A( J, K )/=ZERO )THEN
                        TEMP = ALPHA*A( J, K )
                        DO 230, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  230                   CONTINUE
                     END IF
  240             CONTINUE
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( K, K )
                  IF( TEMP/=ONE )THEN
                     DO 250, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  250                CONTINUE
                  END IF
  260          CONTINUE
            ELSE
               DO 300, K = N, 1, -1
                  DO 280, J = K + 1, N
                     IF( A( J, K )/=ZERO )THEN
                        TEMP = ALPHA*A( J, K )
                        DO 270, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  270                   CONTINUE
                     END IF
  280             CONTINUE
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( K, K )
                  IF( TEMP/=ONE )THEN
                     DO 290, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  290                CONTINUE
                  END IF
  300          CONTINUE
            END IF
         END IF
      END IF
C
      RETURN
C
C     END OF DTRMM .
C
      END

C ABRT
      SUBROUTINE ABRT  
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      CHARACTER*24 STAMP                                                
      DOUBLE PRECISION TIMSTR(3)  
C-----------------------------------------------------------------------
      CALL FDATE(STAMP)                                                 
      READ(UNIT=STAMP,FMT='(3A8)')TIMSTR                               
      WRITE(6,1)TIMSTR
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
C     GENERIC STOP, IN CASE YOU GET THIS FAR
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
      STOP 'IN ABRT'                                                    
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
    1 FORMAT(1X,'Execution terminated abnormally at ',3A8)                                           
      END                                                               

C IDAMAX
      INTEGER FUNCTION IDAMAX(N,DX,INCX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(*)
C
C     FINDS THE INDEX OF ELEMENT HAVING MAX. ABSOLUTE VALUE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      IDAMAX = 0
      IF( N < 1 ) RETURN
      IDAMAX = 1
      IF(N==1) RETURN
      IF(INCX==1)GO TO 20
C
C        CODE FOR INCREMENT NOT EQUAL TO 1
C
      IX = 1
      RMAX = ABS(DX(1))
      IX = IX + INCX
      DO 10 I = 2,N
         IF(ABS(DX(IX))<=RMAX) GO TO 5
         IDAMAX = I
         RMAX = ABS(DX(IX))
    5    IX = IX + INCX
   10 CONTINUE
      RETURN
C
C        CODE FOR INCREMENT EQUAL TO 1
C
   20 RMAX = ABS(DX(1))
      DO 30 I = 2,N
         IF(ABS(DX(I))<=RMAX) GO TO 30
         IDAMAX = I
         RMAX = ABS(DX(I))
   30 CONTINUE
      RETURN
      END

C DAXPY
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
      DOUBLE PRECISION DA
      INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION DX(*),DY(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
      INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC mod
*     ..
      IF (n.LE.0) RETURN
      IF (da.EQ.0.0d0) RETURN
      IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*        code for both increments equal to 1
*
*
*        clean-up loop
*
         m = mod(n,4)
         IF (m.NE.0) THEN
            DO i = 1,m
               dy(i) = dy(i) + da*dx(i)
            END DO
         END IF
         IF (n.LT.4) RETURN
         mp1 = m + 1
         DO i = mp1,n,4
            dy(i) = dy(i) + da*dx(i)
            dy(i+1) = dy(i+1) + da*dx(i+1)
            dy(i+2) = dy(i+2) + da*dx(i+2)
            dy(i+3) = dy(i+3) + da*dx(i+3)
         END DO
      ELSE
*
*        code for unequal increments or equal increments
*          not equal to 1
*
         ix = 1
         iy = 1
         IF (incx.LT.0) ix = (-n+1)*incx + 1
         IF (incy.LT.0) iy = (-n+1)*incy + 1
         DO i = 1,n
          dy(iy) = dy(iy) + da*dx(ix)
          ix = ix + incx
          iy = iy + incy
         END DO
      END IF
      RETURN
      END
       
C DDOT
       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
      INTEGER incx,incy,n
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION dx(*),dy(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
      DOUBLE PRECISION dtemp
      INTEGER i,ix,iy,m,mp1
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC mod
*     ..
      ddot = 0.0d0
      dtemp = 0.0d0
      IF (n.LE.0) RETURN
      IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*        code for both increments equal to 1
*
*
*        clean-up loop
*
         m = mod(n,5)
         IF (m.NE.0) THEN
            DO i = 1,m
               dtemp = dtemp + dx(i)*dy(i)
            END DO
            IF (n.LT.5) THEN
               ddot=dtemp
            RETURN
            END IF
         END IF
         mp1 = m + 1
         DO i = mp1,n,5
          dtemp = dtemp + dx(i)*dy(i) + dx(i+1)*dy(i+1) +
     $            dx(i+2)*dy(i+2) + dx(i+3)*dy(i+3) + dx(i+4)*dy(i+4)
         END DO
      ELSE
*
*        code for unequal increments or equal increments
*          not equal to 1
*
         ix = 1
         iy = 1
         IF (incx.LT.0) ix = (-n+1)*incx + 1
         IF (incy.LT.0) iy = (-n+1)*incy + 1
         DO i = 1,n
            dtemp = dtemp + dx(ix)*dy(iy)
            ix = ix + incx
            iy = iy + incy
         END DO
      END IF
      ddot = dtemp
      RETURN
      END
       
C DNRM2
       DOUBLE PRECISION FUNCTION dnrm2(N,X,INCX)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
      INTEGER incx,n
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION x(*)
*     ..
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION one,zero
      parameter(one=1.0d+0,zero=0.0d+0)
*     ..
*     .. Local Scalars ..
      DOUBLE PRECISION absxi,norm,scale,ssq
      INTEGER ix
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC abs,sqrt
*     ..
      IF (n.LT.1 .OR. incx.LT.1) THEN
          norm = zero
      ELSE IF (n.EQ.1) THEN
          norm = abs(x(1))
      ELSE
          scale = zero
          ssq = one
*        The following loop is equivalent to this call to the LAPACK
*        auxiliary routine:
*        CALL DLASSQ( N, X, INCX, SCALE, SSQ )
*
          DO 10 ix = 1,1 + (n-1)*incx,incx
              IF (x(ix).NE.zero) THEN
                  absxi = abs(x(ix))
                  IF (scale.LT.absxi) THEN
                      ssq = one + ssq* (scale/absxi)**2
                      scale = absxi
                  ELSE
                      ssq = ssq + (absxi/scale)**2
                  END IF
              END IF
   10     CONTINUE
          norm = scale*sqrt(ssq)
      END IF
*
      dnrm2 = norm
      RETURN
*
*     End of DNRM2.
*
      END

C DGEMV
      SUBROUTINE DGEMV(FORMA,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*1 FORMA
      DIMENSION A(LDA,*),X(*),Y(*)
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C        CLONE OF -DGEMV- WRITTEN BY MIKE SCHMIDT
C
      LOCY = 1
C
C                  Y = ALPHA * A * X + BETA * Y
C
      IF(FORMA=='N') THEN
         IF(ALPHA==ONE  .AND.  BETA==ZERO) THEN
            DO 110 I=1,M
               Y(LOCY) =       DDOT(N,A(I,1),LDA,X,INCX)
               LOCY = LOCY+INCY
  110       CONTINUE
         ELSE
            DO 120 I=1,M
               Y(LOCY) = ALPHA*DDOT(N,A(I,1),LDA,X,INCX) + BETA*Y(LOCY)
               LOCY = LOCY+INCY
  120       CONTINUE
         END IF
         RETURN
      END IF
C
C                  Y = ALPHA * A-TRANSPOSE * X + BETA * Y
C
      IF(FORMA=='T') THEN
         IF(ALPHA==ONE  .AND.  BETA==ZERO) THEN
            DO 210 I=1,N
               Y(LOCY) =       DDOT(M,A(1,I),1,X,INCX)
               LOCY = LOCY+INCY
  210       CONTINUE
         ELSE
            DO 220 I=1,N
               Y(LOCY) = ALPHA*DDOT(M,A(1,I),1,X,INCX) + BETA*Y(LOCY)
               LOCY = LOCY+INCY
  220       CONTINUE
         END IF
         RETURN
      END IF
C
      WRITE(6,900) FORMA
      CALL ABRT
      RETURN
  900 FORMAT(1X,'ERROR IN -DGEMV- ... UNRECOGNIZED FORMA=',A1)
      END

C DTRMV
      SUBROUTINE DTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
C     .. SCALAR ARGUMENTS ..
      INTEGER            INCX, LDA, N
      CHARACTER*1      DIAG, TRANS, UPLO
C     .. ARRAY ARGUMENTS ..
      DOUBLE PRECISION   A( LDA, * ), X( * )
C     ..
C
C  PURPOSE
C  =======
C
C  DTRMV  PERFORMS ONE OF THE MATRIX-VECTOR OPERATIONS
C
C     X := A*X,   OR   X := A'*X,
C
C  WHERE X IS AN N ELEMENT VECTOR AND  A IS AN N BY N UNIT, OR NON-UNIT,
C  UPPER OR LOWER TRIANGULAR MATRIX.
C
C  PARAMETERS
C  ==========
C
C  UPLO   - CHARACTER*1.
C           ON ENTRY, UPLO SPECIFIES WHETHER THE MATRIX IS AN UPPER OR
C           LOWER TRIANGULAR MATRIX AS FOLLOWS:
C
C              UPLO = 'U' OR 'U'   A IS AN UPPER TRIANGULAR MATRIX.
C
C              UPLO = 'L' OR 'L'   A IS A LOWER TRIANGULAR MATRIX.
C
C           UNCHANGED ON EXIT.
C
C  TRANS  - CHARACTER*1.
C           ON ENTRY, TRANS SPECIFIES THE OPERATION TO BE PERFORMED AS
C           FOLLOWS:
C
C              TRANS = 'N' OR 'N'   X := A*X.
C
C              TRANS = 'T' OR 'T'   X := A'*X.
C
C              TRANS = 'C' OR 'C'   X := A'*X.
C
C           UNCHANGED ON EXIT.
C
C  DIAG   - CHARACTER*1.
C           ON ENTRY, DIAG SPECIFIES WHETHER OR NOT A IS UNIT
C           TRIANGULAR AS FOLLOWS:
C
C              DIAG = 'U' OR 'U'   A IS ASSUMED TO BE UNIT TRIANGULAR.
C
C              DIAG = 'N' OR 'N'   A IS NOT ASSUMED TO BE UNIT
C                                  TRIANGULAR.
C
C           UNCHANGED ON EXIT.
C
C  N      - INTEGER.
C           ON ENTRY, N SPECIFIES THE ORDER OF THE MATRIX A.
C           N MUST BE AT LEAST ZERO.
C           UNCHANGED ON EXIT.
C
C  A      - DOUBLE PRECISION ARRAY OF DIMENSION ( LDA, N ).
C           BEFORE ENTRY WITH  UPLO = 'U' OR 'U', THE LEADING N BY N
C           UPPER TRIANGULAR PART OF THE ARRAY A MUST CONTAIN THE UPPER
C           TRIANGULAR MATRIX AND THE STRICTLY LOWER TRIANGULAR PART OF
C           A IS NOT REFERENCED.
C           BEFORE ENTRY WITH UPLO = 'L' OR 'L', THE LEADING N BY N
C           LOWER TRIANGULAR PART OF THE ARRAY A MUST CONTAIN THE LOWER
C           TRIANGULAR MATRIX AND THE STRICTLY UPPER TRIANGULAR PART OF
C           A IS NOT REFERENCED.
C           NOTE THAT WHEN  DIAG = 'U' OR 'U', THE DIAGONAL ELEMENTS OF
C           A ARE NOT REFERENCED EITHER, BUT ARE ASSUMED TO BE UNITY.
C           UNCHANGED ON EXIT.
C
C  LDA    - INTEGER.
C           ON ENTRY, LDA SPECIFIES THE FIRST DIMENSION OF A AS DECLARED
C           IN THE CALLING (SUB) PROGRAM. LDA MUST BE AT LEAST
C           MAX( 1, N ).
C           UNCHANGED ON EXIT.
C
C  X      - DOUBLE PRECISION ARRAY OF DIMENSION AT LEAST
C           ( 1 + ( N - 1 )*ABS( INCX ) ).
C           BEFORE ENTRY, THE INCREMENTED ARRAY X MUST CONTAIN THE N
C           ELEMENT VECTOR X. ON EXIT, X IS OVERWRITTEN WITH THE
C           TRANFORMED VECTOR X.
C
C  INCX   - INTEGER.
C           ON ENTRY, INCX SPECIFIES THE INCREMENT FOR THE ELEMENTS OF
C           X. INCX MUST NOT BE ZERO.
C           UNCHANGED ON EXIT.
C
C
C  LEVEL 2 BLAS ROUTINE.
C
C  -- WRITTEN ON 22-OCTOBER-1986.
C     JACK DONGARRA, JEREMY DU CROZ, SVEN HAMMARLING, RICHARD HANSON
C
C     .. PARAMETERS ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, J, JX, KX
      LOGICAL            NOUNIT
C     .. EXTERNAL FUNCTIONS ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
C     .. EXTERNAL ROUTINES ..
      EXTERNAL           XERBLA
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          MAX
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
C     TEST THE INPUT PARAMETERS.
C
      INFO = 0
      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
     $         .NOT.LSAME( UPLO , 'L' )      )THEN
         INFO = 1
      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
     $         .NOT.LSAME( TRANS, 'T' ).AND.
     $         .NOT.LSAME( TRANS, 'C' )      )THEN
         INFO = 2
      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
     $         .NOT.LSAME( DIAG , 'N' )      )THEN
         INFO = 3
      ELSE IF( N<0 )THEN
         INFO = 4
      ELSE IF( LDA<MAX( 1, N ) )THEN
         INFO = 6
      ELSE IF( INCX==0 )THEN
         INFO = 8
      END IF
      IF( INFO/=0 )THEN
         CALL XERBLA( 'DTRMV ', INFO )
         RETURN
      END IF
C
C     QUICK RETURN IF POSSIBLE.
C
      IF( N==0 )
     $   RETURN
C
      NOUNIT = LSAME( DIAG, 'N' )
C
C     SET UP THE START POINT IN X IF THE INCREMENT IS NOT UNITY. THIS
C     WILL BE  ( N - 1 )*INCX  TOO SMALL FOR DESCENDING LOOPS.
C
      IF( INCX<=0 )THEN
         KX = 1 - ( N - 1 )*INCX
      ELSE IF( INCX/=1 )THEN
         KX = 1
      END IF
C
C     START THE OPERATIONS. IN THIS VERSION THE ELEMENTS OF A ARE
C     ACCESSED SEQUENTIALLY WITH ONE PASS THROUGH A.
C
      IF( LSAME( TRANS, 'N' ) )THEN
C
C        FORM  X := A*X.
C
         IF( LSAME( UPLO, 'U' ) )THEN
            IF( INCX==1 )THEN
               DO 20, J = 1, N
                  IF( X( J )/=ZERO )THEN
                     TEMP = X( J )
                     DO 10, I = 1, J - 1
                        X( I ) = X( I ) + TEMP*A( I, J )
   10                CONTINUE
                     IF( NOUNIT )
     $                  X( J ) = X( J )*A( J, J )
                  END IF
   20          CONTINUE
            ELSE
               JX = KX
               DO 40, J = 1, N
                  IF( X( JX )/=ZERO )THEN
                     TEMP = X( JX )
                     IX   = KX
                     DO 30, I = 1, J - 1
                        X( IX ) = X( IX ) + TEMP*A( I, J )
                        IX      = IX      + INCX
   30                CONTINUE
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )*A( J, J )
                  END IF
                  JX = JX + INCX
   40          CONTINUE
            END IF
         ELSE
            IF( INCX==1 )THEN
               DO 60, J = N, 1, -1
                  IF( X( J )/=ZERO )THEN
                     TEMP = X( J )
                     DO 50, I = N, J + 1, -1
                        X( I ) = X( I ) + TEMP*A( I, J )
   50                CONTINUE
                     IF( NOUNIT )
     $                  X( J ) = X( J )*A( J, J )
                  END IF
   60          CONTINUE
            ELSE
               KX = KX + ( N - 1 )*INCX
               JX = KX
               DO 80, J = N, 1, -1
                  IF( X( JX )/=ZERO )THEN
                     TEMP = X( JX )
                     IX   = KX
                     DO 70, I = N, J + 1, -1
                        X( IX ) = X( IX ) + TEMP*A( I, J )
                        IX      = IX      - INCX
   70                CONTINUE
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )*A( J, J )
                  END IF
                  JX = JX - INCX
   80          CONTINUE
            END IF
         END IF
      ELSE
C
C        FORM  X := A'*X.
C
         IF( LSAME( UPLO, 'U' ) )THEN
            IF( INCX==1 )THEN
               DO 100, J = N, 1, -1
                  TEMP = X( J )
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 90, I = J - 1, 1, -1
                     TEMP = TEMP + A( I, J )*X( I )
   90             CONTINUE
                  X( J ) = TEMP
  100          CONTINUE
            ELSE
               JX = KX + ( N - 1 )*INCX
               DO 120, J = N, 1, -1
                  TEMP = X( JX )
                  IX   = JX
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 110, I = J - 1, 1, -1
                     IX   = IX   - INCX
                     TEMP = TEMP + A( I, J )*X( IX )
  110             CONTINUE
                  X( JX ) = TEMP
                  JX      = JX   - INCX
  120          CONTINUE
            END IF
         ELSE
            IF( INCX==1 )THEN
               DO 140, J = 1, N
                  TEMP = X( J )
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 130, I = J + 1, N
                     TEMP = TEMP + A( I, J )*X( I )
  130             CONTINUE
                  X( J ) = TEMP
  140          CONTINUE
            ELSE
               JX = KX
               DO 160, J = 1, N
                  TEMP = X( JX )
                  IX   = JX
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 150, I = J + 1, N
                     IX   = IX   + INCX
                     TEMP = TEMP + A( I, J )*X( IX )
  150             CONTINUE
                  X( JX ) = TEMP
                  JX      = JX   + INCX
  160          CONTINUE
            END IF
         END IF
      END IF
C
      RETURN
C
C     END OF DTRMV .
C
      END

C DGEMM
      SUBROUTINE DGEMM(FORMA,FORMB,L,N,M,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*1 FORMA,FORMB
      DOUBLE PRECISION A(LDA,*), B(LDB,*), C(LDC,*)
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     THIS IS A PLAIN VANILLA FORTRAN CLONE OF DGEMM
C
      IF (FORMA=='N' .AND. FORMB=='N') THEN
         IF(ALPHA==ONE  .AND.  BETA==ZERO) THEN
            DO 30 IL = 1, L
               DO 20 IN = 1, N
                  T = ZERO
                  DO 10 IM = 1, M
                     T = T + A(IL,IM)*B(IM,IN)
   10             CONTINUE
                  C(IL,IN) = T
   20          CONTINUE
   30       CONTINUE
         ELSE
            DO 80 IL = 1, L
               DO 70 IN = 1, N
                  T = ZERO
                  DO 60 IM = 1, M
                     T = T + A(IL,IM)*B(IM,IN)
   60             CONTINUE
                  C(IL,IN) = ALPHA*T + BETA*C(IL,IN)
   70          CONTINUE
   80       CONTINUE
         END IF
         RETURN
      END IF
C
      IF (FORMA=='T' .AND. FORMB=='N') THEN
         IF(ALPHA==ONE  .AND.  BETA==ZERO) THEN
            DO 130 IL = 1, L
               DO 120 IN = 1, N
                  T = ZERO
                  DO 110 IM = 1, M
                     T = T + A(IM,IL)*B(IM,IN)
  110             CONTINUE
                  C(IL,IN) = T
  120          CONTINUE
  130       CONTINUE
         ELSE
            DO 180 IL = 1, L
               DO 170 IN = 1, N
                  T = ZERO
                  DO 160 IM = 1, M
                     T = T + A(IM,IL)*B(IM,IN)
  160             CONTINUE
                  C(IL,IN) = ALPHA*T + BETA*C(IL,IN)
  170          CONTINUE
  180       CONTINUE
         END IF
         RETURN
      END IF
C
      IF (FORMA=='N' .AND. FORMB=='T') THEN
         IF(ALPHA==ONE  .AND.  BETA==ZERO) THEN
            DO 230 IL = 1, L
               DO 220 IN = 1, N
                  T = ZERO
                  DO 210 IM = 1, M
                     T = T + A(IL,IM)*B(IN,IM)
  210             CONTINUE
                  C(IL,IN) = T
  220          CONTINUE
  230       CONTINUE
         ELSE
            DO 280 IL = 1, L
               DO 270 IN = 1, N
                  T = ZERO
                  DO 260 IM = 1, M
                     T = T + A(IL,IM)*B(IN,IM)
  260             CONTINUE
                  C(IL,IN) = ALPHA*T + BETA*C(IL,IN)
  270          CONTINUE
  280       CONTINUE
         END IF
         RETURN
      END IF
C
      IF (FORMA=='T' .AND. FORMB=='T') THEN
         IF(ALPHA==ONE  .AND.  BETA==ZERO) THEN
            DO 330 IL = 1, L
               DO 320 IN = 1, N
                  T = ZERO
                  DO 310 IM = 1, M
                     T = T + A(IM,IL)*B(IN,IM)
  310             CONTINUE
                  C(IL,IN) = T
  320          CONTINUE
  330       CONTINUE
         ELSE
            DO 380 IL = 1, L
               DO 370 IN = 1, N
                  T = ZERO
                  DO 360 IM = 1, M
                     T = T + A(IM,IL)*B(IN,IM)
  360             CONTINUE
                  C(IL,IN) = ALPHA*T + BETA*C(IL,IN)
  370          CONTINUE
  380       CONTINUE
         END IF
         RETURN
      END IF
C
      WRITE(6,900) FORMA,FORMB
      CALL ABRT
      RETURN
  900 FORMAT(1X,'ERROR IN -DGEMM- ... ILLEGAL FORMA/FORMB=',A1,1X,A1)
      END

C DCOPY
      SUBROUTINE DCOPY(N,DX,INCX,DY,INCY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DX(*),DY(*)
C
C     COPIES A VECTOR.
C           DY(I) <== DX(I)
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      IF(N<=0) RETURN
      IF(INCX==1.AND.INCY==1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX<0)IX = (-N+1)*INCX + 1
      IF(INCY<0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,7)
      IF( M == 0 ) GO TO 40
      DO 30 I = 1,M
        DY(I) = DX(I)
   30 CONTINUE
      IF( N < 7 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,7
        DY(I) = DX(I)
        DY(I + 1) = DX(I + 1)
        DY(I + 2) = DX(I + 2)
        DY(I + 3) = DX(I + 3)
        DY(I + 4) = DX(I + 4)
        DY(I + 5) = DX(I + 5)
        DY(I + 6) = DX(I + 6)
   50 CONTINUE
      RETURN
      END

C DGER
      SUBROUTINE DGER  ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
C     .. SCALAR ARGUMENTS ..
      DOUBLE PRECISION   ALPHA
      INTEGER            INCX, INCY, LDA, M, N
C     .. ARRAY ARGUMENTS ..
      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
C     ..
C
C  PURPOSE
C  =======
C
C  DGER   PERFORMS THE RANK 1 OPERATION
C
C     A := ALPHA*X*Y' + A,
C
C  WHERE ALPHA IS A SCALAR, X IS AN M ELEMENT VECTOR, Y IS AN N ELEMENT
C  VECTOR AND A IS AN M BY N MATRIX.
C
C  PARAMETERS
C  ==========
C
C  M      - INTEGER.
C           ON ENTRY, M SPECIFIES THE NUMBER OF ROWS OF THE MATRIX A.
C           M MUST BE AT LEAST ZERO.
C           UNCHANGED ON EXIT.
C
C  N      - INTEGER.
C           ON ENTRY, N SPECIFIES THE NUMBER OF COLUMNS OF THE MATRIX A.
C           N MUST BE AT LEAST ZERO.
C           UNCHANGED ON EXIT.
C
C  ALPHA  - DOUBLE PRECISION.
C           ON ENTRY, ALPHA SPECIFIES THE SCALAR ALPHA.
C           UNCHANGED ON EXIT.
C
C  X      - DOUBLE PRECISION ARRAY OF DIMENSION AT LEAST
C           ( 1 + ( M - 1 )*ABS( INCX ) ).
C           BEFORE ENTRY, THE INCREMENTED ARRAY X MUST CONTAIN THE M
C           ELEMENT VECTOR X.
C           UNCHANGED ON EXIT.
C
C  INCX   - INTEGER.
C           ON ENTRY, INCX SPECIFIES THE INCREMENT FOR THE ELEMENTS OF
C           X. INCX MUST NOT BE ZERO.
C           UNCHANGED ON EXIT.
C
C  Y      - DOUBLE PRECISION ARRAY OF DIMENSION AT LEAST
C           ( 1 + ( N - 1 )*ABS( INCY ) ).
C           BEFORE ENTRY, THE INCREMENTED ARRAY Y MUST CONTAIN THE N
C           ELEMENT VECTOR Y.
C           UNCHANGED ON EXIT.
C
C  INCY   - INTEGER.
C           ON ENTRY, INCY SPECIFIES THE INCREMENT FOR THE ELEMENTS OF
C           Y. INCY MUST NOT BE ZERO.
C           UNCHANGED ON EXIT.
C
C  A      - DOUBLE PRECISION ARRAY OF DIMENSION ( LDA, N ).
C           BEFORE ENTRY, THE LEADING M BY N PART OF THE ARRAY A MUST
C           CONTAIN THE MATRIX OF COEFFICIENTS. ON EXIT, A IS
C           OVERWRITTEN BY THE UPDATED MATRIX.
C
C  LDA    - INTEGER.
C           ON ENTRY, LDA SPECIFIES THE FIRST DIMENSION OF A AS DECLARED
C           IN THE CALLING (SUB) PROGRAM. LDA MUST BE AT LEAST
C           MAX( 1, M ).
C           UNCHANGED ON EXIT.
C
C
C  LEVEL 2 BLAS ROUTINE.
C
C  -- WRITTEN ON 22-OCTOBER-1986.
C     JACK DONGARRA, JEREMY DU CROZ, SVEN HAMMARLING, RICHARD HANSON
C
C
C     .. PARAMETERS ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
C     .. LOCAL SCALARS ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, J, JY, KX
C     .. EXTERNAL ROUTINES ..
      EXTERNAL           XERBLA
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC          MAX
C     ..
C     .. EXECUTABLE STATEMENTS ..
C
C     TEST THE INPUT PARAMETERS.
C
      INFO = 0
      IF     ( M<0 )THEN
         INFO = 1
      ELSE IF( N<0 )THEN
         INFO = 2
      ELSE IF( INCX==0 )THEN
         INFO = 5
      ELSE IF( INCY==0 )THEN
         INFO = 7
      ELSE IF( LDA<MAX( 1, M ) )THEN
         INFO = 9
      END IF
      IF( INFO/=0 )THEN
         CALL XERBLA( 'DGER  ', INFO )
         RETURN
      END IF
C
C     QUICK RETURN IF POSSIBLE.
C
      IF( ( M==0 ).OR.( N==0 ).OR.( ALPHA==ZERO ) )
     $   RETURN
C
C     START THE OPERATIONS. IN THIS VERSION THE ELEMENTS OF A ARE
C     ACCESSED SEQUENTIALLY WITH ONE PASS THROUGH A.
C
      IF( INCY>0 )THEN
         JY = 1
      ELSE
         JY = 1 - ( N - 1 )*INCY
      END IF
      IF( INCX==1 )THEN
         DO 20, J = 1, N
            IF( Y( JY )/=ZERO )THEN
               TEMP = ALPHA*Y( JY )
               DO 10, I = 1, M
                  A( I, J ) = A( I, J ) + X( I )*TEMP
   10          CONTINUE
            END IF
            JY = JY + INCY
   20    CONTINUE
      ELSE
         IF( INCX>0 )THEN
            KX = 1
         ELSE
            KX = 1 - ( M - 1 )*INCX
         END IF
         DO 40, J = 1, N
            IF( Y( JY )/=ZERO )THEN
               TEMP = ALPHA*Y( JY )
               IX   = KX
               DO 30, I = 1, M
                  A( I, J ) = A( I, J ) + X( IX )*TEMP
                  IX        = IX        + INCX
   30          CONTINUE
            END IF
            JY = JY + INCY
   40    CONTINUE
      END IF
C
      RETURN
C
C     END OF DGER  .
C
      END

C DSCAL
      SUBROUTINE DSCAL(N,DA,DX,INCX)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
      DOUBLE PRECISION DA
      INTEGER INCX,N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION DX(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
      INTEGER I,M,MP1,NINCX
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC mod
*     ..
      IF (n.LE.0 .OR. incx.LE.0) RETURN
      IF (incx.EQ.1) THEN
*
*        code for increment equal to 1
*
*
*        clean-up loop
*
         m = mod(n,5)
         IF (m.NE.0) THEN
            DO i = 1,m
               dx(i) = da*dx(i)
            END DO
            IF (n.LT.5) RETURN
         END IF
         mp1 = m + 1
         DO i = mp1,n,5
            dx(i) = da*dx(i)
            dx(i+1) = da*dx(i+1)
            dx(i+2) = da*dx(i+2)
            dx(i+3) = da*dx(i+3)
            dx(i+4) = da*dx(i+4)
         END DO
      ELSE
*
*        code for increment not equal to 1
*
         nincx = n*incx
         DO i = 1,nincx,incx
            dx(i) = da*dx(i)
         END DO
      END IF
      RETURN
      END

C DSWAP
      SUBROUTINE DSWAP(N,DX,INCX,DY,INCY)
*
*  -- Reference BLAS level1 routine (version 3.8.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2017
*
*     .. Scalar Arguments ..
      INTEGER INCX,INCY,N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION DX(*),DY(*)
*     ..
*
*  =====================================================================
*
*     .. Local Scalars ..
      DOUBLE PRECISION DTEMP
      INTEGER I,IX,IY,M,MP1
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC mod
*     ..
      IF (n.LE.0) RETURN
      IF (incx.EQ.1 .AND. incy.EQ.1) THEN
*
*       code for both increments equal to 1
*
*
*       clean-up loop
*
         m = mod(n,3)
         IF (m.NE.0) THEN
            DO i = 1,m
               dtemp = dx(i)
               dx(i) = dy(i)
               dy(i) = dtemp
            END DO
            IF (n.LT.3) RETURN
         END IF
         mp1 = m + 1
         DO i = mp1,n,3
            dtemp = dx(i)
            dx(i) = dy(i)
            dy(i) = dtemp
            dtemp = dx(i+1)
            dx(i+1) = dy(i+1)
            dy(i+1) = dtemp
            dtemp = dx(i+2)
            dx(i+2) = dy(i+2)
            dy(i+2) = dtemp
         END DO
      ELSE
*
*       code for unequal increments or equal increments not equal
*         to 1
*
         ix = 1
         iy = 1
         IF (incx.LT.0) ix = (-n+1)*incx + 1
         IF (incy.LT.0) iy = (-n+1)*incy + 1
         DO i = 1,n
            dtemp = dx(ix)
            dx(ix) = dy(iy)
            dy(iy) = dtemp
            ix = ix + incx
            iy = iy + incy
         END DO
      END IF
      RETURN
      END

!======================================================================!
!                                                                      !
!                           LBFGS SUBROUTINES                          !
!                                                                      !
!======================================================================!

      SUBROUTINE LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER N,M,IPRINT(2),IFLAG
      DOUBLE PRECISION X(N),G(N),DIAG(N),W(N*(2*M+1)+2*M)
      DOUBLE PRECISION F,EPS,XTOL
      LOGICAL DIAGCO
C
C        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION
C                          JORGE NOCEDAL
C                        *** July 1990 ***
C
C 
C     This subroutine solves the unconstrained minimization problem
C 
C                      min F(x),    x= (x1,x2,...,xN),
C
C      using the limited memory BFGS method. The routine is especially
C      effective on problems involving a large number of variables. In
C      a typical iteration of this method an approximation Hk to the
C      inverse of the Hessian is obtained by applying M BFGS updates to
C      a diagonal matrix Hk0, using information from the previous M steps.
C      The user specifies the number M, which determines the amount of
C      storage required by the routine. The user may also provide the
C      diagonal matrices Hk0 if not satisfied with the default choice.
C      The algorithm is described in "On the limited memory BFGS method
C      for large scale optimization", by D. Liu and J. Nocedal,
C      Mathematical Programming B 45 (1989) 503-528.
C 
C      The user is required to calculate the function value F and its
C      gradient G. In order to allow the user complete control over
C      these computations, reverse  communication is used. The routine
C      must be called repeatedly under the control of the parameter
C      IFLAG. 
C
C      The steplength is determined at each iteration by means of the
C      line search routine MCVSRCH, which is a slight modification of
C      the routine CSRCH written by More' and Thuente.
C 
C      The calling statement is 
C 
C          CALL LBFGS(N,M,X,F,G,DIAGCO,DIAG,IPRINT,EPS,XTOL,W,IFLAG)
C 
C      where
C 
C     N       is an INTEGER variable that must be set by the user to the
C             number of variables. It is not altered by the routine.
C             Restriction: N>0.
C 
C     M       is an INTEGER variable that must be set by the user to
C             the number of corrections used in the BFGS update. It
C             is not altered by the routine. Values of M less than 3 are
C             not recommended; large values of M will result in excessive
C             computing time. 3<= M <=7 is recommended. Restriction: M>0.
C 
C     X       is a DOUBLE PRECISION array of length N. On initial entry
C             it must be set by the user to the values of the initial
C             estimate of the solution vector. On exit with IFLAG=0, it
C             contains the values of the variables at the best point
C             found (usually a solution).
C 
C     F       is a DOUBLE PRECISION variable. Before initial entry and on
C             a re-entry with IFLAG=1, it must be set by the user to
C             contain the value of the function F at the point X.
C 
C     G       is a DOUBLE PRECISION array of length N. Before initial
C             entry and on a re-entry with IFLAG=1, it must be set by
C             the user to contain the components of the gradient G at
C             the point X.
C 
C     DIAGCO  is a LOGICAL variable that must be set to .TRUE. if the
C             user  wishes to provide the diagonal matrix Hk0 at each
C             iteration. Otherwise it should be set to .FALSE., in which
C             case  LBFGS will use a default value described below. If
C             DIAGCO is set to .TRUE. the routine will return at each
C             iteration of the algorithm with IFLAG=2, and the diagonal
C              matrix Hk0  must be provided in the array DIAG.
C 
C 
C     DIAG    is a DOUBLE PRECISION array of length N. If DIAGCO=.TRUE.,
C             then on initial entry or on re-entry with IFLAG=2, DIAG
C             it must be set by the user to contain the values of the 
C             diagonal matrix Hk0.  Restriction: all elements of DIAG
C             must be positive.
C 
C     IPRINT  is an INTEGER array of length two which must be set by the
C             user.
C 
C             IPRINT(1) specifies the frequency of the output:
C                IPRINT(1) < 0 : no output is generated,
C                IPRINT(1) = 0 : output only at first and last iteration,
C                IPRINT(1) > 0 : output every IPRINT(1) iterations.
C 
C             IPRINT(2) specifies the type of output generated:
C                IPRINT(2) = 0 : iteration count, number of function 
C                                evaluations, function value, norm of the
C                                gradient, and steplength,
C                IPRINT(2) = 1 : same as IPRINT(2)=0, plus vector of
C                                variables and  gradient vector at the
C                                initial point,
C                IPRINT(2) = 2 : same as IPRINT(2)=1, plus vector of
C                                variables,
C                IPRINT(2) = 3 : same as IPRINT(2)=2, plus gradient vector.
C 
C 
C     EPS     is a positive DOUBLE PRECISION variable that must be set by
C             the user, and determines the accuracy with which the solution
C             is to be found. The subroutine terminates when
C
C                         ||G|| < EPS max(1,||X||),
C
C             where ||.|| denotes the Euclidean norm.
C 
C     XTOL    is a  positive DOUBLE PRECISION variable that must be set by
C             the user to an estimate of the machine precision (e.g.
C             10**(-16) on a SUN station 3/60). The line search routine will
C             terminate if the relative width of the interval of uncertainty
C             is less than XTOL.
C 
C     W       is a DOUBLE PRECISION array of length N(2M+1)+2M used as
C             workspace for LBFGS. This array must not be altered by the
C             user.
C 
C     IFLAG   is an INTEGER variable that must be set to 0 on initial entry
C             to the subroutine. A return with IFLAG<0 indicates an error,
C             and IFLAG=0 indicates that the routine has terminated without
C             detecting errors. On a return with IFLAG=1, the user must
C             evaluate the function F and gradient G. On a return with
C             IFLAG=2, the user must provide the diagonal matrix Hk0.
C 
C             The following negative values of IFLAG, detecting an error,
C             are possible:
C 
C              IFLAG=-1  The line search routine MCSRCH failed. The
C                        parameter INFO provides more detailed information
C                        (see also the documentation of MCSRCH):
C
C                       INFO = 0  IMPROPER INPUT PARAMETERS.
C
C                       INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF
C                                 UNCERTAINTY IS AT MOST XTOL.
C
C                       INFO = 3  MORE THAN 20 FUNCTION EVALUATIONS WERE
C                                 REQUIRED AT THE PRESENT ITERATION.
C
C                       INFO = 4  THE STEP IS TOO SMALL.
C
C                       INFO = 5  THE STEP IS TOO LARGE.
C
C                       INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS. 
C                                 THERE MAY NOT BE A STEP WHICH SATISFIES
C                                 THE SUFFICIENT DECREASE AND CURVATURE
C                                 CONDITIONS. TOLERANCES MAY BE TOO SMALL.
C
C 
C              IFLAG=-2  The i-th diagonal element of the diagonal inverse
C                        Hessian approximation, given in DIAG, is not
C                        positive.
C           
C              IFLAG=-3  Improper input parameters for LBFGS (N or M are
C                        not positive).
C 
C
C
C    ON THE DRIVER:
C
C    The program that calls LBFGS must contain the declaration:
C
C                       EXTERNAL LB2
C
C    LB2 is a BLOCK DATA that defines the default values of several
C    parameters described in the COMMON section. 
C
C 
C 
C    COMMON:
C 
C     The subroutine contains one common area, which the user may wish to
C    reference:
C 
         COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
C 
C    MP  is an INTEGER variable with default value 6. It is used as the
C        unit number for the printing of the monitoring information
C        controlled by IPRINT.
C 
C    LP  is an INTEGER variable with default value 6. It is used as the
C        unit number for the printing of error messages. This printing
C        may be suppressed by setting LP to a non-positive value.
C 
C    GTOL is a DOUBLE PRECISION variable with default value 0.9, which
C        controls the accuracy of the line search routine MCSRCH. If the
C        function and gradient evaluations are inexpensive with respect
C        to the cost of the iteration (which is sometimes the case when
C        solving very large problems) it may be advantageous to set GTOL
C        to a small value. A typical small value is 0.1.  Restriction:
C        GTOL should be greater than 1.D-04.
C 
C    STPMIN and STPMAX are non-negative DOUBLE PRECISION variables which
C        specify lower and uper bounds for the step in the line search.
C        Their default values are 1.D-20 and 1.D+20, respectively. These
C        values need not be modified unless the exponents are too large
C        for the machine being used, or unless the problem is extremely
C        badly scaled (in which case the exponents should be increased).
C 
C
C  MACHINE DEPENDENCIES
C
C        The only variables that are machine-dependent are XTOL,
C        STPMIN and STPMAX.
C 
C
C  GENERAL INFORMATION
C 
C    Other routines called directly:  DAXPY, DDOT, LB1, MCSRCH
C 
C    Input/Output  :  No input; diagnostic messages on unit MP and
C                     error messages on unit LP.
C 
C 
C     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
      DOUBLE PRECISION GTOL,ONE,ZERO,GNORM,DDOT,STP1,FTOL,STPMIN,
     .                 STPMAX,STP,YS,YY,SQ,YR,BETA,XNORM
      INTEGER MP,LP,ITER,NFUN,POINT,ISPT,IYPT,MAXFEV,INFO,
     .        BOUND,NPT,CP,I,NFEV,INMC,IYCN,ISCN
      LOGICAL FINISH
C
      SAVE
      DATA ONE,ZERO/1.0D+0,0.0D+0/
C
C     INITIALIZE
C     ----------
C
      IF(IFLAG.EQ.0) GO TO 10
      GO TO (172,100) IFLAG
  10  ITER= 0
      IF(N.LE.0.OR.M.LE.0) GO TO 196
      IF(GTOL.LE.1.D-04) THEN
        IF(LP.GT.0) WRITE(LP,245)
        GTOL=9.D-01
      ENDIF
      NFUN= 1
      POINT= 0
      FINISH= .FALSE.
      IF(DIAGCO) THEN
         DO 30 I=1,N
 30      IF (DIAG(I).LE.ZERO) GO TO 195
      ELSE
         DO 40 I=1,N
 40      DIAG(I)= 1.0D0
      ENDIF
C
C     THE WORK VECTOR W IS DIVIDED AS FOLLOWS:
C     ---------------------------------------
C     THE FIRST N LOCATIONS ARE USED TO STORE THE GRADIENT AND
C         OTHER TEMPORARY INFORMATION.
C     LOCATIONS (N+1)...(N+M) STORE THE SCALARS RHO.
C     LOCATIONS (N+M+1)...(N+2M) STORE THE NUMBERS ALPHA USED
C         IN THE FORMULA THAT COMPUTES H*G.
C     LOCATIONS (N+2M+1)...(N+2M+NM) STORE THE LAST M SEARCH
C         STEPS.
C     LOCATIONS (N+2M+NM+1)...(N+2M+2NM) STORE THE LAST M
C         GRADIENT DIFFERENCES.
C
C     THE SEARCH STEPS AND GRADIENT DIFFERENCES ARE STORED IN A
C     CIRCULAR ORDER CONTROLLED BY THE PARAMETER POINT.
C
      ISPT= N+2*M
      IYPT= ISPT+N*M     
      DO 50 I=1,N
 50   W(ISPT+I)= -G(I)*DIAG(I)
      GNORM= DSQRT(DDOT(N,G,1,G,1))
      STP1= ONE/GNORM
C
C     PARAMETERS FOR LINE SEARCH ROUTINE
C     
      FTOL= 1.0D-4
      MAXFEV= 20
C
      IF(IPRINT(1).GE.0) CALL LB1(IPRINT,ITER,NFUN,
     *                     GNORM,N,M,X,F,G,STP,FINISH)
C
C    --------------------
C     MAIN ITERATION LOOP
C    --------------------
C
 80   ITER= ITER+1
      INFO=0
      BOUND=ITER-1
      IF(ITER.EQ.1) GO TO 165
      IF (ITER .GT. M)BOUND=M
C
         YS= DDOT(N,W(IYPT+NPT+1),1,W(ISPT+NPT+1),1)
      IF(.NOT.DIAGCO) THEN
         YY= DDOT(N,W(IYPT+NPT+1),1,W(IYPT+NPT+1),1)
         DO 90 I=1,N
   90    DIAG(I)= YS/YY
      ELSE
         IFLAG=2
         RETURN
      ENDIF
 100  CONTINUE
      IF(DIAGCO) THEN
        DO 110 I=1,N
 110    IF (DIAG(I).LE.ZERO) GO TO 195
      ENDIF
C
C     COMPUTE -H*G USING THE FORMULA GIVEN IN: Nocedal, J. 1980,
C     "Updating quasi-Newton matrices with limited storage",
C     Mathematics of Computation, Vol.24, No.151, pp. 773-782.
C     ---------------------------------------------------------
C
      CP= POINT
      IF (POINT.EQ.0) CP=M
      W(N+CP)= ONE/YS
      DO 112 I=1,N
 112  W(I)= -G(I)
      CP= POINT
      DO 125 I= 1,BOUND
         CP=CP-1
         IF (CP.EQ. -1)CP=M-1
         SQ= DDOT(N,W(ISPT+CP*N+1),1,W,1)
         INMC=N+M+CP+1
         IYCN=IYPT+CP*N
         W(INMC)= W(N+CP+1)*SQ
         CALL DAXPY(N,-W(INMC),W(IYCN+1),1,W,1)
 125  CONTINUE
C
      DO 130 I=1,N
 130  W(I)=DIAG(I)*W(I)
C
      DO 145 I=1,BOUND
         YR= DDOT(N,W(IYPT+CP*N+1),1,W,1)
         BETA= W(N+CP+1)*YR
         INMC=N+M+CP+1
         BETA= W(INMC)-BETA
         ISCN=ISPT+CP*N
         CALL DAXPY(N,BETA,W(ISCN+1),1,W,1)
         CP=CP+1
         IF (CP.EQ.M)CP=0
 145  CONTINUE
C
C     STORE THE NEW SEARCH DIRECTION
C     ------------------------------
C
       DO 160 I=1,N
 160   W(ISPT+POINT*N+I)= W(I)
C
C     OBTAIN THE ONE-DIMENSIONAL MINIMIZER OF THE FUNCTION 
C     BY USING THE LINE SEARCH ROUTINE MCSRCH
C     ----------------------------------------------------
 165  NFEV=0
      STP=ONE
      IF (ITER.EQ.1) STP=STP1
      DO 170 I=1,N
 170  W(I)=G(I)
 172  CONTINUE
      CALL MCSRCH(N,X,F,G,W(ISPT+POINT*N+1),STP,FTOL,
     *            XTOL,MAXFEV,INFO,NFEV,DIAG)
      IF (INFO .EQ. -1) THEN
        IFLAG=1
        RETURN
      ENDIF
      IF (INFO .NE. 1) GO TO 190
      NFUN= NFUN + NFEV
C
C     COMPUTE THE NEW STEP AND GRADIENT CHANGE 
C     -----------------------------------------
C
      NPT=POINT*N
      DO 175 I=1,N
      W(ISPT+NPT+I)= STP*W(ISPT+NPT+I)
 175  W(IYPT+NPT+I)= G(I)-W(I)
      POINT=POINT+1
      IF (POINT.EQ.M)POINT=0
C
C     TERMINATION TEST
C     ----------------
C
      GNORM= DSQRT(DDOT(N,G,1,G,1))
      XNORM= DSQRT(DDOT(N,X,1,X,1))
      XNORM= DMAX1(1.0D0,XNORM)
      IF (GNORM/XNORM .LE. EPS) FINISH=.TRUE.
C
      IF(IPRINT(1).GE.0) CALL LB1(IPRINT,ITER,NFUN,
     *               GNORM,N,M,X,F,G,STP,FINISH)
      IF (FINISH) THEN
         IFLAG=0
         RETURN
      ENDIF
      GO TO 80
C
C     ------------------------------------------------------------
C     END OF MAIN ITERATION LOOP. ERROR EXITS.
C     ------------------------------------------------------------
C
 190  IFLAG=-1
      IF(LP.GT.0) WRITE(LP,200) INFO
      RETURN
 195  IFLAG=-2
      IF(LP.GT.0) WRITE(LP,235) I
      RETURN
 196  IFLAG= -3
      IF(LP.GT.0) WRITE(LP,240)
C
C     FORMATS
C     -------
C
 200  FORMAT(/' IFLAG= -1 ',/' LINE SEARCH FAILED. SEE'
     .        ' DOCUMENTATION OF ROUTINE MCSRCH',/' ERROR RETURN'
     .        ' OF LINE SEARCH: INFO= ',I2,/
     .        ' POSSIBLE CAUSES: FUNCTION OR GRADIENT ARE INCORRECT',/,
     .        ' OR INCORRECT TOLERANCES')
 235  FORMAT(/' IFLAG= -2',/' THE',I5,'-TH DIAGONAL ELEMENT OF THE',/,
     .       ' INVERSE HESSIAN APPROXIMATION IS NOT POSITIVE')
 240  FORMAT(/' IFLAG= -3',/' IMPROPER INPUT PARAMETERS (N OR M',
     .       ' ARE NOT POSITIVE)')
 245  FORMAT(/'  GTOL IS LESS THAN OR EQUAL TO 1.D-04',
     .       / ' IT HAS BEEN RESET TO 9.D-01')
      RETURN
      END

      SUBROUTINE LB1(IPRINT,ITER,NFUN,
     *                     GNORM,N,M,X,F,G,STP,FINISH)
C
C     -------------------------------------------------------------
C     THIS ROUTINE PRINTS MONITORING INFORMATION. THE FREQUENCY AND
C     AMOUNT OF OUTPUT ARE CONTROLLED BY IPRINT.
C     -------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER IPRINT(2),ITER,NFUN,LP,MP,N,M
      DOUBLE PRECISION X(N),G(N),F,GNORM,STP,GTOL,STPMIN,STPMAX
      LOGICAL FINISH
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
C
      IF (ITER.EQ.0)THEN
           WRITE(MP,10)
           WRITE(MP,*)
           WRITE(MP,20) N,M
           WRITE(MP,30)F,GNORM
                 IF (IPRINT(2).GE.1)THEN
                     WRITE(MP,40)
                     WRITE(MP,50) (X(I),I=1,N)
                     WRITE(MP,60)
                     WRITE(MP,50) (G(I),I=1,N)
                  ENDIF
CION           WRITE(MP,10)
CION           WRITE(MP,70)
      ELSE
          IF ((IPRINT(1).EQ.0).AND.(ITER.NE.1.AND..NOT.FINISH))RETURN
              IF (IPRINT(1).NE.0)THEN
                   IF(MOD(ITER-1,IPRINT(1)).EQ.0.OR.FINISH)THEN
                         IF(IPRINT(2).GT.1.AND.ITER.GT.1) WRITE(MP,70)
                         WRITE(MP,80)ITER,NFUN,F,GNORM,STP
                   ELSE
                         RETURN
                   ENDIF
              ELSE
                   IF( IPRINT(2).GT.1.AND.FINISH) WRITE(MP,70)
                   WRITE(MP,80)ITER,NFUN,F,GNORM,STP
              ENDIF
              IF (IPRINT(2).EQ.2.OR.IPRINT(2).EQ.3)THEN
                    IF (FINISH)THEN
                        WRITE(MP,90) F
                    ELSE
                        WRITE(MP,40)
                    ENDIF
                      WRITE(MP,50)(X(I),I=1,N)
                  IF (IPRINT(2).EQ.3)THEN
                      WRITE(MP,60)
                      WRITE(MP,50)(G(I),I=1,N)
                  ENDIF
              ENDIF
            IF (FINISH) THEN
             WRITE(MP,100)
             WRITE(MP,*)
             WRITE(MP,90) F
            ENDIF
      ENDIF
C
 10   FORMAT('  Start of LBFGS optimization details')
 20   FORMAT('  N=',I5,'   NUMBER OF CORRECTIONS=',I2,
     .       /,  '       INITIAL VALUES')
 30   FORMAT(' F= ',1PD10.3,'   GNORM= ',1PD10.3)
 40   FORMAT(' VECTOR X= ')
 50   FORMAT(6(2X,1PD10.3))
 60   FORMAT(' GRADIENT VECTOR G= ')
 70   FORMAT(/'   I   NFN',4X,'FUNC',8X,'GNORM',7X,'STEPLENGTH'/)
 80   FORMAT(2(I4,1X),3X,3(1PD10.3,2X))
 90   FORMAT(' Final objective value = ',1PD10.3)
 100  FORMAT(/' THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.',
     .       /' IFLAG = 0')
C
      RETURN
      END

      BLOCK DATA LB2
      INTEGER LP,MP
      DOUBLE PRECISION GTOL,STPMIN,STPMAX
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
C     DATA MP,LP,GTOL,STPMIN,STPMAX/6,6,9.0D-01,1.0D-20,1.0D+20/
C SET UNIT=100 AS THE FILE WHERE WRITE DOWN OPTIMIZATION INFORMATION
      DATA MP,LP,GTOL,STPMIN,STPMAX/11,11,9.0D-01,1.0D-20,1.0D+20/
      END

      SUBROUTINE MCSRCH(N,X,F,G,S,STP,FTOL,XTOL,MAXFEV,INFO,NFEV,WA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)         
      INTEGER N,MAXFEV,INFO,NFEV
      DOUBLE PRECISION F,STP,FTOL,GTOL,XTOL,STPMIN,STPMAX
      DOUBLE PRECISION X(N),G(N),S(N),WA(N)
      COMMON /LB3/MP,LP,GTOL,STPMIN,STPMAX
      SAVE
C
C                     LINE SEARCH SUBROUTINE MCSRCH
C                
C     A slight modification of the subroutine CSRCH of More' and Thuente.
C     The changes are to allow reverse communication, and do not affect
C     the performance of the routine. 
C
C     THE PURPOSE OF MCSRCH IS TO FIND A STEP WHICH SATISFIES
C     A SUFFICIENT DECREASE CONDITION AND A CURVATURE CONDITION.
C
C     AT EACH STAGE THE SUBROUTINE UPDATES AN INTERVAL OF
C     UNCERTAINTY WITH ENDPOINTS STX AND STY. THE INTERVAL OF
C     UNCERTAINTY IS INITIALLY CHOSEN SO THAT IT CONTAINS A
C     MINIMIZER OF THE MODIFIED FUNCTION
C
C          F(X+STP*S) - F(X) - FTOL*STP*(GRADF(X)'S).
C
C     IF A STEP IS OBTAINED FOR WHICH THE MODIFIED FUNCTION
C     HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE DERIVATIVE,
C     THEN THE INTERVAL OF UNCERTAINTY IS CHOSEN SO THAT IT
C     CONTAINS A MINIMIZER OF F(X+STP*S).
C
C     THE ALGORITHM IS DESIGNED TO FIND A STEP WHICH SATISFIES
C     THE SUFFICIENT DECREASE CONDITION
C
C           F(X+STP*S) .LE. F(X) + FTOL*STP*(GRADF(X)'S),
C
C     AND THE CURVATURE CONDITION
C
C           ABS(GRADF(X+STP*S)'S)) .LE. GTOL*ABS(GRADF(X)'S).
C
C     IF FTOL IS LESS THAN GTOL AND IF, FOR EXAMPLE, THE FUNCTION
C     IS BOUNDED BELOW, THEN THERE IS ALWAYS A STEP WHICH SATISFIES
C     BOTH CONDITIONS. IF NO STEP CAN BE FOUND WHICH SATISFIES BOTH
C     CONDITIONS, THEN THE ALGORITHM USUALLY STOPS WHEN ROUNDING
C     ERRORS PREVENT FURTHER PROGRESS. IN THIS CASE STP ONLY
C     SATISFIES THE SUFFICIENT DECREASE CONDITION.
C
C     THE SUBROUTINE STATEMENT IS
C
C        SUBROUTINE MCSRCH(N,X,F,G,S,STP,FTOL,XTOL, MAXFEV,INFO,NFEV,WA)
C     WHERE
C
C       N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER
C         OF VARIABLES.
C
C       X IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE
C         BASE POINT FOR THE LINE SEARCH. ON OUTPUT IT CONTAINS
C         X + STP*S.
C
C       F IS A VARIABLE. ON INPUT IT MUST CONTAIN THE VALUE OF F
C         AT X. ON OUTPUT IT CONTAINS THE VALUE OF F AT X + STP*S.
C
C       G IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE
C         GRADIENT OF F AT X. ON OUTPUT IT CONTAINS THE GRADIENT
C         OF F AT X + STP*S.
C
C       S IS AN INPUT ARRAY OF LENGTH N WHICH SPECIFIES THE
C         SEARCH DIRECTION.
C
C       STP IS A NONNEGATIVE VARIABLE. ON INPUT STP CONTAINS AN
C         INITIAL ESTIMATE OF A SATISFACTORY STEP. ON OUTPUT
C         STP CONTAINS THE FINAL ESTIMATE.
C
C       FTOL AND GTOL ARE NONNEGATIVE INPUT VARIABLES. (In this reverse
C         communication implementation GTOL is defined in a COMMON
C         statement.) TERMINATION OCCURS WHEN THE SUFFICIENT DECREASE
C         CONDITION AND THE DIRECTIONAL DERIVATIVE CONDITION ARE
C         SATISFIED.
C
C       XTOL IS A NONNEGATIVE INPUT VARIABLE. TERMINATION OCCURS
C         WHEN THE RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
C         IS AT MOST XTOL.
C
C       STPMIN AND STPMAX ARE NONNEGATIVE INPUT VARIABLES WHICH
C         SPECIFY LOWER AND UPPER BOUNDS FOR THE STEP. (In this reverse
C         communication implementatin they are defined in a COMMON
C         statement).
C
C       MAXFEV IS A POSITIVE INTEGER INPUT VARIABLE. TERMINATION
C         OCCURS WHEN THE NUMBER OF CALLS TO FCN IS AT LEAST
C         MAXFEV BY THE END OF AN ITERATION.
C
C       INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
C
C         INFO = 0  IMPROPER INPUT PARAMETERS.
C
C         INFO =-1  A RETURN IS MADE TO COMPUTE THE FUNCTION AND GRADIENT.
C
C         INFO = 1  THE SUFFICIENT DECREASE CONDITION AND THE
C                   DIRECTIONAL DERIVATIVE CONDITION HOLD.
C
C         INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
C                   IS AT MOST XTOL.
C
C         INFO = 3  NUMBER OF CALLS TO FCN HAS REACHED MAXFEV.
C
C         INFO = 4  THE STEP IS AT THE LOWER BOUND STPMIN.
C
C         INFO = 5  THE STEP IS AT THE UPPER BOUND STPMAX.
C
C         INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS.
C                   THERE MAY NOT BE A STEP WHICH SATISFIES THE
C                   SUFFICIENT DECREASE AND CURVATURE CONDITIONS.
C                   TOLERANCES MAY BE TOO SMALL.
C
C       NFEV IS AN INTEGER OUTPUT VARIABLE SET TO THE NUMBER OF
C         CALLS TO FCN.
C
C       WA IS A WORK ARRAY OF LENGTH N.
C
C     SUBPROGRAMS CALLED
C
C       MCSTEP
C
C       FORTRAN-SUPPLIED...ABS,MAX,MIN
C
C     ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
C     JORGE J. MORE', DAVID J. THUENTE
C
C     **********
      INTEGER INFOC,J
      LOGICAL BRACKT,STAGE1
      DOUBLE PRECISION DG,DGM,DGINIT,DGTEST,DGX,DGXM,DGY,DGYM,
     *       FINIT,FTEST1,FM,FX,FXM,FY,FYM,P5,P66,STX,STY,
     *       STMIN,STMAX,WIDTH,WIDTH1,XTRAPF,ZERO
      DATA P5,P66,XTRAPF,ZERO /0.5D0,0.66D0,4.0D0,0.0D0/
      IF(INFO.EQ.-1) GO TO 45
      INFOC = 1
C
C     CHECK THE INPUT PARAMETERS FOR ERRORS.
C
      IF (N .LE. 0 .OR. STP .LE. ZERO .OR. FTOL .LT. ZERO .OR.
     *    GTOL .LT. ZERO .OR. XTOL .LT. ZERO .OR. STPMIN .LT. ZERO
     *    .OR. STPMAX .LT. STPMIN .OR. MAXFEV .LE. 0) RETURN
C
C     COMPUTE THE INITIAL GRADIENT IN THE SEARCH DIRECTION
C     AND CHECK THAT S IS A DESCENT DIRECTION.
C
      DGINIT = ZERO
      DO 10 J = 1, N
         DGINIT = DGINIT + G(J)*S(J)
   10    CONTINUE
      IF (DGINIT .GE. ZERO) then
         write(LP,15)
   15    FORMAT(/'  THE SEARCH DIRECTION IS NOT A DESCENT DIRECTION')
         RETURN
         ENDIF
C
C     INITIALIZE LOCAL VARIABLES.
C
      BRACKT = .FALSE.
      STAGE1 = .TRUE.
      NFEV = 0
      FINIT = F
      DGTEST = FTOL*DGINIT
      WIDTH = STPMAX - STPMIN
      WIDTH1 = WIDTH/P5
      DO 20 J = 1, N
         WA(J) = X(J)
   20    CONTINUE
C
C     THE VARIABLES STX, FX, DGX CONTAIN THE VALUES OF THE STEP,
C     FUNCTION, AND DIRECTIONAL DERIVATIVE AT THE BEST STEP.
C     THE VARIABLES STY, FY, DGY CONTAIN THE VALUE OF THE STEP,
C     FUNCTION, AND DERIVATIVE AT THE OTHER ENDPOINT OF
C     THE INTERVAL OF UNCERTAINTY.
C     THE VARIABLES STP, F, DG CONTAIN THE VALUES OF THE STEP,
C     FUNCTION, AND DERIVATIVE AT THE CURRENT STEP.
C
      STX = ZERO
      FX = FINIT
      DGX = DGINIT
      STY = ZERO
      FY = FINIT
      DGY = DGINIT
C
C     START OF ITERATION.
C
   30 CONTINUE
C
C        SET THE MINIMUM AND MAXIMUM STEPS TO CORRESPOND
C        TO THE PRESENT INTERVAL OF UNCERTAINTY.
C
         IF (BRACKT) THEN
            STMIN = MIN(STX,STY)
            STMAX = MAX(STX,STY)
         ELSE
            STMIN = STX
            STMAX = STP + XTRAPF*(STP - STX)
            END IF
C
C        FORCE THE STEP TO BE WITHIN THE BOUNDS STPMAX AND STPMIN.
C
         STP = MAX(STP,STPMIN)
         STP = MIN(STP,STPMAX)
C
C        IF AN UNUSUAL TERMINATION IS TO OCCUR THEN LET
C        STP BE THE LOWEST POINT OBTAINED SO FAR.
C
         IF ((BRACKT .AND. (STP .LE. STMIN .OR. STP .GE. STMAX))
     *      .OR. NFEV .GE. MAXFEV-1 .OR. INFOC .EQ. 0
     *      .OR. (BRACKT .AND. STMAX-STMIN .LE. XTOL*STMAX)) STP = STX
C
C        EVALUATE THE FUNCTION AND GRADIENT AT STP
C        AND COMPUTE THE DIRECTIONAL DERIVATIVE.
C        We return to main program to obtain F and G.
C
         DO 40 J = 1, N
            X(J) = WA(J) + STP*S(J)
   40       CONTINUE
         INFO=-1
         RETURN
C
   45    INFO=0
         NFEV = NFEV + 1
         DG = ZERO
         DO 50 J = 1, N
            DG = DG + G(J)*S(J)
   50       CONTINUE
         FTEST1 = FINIT + STP*DGTEST
C
C        TEST FOR CONVERGENCE.
C
         IF ((BRACKT .AND. (STP .LE. STMIN .OR. STP .GE. STMAX))
     *      .OR. INFOC .EQ. 0) INFO = 6
         IF (STP .EQ. STPMAX .AND.
     *       F .LE. FTEST1 .AND. DG .LE. DGTEST) INFO = 5
         IF (STP .EQ. STPMIN .AND.
     *       (F .GT. FTEST1 .OR. DG .GE. DGTEST)) INFO = 4
         IF (NFEV .GE. MAXFEV) INFO = 3
         IF (BRACKT .AND. STMAX-STMIN .LE. XTOL*STMAX) INFO = 2
         IF (F .LE. FTEST1 .AND. ABS(DG) .LE. GTOL*(-DGINIT)) INFO = 1
C
C        CHECK FOR TERMINATION.
C
         IF (INFO .NE. 0) RETURN
C
C        IN THE FIRST STAGE WE SEEK A STEP FOR WHICH THE MODIFIED
C        FUNCTION HAS A NONPOSITIVE VALUE AND NONNEGATIVE DERIVATIVE.
C
         IF (STAGE1 .AND. F .LE. FTEST1 .AND.
     *       DG .GE. MIN(FTOL,GTOL)*DGINIT) STAGE1 = .FALSE.
C
C        A MODIFIED FUNCTION IS USED TO PREDICT THE STEP ONLY IF
C        WE HAVE NOT OBTAINED A STEP FOR WHICH THE MODIFIED
C        FUNCTION HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE
C        DERIVATIVE, AND IF A LOWER FUNCTION VALUE HAS BEEN
C        OBTAINED BUT THE DECREASE IS NOT SUFFICIENT.
C
         IF (STAGE1 .AND. F .LE. FX .AND. F .GT. FTEST1) THEN
C
C           DEFINE THE MODIFIED FUNCTION AND DERIVATIVE VALUES.
C
            FM = F - STP*DGTEST
            FXM = FX - STX*DGTEST
            FYM = FY - STY*DGTEST
            DGM = DG - DGTEST
            DGXM = DGX - DGTEST
            DGYM = DGY - DGTEST
C
C           CALL CSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
C           AND TO COMPUTE THE NEW STEP.
C
            CALL MCSTEP(STX,FXM,DGXM,STY,FYM,DGYM,STP,FM,DGM,
     *                 BRACKT,STMIN,STMAX,INFOC)
C
C           RESET THE FUNCTION AND GRADIENT VALUES FOR F.
C
            FX = FXM + STX*DGTEST
            FY = FYM + STY*DGTEST
            DGX = DGXM + DGTEST
            DGY = DGYM + DGTEST
         ELSE
C
C           CALL MCSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
C           AND TO COMPUTE THE NEW STEP.
C
            CALL MCSTEP(STX,FX,DGX,STY,FY,DGY,STP,F,DG,
     *                 BRACKT,STMIN,STMAX,INFOC)
            END IF
C
C        FORCE A SUFFICIENT DECREASE IN THE SIZE OF THE
C        INTERVAL OF UNCERTAINTY.
C
         IF (BRACKT) THEN
            IF (ABS(STY-STX) .GE. P66*WIDTH1)
     *         STP = STX + P5*(STY - STX)
            WIDTH1 = WIDTH
            WIDTH = ABS(STY-STX)
            END IF
C
C        END OF ITERATION.
C
         GO TO 30
C
C     LAST LINE OF SUBROUTINE MCSRCH.
C
      END
      
      SUBROUTINE MCSTEP(STX,FX,DX,STY,FY,DY,STP,FP,DP,BRACKT,
     *                 STPMIN,STPMAX,INFO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER INFO
      DOUBLE PRECISION STX,FX,DX,STY,FY,DY,STP,FP,DP,STPMIN,STPMAX
      LOGICAL BRACKT,BOUND
C
C     SUBROUTINE MCSTEP
C
C     THE PURPOSE OF MCSTEP IS TO COMPUTE A SAFEGUARDED STEP FOR
C     A LINESEARCH AND TO UPDATE AN INTERVAL OF UNCERTAINTY FOR
C     A MINIMIZER OF THE FUNCTION.
C
C     THE PARAMETER STX CONTAINS THE STEP WITH THE LEAST FUNCTION
C     VALUE. THE PARAMETER STP CONTAINS THE CURRENT STEP. IT IS
C     ASSUMED THAT THE DERIVATIVE AT STX IS NEGATIVE IN THE
C     DIRECTION OF THE STEP. IF BRACKT IS SET TRUE THEN A
C     MINIMIZER HAS BEEN BRACKETED IN AN INTERVAL OF UNCERTAINTY
C     WITH ENDPOINTS STX AND STY.
C
C     THE SUBROUTINE STATEMENT IS
C
C       SUBROUTINE MCSTEP(STX,FX,DX,STY,FY,DY,STP,FP,DP,BRACKT,
C                        STPMIN,STPMAX,INFO)
C
C     WHERE
C
C       STX, FX, AND DX ARE VARIABLES WHICH SPECIFY THE STEP,
C         THE FUNCTION, AND THE DERIVATIVE AT THE BEST STEP OBTAINED
C         SO FAR. THE DERIVATIVE MUST BE NEGATIVE IN THE DIRECTION
C         OF THE STEP, THAT IS, DX AND STP-STX MUST HAVE OPPOSITE
C         SIGNS. ON OUTPUT THESE PARAMETERS ARE UPDATED APPROPRIATELY.
C
C       STY, FY, AND DY ARE VARIABLES WHICH SPECIFY THE STEP,
C         THE FUNCTION, AND THE DERIVATIVE AT THE OTHER ENDPOINT OF
C         THE INTERVAL OF UNCERTAINTY. ON OUTPUT THESE PARAMETERS ARE
C         UPDATED APPROPRIATELY.
C
C       STP, FP, AND DP ARE VARIABLES WHICH SPECIFY THE STEP,
C         THE FUNCTION, AND THE DERIVATIVE AT THE CURRENT STEP.
C         IF BRACKT IS SET TRUE THEN ON INPUT STP MUST BE
C         BETWEEN STX AND STY. ON OUTPUT STP IS SET TO THE NEW STEP.
C
C       BRACKT IS A LOGICAL VARIABLE WHICH SPECIFIES IF A MINIMIZER
C         HAS BEEN BRACKETED. IF THE MINIMIZER HAS NOT BEEN BRACKETED
C         THEN ON INPUT BRACKT MUST BE SET FALSE. IF THE MINIMIZER
C         IS BRACKETED THEN ON OUTPUT BRACKT IS SET TRUE.
C
C       STPMIN AND STPMAX ARE INPUT VARIABLES WHICH SPECIFY LOWER
C         AND UPPER BOUNDS FOR THE STEP.
C
C       INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
C         IF INFO = 1,2,3,4,5, THEN THE STEP HAS BEEN COMPUTED
C         ACCORDING TO ONE OF THE FIVE CASES BELOW. OTHERWISE
C         INFO = 0, AND THIS INDICATES IMPROPER INPUT PARAMETERS.
C
C     SUBPROGRAMS CALLED
C
C       FORTRAN-SUPPLIED ... ABS,MAX,MIN,SQRT
C
C     ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
C     JORGE J. MORE', DAVID J. THUENTE
C
      DOUBLE PRECISION GAMMA,P,Q,R,S,SGND,STPC,STPF,STPQ,THETA
      INFO = 0
C
C     CHECK THE INPUT PARAMETERS FOR ERRORS.
C
      IF ((BRACKT .AND. (STP .LE. MIN(STX,STY) .OR.
     *    STP .GE. MAX(STX,STY))) .OR.
     *    DX*(STP-STX) .GE. 0.0 .OR. STPMAX .LT. STPMIN) RETURN
C
C     DETERMINE IF THE DERIVATIVES HAVE OPPOSITE SIGN.
C
      SGND = DP*(DX/ABS(DX))
C
C     FIRST CASE. A HIGHER FUNCTION VALUE.
C     THE MINIMUM IS BRACKETED. IF THE CUBIC STEP IS CLOSER
C     TO STX THAN THE QUADRATIC STEP, THE CUBIC STEP IS TAKEN,
C     ELSE THE AVERAGE OF THE CUBIC AND QUADRATIC STEPS IS TAKEN.
C
      IF (FP .GT. FX) THEN
         INFO = 1
         BOUND = .TRUE.
         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
         S = MAX(ABS(THETA),ABS(DX),ABS(DP))
         GAMMA = S*SQRT((THETA/S)**2 - (DX/S)*(DP/S))
         IF (STP .LT. STX) GAMMA = -GAMMA
         P = (GAMMA - DX) + THETA
         Q = ((GAMMA - DX) + GAMMA) + DP
         R = P/Q
         STPC = STX + R*(STP - STX)
         STPQ = STX + ((DX/((FX-FP)/(STP-STX)+DX))/2)*(STP - STX)
         IF (ABS(STPC-STX) .LT. ABS(STPQ-STX)) THEN
            STPF = STPC
         ELSE
           STPF = STPC + (STPQ - STPC)/2
           END IF
         BRACKT = .TRUE.
C
C     SECOND CASE. A LOWER FUNCTION VALUE AND DERIVATIVES OF
C     OPPOSITE SIGN. THE MINIMUM IS BRACKETED. IF THE CUBIC
C     STEP IS CLOSER TO STX THAN THE QUADRATIC (SECANT) STEP,
C     THE CUBIC STEP IS TAKEN, ELSE THE QUADRATIC STEP IS TAKEN.
C
      ELSE IF (SGND .LT. 0.0) THEN
         INFO = 2
         BOUND = .FALSE.
         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
         S = MAX(ABS(THETA),ABS(DX),ABS(DP))
         GAMMA = S*SQRT((THETA/S)**2 - (DX/S)*(DP/S))
         IF (STP .GT. STX) GAMMA = -GAMMA
         P = (GAMMA - DP) + THETA
         Q = ((GAMMA - DP) + GAMMA) + DX
         R = P/Q
         STPC = STP + R*(STX - STP)
         STPQ = STP + (DP/(DP-DX))*(STX - STP)
         IF (ABS(STPC-STP) .GT. ABS(STPQ-STP)) THEN
            STPF = STPC
         ELSE
            STPF = STPQ
            END IF
         BRACKT = .TRUE.
C
C     THIRD CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
C     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DECREASES.
C     THE CUBIC STEP IS ONLY USED IF THE CUBIC TENDS TO INFINITY
C     IN THE DIRECTION OF THE STEP OR IF THE MINIMUM OF THE CUBIC
C     IS BEYOND STP. OTHERWISE THE CUBIC STEP IS DEFINED TO BE
C     EITHER STPMIN OR STPMAX. THE QUADRATIC (SECANT) STEP IS ALSO
C     COMPUTED AND IF THE MINIMUM IS BRACKETED THEN THE THE STEP
C     CLOSEST TO STX IS TAKEN, ELSE THE STEP FARTHEST AWAY IS TAKEN.
C
      ELSE IF (ABS(DP) .LT. ABS(DX)) THEN
         INFO = 3
         BOUND = .TRUE.
         THETA = 3*(FX - FP)/(STP - STX) + DX + DP
         S = MAX(ABS(THETA),ABS(DX),ABS(DP))
C
C        THE CASE GAMMA = 0 ONLY ARISES IF THE CUBIC DOES NOT TEND
C        TO INFINITY IN THE DIRECTION OF THE STEP.
C
         GAMMA = S*SQRT(MAX(0.0D0,(THETA/S)**2 - (DX/S)*(DP/S)))
         IF (STP .GT. STX) GAMMA = -GAMMA
         P = (GAMMA - DP) + THETA
         Q = (GAMMA + (DX - DP)) + GAMMA
         R = P/Q
         IF (R .LT. 0.0 .AND. GAMMA .NE. 0.0) THEN
            STPC = STP + R*(STX - STP)
         ELSE IF (STP .GT. STX) THEN
            STPC = STPMAX
         ELSE
            STPC = STPMIN
            END IF
         STPQ = STP + (DP/(DP-DX))*(STX - STP)
         IF (BRACKT) THEN
            IF (ABS(STP-STPC) .LT. ABS(STP-STPQ)) THEN
               STPF = STPC
            ELSE
               STPF = STPQ
               END IF
         ELSE
            IF (ABS(STP-STPC) .GT. ABS(STP-STPQ)) THEN
               STPF = STPC
            ELSE
               STPF = STPQ
               END IF
            END IF
C
C     FOURTH CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
C     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DOES
C     NOT DECREASE. IF THE MINIMUM IS NOT BRACKETED, THE STEP
C     IS EITHER STPMIN OR STPMAX, ELSE THE CUBIC STEP IS TAKEN.
C
      ELSE
         INFO = 4
         BOUND = .FALSE.
         IF (BRACKT) THEN
            THETA = 3*(FP - FY)/(STY - STP) + DY + DP
            S = MAX(ABS(THETA),ABS(DY),ABS(DP))
            GAMMA = S*SQRT((THETA/S)**2 - (DY/S)*(DP/S))
            IF (STP .GT. STY) GAMMA = -GAMMA
            P = (GAMMA - DP) + THETA
            Q = ((GAMMA - DP) + GAMMA) + DY
            R = P/Q
            STPC = STP + R*(STY - STP)
            STPF = STPC
         ELSE IF (STP .GT. STX) THEN
            STPF = STPMAX
         ELSE
            STPF = STPMIN
            END IF
         END IF
C
C     UPDATE THE INTERVAL OF UNCERTAINTY. THIS UPDATE DOES NOT
C     DEPEND ON THE NEW STEP OR THE CASE ANALYSIS ABOVE.
C
      IF (FP .GT. FX) THEN
         STY = STP
         FY = FP
         DY = DP
      ELSE
         IF (SGND .LT. 0.0) THEN
            STY = STX
            FY = FX
            DY = DX
            END IF
         STX = STP
         FX = FP
         DX = DP
         END IF
C
C     COMPUTE THE NEW STEP AND SAFEGUARD IT.
C
      STPF = MIN(STPMAX,STPF)
      STPF = MAX(STPMIN,STPF)
      STP = STPF
      IF (BRACKT .AND. BOUND) THEN
         IF (STY .GT. STX) THEN
            STP = MIN(STX+0.66*(STY-STX),STP)
         ELSE
            STP = MAX(STX+0.66*(STY-STX),STP)
            END IF
         END IF
      RETURN
C
C     LAST LINE OF SUBROUTINE MCSTEP.
C
      END

!======================================================================!
!                                                                      !
!                F R A G M E N T   S U B R O U T I N E S               !
!                                                                      !
!                  ( Theor. Chem. Acc. 134, 151, 2015 )                !
!                                                                      !
!======================================================================!
!                                                                      !
!   ORBOPTFrc: Optimize Orbitals of the Core-Fragment                  !
!   COEFW_F: COEFN = COEF*W where COEFN(N,Nf), COEF(N,N) and W(Nf,Nf)  !
!            Note: the sum index k runs within fragment kf = INDf(k)   !
!   ENERGYFr: Calculate the electronic energy and Lagrange Multipliers !
!   FFJMNFrc: Calculate the gen. Fock matrices Fj(m,n) and Frj(m,n)    !
!   PRODWCWFik: PRODWCWFik = W(ik)*CW12(q)                             !
!   PRODWCWFikq: PRODWCWFikq = W(ik)*CW12(q) excluding q'=q            !
!   ELGF: Calculate the Lagrange Multipliers of the fragment 'f'       !              
!   PCONVE_F: Check for the symmetry of Lagrangian of the fragment 'f' !
!   FFMIUG_SCALING_F: Decrease gen-Fock using a scaling factor of 'f'  !
!                                                                      !
!======================================================================!

C ORBOPTFrc
      SUBROUTINE ORBOPTFrc(ITCALL,ITLIM,AHCORE,IJKL,XIJKL,QD,COEF,RO,
     &                     CJ12,CK12,ELAG,FMIUG0,
     &                     DIPN,ADIPx,ADIPy,ADIPz,ILOOP)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
c
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::EVA,TEMP,CFM
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::FMIUG,W,COEFNEW,BFM
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:,:)::FK
c
      INTEGER,ALLOCATABLE,DIMENSION(:)::INO1,INDOC,INCWO,INAC,INO0,INDf
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::WFr
C-----------------------------------------------------------------------
C     Read fragment information on the FILE 10 (FRAG)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      REWIND(10)
      READ(10,'(I6)')NFRAG
      ALLOCATE (INO1(NFRAG),INDOC(NFRAG),INCWO(NFRAG))
      ALLOCATE (INAC(NFRAG),INO0(NFRAG))
      DO i=1,NFRAG
       READ(10,'(6I6)')INO1(i),INDOC(i),INSOC,INCWO(i),INAC(i),INO0(i)
      ENDDO 
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
C
C     NO1f:  Number of inactive doubly occupied orbitals (OCC=1)
C     NDOCf: Number of strongly occupied MOs
C     NCWOf: Number of coupled weakly occupied MOs per strongly occupied
C     NO0f: Empty orbitals  (OCC=0)
C
C     NCOf:  Number of HF occupied MOs (OCC=1)
C     NVIRf: Number of HF virtual  MOs (OCC=0)
C     NCWOf*NDOCf: Active orbitals in the virtual subspace
C     NACf: Dimension of the active natural orbital subspace
C
C           NCOf      |       NVIRf          = NBFf
C       NO1f + NDOCf  |  NCWOf*NDOCf + NO0f  = NBFf
C            |      NACf             |
C
C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
      NO1f=INO1(1)
      NDOCf=INDOC(1)
      NCWOf=INCWO(1)
      NO0f=INO0(1)

      NCOf = NO1f + NDOCf
      NVIRf= NCWOf*NDOCf + NO0f
      NACf = NDOCf * ( 1 + NCWOf )
      NBFf = NO1f + NACf + NO0f

      NBF5f = NO1f + NACf
      IF(NBF5f>NBFf)NBF5f = NBFf
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Index correspondence
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (INDf(NBFf))
      DO i=1,NO1f 
       INDf(i) = i                       ! 1,NO1f
      ENDDO
      DO i=1,NACf                
       INDf(NO1f+i) = NCO-NDOCf+i        ! NCO-NDOCf+1,NCO+NCWOf*NDOCf
      ENDDO
      DO i=1,NO0f                     
       INDf(NO1f+NACf+i) = NBF-NO0f+i    ! NBF-NO0f+1,NBF
      ENDDO
C-----------------------------------------------------------------------
C                          Orbital Optimization
C-----------------------------------------------------------------------
      CONVGDELAG=.FALSE.
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     First Call to ORBOPTFrc
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(ITCALL==1)THEN
       WRITE(6,1)
       EELEC_OLD=EELEC
       SUMDIF_OLD=0.0d0
      ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Calculate Initial Electronic Energy (EELEC) and Lagrangian
C     Note: This Energy is equal to EELEC from MOLOCUPrc
C     PCONV = ABS(DIF_EELEC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ALLOCATE (WFr(NSQ,NBF5f))
      CALL ENERGYFrc(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,ELAG,
     &               DIPN,ADIPx,ADIPy,ADIPz,INDf,WFr,0)
      CALL PCONVE_F(INDf,ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
      DIF_EELEC=EELEC-EELEC_OLD
      PCONV=ABS(DIF_EELEC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Output of the first evaluated energy
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      WRITE(6,2)ITCALL,EELEC,EELEC+EN,DIF_EELEC,DUMEL
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check ITCALL and SUMDIF for changing the scaling factor
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF(SCALING.and.ITCALL>2.and.ITCALL>ITLIM.and.
     &   SUMDIF>SUMDIF_OLD)THEN
       NZEROS=NZEROS+1
       ITLIM=ITCALL+ITZITER
C      NZEROS>NZEROSm -> Restart from here with NZEROSr
       IF(NZEROS>NZEROSm)THEN
        NZEROS=NZEROSr
       ENDIF
      ENDIF
      SUMDIF_OLD=SUMDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Check for the Symmetry of Lagrangian (ELAG(IQJQ)-ELAG(JQIQ))
C     for ITCALL>1 (do not stop in the first call)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      IF( ITCALL>1 .and. DUMEL<THRESHL .and. PCONV < THRESHE )THEN
       CONVGDELAG=.TRUE.
       RETURN
      ENDIF
C-----------------------------------------------------------------------
C                       START SCF-ITERATION CYCLE
C-----------------------------------------------------------------------
      ALLOCATE (FMIUG(NBFf,NBFf),W(NBFf,NBFf),EVA(NBFf),TEMP(NBFf))
      ALLOCATE (COEFNEW(NBF,NBFf),FK(MAXLOOP,NBFf,NBFf))
      ALLOCATE (BFM(MAXLOOP+1,MAXLOOP+1),CFM(MAXLOOP+1))
C
      IF(ITCALL==1.and.INPUTFMIUG==0)THEN
       MAXLP=1
      ELSE
       MAXLP=MAXLOOP
      ENDIF
C-----------------------------------------------------------------------
      ILOOP=0
      IDIIS=0
      DO LOOP=1,MAXLP
       ILOOP=ILOOP+1
       EELEC_OLD2=EELEC
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Generalized Fock Matrix (FMIUG)
C
C      Convergent technique:
C
C      1) SCALING:   Decrease FMIUG using a scaling factor.
C                    The scaling factor varies until the number of
C                    ZEROS (.000##) is equal for all elements Fij
C      3) DIIS       Direct Inversion in the Iterative Subspace 
C
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF(SCALING)CALL FFMIUG_SCALING_F(INDf,FMIUG,ELAG,FMIUG0,ITCALL)
       IF(DIIS.and.DUMEL<THDIIS)THEN
        CALL FFMIUG_DIIS(NBFf,FMIUG,CFM,BFM,FK,IDIIS)
       ENDIF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      DIAGONALIZE SQUARE MATRIX (FMIUG) FOR REAL SYMMETRIC CASE
C      W - EIGENVECTORS, EVA - EIGENVALUES IN ALGEBRAIC DESCENDING ORDER
C      HOUSEHOLDER METHOD
C      NOTE: ONLY LOWER TRIANGLE IS USED + THIS IS DESTROYED !!!
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL DIAG(NBFf,FMIUG,W,EVA,TEMP)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Move EVA -> FMIUG0
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO I=1,NBFf
        IQ=INDf(i)
        FMIUG0(IQ)=EVA(I)
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      New Coefficients (COEFNEW=COEF*W), Move COEFNEW -> COEF
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL COEFW_F(INDf,NBF,NBFf,COEFNEW,COEF,W)
       DO j=1,NBFf
        JQ=INDf(j)
        DO i=1,NBF
         COEF(i,JQ) = COEFNEW(i,j)
        ENDDO
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Calculate Dj(miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,nbf)
C      Keep Matrices Jj, Kj in WJj, WKj
C      Form F Matrix and keep it in WF
C      Compute G, Lagrangian Multipliers (ELAG) and one-energies (E)
C      Calculate Electronic Energy (EELEC)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       CALL ENERGYFrc(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,ELAG,
     &                DIPN,ADIPx,ADIPy,ADIPz,INDf,WFr,1)
       DIF_EELEC2=EELEC-EELEC_OLD2
C      Intermediate Output (Nprint=2)
       IF(NPRINT==2)WRITE(6,3)LOOP,EELEC,EELEC+EN,DIF_EELEC2
       CALL PCONVE_F(INDf,ELAG,DUMEL,MAXI,MAXJ,SUMDIF)
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C      Check for energy convergent solution
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       IF( DABS(DIF_EELEC2) < THRESHEC )THEN
        DEALLOCATE (COEFNEW,FMIUG,W,EVA,TEMP)
        DIF_EELEC=EELEC-EELEC_OLD
        EELEC_OLD=EELEC
        RETURN
       ENDIF
C------------------------------------------------------------------------
C                       LOOP-END OF SCF-ITERATION
C-----------------------------------------------------------------------
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Itermediate Output of the external iteration
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      DIF_EELEC=EELEC-EELEC_OLD
      EELEC_OLD=EELEC
C-----------------------------------------------------------------------
C     FORMAT STATEMENTS
C-----------------------------------------------------------------------
    1 FORMAT(/2X,'RESULTS OF OCCUPATION-COEFFICIENT S.C.F. PROCEDURE'
     *      ,/1X,'===================================================',
     *  //2X,'Iter',5X,'Electronic Energy',6X,'Total Energy',
     *    3X,'Energy Convergency',4X,'Max Mul-Lag Diff',/)
    2 FORMAT(I5,'.',1X,F20.10,1X,F19.10,2X,F15.10,8X,F11.6)
    3 FORMAT(2X,I3,'.',3X,F17.8,4X,F15.8,6X,F11.6)
C-----------------------------------------------------------------------
      DEALLOCATE (INO1,INDOC,INCWO,INAC,INO0,INDf,WFr)
      RETURN
      END

C COEFW_F
      SUBROUTINE COEFW_F(INDf,N,Nf,COEFN,COEF,W)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(Nf)::INDf
      DOUBLE PRECISION,DIMENSION(N,Nf)::COEFN
      DOUBLE PRECISION,DIMENSION(N,N)::COEF
      DOUBLE PRECISION,DIMENSION(Nf,Nf)::W
C-----------------------------------------------------------------------
C     COEFN = COEF*W
C-----------------------------------------------------------------------
      DO i=1,N
       DO j=1,Nf
        COEFN(i,j)=0.0d0
        do k=1,Nf
         kf = INDf(k)
         COEFN(i,j) = COEFN(i,j) + COEF(i,kf)*W(k,j)
        enddo
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C ENERGYFrc
      SUBROUTINE ENERGYFrc(AHCORE,IJKL,XIJKL,QD,COEF,RO,CJ12,CK12,
     &                      ELAG,DIPN,ADIPx,ADIPy,ADIPz,INDf,WFr,IE)
C-----------------------------------------------------------------------
C     Calculate the electronic energy and Lagrange Multipliers
C-----------------------------------------------------------------------
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NBFf)::INDf
      INTEGER,DIMENSION(NSTORE)::IJKL
      DOUBLE PRECISION,DIMENSION(NSTORE)::XIJKL
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::AHCORE,COEF,ELAG
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(3)::DIPN
      DOUBLE PRECISION,DIMENSION(NBF,NBF,NBF)::QD
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5f)::WFr
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:,:)::WJj,WKj,WF,G,AUX1
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:)::AUX2
C-----------------------------------------------------------------------
C     Calculate Dj: QD(j,miu,niu), Jj(miu,niu), Kj(miu,niu) (j=1,NBF5) 
C-----------------------------------------------------------------------
      ALLOCATE (WJj(NSQ,NBF5),WKj(NSQ,NBF5),AUX1(NBF,NBF),AUX2(NSQ))
      DO j=1,NBF5
       CALL DENMATj(j,AUX1,COEF,NBF)
       QD(j,1:NBF,1:NBF) = AUX1(1:NBF,1:NBF)
       CALL HSTARJ(AUX2,AUX1,IJKL,XIJKL)
       WJj(1:NSQ,j) = AUX2(1:NSQ)
       CALL HSTARK(AUX2,AUX1,IJKL,XIJKL)
       WKj(1:NSQ,j) = AUX2(1:NSQ)
      ENDDO
      DEALLOCATE (AUX1,AUX2)
C-----------------------------------------------------------------------
C     Form F Matrix and keep it in WF
C     WFr: Constant part of F related to the interactions with fragments
C-----------------------------------------------------------------------
      ALLOCATE (WF(NSQ,NBF5f))
      CALL FFJMNFrc(INDf,RO,CJ12,CK12,AHCORE,WJj,WKj,WF,WFr,
     &              ADIPx,ADIPy,ADIPz,IE)
      DEALLOCATE (WJj,WKj)
C-----------------------------------------------------------------------
C     Calculate G Matrix
C-----------------------------------------------------------------------
      ALLOCATE (G(NBF,NBF5f))
      DO jf=1,NBF5f
       IQ = INDf(jf)
       do i=1,nbf
        G(i,jf) = FC(i,IQ,WF(1,jf),COEF) + FC(i,IQ,WFr(1,jf),COEF)
       enddo
      ENDDO
      DEALLOCATE (WF)
C-----------------------------------------------------------------------
C     Lagrangian Multipliers (ELAG)
C-----------------------------------------------------------------------
      CALL ELGF(INDf,ELAG,COEF,G)
      DEALLOCATE (G)
C-----------------------------------------------------------------------
C     Calculate ELECTRONIC ENERGY
C-----------------------------------------------------------------------
C     Calculate Trace(Ct*RO*H*C+Ct*G)
      CALL EELECTRr(EELEC,AHCORE,ELAG,COEF,RO)
C     Include Nuclear Dipoles if electric field =/ 0
      IF(EFIELDL)THEN
       CALL EELECTRr_EFIELD(EELEC_EF,COEF,RO,DIPN,ADIPX,ADIPY,ADIPZ)
       EELEC=EELEC+EELEC_EF
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C FFJMNFrc
      SUBROUTINE FFJMNFrc(INDf,RO,CJ12,CK12,H,DJ,DK,F,Fr,
     &                    ADIPx,ADIPy,ADIPz,IE)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF5)::RO
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CJ12,CK12
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::H,ADIPx,ADIPy,ADIPz
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::DJ,DK
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5f)::F,Fr
C-----------------------------------------------------------------------
C                            Calculate Fj(m,n)
C-----------------------------------------------------------------------
      IF(NO1f>1)THEN
       do i=1,nbf
        do k=1,nbf
         ik=i+(k-1)*nbf
         F(ik,1) = H(i,k) + PRODWCWFik(ik,INDf,DJ,CJ12)
     &                    - PRODWCWFik(ik,INDf,DK,CK12)
         DO jf=NO1f+1,NBF5f
          j = INDf(jf)
          F(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )
     &             + PRODWCWFikq(ik,jf,INDf,DJ,CJ12)
     &             - PRODWCWFikq(ik,jf,INDf,DK,CK12)
         ENDDO
        enddo
       enddo
       DO jf=2,NO1f
        F(1:NSQ,jf) = F(1:NSQ,1)
       ENDDO
      ELSE
       DO jf=1,NBF5f
        j = INDf(jf)
        do i=1,nbf
         do k=1,nbf
          ik=i+(k-1)*nbf
          F(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )
     &             + PRODWCWFikq(ik,jf,INDf,DJ,CJ12)
     &             - PRODWCWFikq(ik,jf,INDf,DK,CK12)
         enddo
        enddo
       ENDDO
      ENDIF
C-----------------------------------------------------------------------
C                          Calculate Frj(m,n)
C-----------------------------------------------------------------------
      IF(IE==0)THEN
       IF(NO1f>1)THEN
        do i=1,nbf
         do k=1,nbf
          ik=i+(k-1)*nbf
          Fr(ik,1) = H(i,k)+PRODWCWij(ik,DJ,CJ12)-PRODWCWij(ik,DK,CK12)
          Fr(ik,1) = Fr(ik,1)-F(ik,1)
          DO jf=NO1f+1,NBF5f
           j = INDf(jf)
           Fr(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )
     &               + PRODWCWijq(ik,j,DJ,CJ12)-PRODWCWijq(ik,j,DK,CK12)
           Fr(ik,jf) = Fr(ik,jf) - F(ik,jf)
          ENDDO
         enddo
        enddo
        DO jf=2,NO1f
         Fr(1:NSQ,jf) = Fr(1:NSQ,1)
        ENDDO
       ELSE
        DO jf=1,NBF5f
         j = INDf(jf)
         do i=1,nbf
          do k=1,nbf
           ik=i+(k-1)*nbf
           Fr(ik,jf) = RO(j) * ( H(i,k) + DJ(ik,j) )
     &               + PRODWCWijq(ik,j,DJ,CJ12)-PRODWCWijq(ik,j,DK,CK12)
           Fr(ik,jf) = Fr(ik,jf) - F(ik,jf)
          enddo
         enddo
        ENDDO
       ENDIF
C-----------------------------------------------------------------------
C      Including Electric Field
C      Note: FEikj is constant, so can be keeped in Fr
C-----------------------------------------------------------------------
       IF(EFIELDL)THEN
        DO jf=1,NBF5f
         j = INDf(jf)
         do i=1,nbf
         do k=1,nbf
          ik=i+(k-1)*nbf
          FEikj = ( EX*ADIPx(i,k)+EY*ADIPy(i,k)+EZ*ADIPz(i,k) ) * RO(j)
          Fr(ik,jf) = Fr(ik,jf) + FEikj
         enddo
         enddo
        ENDDO
       ENDIF
C-----------------------------------------------------------------------
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

C PRODWCWFik
      FUNCTION PRODWCWFik(ik,INDf,W,CW12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*CW12(1,*) por IQP
C-----------------------------------------------------------------------
      IQ = INDf(1)
      PRODWCWFik = 0.0d0
      DO j=1,NBF5f
       IQP = INDf(j)
       PRODWCWFik = PRODWCWFik + W(ik,IQP)*CW12(IQ,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PRODWCWFikq
      FUNCTION PRODWCWFikq(ik,jf,INDf,W,CW12)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF5,NBF5)::CW12
      DOUBLE PRECISION,DIMENSION(NSQ,NBF5)::W
C-----------------------------------------------------------------------
C     Sum W*CW12(IQ,*) por IQP, IQ is not considered
C-----------------------------------------------------------------------
      PRODWCWFikq = 0.0d0
      IQ = INDf(jf)
      DO j=1,jf-1
       IQP = INDf(j)
       PRODWCWFikq = PRODWCWFikq + W(ik,IQP)*CW12(IQ,IQP)
      ENDDO
      DO j=jf+1,NBF5f
       IQP = INDf(j)
       PRODWCWFikq = PRODWCWFikq + W(ik,IQP)*CW12(IQ,IQP)
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C ELGF
      SUBROUTINE ELGF(INDf,ELAG,C,G)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG,C
      DOUBLE PRECISION,DIMENSION(NBF,NBF5f)::G
C-----------------------------------------------------------------------
C     Calculate the Lagrangian Multipliers
C-----------------------------------------------------------------------
      DO i=1,NBFf
       IQ=INDf(i)
       DO j=1,NBF5f
        JQ=INDf(j)
        ELAG(IQ,JQ) = 0.0d0
        do k=1,nbf
         ELAG(IQ,JQ) = ELAG(IQ,JQ) + C(k,IQ)*G(k,j)
        enddo
       ENDDO
       DO j=NBF5f+1,NBFf
        JQ=INDf(j)
        ELAG(IQ,JQ) = 0.0d0
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C PCONVE_F
      SUBROUTINE PCONVE_F(INDf,ELAG,DUM,MAXI,MAXJ,SUMDIFF)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG
C-----------------------------------------------------------------------
C     MAXIMUM LAGRANGE MULTYPLIER DIFFERENCE [ELAG(IQ,JQ)-ELAG(JQ,IQ)]
C-----------------------------------------------------------------------
      DUM=0.0d0
      SUMDIFF=0.0d0
      DO i=1,NBFf
       IQ=INDf(i)
       DO j=1,NBFf
        JQ=INDf(j)
        GCF=DABS(ELAG(IQ,JQ)-ELAG(JQ,IQ))
        SUMDIFF=SUMDIFF+GCF
        IF(GCF>DUM)THEN
         DUM=GCF
         MAXI=IQ
         MAXJ=JQ
        ENDIF
       ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

C FFMIUG_SCALING_F
      SUBROUTINE FFMIUG_SCALING_F(INDf,FMIUG,ELAG,FMIUG0,ITCALL)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER,DIMENSION(NBFf)::INDf
      DOUBLE PRECISION,DIMENSION(NBF)::FMIUG0
      DOUBLE PRECISION,DIMENSION(NBFf,NBFf)::FMIUG
      DOUBLE PRECISION,DIMENSION(NBF,NBF)::ELAG
C-----------------------------------------------------------------------
C     Generalized Fock Matrix (FMIUG)
C-----------------------------------------------------------------------
      IF(itcall==1.AND.INPUTFMIUG==0)THEN          ! only for itcall==1
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO i=1,NBFf
        IQ=INDf(i)
        DO j=1,i-1
         JQ=INDf(j)
         FMIUG(i,j)=(ELAG(IQ,JQ)+ELAG(JQ,IQ))/2.0        ! Nondiagonal 
         FMIUG(j,i)=FMIUG(i,j)
        ENDDO
        FMIUG(i,i)=ELAG(IQ,IQ)                            ! Diagonal
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ELSE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       DO i=1,NBFf
        IQ=INDf(i)
        DO j=1,i-1
         JQ=INDf(j)
         FMIUG(i,j)=ELAG(IQ,JQ)-ELAG(JQ,IQ)              ! Nondiagonal 
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
C        Decrease FMIUG using a scaling factor
C        The scaling factor varies until the number of
C        ZEROS (.000##) is equal for all elements Fij
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         CALL F01(NZEROS+9,FMIUG(i,j))
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
         FMIUG(j,i)=FMIUG(i,j)                           ! Fji=Fij
        ENDDO
        FMIUG(i,i)=FMIUG0(IQ)                            ! Diagonal
       ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      ENDIF
C-----------------------------------------------------------------------
      RETURN
      END

! ==================================================================== !
!                                                                      !
!                       M P I   S U B R O U T I N E S                  !
!                                                                      !
!   04/26/13 module developed by Eduard Matito (ematito@gmail.com)     !
!                                                                      !
!   06/28/17 modified by Ion Mitxelena (ion.mitxelena@ehu.eus)         !
!                                                                      !
! ==================================================================== !
!                                                                      !
!   mpip.f is the responsible for the MPI protocol. You can find here  !
!          the necessary subroutines for the slave nodes.              !
!                                                                      !
!   INIMPI: Initializion of the parallel or serial version of the code !
!   Abortx: Abort if OPT-MPI fatal error occurs.                       !
!   SlaveDvr: Slave driver                                             !
!   SlvInt: Calculation of the integrals in the slave nodes.           !
!   SLVHSTJ: HSTARJ subroutine adapted for Slaves                      !
!   SLVHSTK: HSTARK subroutine adapted for Slaves                      !
!   SLVFORM2JK: FORM2JK subroutine adapted for Slaves                  !
!   SLVFORMJK: FORMJK adapted for Slaves                               !
!                                                                      !
!======================================================================!

C INIMPI
      Subroutine INIMPI()
      Implicit None
#include "mpip.h"
#ifdef MPI
      Write(6,'(A)')' This is the parallel version of the code'
      CALL MPI_INIT (IERR)
      CALL MPI_COMM_RANK (MPI_COMM_WORLD,MY_ID,IERR)
      CALL MPI_COMM_SIZE (MPI_COMM_WORLD,NPROCS,IERR)
      LMASTR=(MY_ID.EQ.MASTER)
c      Write(6,'(/,1X,A,I4,A,I8)') 'Core active: ',MY_ID,'/',NPROCS
      IF (LMASTR) Write(6,'(A,I4,A,I8)') 'Master: ',MY_ID
C     
      IF (NPROCS<2) THEN
        Call Abortx ("OPT-MPI Fatal error! Use at least 2 cores!")
      ELSE IF (.NOT.LMASTR) THEN
        Call SlaveDvr()
      ENDIF
C
#else
      Write(6,'(A)')' This is the serial version of the code'
      NPROCS=1
      MY_ID=0
      LMASTR=.True.
#endif
      End

C Abortx
      Subroutine Abortx(String)
      Implicit None
#include "mpip.h"
      Character*(*) String
#ifdef MPI
      CALL MPI_ABORT(MPI_COMM_WORLD,1,IERR)
#endif     
      Write(6,'(A,A)') 'Error... Aborting!',String
      Stop 'Error: Aborting!'
      End

C======================================================================C
C                 Hereafter slave-only subroutines                     C
C======================================================================C

#ifdef MPI

C SlaveDvr
      Subroutine SlaveDvr()
      Implicit None
#include "mpip.h"
      INTEGER NINTCR
   10 CALL MPI_BCAST(NINTCR,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      Call SlvInt(NINTCR)
      GOTO 10
      End

C SlvInt
      Subroutine SlvInt(NINTCR)
      Implicit None
#include "mpip.h"
      INTEGER NINTCR,N,K,JJ,IERI,ID,NOPT,IER,NOPTCG
      Double Precision ERI
      ALLOCATABLE::ERI(:),IERI(:)
      ALLOCATE(IERI(NINTCR),ERI(NINTCR),STAT=IER)
      IF(IER/=0)CALL ERRORMEM(NINTCR)
      ID=MY_ID
      K=MASTER
      JJ=1
   10 CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      IF (N<0) GOTO 20
      CALL MPI_RECV(ERI(JJ),N,MPI_REAL8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      CALL MPI_RECV(IERI(JJ),N,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,
     >              IERR)
C 
      JJ=JJ+N
      GOTO 10
C
C     Now it has all the integrals in the node, waits for wake-up signal
C     and call the pertinent subroutine (either form J or K integrals)
C
   20 CALL MPI_RECV(NOPT,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
      IF (NOPT==0) THEN
       CALL MPI_RECV(NOPTCG,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,
     &               STATUS,IERR)
       IF (NOPTCG==0) GOTO 30   
       CALL MPI_FINALIZE(IERR)
      ELSE IF (NOPT==1) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVHSTJ(N,JJ-1,IERI,ERI)
      ELSE IF (NOPT==2) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVHSTK(N,JJ-1,IERI,ERI)
      ELSE IF (NOPT==3) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVFORM2JK(N,JJ-1,IERI,ERI)
      ELSE IF (NOPT==4) THEN
       CALL MPI_RECV(N,1,MPI_INTEGER8,K,ID,MPI_COMM_WORLD,STATUS,IERR)
       CALL SLVFORMJK(N,JJ-1,IERI,ERI)
      ELSE
       Call Abortx ("I do not know this MPI option!")
      ENDIF    
      GOTO 20
   30 CONTINUE
C
      End

C SLVHSTJ
      SUBROUTINE SLVHSTJ(N,NN,IERI,ERI)
C     HSTARJ adapted for Slaves 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      DIMENSION IERI(NN),ERI(NN)
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
C
C     Get P matrix from Master node
C
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
C
      F  = 0.0d0
      FF = 0.0d0
      DO M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
                   F(NIJ)=F(NIJ)+0.5d0*P(NKL)*XJ
       IF(NIJ/=NKL)F(NKL)=F(NKL)+0.5d0*P(NIJ)*XJ
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Send pieces to master
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,MASTER,
     &                MPI_COMM_WORLD,IERR)
C-----------------------------------------------------------------------
      DEALLOCATE(P,F,FF)
      RETURN
      END

C SLVHSTK
      SUBROUTINE SLVHSTK(N,NN,IERI,ERI)
C     HSTARK adapted for Slaves
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      INTEGER,DIMENSION(NN)::IERI
      DOUBLE PRECISION,DIMENSION(NN)::ERI
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Get P matrix from Master node
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
C
      F = 0.0d0
      FF = 0.0d0
C
      DO 1 M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L

       XJ = 0.25*XJ
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)

       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L)XK=XK+XK
                       F(NIK)=F(NIK)+P(NJL)*XK
       IF(NIK/=NJL)    F(NJL)=F(NJL)+P(NIK)*XK
       IF(I==J.OR.K==L)GOTO 1
       NIL = I*(I-1)/2 + L
       NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
       IF(I==L.OR.J==K)XJ=XJ+XJ
                       F(NIL)=F(NIL)+P(NJK)*XJ
       IF(NIL/=NJK)    F(NJK)=F(NJK)+P(NIL)*XJ
    1 CONTINUE
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Send pieces to master
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,
     &                MASTER,MPI_COMM_WORLD,IERR)
C-----------------------------------------------------------------------
      DEALLOCATE(FF,P,F)
      RETURN
      END

C SLVFORM2JK
      SUBROUTINE SLVFORM2JK(N,NN,IERI,ERI)
C     FORM2JK adapted for Slaves
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      INTEGER,DIMENSION(NN)::IERI
      DOUBLE PRECISION,DIMENSION(NN)::ERI
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Get P matrix from Master node
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
C
      F = 0.0d0
      FF = 0.0d0
C
      DO M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
C-----------------------------------------------------------------------
C      2*J
C-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
                   F(NIJ)=F(NIJ)+P(NKL)*XJ
       IF(NIJ/=NKL)F(NKL)=F(NKL)+P(NIJ)*XJ
C-----------------------------------------------------------------------
C      -K
C-----------------------------------------------------------------------
       XJ = 0.25d0*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Send pieces to master
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,
     &                MASTER,MPI_COMM_WORLD,IERR)
C-----------------------------------------------------------------------
      DEALLOCATE(P,F,FF)
      RETURN
      END

C SLVFORMJK
      SUBROUTINE SLVFORMJK(N,NN,IERI,ERI)
C     FORMJK adapted for Slaves
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER NBF
      INTEGER,DIMENSION(NN)::IERI
      DOUBLE PRECISION,DIMENSION(NN)::ERI
      ALLOCATABLE::P(:),F(:),FF(:)
      ALLOCATE (P(N),F(N),FF(N))
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Get P matrix from Master node
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_BCAST(NBF,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(P,N,MPI_REAL8,MASTER,MPI_COMM_WORLD,IERR)
C
      F = 0.0d0
      FF = 0.0d0
C
      DO M=1,NN
       LABEL = IERI(M)
       CALL LABELIJKL(LABEL,I,J,K,L)
C-----------------------------------------------------------------------
C      J
C-----------------------------------------------------------------------
       XJ = ERI(M)
       NIJ = I*(I-1)/2 + J
       NKL = K*(K-1)/2 + L
       CALL OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
                   F(NIJ)=F(NIJ)+0.5d0*P(NKL)*XJ
       IF(NIJ/=NKL)F(NKL)=F(NKL)+0.5d0*P(NIJ)*XJ
C-----------------------------------------------------------------------
C      -K
C-----------------------------------------------------------------------
       XJ = 0.25d0*XJ
       XK = XJ
       NIK = I*(I-1)/2 + K
       NJL = MAX0(J,L)*(MAX0(J,L)-1)/2 + MIN0(J,L)
       IF(I==K.OR.J==L) XK=XK+XK
                          F(NIK)=F(NIK)-P(NJL)*XK
       IF(NIK/=NJL)       F(NJL)=F(NJL)-P(NIK)*XK
       IF(I/=J.and.K/=L)THEN
        NIL = I*(I-1)/2 + L
        NJK = MAX0(J,K)*(MAX0(J,K)-1)/2 + MIN0(J,K)
        IF(I==L.OR.J==K) XJ=XJ+XJ
                           F(NIL)=F(NIL)-P(NJK)*XJ
        IF(NIL/=NJK)       F(NJK)=F(NJK)-P(NIL)*XJ
       ENDIF
      ENDDO
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C     Send pieces to master
C- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      CALL MPI_REDUCE(F,FF,N,MPI_REAL8,MPI_SUM,MASTER,
     &                MPI_COMM_WORLD,IERR)
C-----------------------------------------------------------------------
      DEALLOCATE(P,F,FF)
      RETURN
      END

#endif

C ERRORMEM
      SUBROUTINE ERRORMEM(NMEMORY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER :: NMEMORY
      DOUBLE PRECISION :: GBNUMBER
      GBNUMBER = DFLOAT(NMEMORY*8)/(1024.0d0**3)
      WRITE(6,1)NMEMORY,GBNUMBER
    1 FORMAT(//10X,'Sorry, You need more Memory!, NMEMORY =',I20,2X,
     &             '=',F10.2,' GB')
      STOP
      END

C DISTRIBUTION
      SUBROUTINE DISTRIBUTION(IPRINTOPT)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
      INTEGER:: IPRINTOPT      
#include "mpip.h"
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
C     NINTMX:  Number of 2e-integrals (ERIs) per record (15000)
C     NINTCHK: Integral of NINTMX in each core
C     NPROCS:  Number of cores
C     NCHUNKS: Number of chunks
C     NINTCR:  Dimension of ERIs in Slaves
C     NSTORE:  Dimension of ERIs in Master
C              NIJKL if serial, NINTCR if parallel
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
#ifdef MPI
      NINTCHK = INT(NINTMX/(2*NPROCS))*2+2
      NCHUNKS = INT(NIJKL/NINTMX)+1+10
      NINTCR = NINTCHK*NCHUNKS
      NSTORE = NINTCR+NINTMX
      IF(IPRINTOPT==1)THEN
       Write(6,501)
       Write(6,502)NIJKL
       Write(6,503)NINTCHK
       Write(6,504)NCHUNKS
       Write(6,505)NINTCR
       Write(6,506)NSTORE
      ENDIF
#else
      NINTCR = NIJKL
      NSTORE = NINTCR
      IPRINTOPT = IPRINTOPT     !   Avoiding warnings
#endif
C-----------------------------------------------------------------------
C     Format Statements
C-----------------------------------------------------------------------
  501 FORMAT(/,1X,'Distribution:',/)
  502 FORMAT(1X,'Integrals:                ',I18)
  503 FORMAT(1X,'Integrals/chunk:          ',I18)
  504 FORMAT(1X,'Chunks:                   ',I18)
  505 FORMAT(1X,'Max size per slaves:      ',I18)
  506 FORMAT(1X,'Max size in master:       ',I18)
C-----------------------------------------------------------------------
      RETURN
      END

C READERIs
      SUBROUTINE READERIs(IERI,ERI,IX2,BUFP2,NINTEGt,IDONTW,NREC)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
#include "mpip.h"
      INTEGER,DIMENSION(NINTEGt) :: IX2
      DOUBLE PRECISION,DIMENSION(NINTEGt) :: BUFP2
      INTEGER,DIMENSION(NSTORE) :: IERI
      DOUBLE PRECISION,DIMENSION(NSTORE) :: ERI
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IX
      DOUBLE PRECISION,ALLOCATABLE,DIMENSION(:) :: XX
#ifdef MPI
      LOGICAL TROUBLE
#endif
C-----------------------------------------------------------------------
      IF(IDONTW==0)ALLOCATE(IX(NINTMX),XX(NINTMX))
C-----------------------------------------------------------------------
C     NINTMX: Total Number of 2e-integrals per record (15000)
C     NIJKL:  Total Number of 2e-integrals
C     IERI:   I,J,K,L Indeces of the integrals
C     ERI:    Value of the integrals
C     NINTCR: Dimension of ERIs in Slaves
C-----------------------------------------------------------------------
#ifdef MPI
      TROUBLE=.FALSE.
      CALL MPI_BCAST(NINTCR,1,MPI_INTEGER8,MASTER,MPI_COMM_WORLD,IERR)
#endif
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
C     III  : Last position of the integrals in the Master
C     JJ   : Pointer of the integrals
C     ITOT : Total integrals read so far
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
      III  = 0
      JJ   = 0
      ITOT = 0
      IRECORD = 0
      IF(IDONTW==0)REWIND(1)
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
   10 CONTINUE
      IF(IDONTW==1)THEN
       IRECORD = IRECORD + 1
       IJBUFi = (IRECORD-1)*NINTMX
       if(IRECORD<NREC)then
        NNINT = NINTMX
        NX = NNINT
       else
        NNINT = NINTEGt - (NREC-1)*NINTMX
        NX = -NNINT
       end if
       IF(NX==0)GOTO 20
       DO M=1,NNINT
        I = M + III
        IERI(I) = IX2(IJBUFi+M)
        ERI(I) = BUFP2(IJBUFi+M)
       ENDDO
      ELSE
       READ(1,END=100)NX,IX,XX
       IF(NX==0)GOTO 20
       NNINT = IABS(NX)
       DO M=1,NNINT
        I = M + III
        IERI(I) = IX(M)
        ERI(I) = XX(M)
       ENDDO
      END IF
C
#ifdef MPI
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
C      Distributing integrals into chunks of size 2
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
       IPARITY = MOD(NNINT,2)
       NPAIRS = (NNINT+IPARITY)/2
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
C      If non-even number of integrals in a chunk other than last
C      (and only the last, complain!)
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
       IF (IPARITY/=0.AND.TROUBLE) THEN
        Write(6,*) 'Non-even number of integrals, problem!'
        Call Abortx('Non-even number of integrals, problem!')
       ENDIF
       IF (IPARITY/=0) TROUBLE=.TRUE.
       NLEFT=MOD(NPAIRS,NPROCS)
       NCHSZ=(NPAIRS-NLEFT)/NPROCS
       IF (NLEFT>0) NCHSZ=NCHSZ+1
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
C      Sends chunks of integrals to the slaves
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
       III = III+NCHSZ*2
       JJ  = III+1
       NPAIRS=NPAIRS-NCHSZ
C
       DO I=1,NPROCS-1
        NLEFT=MOD(NPAIRS,NPROCS-I)
        NCHSZ=(NPAIRS-NLEFT)/(NPROCS-I)
        IF (NLEFT>0) NCHSZ=NCHSZ+1
        NPAIRS=NPAIRS-NCHSZ
        NSIZE=NCHSZ*2
        IF (I.EQ.(NPROCS-1).AND.IPARITY.NE.0) NSIZE=NSIZE-1
        CALL MPI_SEND(NSIZE,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
        CALL MPI_SEND(ERI(JJ),NSIZE,MPI_REAL8,I,I,MPI_COMM_WORLD,IERR)
        CALL MPI_SEND(IERI(JJ),NSIZE,MPI_INTEGER8,I,I,MPI_COMM_WORLD,
     &                IERR)
        JJ=JJ+NSIZE
        ITOT=ITOT+NSIZE
       ENDDO
#else
       III=III+NNINT
#endif
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
      IF(NX>0)GOTO 10
   20 CONTINUE
C-.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.- -.-
#ifdef MPI
      DO I=1,NPROCS-1
       CALL MPI_SEND(-I,1,MPI_INTEGER8,I,I,MPI_COMM_WORLD,IERR)
      ENDDO
      ITOT=ITOT+III
      NINTCR=III
      IF(ITOT/=NIJKL)THEN
       Call Abortx("Problem with integrals. Not everything shared?!?")
      ENDIF
#endif
C-----------------------------------------------------------------------
      IF(IDONTW==0)DEALLOCATE(XX,IX)
      RETURN
  100 CONTINUE
      WRITE(6,200)
  200 FORMAT(1X,'ERROR - ENCOUNTERED END OF FILE ON UNIT 1',I2)
      STOP
      END

C OTTOINTEGR
      SUBROUTINE OTTOINTEGR(I,J,K,L,NIJ,NKL,XJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     TRANSFORM INTO INTSCF INTEGRALS
C-----------------------------------------------------------------------
      IF(I==J)XJ=XJ*2.0
      IF(K==L)XJ=XJ*2.0
      IF(NIJ==NKL)XJ=XJ*2.0
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!                                                                      !
!                  H E S S I A N  S U B R O U T I N E S                !
!                                                                      !
!        Module written by Ion Mitxelena (ion.mitxelena@ehu.eus)       !
!                                                                      !
!======================================================================!

C GRADSPURIFY
      SUBROUTINE GRADSPURIFY(GRADS,NV)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::NV
      DOUBLE PRECISION,DIMENSION(NV),INTENT(INOUT)::GRADS
      DOUBLE PRECISION::GOLD
      INTEGER::I,J
      DOUBLE PRECISION,PARAMETER::THR=0.000001D+00,THR2=0.0000001D+00
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00
C-----------------------------------------------------------------------
      DO I=1,NV
        IF(DABS(GRADS(I))<=THR) THEN
          GRADS(I) = ZERO
          CYCLE
        ENDIF
        DO J=1,I-1
          IF(DABS(DABS(GRADS(I))-DABS(GRADS(J)))<THR2) THEN
            GOLD = GRADS(J)
            GRADS(J) = DABS(GRADS(I))
            IF(GOLD<ZERO) GRADS(J) = - DABS(GRADS(I))
          ENDIF
        ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!     Computation of Hessian numerically from analytic gradients       !
!                                                                      !
!     HSSNUMd: Main routine, use the 6-grid numerical formula          !
!     SETFCMd: Form Hessian from the gradients                         !
!     SYMFCMd: Symmetrize the Hessian                                  !
!                                                                      !
!======================================================================!

C HSSNUMd      
      SUBROUTINE HSSNUMd(FCM,NC1,CXYZ,EG,DIP,DDM,NINTEG,IDONTW,
     &                   ZAN,IAN,IMIN,IMAX,KSTART,KATOM,KTYPE,
     &                   KLOC,INTYP,KNG,KMIN,KMAX,ISH,ITYP,C1,C2,
     &                   EX1,CS,CP,CD,CF,CG,CH,CI,IRUNTYP)
C      
C     THIS ROUTINE COMPUTES HESSIAN MATRIX NUMERICALLY
C     BY USING ANALYTIC GRADIENTS
C
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C     ARGUMENTS
      INTEGER,INTENT(IN) :: NC1,NINTEG,IDONTW
      DOUBLE PRECISION,DIMENSION(NC1,NC1),INTENT(OUT) :: FCM
      DOUBLE PRECISION,DIMENSION(NC1),INTENT(IN) :: CXYZ
      DOUBLE PRECISION,DIMENSION(NC1),INTENT(INOUT) :: EG
      DOUBLE PRECISION,DIMENSION(3),INTENT(INOUT) :: DIP
      DOUBLE PRECISION,DIMENSION(9,NC1/3),INTENT(OUT)::DDM
      DOUBLE PRECISION,DIMENSION(NC1/3),INTENT(IN) :: ZAN
      INTEGER,DIMENSION(NC1/3),INTENT(IN):: IAN,IMIN,IMAX
      INTEGER,DIMENSION(NSHELL),INTENT(IN) :: KSTART,KATOM,KTYPE,KLOC
      INTEGER,DIMENSION(NSHELL),INTENT(IN) :: INTYP,KNG,KMIN,KMAX
      INTEGER,DIMENSION(NPRIMI),INTENT(IN) :: ISH,ITYP
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::C1,C2,EX1,CS,CP
      DOUBLE PRECISION,DIMENSION(NPRIMI),INTENT(IN)::CD,CF,CG,CH,CI
C     VARIABLES      
      DOUBLE PRECISION,DIMENSION(NC1) :: CDISP,EGDISP
      DOUBLE PRECISION,DIMENSION(2) :: D
      DOUBLE PRECISION,DIMENSION(3) :: DEQ
      LOGICAL,DIMENSION(NATOMS)::SKIP
      DOUBLE PRECISION,PARAMETER :: UNIT=0.52917724924D+00
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00
C-----------------------------------------------------------------------
C NVIB   =    The number of displacements in each Cartesian
C             direction for force field computation.C
C VIBSIZ =    Displacement size (in Bohrs). This pertains to
C             Both SEMINUM and FULLNUM.  Default=0.01     
C-----------------------------------------------------------------------
      WRITE(11,9111)
      WRITE(6,'(/,72(1H-),/)')
      WRITE(6,*)'Note: Numerical Hessian and Frequencies in CGO file !!'
      WRITE(6,'(/,72(1H-),/)')
      VIBSIZ = 0.01D+00
      NVIB = 2
      D(1) =  VIBSIZ
      D(2) = -VIBSIZ
      DEL = VIBSIZ*NVIB*UNIT
      IVIB   = 0
      IATOM  = 0
      ICOORD = 0
      SKIP = .FALSE.
C
C     SET HESSIAN AND DIPOLE DERIVATIVES WITH VIB 0 GEOMETRY'S GRADIENT
      CDISP = CXYZ
C     PURIFY THE GRADIENT BY HOUSEHOLDER METHOD
      CALL GRADSPURIFY(EG,NC1)
      WRITE(11,9059)
      EGDISP = EG
      WRITE(11,9060)
      DO I = 1,NATOMS
        WRITE(11,'(I4,3F15.4)')
     &   I,EG(1+(I-1)*3),EG(2+(I-1)*3),EG(3+(I-1)*3)
      ENDDO
      WRITE(11,*)      
      CALL SETDDMd(DDM,DIP,DEL,DEQ,0,NVIB,NC1,NVIB)
      CALL SETFCMd(FCM,NC1,NC1,EG,IVIB)
C
C     IDENTIFY FROZEN ATOMS
      IF(FROZEN) THEN
       WRITE(11,3)
       DO I = 1,200,2
         IF(IFROZEN(I).EQ.0) EXIT
         SKIP(IFROZEN(I+1)) = .TRUE.
       ENDDO
      END IF
C
      NMAXSKIP = NATOMS
      DO I = NATOMS,1,-1
        IF(SKIP(I) .eqv. .FALSE.)THEN
         NMAXSKIP = I
         EXIT
        ENDIF
      ENDDO
C
C      WRITE(11,'(/,72(1H*),/)')
      NDISPL=0
      NOPTCG=0
      DO IVIB = 1,NVIB
         DO IATOM = 1,NATOMS
           IF(SKIP(IATOM)) CYCLE
           NVA = 3*(IATOM-1)
           DO ICOORD = 1,3
             NV = NVA+ICOORD
             CDISP(NV) = CDISP(NV)+D(IVIB)
C            ENERGY AND GRADIENT AT DISPLACED GEOM 
             IF(IVIB==NVIB.AND.IATOM==NMAXSKIP.AND.ICOORD==3)NOPTCG=1
             CALL ENERGRAD(NINTEG,IDONTW,IEMOM,NATOMS,NBF,
     &                     NSHELL,NPRIMI,ZAN,CDISP,IAN,IMIN,IMAX,
     &                     KSTART,KATOM,KTYPE,KLOC,INTYP,KNG,
     &                     KMIN,KMAX,ISH,ITYP,C1,C2,EX1,CS,CP,CD,CF,
     &                     CG,CH,CI,EGDISP,IRUNTYP,DIP,NOPTCG,0)
C            PURIFY THE GRADIENT BY HOUSEHOLDER METHOD
             CALL GRADSPURIFY(EGDISP,NC1)
             ENERGY = EELEC + EN
C            MOVE THIS DISPLACED ATOM BACK TO WHERE IT CAME FROM
             CDISP(NV) = CDISP(NV)-D(IVIB)
C            CHECK ENERGY
             WRITE(11,9002)ENERGY
C            COMPUTE CORRESPONDING HESSIAN AND DIPOLE DERIVATIVES
             CALL SETFCMd(FCM,NC1,NV,EGDISP,IVIB)
             CALL SETDDMd(DDM,DIP,DEL,DEQ,NV,IVIB,NC1,NVIB)
             EGDISP = ZERO
             NDISPL=NDISPL+1
           ENDDO
         ENDDO
      ENDDO
C      
C     COMPLETE NUMERICAL DIFFERENTIATIONS
C     SYMMETRIZE THE FORCE CONSTANT AND DIPOLE DERIVATIVE MATRIX
      CALL SYMFCMd(FCM,NC1,VIBSIZ)
      CALL SYMDDMd(DDM,NATOMS)
C     ZERO OFF FCM ELEMENTS FOR PARTIAL HESSIAN ANALYSIS      
      IF (FROZEN) THEN
      DO IFF=1,200,2
       IF(IFROZEN(IFF).EQ.0) EXIT
       IFREEZZ = 3*(IFROZEN(IFF+1)-1)+IFROZEN(IFF)
C      SET DIAGONAL FCM ELEMENTS BE 1.0D-08 FOR PARTIAL HESSIAN       
       FCM(IFREEZZ,IFREEZZ)=1.0D-08
       DO I = 1, NC1
          FCM(I,IFREEZZ)=ZERO
          FCM(IFREEZZ,I)=ZERO
       ENDDO
      ENDDO
      ENDIF
C
C     PRINT OUT TOTAL PNOF HESSIAN
      IF(NPRINT>0) THEN
C       WRITE(11,'(/,72(1H*),/)')
       WRITE(11,1)
       DO I=1,NATOMS
        DO J=1,I
         WRITE(11,'(A4,2X,I4,I4,3F14.4)')
     &    'X',I,J,FCM(1+(I-1)*3,1+(J-1)*3),
     &           FCM(2+(I-1)*3,1+(J-1)*3),FCM(3+(I-1)*3,1+(J-1)*3)
         WRITE(11,'(A4,2X,I4,I4,3F14.4)')
     &   'Y',I,J,FCM(1+(I-1)*3,2+(J-1)*3),
     &           FCM(2+(I-1)*3,2+(J-1)*3),FCM(3+(I-1)*3,2+(J-1)*3)
         WRITE(11,'(A4,2X,I4,I4,3F14.4)')
     &   'Z',I,J,FCM(1+(I-1)*3,3+(J-1)*3),
     &           FCM(2+(I-1)*3,3+(J-1)*3),FCM(3+(I-1)*3,3+(J-1)*3)
        ENDDO
       ENDDO
      ENDIF
C     END HESSIAN CALCULATION
      WRITE(11,9100)
      RETURN
C-----------------------------------------------------------------------
 9059 FORMAT(/1X,'1E-06 is used for Gradient Cutoff')
 9060 FORMAT(/1X,'At Equilibrium Geometry, Energy Gradient is',/)
 9111 FORMAT(/4X,'- START NUMERICAL HESSIAN CALCULATION -')
 9100 FORMAT(/4X,'- END OF NUMERICAL HESSIAN CALCULATION -')
 9002 FORMAT(1X,' Energy at displaced Geom.:',1X,F20.10)
 1    FORMAT(//1X,'Hessian computed from analytic Gradients',                    
     &        /1X,'----------------------------------------',
     &      //25X,'X',13X,'Y',13X,'Z',/)
C 2    FORMAT( /,2X,F10.7,5X,F10.7,5X,F10.7)
 3    FORMAT(/1X,'WARNING,ALL GRADIENTS RELATED TO A FROZEN ATOM ARE'
     &            ' SET TO ZERO')
      END

C SETFCMd      
      SUBROUTINE SETFCMd(FCM,M,NV,EG,IVIB)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::IVIB,M,NV
      DOUBLE PRECISION,DIMENSION(M,M),INTENT(OUT)::FCM
      DOUBLE PRECISION,DIMENSION(M),INTENT(IN)::EG
      INTEGER:: I
C-----------------------------------------------------------------------      
C     SET ELEMENTS OF THE FORCE CONSTANT MATRIX
C-----------------------------------------------------------------------
      IF(IVIB .EQ. 0) THEN
C       INITIALIZE FCM TO ZERO
        FCM = 0.0D+00
        RETURN
      ENDIF  
C     STORE COLUMN 'NV' IN THE FCM
      IF(IVIB.EQ.1) THEN
C     FIRST DIFFERENCING
       DO I = 1,M
         FCM(I,NV) = EG(I)
       ENDDO
       RETURN
      ENDIF
C     SECOND DIFFERENCING
      DO I = 1,M
         FCM(I,NV) = FCM(I,NV)-EG(I)
      ENDDO
C-----------------------------------------------------------------------      
      RETURN
      END

C SYMFCMd      
      SUBROUTINE SYMFCMd(FCM,NCOORD,VIBSIZ)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::NCOORD
      DOUBLE PRECISION,INTENT(IN)::VIBSIZ
      DOUBLE PRECISION,DIMENSION(NCOORD,NCOORD),INTENT(INOUT)::FCM
      INTEGER:: I,J
      DOUBLE PRECISION:: DUM,AVE
      DOUBLE PRECISION,PARAMETER::HALF=0.5D+00
      DOUBLE PRECISION,PARAMETER::ONE=1.0D+00,TWO=2.0D+00
C-----------------------------------------------------------------------      
C      COMPLETE COMPUTATION OF THE FORCE CONSTANT MATRIX
C      MATRIX IS SYMMETRIZED.COMPLETE THE FINITE DIFFERENCING
C-----------------------------------------------------------------------
      DUM = ONE/(VIBSIZ*TWO)
      DO I = 1,NCOORD
         DO J = 1,NCOORD
            FCM(I,J) = DUM*FCM(I,J)
         ENDDO
      ENDDO
C     SYMMETRIZE THE FORCE CONSTANT MATRIX
      DO I = 2,NCOORD
         DO J = 1,I-1
            AVE = (FCM(I,J)+FCM(J,I))*HALF
            FCM(J,I) = AVE
            FCM(I,J) = AVE
         ENDDO
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!
!     Harmonic Vibrational analysis and thermodynamical analysis       !
!                                                                      !
!     FGMTRXd: Main routine to do Harm Vib analysis                    !
!     HESMASd: Computes the mass-weighted Hessian                      !
!     CENMASd: Computes the center of mass with mass-weighting         !
!     STFASEd: Set the fase of Hessian                                 !
!                                                                      !
!======================================================================!

C FGMTRXd
      SUBROUTINE FGMTRXd(CXYZ,VEC,GRAD,NC1,ZNUC,ZMASS,DDM)
      USE PARCOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)   
C-----------------------------------------------------------------------
C     THE FOLLOWING ARE HOLLERITH (1-4 CHARACTER) VARIABLES
      CHARACTER*2 LETI,IBLANK
      CHARACTER*4 CLAB(3)
      DOUBLE PRECISION :: LAB(9)
C     ARGUMENTS      
C     NC1 = NCOORD = 3*NATOMS, NC2 = (NC1**2+NC1)/2
      DOUBLE PRECISION,DIMENSION(NC1,NC1),INTENT(INOUT) :: VEC
      DOUBLE PRECISION,DIMENSION(NC1),INTENT(IN) :: CXYZ
      DOUBLE PRECISION,DIMENSION(3,NATOMS),INTENT(IN) :: GRAD
      DOUBLE PRECISION,DIMENSION(3,NC1) :: SVTZR,SVTZT
      DOUBLE PRECISION,DIMENSION(NC1) :: SVTZTT,SVTZRT
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN) :: ZNUC
      DOUBLE PRECISION,DIMENSION(NATOMS),INTENT(IN) :: ZMASS
      DOUBLE PRECISION,DIMENSION(3,NC1),INTENT(INOUT)::DDM
C     FUNCTIONS
      DOUBLE PRECISION :: DDOT
C     VARIABLES
      DOUBLE PRECISION :: ZMASST
      DOUBLE PRECISION,DIMENSION(3) :: CMASS
      DOUBLE PRECISION,DIMENSION(NC1) :: FREQ,RM,E
      INTEGER,DIMENSION(NC1) :: IA
      DOUBLE PRECISION,DIMENSION(3,NATOMS) :: COM
      DOUBLE PRECISION,DIMENSION(NC1,8) :: SCR
      INTEGER :: NIMAG,NLAST,NSKIP                                      
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00, ONE=1.0D+00
      DOUBLE PRECISION,PARAMETER :: TWO=2.0D+00, THREE=3.0D+00
      DOUBLE PRECISION,PARAMETER :: FOUR=4.0D+00, SIX=6.0D+00
      DOUBLE PRECISION,PARAMETER :: SEVEN=7.0D+00, TFACT=2.642461D+07
      DOUBLE PRECISION,PARAMETER :: PLANCK=6.626176D-34
      DOUBLE PRECISION,PARAMETER :: BOHR = 5.29177249D-11
      DOUBLE PRECISION,PARAMETER :: AVOGAD=6.022045D+23
      DOUBLE PRECISION,PARAMETER :: TOANGS=0.52917724924D+00
      DOUBLE PRECISION,PARAMETER :: CATOM = 12.011D+00
C-----------------------------------------------------------------------
      DATA CLAB /'   X','   Y','   Z'/
      DATA LETI,IBLANK/' I','  '/
C-----------------------------------------------------------------------
C     WILSON -FG- MATRIX VIBRATIONAL ANALYSIS
C     W.D.GWINN   J.CHEM.PHYS.  55, 477-481 (1971)
C-----------------------------------------------------------------------
      NIMAG = 0
      WRITE(11,9000)
C
C     ZMASS=MASSES, RM=TRIPLES OF INVERSE SQUARE ROOTS OF MASSES.
      WRITE(11,9030)
      DO IAT = 1,NATOMS
         WRITE(11,9040) IAT,ZMASS(IAT)
      ENDDO
      I0=0
      DO I=1,NATOMS
         IF(ZMASS(I)>ZERO) THEN
            DMY = ONE/DSQRT(ZMASS(I))
         ELSE
            DMY = ONE
         END IF
         RM(I0+1) = DMY
         RM(I0+2) = DMY
         RM(I0+3) = DMY
         I0=I0+3
      ENDDO
C
C     ----- GENERATE MASS WEIGHTED GRADIENT AND HESSIAN
      I0 = 1
      DO I=1,NATOMS
        DO J=1,3
           SVTZT(J,I) = GRAD(J,I) 
           SVTZT(J,I) = RM(I0) * SVTZT(J,I)
        ENDDO
        I0 = I0+3
      ENDDO
      CALL HESMASd(NC1,VEC,RM)
C
C     ----- GET CENTER OF MASS IN MASS-WEIGHTED CARTESIAN COORDS
      CALL CENMASd(NATOMS,CXYZ,COM,ZMASST,CMASS,ZMASS)
C
C     ----- GET NORMAL MODES AND FREQUENCIES
      IERR = 0
      DO I=1,NC1
        IA(I) = (I*I-I)/2
      ENDDO
C     
      CALL DIAG(NC1,VEC,VEC,E,SCR(:,1))
      CALL STFASEd(VEC,NC1,NC1,NC1)
C
C     ----- TRANSLATIONAL AND ROTATIONAL SAYVETZ CONDITIONS
      SVTZR = ZERO
      SVTZT = ZERO
      DO I=1,NC1
         DO J=1,NATOMS
            JJ=MAX(3*(J-1),6*(J-1)-3*NATOMS)
            AMASS=ONE/RM((J-1)*3+1)
            DO K=1,3
               K1=MOD(K+1,4)+(K+1)/4
               K2=MOD(K+2,4)+(K+2)/4
               SVTZT(K,I)=SVTZT(K,I)+AMASS*VEC(JJ+K,I)
               SVTZR(K,I)=SVTZR(K,I)+COM(K1,J)*VEC(JJ+K2,I)
     &                              -COM(K2,J)*VEC(JJ+K1,I)
            ENDDO
         ENDDO
         SVTZTT(I)=DSQRT(SVTZT(1,I)**2+SVTZT(2,I)**2+SVTZT(3,I)**2)
         SVTZRT(I)=DSQRT(SVTZR(1,I)**2+SVTZR(2,I)**2+SVTZR(3,I)**2)
      ENDDO
C
C     ----- CONVERT NORMAL MODE DISPLACEMENTS -----
C     (FROM MASS WEIGHTED CARTESIAN TO CARTESIAN SPACE)
      DO I = 1,NC1
       DO J = 1,NC1
        VEC(J,I) = VEC(J,I)*RM(J)
       END DO
      END DO
C
C     COMPUTE REDUCED MASS
      DO J = 1,NC1
         DD = DDOT(NC1,VEC(1,J),1,VEC(1,J),1)
         SCR(J,4) = ONE/DD
      END DO
C
C     COUNT NUMBER OF NEGATIVE EIGENVALUES
      DO I = 1,NC1
         IF(E(I)<ZERO) NIMAG=NIMAG+1
      ENDDO
C
C     DECIDE WHICH MODES ARE NOT TRUE VIBRATIONS
      NSKIP = 6
C      IF(LINEAR) NSKIP = 5
      IF(NATOMS==2) NSKIP = 5
      DO IAT=1,NATOMS
         NUCZ = INT(ZNUC(IAT))
         IF(NUCZ.EQ.0) NSKIP=NSKIP+3
      ENDDO
C
      NLAST = NSKIP
      DO I=1,NIMAG
         N2OF3 = 0
         MAYBE = I+NSKIP
         IF(MAYBE>NC1) EXIT
         IF(DABS(E(I))>DABS(E(MAYBE))) N2OF3=N2OF3+1
         
         
            IF(0.01D+00+SVTZRT(I)<SVTZRT(MAYBE)) N2OF3=N2OF3+1
            IF(0.01D+00+SVTZTT(I)<SVTZTT(MAYBE)) N2OF3=N2OF3+1
            IF(N2OF3.GE.2) NLAST = NLAST + 1
            IF(N2OF3.EQ.2) WRITE(11,9050) I,MAYBE
            IF(N2OF3.EQ.1) WRITE(11,9050) MAYBE,I
            IF(N2OF3.LE.1) EXIT
         
      ENDDO
C
      NFIRST = NLAST - NSKIP + 1
      NIMAG = NFIRST-1
      WRITE(11,9060) NFIRST,NLAST
C
C     ----- PRINT MESSAGE FOR PARTIAL HESSIAN ANALYSIS -----
      IF(FROZEN) THEN
      NFRZ = 0
      DO I=1,200,2
        IF(IFROZEN(I).EQ.0) EXIT
        NFRZ = NFRZ + 1
      ENDDO
C      
      IF(NFRZ.GE.6)THEN
          IF(NFRZ.GE.9)THEN
             WRITE(11,9063)NLAST+1, NLAST+NFRZ-6, NLAST+NFRZ-5,
     &       NLAST+NFRZ-3, NLAST+1, NLAST+NFRZ-3
          ELSE
             WRITE(11,9064) NLAST+1, NLAST+NFRZ-3,
     &       NLAST+1, NLAST+NFRZ-3
          END IF
      END IF
      ENDIF
C
C     ----- CONVERT FREQUENCIES TO WAVENUMBERS -----
      DO I = 1,NC1
         FREQ(I) = DSQRT(DABS(TFACT*E(I)))
      ENDDO
C
C     ----- PRINT WARNING FOR SKIPPING FROZEN FREQUENCIES -----
      IF(FROZEN) THEN
       IF(NFRZ.GE.6)THEN
             IF(FREQ(NLAST+NFRZ-3)>12.AND.FREQ(NLAST+NFRZ-2)<30)
     &       WRITE(11,9065)NLAST+NFRZ-3,NLAST+NFRZ-2
       END IF
      ENDIF
C
C     ----- COMPUTE IR INTENSITIES -----
C     PROJECT THE DIPOLE DERIVATIVE TENSOR ONTO EACH NORMAL MODE,
C     AND TAKE THE SQUARE OF THE NORM OF THIS 3 COMPONENT VECTOR
      DDM(:,:) = DDM(:,:)*DFAC
      DO J = 1,NC1
         DDX = DDOT(NC1,VEC(1,J),1,DDM(1,1),3)
         DDY = DDOT(NC1,VEC(1,J),1,DDM(2,1),3)
         DDZ = DDOT(NC1,VEC(1,J),1,DDM(3,1),3)
         SCR(J,1) = DDX*DDX + DDY*DDY + DDZ*DDZ
      ENDDO
C
C     PRINT OUT UNITS INFO
      WRITE(11,9070)
      MAXCOL = 0
      INCR = 5
C      
C     PRINT THE FREQUENCY AND INTENSITY
      DO
       MINCOL = MAXCOL+1
       MAXCOL = MAXCOL+INCR
       IF (MAXCOL > NC1) MAXCOL = NC1
       WRITE (11,9090)
       WRITE (11,9100) (J,J = MINCOL,MAXCOL)
       DO J=MINCOL,MAXCOL
          JJ = J + 1 - MINCOL
          LAB(JJ) = transfer (LETI,LAB(JJ))            ! LAB(JJ) = LETI
          IF(J>NIMAG)LAB(JJ)=transfer(IBLANK,LAB(JJ))  ! LAB(JJ)=IBLANK
       ENDDO
       WRITE(11,9110) (FREQ(J),LAB(J+1-MINCOL),J = MINCOL,MAXCOL)
       WRITE(11,9120) (SCR(J,1),J=MINCOL,MAXCOL)
       WRITE(11,9115) (SCR(J,4),J=MINCOL,MAXCOL)
       WRITE(11,9090)
C      
C      PRINT AB INITIO NORMAL MODE COMPONENTS
       DO IAT = 1,NATOMS
          I0 = 3*(IAT-1)
          WRITE(11,9150) IAT,
     &                   CLAB(1),(VEC(I0+1,J),J=MINCOL,MAXCOL)
          WRITE(11,9160) CLAB(2),(VEC(I0+2,J),J=MINCOL,MAXCOL)
          WRITE(11,9160) CLAB(3),(VEC(I0+3,J),J=MINCOL,MAXCOL)
       ENDDO
C      
C      PRINT SAYVETZ CONDITIONS
       WRITE(11,9090)
       WRITE(11,9180) CLAB(1),(SVTZT(1,I),I=MINCOL,MAXCOL)
       WRITE(11,9160) CLAB(2),(SVTZT(2,I),I=MINCOL,MAXCOL)
       WRITE(11,9160) CLAB(3),(SVTZT(3,I),I=MINCOL,MAXCOL)
       WRITE(11,9200) (SVTZTT(I),I=MINCOL,MAXCOL)
       WRITE(11,9090)
       WRITE(11,9190) CLAB(1),(SVTZR(1,I),I=MINCOL,MAXCOL)
       WRITE(11,9160) CLAB(2),(SVTZR(2,I),I=MINCOL,MAXCOL)
       WRITE(11,9160) CLAB(3),(SVTZR(3,I),I=MINCOL,MAXCOL)
       WRITE(11,9200) (SVTZRT(I),I=MINCOL,MAXCOL)
       IF (MAXCOL>NC1 .OR. MAXCOL.EQ.NC1) EXIT
      ENDDO
C
      WRITE(11,9220)
      WRITE(11,9090)
      WRITE(11,8050)
      WRITE(11,'(/,72(1H*),/)')      
C     FOR PUNCHING COMPONENTS OF THE NORMAL MODES SEE FGMTRX
C-----------------------------------------------------------------------      
      RETURN
C                            PRINT FORMATS
 8050 FORMAT(' END OF NORMAL MODES')
 9000 FORMAT(//1X,
     * 'Normal Coordinate Analysis in the Harmonic Approximation',/1X,
     *  56(1H-))
 9030 FORMAT(/10X,'ATOMIC WEIGHTS (AMU)'/)
 9040 FORMAT(I5,5X,F15.5)
C 9045 FORMAT(8X,'THE FORCE CONSTANT MATRIX WILL BE PROJECTED TO',
C     *       /,8X,'ELIMINATE ROTATIONAL AND VIBRATIONAL CONTAMINANTS,',
C     *       /,8X,'THOUGH THIS CHANGES THE HESSIAN SIGNIFICANTLY, SO',
C     *       /,8X,'PREVIOUS NON-PROJECTED (PROJECT=F) CALCULATION',
C     *       /,8X,'SHOULD BE DONE TO ANALIZE SAYVETZ CONDITIONS')
 9050 FORMAT(/1X,'* * * WARNING, MODE',I2,' HAS BEEN CHOSEN AS A ',
     *          'VIBRATION'/10X,'WHILE MODE',I2,
     *          ' IS ASSUMED TO BE A TRANSLATION/ROTATION.'/
     *       1X,'PLEASE VERIFY THE PROGRAM''S DECISION MANUALLY!'/)
 9060 FORMAT(/1X,'MODES',I2,' TO',I2,' ARE TAKEN AS ROTATIONS',
     *       ' AND TRANSLATIONS.')
 9063 FORMAT(/1X,'MODES',I3,' TO',I3,' ARE INTERNAL ',
     *          'VIBRATIONS ',
     *          'OF FROZEN ATOMS.',
     *          /1X,'MODES',I3,' TO',I3,' ARE RELATIVE ',
     *          'VIBRATIONS ',
     *          'BETWEEN FROZEN AND UNFROZEN ATOMS.',
     *          /1X,'MODES',I3,' TO',I3,' DO NOT CONTRIBUTE TO ',
     *          'VIBRATIONAL PARTITION FUNCTION',
     *          ' AND ENERGY.',/)
 9064 FORMAT(/1X,'MODES',I3,' TO',I3,' ARE RELATIVE ',
     *          'VIBRATIONS ',
     *          'BETWEEN FROZEN AND UNFROZEN ATOMS.',
     *          /1X,'MODES',I3,' TO',I3,' DO NOT CONTRIBUTE TO ',
     *          'VIBRATIONAL ',
     *          'ENERGIES AND PARTITION FUNCTION.',/)
 9065 FORMAT(//1X,'* * * WARNING ! * * *',//
     *          1X,'MODE',I3,' IS TAKEN AS A RELATIVE VIBRATION ',
     *          'BETWEEN FROZEN AND UNFROZEN ATOMS ',
     *          /1X,'WHILE MODE',I3,' IS TAKEN AS AN INTERNAL ',
     *          'VIBRATION OF UNFROZEN ATOMS.',//
     *          1X,'PLEASE VERIFY THE PROGRAM''S DECISION MANUALLY !'/)
 9070 FORMAT(/5X,'FREQUENCIES IN CM**-1, IR INTENSITIES IN DEBYE**2/',
     *           'AMU-ANGSTROM**2,'/5X,'REDUCED MASSES IN AMU.')
 9090 FORMAT(1X)
 9100 FORMAT(20X,9(4X,I3,5X))
 9110 FORMAT(1X,'      FREQUENCY:',3X,9(F10.2,A2))
 9115 FORMAT(1X,'   REDUCED MASS:',3X,9(F10.5,2X))
 9120 FORMAT(1X,'   IR INTENSITY:',3X,9(F10.5,2X))
 9150 FORMAT(I3,13X,A4,9F12.8)
 9160 FORMAT(16X,A4,9F12.8)
C 9170 FORMAT(I3,I3,2X,A8,A4,9F12.8)
 9180 FORMAT(16H TRANS. SAYVETZ ,A4,9F12.8)
 9190 FORMAT(16H   ROT. SAYVETZ ,A4,9F12.8)
 9200 FORMAT(15X,5HTOTAL,9F12.8)
C 9210 FORMAT(/1X,'REFERENCE ON SAYVETZ CONDITIONS -',
C     *         ' A. SAYVETZ, J.CHEM.PHYS., 7, 383-389(1939).')
 9220 FORMAT(/1X,'NOTE - THE MODES J,K ARE ORTHONORMALIZED',
     *           ' ACCORDING TO'/
     *        1X,'SUM ON I   M(I) * (X(I,J)*X(I,K) + Y(I,J)*',
     *           'Y(I,K) + Z(I,J)*Z(I,K)) = DELTA(J,K)')
      END

C HESMASd      
      SUBROUTINE HESMASd(NCOORD,HESS,RTRMS)
      IMPLICIT NONE
      INTEGER,INTENT(IN)::NCOORD
      DOUBLE PRECISION,DIMENSION(NCOORD,NCOORD),INTENT(INOUT)::HESS
      DOUBLE PRECISION,DIMENSION(NCOORD),INTENT(IN)::RTRMS
      DOUBLE PRECISION,DIMENSION((NCOORD**2+NCOORD)/2):: A
      DOUBLE PRECISION:: RTRMSI
      INTEGER:: I,J,IJ
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
C-----------------------------------------------------------------------      
C     LET A=AB INITIO ATOMS
      IJ = 0
      DO I=1,NCOORD
       RTRMSI = RTRMS(I)
       DO J=1,I
        IJ = IJ + 1
        A(IJ) = RTRMSI * HESS(I,J) * RTRMS(J)
       END DO
      END DO
C     SYMMETRIZE FULL HESSIAN
      IJ=0
      DO I=1,NCOORD
       DO J=1,I
        IJ=IJ+1
        HESS(I,J)=A(IJ)
        HESS(J,I)=A(IJ)
       END DO
      END DO
C-----------------------------------------------------------------------      
      RETURN
      END

C CENMASd      
      SUBROUTINE CENMASd(NAT,C,COM,ZMASST,CMASS,ZMASS)
      IMPLICIT NONE
      INTEGER,INTENT(IN):: NAT
      DOUBLE PRECISION,INTENT(OUT):: ZMASST
      DOUBLE PRECISION,DIMENSION(3,NAT),INTENT(IN)::C
      DOUBLE PRECISION,DIMENSION(3,NAT),INTENT(OUT)::COM
      DOUBLE PRECISION,DIMENSION(3),INTENT(OUT)::CMASS
      DOUBLE PRECISION,DIMENSION(NAT),INTENT(IN)::ZMASS
      DOUBLE PRECISION:: AMASS
      INTEGER:: I,J
      DOUBLE PRECISION,PARAMETER::ZERO=0.0D+00,ONE=1.0D+00
C-----------------------------------------------------------------------      
C     CALCULATE TOTAL MASS AND CENTER OF MASS
C-----------------------------------------------------------------------
      ZMASST= ZERO
      CMASS = ZERO
C
      DO I=1,NAT
       AMASS=ZMASS(I)
       ZMASST=ZMASST+AMASS
       DO J=1,3
        CMASS(J)=CMASS(J)+AMASS*C(J,I)
       END DO
      END DO
C
      DO I=1,3
       CMASS(I)=CMASS(I)/ZMASST
      END DO
C
      DO I=1,NAT
       IF (ZMASS(I)>ZERO) THEN
        AMASS = DSQRT(ZMASS(I))
       ELSE
        AMASS = ONE
       END IF
       DO J=1,3
        COM(J,I) = AMASS * (C(J,I)-CMASS(J))
       END DO
      END DO
C-----------------------------------------------------------------------      
      RETURN
      END   

!======================================================================!
!     DIPOLE DERIVATIVE MATRIX CALCULATION FOR obtaining IR intensities!
!                                                                      !
!     SETDDMd: Numerical Dipole derivative matrix computation          !
!     SYMDDMd: Purify the dipole derivative tensor below a threshold   !
!                                                                      !
!======================================================================!

C SYMDDMd
      SUBROUTINE SYMDDMd(DDM,NAT)
      IMPLICIT NONE
      INTEGER,INTENT(IN):: NAT
      DOUBLE PRECISION,DIMENSION(9,NAT),INTENT(INOUT):: DDM
      INTEGER:: I,J
      DOUBLE PRECISION,PARAMETER ::ZERO=0.0D+00, TM7=1.0D-07
C     HOUSEHOLDER PURIFY DIPOLE DERIVATIVE TENSOR
      DO I=1,NAT
         DO J=1,9
            IF(DABS(DDM(J,I)).LT.TM7) DDM(J,I)=ZERO
         ENDDO
      ENDDO
      RETURN
      END

C SETDDMd      
      SUBROUTINE SETDDMd(DDM,DIP,DEL,DEQ,NP,IVIB,NCOORD,NVIB)
      IMPLICIT NONE
C     ARGUMENTS      
      INTEGER,INTENT(IN):: NP,IVIB,NCOORD,NVIB
      DOUBLE PRECISION,DIMENSION(3,NCOORD),INTENT(INOUT):: DDM
      DOUBLE PRECISION,DIMENSION(3),INTENT(INOUT):: DEQ
      DOUBLE PRECISION,DIMENSION(3),INTENT(IN):: DIP
      DOUBLE PRECISION,INTENT(IN):: DEL
C     VARIABLES      
      DOUBLE PRECISION:: DELI
      INTEGER:: I
      DOUBLE PRECISION,PARAMETER ::ONE=1.0D+00,ZERO=0.0D+00
C      
      DELI = ONE/DEL
      IF(NP <= 0) THEN
C        INITIALIZE DIPOLE DERIVATIVE MATRIX
         DEQ(1) = DIP(1)
         DEQ(2) = DIP(2)
         DEQ(3) = DIP(3)
         DDM = ZERO
         RETURN
      ENDIF
C
C     UPDATE DIPOLE DERIVATIVE MATRIX
      IF(IVIB .EQ. 2) THEN
        DO I=1,3
          DDM(I,NP) = (DDM(I,NP) - DIP(I))*DELI
        ENDDO
        RETURN
      ENDIF
      IF(NVIB .EQ. 2) THEN
        DO I=1,3
          DDM(I,NP) = DIP(I)
        ENDDO
        RETURN
      ENDIF
      DO I=1,3
         DDM(I,NP) = (DIP(I) - DEQ(I))*DELI
      ENDDO
C-----------------------------------------------------------------------
      RETURN
      END

!======================================================================!

